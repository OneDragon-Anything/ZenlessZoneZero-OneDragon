```
ZENLESSZONEZERO-ONEDRAGON
├── requirements-dev-ext.txt    這個文件 `requirements-dev-ext.txt` 是一個 Python 項目額外的依賴需求文件，主要用於開發或部署環境。 |  | *   **主要功能:** 列出額外的 Python 庫依賴，用於開發和部署。 | *   **核心依賴:** |     *   `polib==1.2.0`: 用於處理 `.po` 文件，例如將 `.mo` 文件編譯成 `.po` 文件。 |     *   `pyinstaller==6.7.0`: 用於將 Python 項目打包成可執行文件 (`.exe`)。 |     *   `pip-tools==7.4.1`: 用於管理和編譯依賴關係，通常與 `pip-compile` 命令一起使用。 |     *   `colorama==0.4.6`: 用於在終端中顯示彩色文本。 | *   **重要功能點:** 這些依賴項擴展了基本項目的功能，包括國際化支持、打包成可執行文件、依賴管理和終端美化。
├── requirements-dev.txt    這個文件 `requirements-dev.txt` 是一個 Python 項目開發依賴文件，列出了項目所需的 Python 庫及其版本。 |  | *   **主要功能:** 聲明項目開發所需的 Python 庫及其版本，用於環境構建和依賴管理。 | *   **核心類和函數:**  無，此文件僅為依賴聲明。 | *   **重要功能點:** |     *   列出項目所需的 Python 庫，例如 `pyside6`, `opencv-python`, `pyautogui` 等。 |     *   指定了每個庫的具體版本號，確保依賴的一致性。
├── requirements-gamepad.txt    這個文件 `requirements-gamepad.txt` 是一個 Python 專案的依賴文件，主要功能是聲明專案需要安裝的第三方庫。 |  | *   **主要功能:** 聲明專案依賴。 | *   **核心:** 僅包含一個依賴項 `vgamepad==0.1.0`。 | *   **重要功能點:** 指定了 `vgamepad` 庫的版本為 0.1.0，用於遊戲手柄的輸入處理。
├── requirements-prod.txt    這個文件是一個由 `pip-compile` 生成的 Python 依賴項文件，用於生產環境。 |  | *   **主要功能:** 列出並指定了項目所需的 Python 庫及其版本，以確保在生產環境中依賴項的一致性。 | *   **核心類和函數:**  沒有定義類或函數，它只是一個依賴項列表。 | *   **重要功能點:** |     *   列出了所有依賴項及其版本號。 |     *   包含了依賴項的依賴關係信息 (例如，`via librosa`)。 |     *   使用清華大學的 PyPI 鏡像加速下載。 |     *   依賴項列表是從 `requirements-dev.txt` 派生而來，這表明它是一個開發環境的子集或修改版本。
├── .github/
│   ├── README.md    這個 README.md 文件是 ZenlessZoneZero-OneDragon 項目的一個介紹文件，主要功能是為用戶提供項目的概述、功能介紹、快速入門指南、免責聲明、貢獻者信息、社區鏈接和支持方式。 |  | *   **主要功能:** 該項目是一個基於圖像識別和自動化的智能解決方案，專為遊戲 Zenless Zone Zero 設計，提供自動戰鬥、閃避助手、日常清理、空洞作戰等功能。 | *   **核心類和函數:**  由於是 README 文件，沒有代碼，因此沒有核心類和函數。 | *   **重要功能點:** |     *   自動戰鬥，支持自定義邏輯。 |     *   閃避助手，基於聲音和圖像識別。 |     *   日常清理，包括多個遊戲內日常任務。 |     *   空洞作戰，基於大模型訓練的識別和尋路功能。 |     *   提供快速入門指南和官方網站鏈接。 |     *   包含免責聲明，強調項目僅供學習交流，使用風險自負。 |     *   列出貢獻者，並提供社區鏈接和支持方式。
│   ├── ISSUE_TEMPLATE/
│   │   ├── 01-bug-common.yml    這個 YAML 文件定義了一個用於 GitHub issue 的模板，專門用於用戶提交通用問題反饋。 |  | *   **主要功能:** 創建一個結構化的 issue 模板，引導用戶提供足夠的信息來報告問題。 | *   **核心元素:** |     *   `name`: 模板的名稱 "问题反馈-通用"。 |     *   `description`: 模板的描述，說明適用場景。 |     *   `title`: issue 的標題格式。 |     *   `labels`: 預設的 issue 標籤。 |     *   `body`: 包含多個部分的 issue 內容，用於收集用戶信息。 | *   **重要功能點:** |     *   提供前置須知，包括版本更新、搜索現有 issue、閱讀使用說明等。 |     *   使用複選框確認用戶已完成必要步驟。 |     *   要求提供代碼版本、問題描述、遊戲截圖、運行日誌和建議。 |     *   明確說明截圖和日誌的獲取方式和位置。 |     *   強調使用特定方式截圖，以及提供足夠信息的重要性。
│   │   ├── 02-bug-battle-assistant.yml    这个文件定义了一个用于在 GitHub 上提交战斗助手问题反馈的 issue 模板。 |  | *   **主要功能:** 引导用户提供详细信息，以便开发者能够诊断和解决战斗助手相关的问题。 | *   **核心结构:** 使用 YAML 格式定义了 issue 模板的各个组成部分，包括标题、标签、正文内容和用户输入字段。 | *   **重要功能点:** |     *   提供关于如何提交问题的详细说明，包括代码版本、配置、问题描述、截图和日志。 |     *   强制用户确认他们已完成某些步骤，例如使用最新版本的代码、搜索现有问题和更新模型。 |     *   要求用户提供详细的问题描述和重现步骤，以便开发者能够复现问题。 |     *   引导用户使用特定的截图方式（脚本F11）和日志文件位置。 |     *   鼓励用户提供建议。
│   │   ├── 03-bug-hollow-zero.yml    這個 YAML 文件定義了一個用於在 GitHub 上提交與遊戲 "枯萎之都" 相關的 bug 反饋的 issue 模板。 |  | **主要功能:** |  | *   創建一個結構化的 issue 模板，用於收集關於 "枯萎之都" 遊戲問題的詳細信息。 |  | **核心類和函數:** |  | *   該文件使用 YAML 格式，沒有類或函數。它定義了 issue 模板的結構。 |  | **重要功能點:** |  | *   **信息收集:** 模板要求用戶提供詳細信息，包括問題描述、重現步驟、副本信息、尋路方式、遊戲截圖、運行日誌和建議。 | *   **預檢驗:** 模板包含預檢驗步驟，要求用戶確認他們已更新到最新版本、搜索過現有 issue、更新了模型和腳本等。 | *   **截圖和日誌要求:** 強調使用特定方式截圖（F11 鍵）和提供運行日誌。 | *   **版本信息:** 要求提供代碼版本。 | *   **標籤和標題:** 設置了 issue 的標題和默認標籤。
│   │   └── 04-bug-lost-void.yml    這個 YAML 文件定義了一個用於在 GitHub 上提交關於“零號空洞-迷失之地”遊戲問題的 issue 模板。 |  | **主要功能:** |  | *   創建一個結構化的 issue 模板，用於收集關於遊戲中“迷失之地”區域問題的詳細信息。 |  | **核心元素:** |  | *   `name`:  定義 issue 模板的名稱 ("问题反馈-零号空洞-迷失之地")。 | *   `description`:  提供模板的描述。 | *   `title`:  設置 issue 的標題前綴 ("\[问题反馈] \[迷失之地] ")。 | *   `labels`:  添加預定義的標籤 ("Triage | 待检查")。 | *   `body`:  包含一系列用於收集信息的字段，包括： |     *   Markdown 說明：提供前置須知和提 issue 的方式。 |     *   複選框：要求用戶確認他們已完成某些步驟，例如使用最新版本和更新模型。 |     *   輸入框：用於收集代碼版本。 |     *   文本框：用於收集問題描述、區域類型、遊戲截圖、運行日誌和建議。 |  | **重要功能點:** |  | *   **提供詳細的提問指南**:  包括如何重現問題、提供截圖和日誌，以及如何描述問題。 | *   **強制信息收集**:  通過 `required: true` 屬性確保用戶提供關鍵信息。 | *   **明確的截圖要求**:  強調使用腳本 F11 截圖，並說明截圖位置。 | *   **版本信息**:  要求提供代碼版本，以便於問題的定位和修復。 | *   **結構化的問題描述**:  引導用戶提供清晰的問題描述、區域類型、截圖、日誌和建議。
│   ├── workflows/
│   │   ├── check_yaml.yml    這個 YAML 文件定義了一個 GitHub Actions 工作流程，用於檢查 `config` 目錄下 YAML 文件的語法。 |  | *   **主要功能:** 在推送到 `main`, `YAML_Check`, 和 `dev` 分支，或創建拉取請求時，檢查 `config` 目錄下的 YAML 文件是否符合語法規範。 | *   **核心函數/步驟:** |     *   `actions/checkout@v3`: 檢出代碼。 |     *   `actions/setup-python@v4`: 設置 Python 環境。 |     *   `pip install yamllint`: 安裝 `yamllint` 工具。 |     *   `yamllint config -c config/.yamllint`: 使用 `yamllint` 檢查 `config` 目錄下的 YAML 文件，並使用指定的配置文件。 | *   **重要功能點:** |     *   觸發條件：`push` 和 `pull_request` 事件，且文件路徑匹配 `config/**`。 |     *   使用 `yamllint` 進行 YAML 語法檢查。 |     *   指定了 Python 版本。
│   │   └── locale-po.yml    這個 YAML 文件定義了一個 GitHub Actions 工作流程，用於將 `.po` 文件編譯成 `.mo` 文件。 |  | *   **主要功能:** 自動編譯 `.po` 翻譯文件並提交更改。 | *   **核心函數/腳本:** `src/one_dragon/devtools/compile_po.py` (用於編譯 `.po` 文件)。 | *   **重要功能點:** |     *   觸發條件：在 `main` 和 `dev_locale` 分支的推送，以及 `.po` 文件或 `locale-po.yml` 文件更改時觸發。 |     *   使用 Python 3.11 環境。 |     *   安裝 `polib` 庫。 |     *   運行 `compile_po.py` 腳本編譯 `.po` 文件。 |     *   如果編譯後有更改，則提交 `.mo` 文件到倉庫。
│   └── 开发文档/
│       ├── 开发指南.md    這個 Markdown 文件提供了 Python 應用程序的開發和打包指南。 |  | *   **主要功能:** 描述了設置開發環境和打包 Python 應用程序的步驟。 | *   **核心類和函數:**  無特定類或函數，主要涉及命令行指令。 | *   **重要功能點:** |     *   Python 環境設置，推薦 Python 3.11.9。 |     *   使用 `pip` 和 `pip-compile` 管理依賴。 |     *   使用 `pyinstaller` 打包應用程序，包括生成 `.spec` 文件。 |     *   提供了打包安裝器、完整運行器和調度器等多個可執行文件的命令。
│       └── 版本更新.md    這個 Markdown 文件描述了遊戲更新的內容，主要集中在角色和皮膚的更新。 |  | **主要功能：** |  | *   新增角色和皮膚，並提供相關的配置和測試。 |  | **核心類和函數：** |  | *   `agent.py`：`AgentEnum` (增加角色) | *   `call_for_support.py`：`reject_agent` (增加拒絕選項) | *   `agent_outfit_config.py`：(增加皮膚選項) | *   `zzz_one_dragon_setting_interface.py`：`get_agent_outfit_group`, `on_interface_shown` (皮膚相關) | *   `zzz_context.py`：`init_agent_template_id` (皮膚初始化) | *   `agent_state_checker.check_length_by_background_gray` (狀態條識別) |  | **重要功能點：** |  | *   **角色更新：** 增加新角色，包括角色名稱、頭像截圖、狀態判斷和測試。 | *   **角色狀態：** 描述了角色狀態的識別原理，基於顏色判斷，並提供了測試和模板管理的流程。 | *   **皮膚更新：** 增加新皮膚，包括配置、截圖和界面初始化。 | *   **配置文件更新：** 更新了 `.yml` 文件，增加了拒絕選項和空洞事件。
├── assets/
│   ├── game_data/
│   │   ├── coffee_data.yml    ## 代码摘要 |  | **文件:** `.\assets\game_data\coffee_data.yml` |  | **主要功能:**  定义游戏中的咖啡数据，包括咖啡名称、以及与任务相关的配置信息。同时包含一个排班表，指定了每天提供的咖啡。 |  | **核心数据结构:** |  | *   `coffee_list`:  一个列表，包含多个咖啡的配置信息，每个咖啡配置是一个字典，包含 `coffee_name` (咖啡名称) 以及其他可选字段，如 `tab_name`, `category_name`, `mission_type_name`, `mission_name` 和 `extra`。 | *   `schedule`:  一个列表，定义了咖啡的排班表，包含 `days` (星期几) 和 `coffee_list` (当天提供的咖啡列表)。 |  | **重要功能点:** |  | *   定义了各种咖啡的名称。 | *   为咖啡关联了任务信息，包括任务所属的标签、类别、任务类型和任务名称。 | *   `extra` 字段用于标记特殊咖啡。 | *   通过 `schedule` 定义了每天提供的咖啡。
│   │   ├── compendium_data.yml    **摘要:** |  | 该 YAML 文件定义了游戏中的任务数据，主要用于组织和管理不同类型的任务。 |  | **核心结构:** |  | *   `tab_name`: 定义任务标签页的名称，如 "目标"、"日常"、"训练"、"作战"。 | *   `category_list`: 定义任务类别，如 "实战模拟室"、"定期清剿"、"恶名狩猎"、"零号空洞"等。 | *   `mission_type_list`: 定义任务类型，如 "基础材料"、"代理人晋升"、"迷失之地"等。 | *   `mission_list`: 定义具体任务，包含 `mission_name` 和 `mission_name_display`，用于显示任务名称。 |  | **重要功能点:** |  | *   定义了不同类型的任务，包括训练、作战等。 | *   组织任务通过标签页、类别和类型进行分类。 | *   为每个任务定义了名称和显示名称。 | *   用于配置游戏中的任务系统，包括任务的组织结构和名称。
│   │   ├── map_area.yml    這個 YAML 文件的主要功能是定義遊戲地圖中的區域及其傳送點 (tp_list)。 |  | 核心結構： |  | *   文件包含一個 YAML 列表，每個元素代表一個地圖區域。 | *   每個區域是一個字典，包含： |     *   `area_name`: 區域的名稱 (字符串)。 |     *   `tp_list`: 一個列表，包含該區域的傳送點名稱 (字符串列表)。 |  | 重要功能點： |  | *   定義了遊戲中不同地圖區域的名稱。 | *   列出了每個區域中可供玩家傳送到的地點。 | *   用於遊戲中地圖的導航和傳送功能。
│   │   ├── agent/
│   │   │   ├── anby.yml    這個 YAML 文件定義了一個名為 "安比" 的遊戲代理的數據。 |  | *   **主要功能:** 儲存遊戲中代理角色的配置數據。 | *   **核心數據:** |     *   `agent_name`: 代理名稱，設定為 "安比"。 |     *   `agent_type`: 代理類型，設定為 "STUN"。 |     *   `dmg_type`: 傷害類型，設定為 "ELECTRIC"。 |     *   `rare_type`: 稀有度類型，設定為 "A"。 | *   **重要功能點:**  定義了代理的基礎屬性，包括名稱、類型、傷害類型和稀有度。
│   │   │   ├── anton.yml    這個 YAML 文件定義了一個遊戲中名為“安東”的 Agent 的數據。 |  | *   **主要功能:** 儲存 Agent 的屬性數據。 | *   **核心類/函數:**  無 (YAML 文件，沒有類或函數)。 | *   **重要功能點:** |     *   `agent_name`:  Agent 的名稱 ("安東")。 |     *   `agent_type`: Agent 的類型 ("ATTACK")。 |     *   `dmg_type`: 傷害類型 ("ELECTRIC")。 |     *   `rare_type`: 稀有度 ("A")。
│   │   │   ├── ben.yml    這個 YAML 文件定義了一個遊戲中名為 "本" 的 Agent 的數據。 |  | *   **主要功能:** 儲存 Agent "本" 的配置數據。 | *   **核心數據:** |     *   `agent_name`: "本" (Agent 的名稱) |     *   `agent_type`: "DEFENSE" (Agent 的類型，防禦型) |     *   `dmg_type`: "FIRE" (Agent 的傷害類型，火焰) |     *   `rare_type`: "A" (Agent 的稀有度，A級) | *   **重要功能點:** 定義了 Agent 的基本屬性，用於遊戲邏輯。
│   │   │   ├── billy.yml    這個 YAML 文件定義了一個名為 "比利" 的遊戲代理 (agent) 的數據。 |  | *   **主要功能:** 儲存遊戲中代理 "比利" 的配置數據。 | *   **核心數據:** |     *   `agent_name`: 代理的名稱，設定為 "比利"。 |     *   `agent_type`: 代理的類型，設定為 "ATTACK"。 |     *   `dmg_type`: 代理的傷害類型，設定為 "ELECTRIC"。 |     *   `rare_type`: 代理的稀有度類型，設定為 "A"。 | *   **重要功能點:** 定義了代理的名稱、類型、傷害類型和稀有度，這些數據將用於遊戲中代理的生成、行為和屬性設定。
│   │   │   ├── corin.yml    這個 YAML 文件定義了一個遊戲中名為“可琳”的 Agent 的數據。 |  | *   **主要功能:** 描述遊戲角色“可琳”的屬性。 | *   **核心數據:** |     *   `agent_name`: "可琳" - Agent 的名稱。 |     *   `agent_type`: "ATTACK" - Agent 的類型，表明其為攻擊型角色。 |     *   `dmg_type`: "PHYSICAL" - 傷害類型為物理傷害。 |     *   `rare_type`: "A" - Agent 的稀有度等級。 | *   **重要功能點:**  定義了 Agent 的基本屬性，包括名稱、類型、傷害類型和稀有度，這些屬性將用於遊戲邏輯中。
│   │   │   ├── ellen.yml    這個 YAML 文件定義了一個遊戲角色「艾蓮」的數據。 |  | *   **主要功能:** 儲存遊戲角色「艾蓮」的屬性數據。 | *   **核心數據:** |     *   `agent_name`: 角色名稱，設定為「艾蓮」。 |     *   `agent_type`: 角色類型，設定為「ATTACK」（攻擊型）。 |     *   `dmg_type`: 傷害類型，設定為「ICE」（冰屬性）。 |     *   `rare_type`: 稀有度，設定為「S」。 | *   **重要功能點:**  定義了角色的基本屬性，包括名稱、類型、傷害屬性和稀有度。
│   │   │   ├── grace.yml    這個 YAML 文件定義了一個名為 "格莉丝" 的遊戲角色數據。 |  | *   **主要功能:** 儲存遊戲角色 "格莉丝" 的屬性數據。 | *   **核心元素:** |     *   `agent_name`: 角色名稱 ("格莉丝")。 |     *   `agent_type`: 角色類型 ("ATTACK")。 |     *   `dmg_type`: 傷害類型 ("ELECTRIC")。 |     *   `rare_type`: 稀有度 ("S")。 | *   **重要功能點:**  定義了角色的基本屬性，包括名稱、類型、傷害類型和稀有度，這些數據將用於遊戲中的角色生成和屬性計算。
│   │   │   ├── koleda.yml    這個 YAML 文件定義了一個名為 "珂蕾妲" 的遊戲代理人的數據。 |  | *   **主要功能:** 描述遊戲中一個代理人的屬性。 | *   **核心數據:** |     *   `agent_name`: 代理人名稱 ("珂蕾妲")。 |     *   `agent_type`: 代理人類型 ("STUN")。 |     *   `dmg_type`: 傷害類型 ("FIRE")。 |     *   `rare_type`: 稀有度 ("S")。 | *   **重要功能點:** 描述了代理人的基本屬性，包括名稱、類型、傷害類型和稀有度。
│   │   │   ├── lucy.yml    這個 YAML 文件定義了一個名為 "露西" 的遊戲代理的數據。 |  | *   **主要功能:** 儲存遊戲中代理角色的配置數據。 | *   **核心數據:** |     *   `agent_name`: 代理名稱，設定為 "露西"。 |     *   `agent_type`: 代理類型，設定為 "SUPPORT"。 |     *   `dmg_type`: 傷害類型，設定為 "FIRE"。 |     *   `rare_type`: 稀有度，設定為 "A"。 | *   **重要功能點:**  定義了代理的基本屬性，包括名稱、類型、傷害類型和稀有度。
│   │   │   ├── lycaon.yml    這個 YAML 文件定義了一個名為 "莱卡恩" 的遊戲代理（agent）的數據。 |  | *   **主要功能:** 儲存遊戲中代理的配置數據。 | *   **核心數據:** |     *   `agent_name`: 代理的名稱，為 "莱卡恩"。 |     *   `agent_type`: 代理的類型，為 "STUN"。 |     *   `dmg_type`: 代理的傷害類型，為 "ICE"。 |     *   `rare_type`: 代理的稀有度，為 "S"。 | *   **重要功能點:** 定義了代理的名稱、類型、傷害類型和稀有度，這些是遊戲中代理的基本屬性。
│   │   │   ├── nekomata.yml    這個 YAML 文件定義了一個名為 "猫又" 的遊戲代理（agent）的數據。 |  | *   **主要功能:** 描述遊戲中一個攻擊型代理的屬性。 | *   **核心數據:** |     *   `agent_name`: "猫又" (代理的名稱) |     *   `agent_type`: "ATTACK" (代理的類型，表示攻擊型) |     *   `dmg_type`: "PHYSICAL" (傷害類型，表示物理傷害) |     *   `rare_type`: "S" (稀有度，表示S級) | *   **重要功能點:**  定義了代理的名稱、類型、傷害類型和稀有度，這些屬性將影響遊戲中的代理行為和強度。
│   │   │   ├── nicole.yml    這個 YAML 文件定義了一個遊戲中名為 "妮可" 的 Agent 的數據。 |  | *   **主要功能:** 儲存 Agent "妮可" 的屬性數據。 | *   **核心數據:** |     *   `agent_name`: "妮可" - Agent 的名稱。 |     *   `agent_type`: "SUPPORT" - Agent 的類型，為支援型。 |     *   `dmg_type`: "ETHER" - Agent 的傷害類型，為以太。 |     *   `rare_type`: "A" - Agent 的稀有度，為 A 級。 | *   **重要功能點:** 定義了 Agent 的基本屬性，用於遊戲內的角色設定。
│   │   │   ├── piper.yml    這個 YAML 文件定義了一個名為 "派派" 的遊戲代理（Agent）的數據。 |  | *   **主要功能:** 描述遊戲中一個攻擊型代理的屬性。 | *   **核心數據:** |     *   `agent_name`: "派派" - 代理的名稱。 |     *   `agent_type`: "ATTACK" - 代理的類型，表明它是一個攻擊型代理。 |     *   `dmg_type`: "PHYSICAL" - 代理的傷害類型，為物理傷害。 |     *   `rare_type`: "A" - 代理的稀有度，為 A 級。 | *   **重要功能點:**  定義了代理的名稱、類型、傷害類型和稀有度，這些是遊戲中代理的基本屬性。
│   │   │   ├── rina.yml    這個 YAML 文件定義了一個遊戲內的角色 "丽娜" 的數據。 |  | *   **主要功能:** 描述遊戲角色 "丽娜" 的屬性。 | *   **核心數據:** |     *   `agent_name`: 角色名稱 ("丽娜") |     *   `agent_type`: 角色類型 ("SUPPORT") |     *   `dmg_type`: 傷害類型 ("ELECTRIC") |     *   `rare_type`: 稀有度 ("S") | *   **重要功能點:**  定義了角色的基本屬性，包括角色類型、傷害類型和稀有度，這些信息將用於遊戲的邏輯和角色管理。
│   │   │   ├── soldier_11.yml    這個 YAML 文件定義了一個遊戲中名為 "11号" 的士兵的 Agent 數據。 |  | *   **主要功能:** 描述遊戲中士兵 Agent 的屬性。 | *   **核心數據:** |     *   `agent_name`: "11号" (Agent 的名稱) |     *   `agent_type`: "ATTACK" (Agent 的類型，表示攻擊型) |     *   `dmg_type`: "FIRE" (Agent 的傷害類型，表示火焰傷害) |     *   `rare_type`: "S" (Agent 的稀有度，表示 S 級) | *   **重要功能點:** 定義了 Agent 的基本屬性，包括名稱、類型、傷害類型和稀有度，這些屬性將用於遊戲邏輯中。
│   │   │   ├── soukaku.yml    這個 YAML 文件定義了一個遊戲角色 "苍角" 的數據。 |  | *   **主要功能:** 描述遊戲角色 "苍角" 的屬性。 | *   **核心數據:** |     *   `agent_name`: 角色名稱 ("苍角") |     *   `agent_type`: 角色類型 ("SUPPORT") |     *   `dmg_type`: 傷害類型 ("ICE") |     *   `rare_type`: 稀有度 ("A") | *   **重要功能點:**  定義了角色的基本屬性，包括角色名稱、類型、傷害類型和稀有度。
│   │   │   └── zhu_yuan.yml    這個 YAML 文件定義了一個遊戲角色 "朱鳶" 的數據。 |  | *   **主要功能:** 描述遊戲角色 "朱鳶" 的屬性。 | *   **核心數據:** |     *   `agent_name`: 角色名稱 ("朱鸢") |     *   `agent_type`: 角色類型 ("ATTACK") |     *   `dmg_type`: 傷害類型 ("ETHER") |     *   `rare_type`: 稀有度 ("S") | *   **重要功能點:** 定義了角色的基本屬性，包括名稱、類型、傷害類型和稀有度。
│   │   ├── hollow_zero/
│   │   │   ├── entry_list.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏 "Hollow Zero" 中的一系列入口点（entry points），这些入口点可能是游戏中的场景、地点或事件。 |  | **核心数据结构:** |  | *   **列表 (List):** 文件内容是一个 YAML 列表，每个元素代表一个入口点。 | *   **字典 (Dictionary):** 每个入口点是一个字典，包含以下键值对： |     *   `entry_name`: 入口点的名称 (字符串)。 |     *   `is_benefit`:  一个布尔值，指示该入口点是否为 "收益" 类型。 |     *   `can_visited_times`:  一个整数，表示可以访问该入口点的次数。 |     *   `can_go`:  一个布尔值，指示是否可以进入该入口点。 |     *   `need_step`:  一个整数，表示进入该入口点所需的步数。 |     *   `is_tp`:  一个布尔值，指示该入口点是否为传送点。 |     *   `is_base`:  一个布尔值，指示该入口点是否为基地。 |     *   `move_afterwards`:  一个布尔值，指示进入该入口点后是否移动。 |  | **重要功能点:** |  | *   定义了游戏中的各种入口点，例如 "起点"、"扭蛋机"、"传送点" 等。 | *   使用 `is_benefit` 属性区分收益型入口点。 | *   使用 `can_visited_times` 限制入口点的访问次数。 | *   使用 `can_go` 和 `need_step` 控制入口点的可访问性。 | *   使用 `is_tp` 标记传送点。 | *   使用 `is_base` 标记基地。 | *   使用 `move_afterwards` 标记进入入口点后是否移动。
│   │   │   ├── resonium.yml    ## 摘要 |  | **文件功能:** |  | 該 YAML 文件定義了一系列遊戲內的物品，包括名稱、分類（category）和稀有度（level）。這些物品涵蓋了多個類別，例如“契合”、“邦布”、“通用”、“詭術”、“研究”、“協助”、“空洞”、“閃避”、“護盾”、“決鬥”、“能量”、“暴擊”、“支援”、“感電”、“凍結”、“強襲”、“引燃”、“以太”和“頑強”。 |  | **核心類和函數:** |  | *   **無核心類或函數:** 該文件主要由數據組成，沒有定義任何類或函數。 | *   **數據結構:** 數據以 YAML 格式組織，每個物品由 `category`, `name`, 和 `level` 字段定義。 |  | **重要功能點:** |  | *   **物品定義:** 文件定義了大量遊戲物品，為遊戲提供了豐富的內容。 | *   **分類:** 物品按不同的類別進行組織，方便遊戲設計和管理。 | *   **稀有度:** 每個物品都有一個稀有度等級，可能用於遊戲平衡或物品掉落機制。 | *   **數據驅動:** 遊戲的物品數據存儲在 YAML 文件中，使得修改和更新物品變得容易。
│   │   │   ├── lost_void/
│   │   │   │   ├── lost_void_artifact_data.yml    **摘要:** |  | *   **主要功能:** 该文件定义了游戏《失落虚空》中各种类型的装备数据，包括终结、机敏、异常·击破、绝境、角色专属装备、通用装备、契合装备、卡牌和杰佩托等。 | *   **核心类和函数:**  该文件使用YAML格式存储数据，没有显式的类或函数定义。数据以列表形式组织，每个元素代表一个装备，包含 `category` (类别), `name` (名称), `level` (等级), 和 `template_id` (模板ID)等字段。 | *   **重要功能点:** |     *   定义了大量不同类型的装备，涵盖了多种游戏机制和角色。 |     *   装备按照类别和等级进行组织，方便游戏内的数据管理和调用。 |     *   每个装备都有一个唯一的 `template_id`，用于关联游戏内的具体实现。
│   │   │   │   └── lost_void_det_class.yml    這個 YAML 文件定義了一系列遊戲中的類別，用於描述《空洞騎士》遊戲中“遺忘虛空”區域的各種事件和元素。 |  | *   **主要功能:** 定義遊戲中不同類型的事件和元素的類別。 | *   **核心結構:**  YAML 文件使用列表結構，每個元素是一個字典，包含 `class_idx` (類別索引) 和 `class_name` (類別名稱) 兩個鍵值對。 | *   **重要功能點:** |     *   定義了多個類別，涵蓋了遊戲中的不同方面，如戰鬥、挑戰、偶遇事件、商店等。 |     *   `class_idx` 用於唯一標識每個類別。 |     *   `class_name` 提供了類別的可讀名稱，方便遊戲開發和維護。
│   │   │   └── normal_event/
│   │   │       ├── 以太露滴.yml    這個 YAML 文件定義了一個名為「以太露滴」的遊戲事件。 |  | *   **主要功能:** 定義了遊戲中一個事件的內容，包括事件名稱、選項及其描述。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "以太露滴"。 |     *   `event_name`: 事件的顯示名稱，為 "以太露滴"。 |     *   `options`:  一個列表，定義了玩家在事件中可以選擇的選項。 |         *   `option_name`: 選項的名稱，例如 "制作为治疗喷雾"、"将以太露滴收集储存"、"直接离开"。 |         *   `desc`: 選項的描述，說明選擇該選項的效果。 | *   **重要功能點:** |     *   定義了玩家可以選擇的三個選項：製作治療噴霧（回復全隊生命值）、收集儲存以太露滴、直接離開。 |     *   每個選項都配有描述，說明選擇後的效果。
│   │   │       ├── 侵蚀扭蛋机.yml    這個 YAML 文件定義了一個遊戲事件，名為 "侵蚀扭蛋机"，屬於 "古怪装置" 事件。它提供了兩個選項：選擇一枚 "诡术鸣徽" 或離開。 |  | *   **主要功能:** 定義遊戲中的一個事件及其選項。 | *   **核心元素:** |     *   `entry_name`: 事件的入口名稱，為 "侵蚀扭蛋机"。 |     *   `event_name`: 事件的名稱，為 "古怪装置"。 |     *   `options`: 事件提供的選項列表。 | *   **重要功能點:**  定義了玩家與事件互動的選項，包括選擇物品或離開。
│   │   │       ├── 假面研究者.yml    這個 YAML 文件定義了一個名為 "假面研究者" 的遊戲事件。 |  | *   **主要功能:** 定義了遊戲中與 "假面研究者" 互動時的選項和結果。 | *   **核心元素:**  `entry_name`, `event_name`, `options`。`options` 包含多個選項，每個選項都有 `option_name` 和可選的 `desc` (描述)。 | *   **重要功能點:** |     *   多種選項，提供不同的遊戲內獎勵或效果，例如：獲得物品（鳴徽、炸彈、邦布、齒輪硬幣、立體複印）、觸發事件、治療效果（消除侵蝕、恢復生命值）、商店。 |     *   部分選項帶有描述，說明選擇後的具體效果。
│   │   │       ├── 全自动医疗仓.yml    這個 YAML 文件定義了遊戲中的一個事件 "全自动医疗仓" 及其相關選項。 |  | *   **主要功能:** 定義了遊戲事件 "全自动医疗仓" 的行為，包括觸發條件和玩家可選擇的選項。 | *   **核心類/函數:**  `entry_name`, `event_name`, `options`, `option_name`, `desc` (這些是 YAML 文件中的關鍵字段，用於定義事件的結構和內容)。 | *   **重要功能點:** |     *   事件 "全自动医疗仓" 及其兩個實例。 |     *   第一個實例定義了兩個選項: "启动医疗仓" (描述為將存活代理人的生命值按比例均分給全隊) 和 "暂时离开"。 |     *   第二個實例僅定義了事件名稱 "启动医疗仓"。
│   │   │       ├── 同伴.yml    這個 YAML 文件定義了一個遊戲事件，名為 "鬼鬼祟祟的学者"。 |  | *   **主要功能:** 定義遊戲中的一個事件，用於觸發遊戲內容。 | *   **核心元素:** |     *   `entry_name`:  事件的入口名稱，值為 "同伴"。 |     *   `event_name`:  事件的名稱，值為 "鬼鬼祟祟的学者"。 | *   **重要功能點:**  定義了遊戲中一個特定事件的元數據，用於遊戲邏輯的觸發和處理。
│   │   │       ├── 呼叫增援-拒绝.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏中“呼叫增援”事件在不同角色下的响应，以及玩家拒绝增援时获得的奖励。 |  | **核心类和函数:** |  | *   **`entry_name`**:  定义了事件的名称，都为“呼叫增援”。 | *   **`event_name`**:  定义了角色对事件的回复。 | *   **`options`**: 定义了玩家拒绝增援后可以获得的奖励，均为随机获得不同类型的鸣徽。 | *   **`option_name`**: 定义了奖励的描述，即随机获得哪种类型的鸣徽。 |  | **重要功能点:** |  | *   **角色差异化响应**: 针对不同角色，`event_name` 提供了不同的文本回复，增加了游戏的个性化。 | *   **奖励机制**:  玩家拒绝增援后，会随机获得一种特定类型的鸣徽，这是一种游戏内的奖励机制。 | *   **鸣徽类型多样性**:  提供了多种不同类型的鸣徽作为奖励，包括以太、冻结、感电、引燃、强袭、决斗、暴击、能量、支援、护盾、闪避、通用和顽强，增加了游戏策略性。 | *   **数据驱动**:  使用 YAML 文件存储数据，方便修改和扩展游戏内容。
│   │   │       ├── 奇怪的侦探.yml    這個 YAML 文件定義了一個遊戲事件，名為 "奇怪的侦探"。 |  | *   **主要功能:** 定義遊戲中的一個事件，可能用於觸發劇情、提供任務或與玩家互動。 | *   **核心元素:** |     *   `entry_name`:  事件的內部名稱，為 "奇怪的侦探"。 |     *   `event_name`:  事件的顯示名稱，為 "旧都失物奇怪的侦探"。 | *   **重要功能點:**  定義了事件的標題和描述，用於在遊戲中識別和呈現該事件。
│   │   │       ├── 奇怪的学生.yml    這個 YAML 文件定義了一個名為 "奇怪的学生" 的遊戲事件，屬於 "旧都失物奇怪的少女" 事件。 |  | *   **主要功能:** 定義遊戲中的一個事件，包含事件名稱、選項列表。 | *   **核心元素:** |     *   `entry_name`: 事件的入口名稱，為 "奇怪的学生"。 |     *   `event_name`: 事件的名稱，為 "旧都失物奇怪的少女"。 |     *   `options`: 一個選項列表，定義了玩家在事件中可以選擇的選項。 | *   **重要功能點:**  定義了玩家在事件中可以選擇的各種選項，例如離開、攻擊、拒絕邀請、詢問等，這些選項將影響遊戲的進程。
│   │   │       ├── 奇货.yml    這個 YAML 文件定義了一個名為 "奇货" 的遊戲事件，描述了一個自動販賣機。 |  | *   **主要功能:** 定義遊戲中的一個事件，玩家可以通過不同的選項與自動販賣機互動，並獲得不同的獎勵。 | *   **核心元素:** |     *   `entry_name`: 事件的唯一標識符，為 "奇货"。 |     *   `event_name`: 事件的顯示名稱，為 "事件人工自动贩卖机"。 |     *   `options`:  一個選項列表，每個選項代表玩家與販賣機互動的不同方式。 | *   **重要功能點:** |     *   不同的選項允許玩家以不同方式與販賣機互動，例如 "拆开贩卖机一探究竞"、"大量投币"、"正常投币"、"恐吓贩卖机"、"搜集浓缩医疗"。 |     *   每個選項都有不同的描述 (`desc`)，說明選擇該選項後玩家會獲得的獎勵或產生的影響。 |     *   獎勵包括稀有邦布插件、普通邦布插件和濃縮醫療，以及壓力值的變化。 |     *   `lcs_percent`:  可能表示事件觸發的機率或相關的邏輯。
│   │   │       ├── 对空部特遣队.yml    這個 YAML 文件定義了一個遊戲事件 "对空部特遣队"。 |  | *   **主要功能:** 定義了遊戲中的一個事件，包含事件名稱、選項及其對應的獎勵。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "对空部特遣队"。 |     *   `event_name`: 事件的顯示名稱，為 "事件对空部特遣队"。 |     *   `options`: 一個選項列表，每個選項代表玩家可以選擇的操作。 |         *   `option_name`: 選項的名稱。 |         *   `desc`: 選項的描述，說明選擇該選項後玩家將獲得的獎勵，例如 "获得2个浓缩医疗" 或 "获得协助类型B级鸣徽"。 | *   **重要功能點:** 定義了玩家在遊戲中可以選擇的事件選項，以及每個選項對應的獎勵。
│   │   │       ├── 怀斯塔学会研究站.yml    這個 YAML 文件定義了一個遊戲事件，名為 "怀斯塔学会研究站"。 |  | *   **主要功能:** 定義了遊戲中一個名為 "怀斯塔学会研究站" 的事件及其選項。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "怀斯塔学会研究站"。 |     *   `event_name`: 事件的顯示名稱，為 "事件怀斯塔学会研究站"。 |     *   `options`:  一個列表，定義了玩家可以選擇的選項。 | *   **重要功能點:** |     *   定義了三個選項，每個選項都有 `option_name` 和 `desc` 描述。 |     *   選項包括： |         *   "想要点武装物资"： 獎勵 2 枚 "[空洞] 鸣徽"。 |         *   "再多要一些"： 增加 70 點壓力值。 |         *   "离开"： 退出事件。
│   │   │       ├── 房屋残骸.yml    這個 YAML 文件定義了一個名為 "房屋残骸" 的遊戲事件。 |  | *   **主要功能:** 定義遊戲中的一個事件，包含事件名稱、觸發機率（`lcs_percent`）以及多個選項，每個選項都描述了玩家可以採取的行動及其結果。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "房屋残骸"。 |     *   `event_name`: 事件的顯示名稱，為 "事件坍塌的房屋"。 |     *   `lcs_percent`: 事件觸發的機率，為 0.6。 |     *   `options`: 一個列表，包含玩家可以選擇的選項，每個選項都有 `option_name` 和 `desc` 描述。 | *   **重要功能點:** |     *   事件包含多個選項，每個選項都提供不同的結果，例如獲得齒輪硬幣、承受侵蝕症狀、損失生命值、資源受損或消耗物品。 |     *   選項提供了多樣化的互動，包括探索、資源管理和風險評估。
│   │   │       ├── 投机客.yml    這個 YAML 文件定義了遊戲中名為「投機客」的事件及其相關選項。 |  | *   **主要功能:** 描述了遊戲事件「投機客」的各種互動選項，包括借款、獲取資源、消除負面狀態、恢復生命值、以及還款等。 | *   **核心類/函數:**  該文件使用 YAML 格式，沒有類或函數的概念，但定義了兩個主要的 `entry_name`，分別是 "投機客" 和 "投機客的提醒"，每個 `entry_name` 下包含了 `event_name` 和 `options` 列表。 | *   **重要功能點:** |     *   多種借款選項，提供不同金額的齒輪硬幣。 |     *   提供獲取稀有資源的選項，例如「超级物资」和「物资大礼包」。 |     *   提供消除負面狀態的選項，例如「净化侵蚀」和「清除压力」。 |     *   提供恢復生命值的選項，例如「身体康复训练」和「恢复身体」。 |     *   提供催化鳴徽的選項。 |     *   提供還款選項。 |     *   「投機客的提醒」事件提供還款相關的選項。
│   │   │       ├── 有偿休息站.yml    這個 YAML 文件定義了遊戲中名為「有償休息站」的事件，包含了多個子事件，每個子事件都有不同的選項。 |  | *   **主要功能:** 定義遊戲中的事件，提供玩家在「有償休息站」中的互動選項。 | *   **核心元素:** |     *   `entry_name`: 事件的入口名稱，都為 "有偿休息站"。 |     *   `event_name`: 子事件的名稱，例如 "热闹的休息站"、"救助伤员"、"互通有无"、"有偿实验"、"事件有偿休息站"。 |     *   `options`: 每個子事件的選項列表，包含 `option_name` 和可選的 `desc` (描述)。 | *   **重要功能點:** |     *   不同的子事件提供了不同的互動方式，例如打聽消息、救助傷員、交易、實驗等。 |     *   部分選項會消耗資源（例如生命值、齒輪硬幣）或影響狀態（例如壓力值、侵蝕）。 |     *   `desc` 字段提供了選項的詳細描述，說明了選擇該選項的後果。
│   │   │       ├── 求救信号.yml    這個 YAML 文件定義了一個遊戲事件，名為 "求救信号"。 |  | *   **主要功能:** 定義了遊戲中名為 "求救信号" 的事件，包含事件名稱和玩家可選擇的選項。 | *   **核心元素:** |     *   `entry_name`: "求救信号" - 事件的內部標識符。 |     *   `event_name`: "事件求救信号" - 事件的顯示名稱。 |     *   `options`: 一個列表，定義了玩家在事件中可以選擇的選項，例如 "进行信号源分析"、"直接进入"、"无视信号" 等。 | *   **重要功能點:**  定義了玩家在事件中可以選擇的各種選項，這些選項將影響遊戲的進程。
│   │   │       ├── 治安官小队.yml    這個 YAML 文件定義了一個遊戲事件 "治安官小队" (治安官小隊)。 |  | *   **主要功能:** 定義遊戲中的一個事件，包含事件名稱、觸發幾率 (lcs_percent) 和多個選項。 | *   **核心類/函數:**  無特定類或函數，文件本身即是數據定義。 | *   **重要功能點:** |     *   `entry_name`: 事件的內部識別名稱，為 "治安官小队"。 |     *   `event_name`: 事件的顯示名稱，為 "治安局预备队"。 |     *   `lcs_percent`: 事件觸發幾率，為 0.5 (50%)。 |     *   `options`:  定義了玩家在事件中可以選擇的選項，包含三個選項: "我一定要珍惜地使用", "不要白不要", "冒风险才有收益"。
│   │   │       ├── 活化结晶.yml    這個 YAML 文件定義了一個名為 "活化结晶" 的遊戲事件。 |  | *   **主要功能:** 定義了遊戲中一個事件的相關數據，包括事件名稱、觸發概率和玩家可選擇的選項。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "活化结晶"。 |     *   `event_name`: 事件的顯示名稱，為 "活化结晶"。 |     *   `lcs_percent`: 事件觸發的概率，為 0.6 (60%)。 |     *   `options`:  一個列表，定義了玩家可以選擇的選項。每個選項包含 `option_name` (選項名稱) 和 `desc` (選項描述)。 | *   **重要功能點:** |     *   定義了三個不同的選項，每個選項都提供了不同的獎勵和負面效果 (侵蝕)。 |     *   選項的描述清楚地說明了每個選項的結果，包括獲得的資源、生命值恢復、侵蝕狀態的改變以及其他遊戲狀態的影響。
│   │   │       ├── 盗洞客.yml    這個 YAML 文件定義了遊戲中與名為“盗洞客”相關的事件和選項。 |  | *   **主要功能:** 定義了遊戲事件的結構，包括事件名稱、入口名稱和玩家可選擇的選項。 | *   **核心結構:**  文件使用 YAML 格式，以列表的形式定義事件。每個事件包含 `entry_name`, `event_name` 和 `options` 字段。 | *   **重要功能點:** |     *   定義了三個不同的事件，都與“盗洞客”相關。 |     *   每個事件都提供了不同的選項，供玩家選擇，例如獲取物資、拒絕合作或繼續前進。 |     *   其中一個事件涉及到“石头剪子布”遊戲。
│   │   │       ├── 盗洞客集会.yml    這個 YAML 文件定義了遊戲中的兩個事件，名為 "盗洞客集会"，它們都屬於 "因缘际会" 事件。 每個事件都包含一系列選項，這些選項會影響遊戲狀態，例如增加或減少資源、改變生命值、壓力值，或提供特殊物品。 |  | 核心類和函數： |  | *   **`entry_name`**:  事件的唯一標識符，這裡都是 "盗洞客集会"。 | *   **`event_name`**: 事件的名稱，這裡都是 "因缘际会"。 | *   **`options`**:  包含玩家可選擇的選項列表。 | *   **`option_name`**:  選項的名稱。 | *   **`desc`**:  選項的描述，說明選項的影響。 |  | 重要功能點： |  | *   定義了多個選項，這些選項提供了不同的遊戲內效果，包括資源增減、生命值變化、壓力值變化、以及物品的獲得或失去。 | *   選項涵蓋了正面和負面效果，增加了遊戲的策略性和風險。 | *   選項的描述清晰地說明了每個選項的後果，方便玩家做出選擇。
│   │   │       ├── 盲盒区域.yml    這個 YAML 文件定義了遊戲中與「盲盒區域」相關的事件和選項。 |  | *   **主要功能:** 定義了遊戲中與盲盒區域互動的事件流程和選項。 | *   **核心類/函數:**  沒有類或函數，只有YAML數據結構。 | *   **重要功能點:** |     *   `entry_name`:  事件的標題，例如 "盲盒区域" 和 "不宜久留"。 |     *   `event_name`:  事件的描述，例如 "特殊区域播报" 和 "特殊区域"。 |     *   `options`:  玩家可以選擇的選項，例如 "拉四下", "拉一下", "离开", "确认继续"。
│   │   │       ├── 真相.yml    這個 YAML 文件定義了一個名為 "真相" 的遊戲事件，描述了事件的名稱、觸發概率、以及玩家可選擇的選項。 |  | *   **主要功能:** 定義遊戲中的一個事件，包含事件名稱、觸發概率和選項。 | *   **核心元素:** |     *   `entry_name`: 事件的唯一標識符，這裡為 "真相"。 |     *   `event_name`: 事件的顯示名稱，這裡為 "事件药剂说明书"。 |     *   `lcs_percent`: 事件觸發的概率，這裡為 0.6 (60%)。 |     *   `options`: 玩家可選擇的選項列表。 |         *   `option_name`: 選項的名稱。 |         *   `desc`: 選項的描述，例如 "压力值+100"。 | *   **重要功能點:** |     *   定義了兩個選項："不使用" 和 "直接使用一点点"，後者會增加玩家的壓力值。
│   │   │       ├── 秘医.yml    這個 YAML 文件定義了一個名為“秘医”的遊戲事件，它提供了多個選項供玩家選擇，每個選項都會產生不同的結果。 |  | *   **主要功能:** 定義遊戲中的一個事件，玩家可以通過選擇不同的選項來獲得不同的獎勵或承受不同的後果。 | *   **核心類/函數:**  該文件是數據文件，沒有類或函數。它使用 YAML 格式來定義事件的結構和選項。 | *   **重要功能點:** |     *   提供多種選項，包括： |         *   獲取醫療物品（濃縮醫療）。 |         *   獲取鳴徽（護盾）。 |         *   恢復生命值。 |         *   獲取齒輪硬幣。 |         *   探查地圖。 |         *   催化鳴徽。 |         *   獲取補給品。 |         *   跳過事件。 |     *   選項會影響玩家的資源、生命值、壓力值和遊戲進度。
│   │   │       ├── 精锐邦布助手.yml    這個 YAML 文件定義了遊戲中名為「精銳邦布助手」的事件，包含多個子事件和選項。 |  | *   **主要功能:** 定義遊戲內的事件，提供玩家與「精銳邦布助手」互動的選項，這些選項會影響玩家的遊戲資源和狀態。 | *   **核心結構:** 文件使用 YAML 格式，以 `entry_name` 標識事件，`event_name` 標識子事件，`options` 包含玩家可選擇的選項。 | *   **重要功能點:** |     *   「武装升级」事件：允許玩家用不同級別的鳴徽交換。 |     *   「随机交换」事件：允許玩家交換鳴徽。 |     *   「事件精锐邦布助手」事件：包含多個選項，例如增加壓力值、複製物品、獲得鳴徽或購買禮包。 |     *   `lcs_percent`: 可能是事件觸發機率的參數。 |     *   `desc`: 描述選項的效果。
│   │   │       ├── 紧急撤离点.yml    這個 YAML 文件定義了遊戲中的兩個事件，都與“緊急撤離點”相關。 |  | *   **主要功能:** 定義了遊戲中與緊急撤離相關的事件，以及玩家在這些事件中的選項。 | *   **核心結構:** 文件使用 YAML 格式，包含多個事件條目 (entries)。每個條目定義了 `entry_name` (事件入口名稱), `event_name` (事件名稱) 和 `options` (玩家選項列表)。 | *   **重要功能點:** |     *   定義了不同事件的名稱，例如 "紧急撤离点" 和 "事件应急撒离点"。 |     *   每個事件都提供了多個玩家選項，例如 "不需要按下按钮" 和 "让X号队员离队体整"。 |     *   其中一個事件包含特定於角色的選項，例如 "还没到偷懒的时间"。
│   │   │       ├── 裂隙.yml    這個 YAML 文件定義了一個名為「裂隙」的遊戲事件，包含事件名稱和多個選項。每個選項都描述了不同的結果，例如壓力值變化、角色生命值恢復或損失、物品遺失等。 |  | *   **主要功能:** 定義遊戲中的一個事件及其選項和結果。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "裂隙"。 |     *   `event_name`: 事件的顯示名稱，為 "事件裂隙"。 |     *   `options`: 一個列表，包含事件的選項。 |         *   `option_name`: 選項的名稱。 |         *   `desc`: 選項的描述，描述了選擇該選項後發生的結果。 | *   **重要功能點:** |     *   定義了多種選項，每個選項都對遊戲狀態產生不同的影響，包括壓力值變化、角色生命值變化、物品遺失等。 |     *   選項的多樣性增加了遊戲的互動性和隨機性。
│   │   │       ├── 调查协会补给站.yml    這個 YAML 文件定義了一個遊戲事件，名為「調查協會補給站」。 |  | *   **主要功能:** 定義了玩家在遊戲中可以選擇的選項，這些選項與獲取補給品或產生其他遊戲效果相關。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "调查协会补给站"。 |     *   `event_name`: 事件的顯示名稱，為 "事件协会支援站"。 |     *   `options`: 一個列表，包含玩家可以選擇的選項。 | *   **重要功能點:** |     *   每個 `option_name` 定義了一個玩家可以選擇的選項。 |     *   `desc` 字段描述了每個選項的效果，包括獲得補給品、觸發事件或影響玩家的狀態（例如壓力值）。 |     *   選項包括：兌換補給品、獲取鳴徽、獲取插件、恢復生命值等。
│   │   │       ├── 调查员.yml    這個 YAML 文件定義了一個名為 "调查员" 的遊戲事件，該事件提供了多個選項供玩家選擇。 |  | *   **主要功能:** 定義遊戲中的一個事件，允許玩家與 "调查员" 互動並獲得獎勵。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "调查员"。 |     *   `event_name`: 事件的顯示名稱，為 "老练的调查员"。 |     *   `options`: 一個列表，定義了玩家可以選擇的選項。 | *   **重要功能點:** |     *   提供多個選項，每個選項都有不同的描述和結果。 |     *   選項包括購買鳴徽、交換鳴徽、用壓力值換取高級鳴徽，以及拒絕互動。 |     *   選項的結果包括消耗遊戲內貨幣、交換物品、增加壓力值和獲得鳴徽。
│   │   │       ├── 资源回收小组.yml    這個 YAML 文件定義了一個名為 "资源回收小组" 的遊戲事件。 |  | *   **主要功能:** 定義了遊戲中一個事件的數據，包括事件名稱、觸發概率、以及玩家可以選擇的選項。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "资源回收小组"。 |     *   `event_name`: 事件的顯示名稱，為 "资源回收小组"。 |     *   `lcs_percent`: 事件觸發的概率，為 0.6 (60%)。 |     *   `options`: 包含多個選項的列表，每個選項定義了玩家可以採取的行動。 | *   **重要功能點:** |     *   定義了四個選項，每個選項都有不同的描述，包括購買、搶奪、求情和離開。 |     *   每個選項都與不同的遊戲內資源消耗或影響相關，例如齒輪幣、生命值和壓力值。
│   │   │       ├── 通道.yml    這個 YAML 文件定義了遊戲中名為“通道”的事件的配置數據。 |  | *   **主要功能**: 定義了遊戲中的事件，包括事件名稱、選項及其效果。 | *   **核心類和函數**:  此文件是數據文件，沒有類或函數。它使用 YAML 格式來定義事件的結構。 | *   **重要功能點**: |     *   `entry_name`:  事件的標識符，都為 "通道"。 |     *   `event_name`:  事件的描述，例如 "前人藏宝，后人生财" 和 "事件安全车厢"。 |     *   `options`:  每個事件的選項列表。 |         *   `option_name`: 選項的名稱。 |         *   `desc`: 選項的描述，描述了選擇該選項後的效果，例如獲得金幣、徽章、損失生命值或壓力值等。
│   │   │       ├── 邂逅.yml    ## 摘要 |  | **文件功能:**  定义了游戏中“邂逅”事件的各种分支和选项，这些事件与不同的角色和地点相关联。 |  | **核心类/函数:**  该文件主要由数据构成，没有明确的类或函数。核心数据结构是YAML格式的事件描述，包含以下字段： | *   `entry_name`: 事件的入口名称，这里统一为 "邂逅"。 | *   `event_name`: 事件的名称。 | *   `lcs_percent`:  可能影响事件结果的百分比。 | *   `options`:  事件提供的选项列表，每个选项包含 `option_name` 和可选的 `desc` (描述)。 |  | **重要功能点:** |  | *   **事件分支:**  文件定义了大量“邂逅”事件，每个事件都与特定角色相关联，并提供不同的选项。 | *   **选项影响:**  选项的选择可能会影响游戏进程，例如，通过描述中的效果（例如，伤害提升，压力值降低，清除侵蚀症状）。 | *   **角色互动:**  事件涉及多个游戏角色，包括安比、比利、妮可等，以及不同组织（如狡兔屋、刑侦特勤组、维多利亚家政等）的角色。 | *   **条件概率:**  `lcs_percent` 字段暗示了某些事件可能存在概率触发的机制。
│   │   │       ├── 门扉禁闭-侵蚀.yml    這個 YAML 文件定義了一個遊戲事件，名為 "门扉禁闭-侵蚀"（門扉禁閉-侵蝕），與 "异化检疫门"（異化檢疫門）相關。它描述了玩家在遊戲中可能遇到的情境，並提供了三個選項供玩家選擇：接受檢疫掃描、使用共犯的鑰匙扣、強行闖入通道。 |  | *   **主要功能:** 定義遊戲中的一個事件及其選項。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "门扉禁闭-侵蚀"。 |     *   `event_name`: 事件的顯示名稱，為 "异化检疫门"。 |     *   `options`: 包含玩家可選擇的選項列表。 | *   **重要功能點:** 定義了玩家在事件中可以採取的行動，包括與遊戲內物品或機制互動的選項。
│   │   │       ├── 门扉禁闭-善战.yml    這個 YAML 文件定義了一個遊戲事件 "门扉禁闭-善战"。 |  | *   **主要功能:** 定義遊戲中的一個事件，描述了事件的名稱、觸發條件和相關參數。 | *   **核心元素:** |     *   `entry_name`: 事件的內部標識符，為 "门扉禁闭-善战"。 |     *   `event_name`: 事件的顯示名稱，為 "怀斯塔学会的前线补给据点"。 |     *   `lcs_percent`: 一個數值，可能表示事件的某種概率或影響。 | *   **重要功能點:**  定義了遊戲事件的關鍵屬性，包括事件的名稱和相關的數值參數。
│   │   │       ├── 门扉禁闭-财富.yml    這個 YAML 文件定義了一個名為“门扉禁闭-财富”的遊戲事件，它與“付费道路”相關聯。它包含一系列選項，玩家可以選擇使用鑰匙、支付費用或離開。核心功能是定義了事件的名稱、描述和玩家可選擇的選項，以及每個選項的描述，例如支付費用或獲得獎勵。
│   │   │       ├── 防卫军后勤站.yml    這個 YAML 文件定義了一個遊戲事件，名為 "防卫军后勤站"。 |  | *   **主要功能**: 定義遊戲中的一個事件，包含事件名稱和玩家可選擇的選項。 | *   **核心元素**: |     *   `entry_name`: 事件的內部名稱，為 "防卫军后勤站"。 |     *   `event_name`: 事件的顯示名稱，為 "防卫军后勤站"。 |     *   `options`: 一個列表，包含玩家可以選擇的選項，包括 "公平交易"、"热情夸赞他们空手套物资" 和 "稍作休息"。 | *   **重要功能點**:  定義了遊戲事件的選項，這些選項將影響遊戲的進程和玩家的互動。
│   │   │       ├── 限时战斗.yml    這個 YAML 文件的摘要如下： |  | 1.  **主要功能:** 定義了遊戲中兩個限時戰鬥事件的數據。 | 2.  **核心類和函數:**  文件使用 YAML 格式，沒有類或函數，而是使用 `entry_name`, `event_name`, `option_name` 等鍵來組織數據。 | 3.  **重要功能點:** |     *   定義了兩個限時戰鬥事件，分別名為 "邦布的秘宝" 和 "身份检查"。 |     *   每個事件包含 `entry_name` 和 `event_name` 屬性，用於標識事件。 |     *   第一個事件包含一個選項 `option_name` 為 "人为财死邦布也是"。
│   │   │       ├── 零号银行.yml    這個 YAML 文件定義了一個名為“零號銀行”的遊戲事件。 |  | *   **主要功能:** 定義了遊戲中“零號銀行”事件的選項和交互。 | *   **核心元素:** |     *   `entry_name`: "零号银行" - 事件的入口名稱。 |     *   `event_name`: "零号银行" - 事件的名稱。 |     *   `options`: 一個列表，定義了玩家在事件中可以選擇的選項，例如“领取存款返利”、“存款”、“离开”、“密开”、“存入齿轮硬币”、“血样”、“接受压力债务”、“不存了”。 | *   **重要功能點:**  定義了玩家在“零號銀行”事件中可以進行的各種操作，包括存款、取款、互動等。
│   │   │       └── 馅饼天降.yml    這個 YAML 文件定義了一個名為 "馅饼天降" 的遊戲事件，它描述了事件的觸發條件、事件名稱、以及玩家在事件中可以選擇的四個選項。 |  | *   **主要功能:** 定義遊戲中的一個隨機事件，玩家可以通過選擇不同的選項來獲得不同的獎勵或承受不同的後果。 | *   **核心元素:** |     *   `entry_name`: 事件的內部名稱，為 "馅饼天降"。 |     *   `event_name`: 事件的顯示名稱，為 "事件埋伏"。 |     *   `lcs_percent`: 事件觸發的概率，為 0.6。 |     *   `options`:  一個列表，包含了玩家可以選擇的選項，每個選項包含： |         *   `option_name`: 選項的名稱。 |         *   `desc`: 選項的描述，說明選擇該選項會發生的事情。 | *   **重要功能點:** |     *   事件觸發概率控制。 |     *   多個選項提供不同的獎勵和懲罰，包括： |         *   消耗齒輪硬幣換取S級鳴徽。 |         *   角色生命值損失換取S級鳴徽。 |         *   生命值損失換取齒輪硬幣。 |         *   損失生命值。
│   │   └── screen_info/
│   │       ├── arcade.yml    這個 YAML 文件定義了遊戲 "arcade" 的屏幕信息，用於界面元素定位和識別。 |  | *   **主要功能:** 描述了 "arcade" 屏幕的各個區域，包括其名稱、坐標、文本和其他相關屬性。 | *   **核心結構:**  YAML 文件使用 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 結構來組織數據。 `area_list` 包含多個區域的定義。 | *   **重要功能點:** |     *   定義了屏幕上不同區域的坐標 (`pc_rect`)，用於定位 UI 元素。 |     *   每個區域都包含 `area_name` (區域名稱) 和 `text` (文本內容)。 |     *   `lcs_percent`, `template_sub_dir`, `template_id`, `template_match_threshold` 屬性用於模板匹配和識別。 |     *   定義了如 "游戏名称", "玩家数量", "下一个游戏", "选择", "模式列表", "开始游戏", "蛇对蛇-点击空白处继续", "蛇对蛇-加载完成" 等區域。
│   │       ├── battle.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏战斗界面的屏幕信息，包括屏幕 ID、名称以及界面上各个区域的详细信息，用于游戏 UI 自动化或图像识别。 |  | **核心数据结构:** |  | *   `screen_id`: 屏幕的唯一标识符，此处为 "battle"。 | *   `screen_name`: 屏幕的显示名称，此处为 "战斗画面"。 | *   `area_list`: 包含多个区域信息的列表，每个区域定义了屏幕上一个特定区域的属性。 |  | **重要功能点:** |  | *   **区域定义:**  `area_list` 中每个元素代表一个屏幕区域，包含以下关键信息： |     *   `area_name`: 区域的名称，例如 "头像-3-1", "按键-普通攻击" 等。 |     *   `pc_rect`: 区域的像素坐标 (左上角 x, y, 右下角 x, y)。 |     *   `text`: 区域内显示的文本。 |     *   `lcs_percent`: 用于图像匹配的相似度百分比。 |     *   `template_sub_dir`: 模板图像的子目录。 |     *   `template_id`: 模板图像的 ID。 |     *   `template_match_threshold`: 模板匹配的阈值。 |     *   `goto_list`:  (未使用)  可能用于定义点击区域后的跳转行为。 | *   **界面元素定位:**  通过 `pc_rect` 定义了游戏中各种按钮、头像、文本框等元素的位置。 | *   **图像识别辅助:**  `template_sub_dir`, `template_id`, `template_match_threshold` 和 `lcs_percent`  用于图像识别，辅助定位和识别屏幕元素。 | *   **战斗结果和操作按钮:** 定义了 "完成", "再来一次", "撤退", "倒带", "退出" 等战斗结果和操作按钮的区域。
│   │       ├── battle_menu.yml    這個 YAML 文件定義了遊戲中戰鬥菜單的屏幕信息。 |  | *   **主要功能:**  描述了戰鬥菜單的界面元素，包括按鈕和菜單項的坐標、文本、以及其他相關屬性。 | *   **核心結構:**  文件使用 YAML 格式，以 `screen_id` 和 `screen_name` 標識屏幕，`area_list` 包含了屏幕上各個區域的詳細信息。 | *   **重要功能點:** |     *   定義了屏幕的 ID 和名稱。 |     *   列出了屏幕上的按鈕和菜單項，例如 "退出戰鬥"、"設置" 和 "返回"。 |     *   每個區域都包含了坐標 (`pc_rect`)、文本 (`text`)、以及用於圖像識別的相關參數 (`template_sub_dir`, `template_id`, `template_match_threshold`)。 |     *   `goto_list` 屬性 (雖然在此文件中為空) 預計用於定義點擊按鈕後的操作。
│   │       ├── battle_result_fail.yml    這個 YAML 文件定義了遊戲中“戰鬥結果 - 失敗”界面的屏幕信息。 |  | *   **主要功能:** 描述了遊戲中戰鬥失敗結果界面的佈局和元素。 | *   **核心結構:**  YAML 文件使用鍵值對的形式，定義了屏幕的 `screen_id`、`screen_name` 和 `area_list`。 `area_list` 包含了屏幕上各個區域的詳細信息，例如標題和按鈕。 | *   **重要功能點:** |     *   定義了屏幕的 `screen_id` 為 `battle_result_fail`。 |     *   定義了屏幕的 `screen_name` 為 "战斗-挑战结果-失败"。 |     *   `area_list` 中包含了標題和“退出”按鈕的區域信息，包括位置 (`pc_rect`)、文本 (`text`)、匹配閾值等。 |     *   `goto_list` 屬性為空，表示這些區域沒有直接的導航目標。
│   │       ├── city_fund.yml    這個 YAML 文件定義了遊戲中 "丽都城募" 屏幕的界面元素信息。 |  | *   **主要功能:** 描述了 "丽都城募" 屏幕的 UI 元素，包括按鈕、文本區域及其位置。 | *   **核心元素:**  `area_list` 包含了屏幕上所有可交互區域的定義。 | *   **重要功能點:** |     *   定义了屏幕上各个区域的名称 ( `area_name` )，例如 "成长任务"、"等级回馈"、"全部领取" 等。 |     *   每个区域都定义了其在 PC 屏幕上的矩形坐标 (`pc_rect`)，用于定位 UI 元素。 |     *   `text` 字段定义了每个区域显示的文本。 |     *   `goto_list` 字段 (目前为空) 预留了跳转到其他界面的功能。 |     *   `template_id` 和 `template_match_threshold` 字段用于模板匹配，可能用于 UI 元素的识别。
│   │       ├── coffee_shop.yml    這個 YAML 文件定義了遊戲中咖啡店屏幕的界面元素信息。 |  | *   **主要功能:** 描述了咖啡店屏幕的各個交互區域，包括按鈕和顯示區域。 | *   **核心結構:** 使用 YAML 格式，定義了 `screen_id`, `screen_name` 和 `area_list`。`area_list` 包含了多個區域的詳細信息。 | *   **重要功能點:** |     *   `area_name`: 每個區域的名稱，例如 "点单" (點單), "咖啡列表" (咖啡列表) 等。 |     *   `pc_rect`: 屏幕上每個區域的矩形坐標，用於定位。 |     *   `text`: 區域顯示的文本。 |     *   `lcs_percent`: 相似度匹配百分比。 |     *   `template_sub_dir`, `template_id`, `template_match_threshold`: 模板匹配相關的配置。
│   │       ├── combat_simulation.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏界面中“实战模拟室”的屏幕信息，包括屏幕 ID、名称以及各个区域的详细信息。这些信息用于游戏 UI 元素的定位和交互。 |  | **核心类和函数:** |  | *   无核心类和函数，该文件主要由数据结构组成。 |  | **重要功能点:** |  | *   `screen_id`:  `combat_simulation`，标识屏幕的唯一 ID。 | *   `screen_name`:  `实战模拟室`，屏幕的显示名称。 | *   `area_list`:  一个列表，定义了屏幕上各个区域的详细信息，每个区域包含： |     *   `area_name`: 区域的名称，例如“挑战奖励”、“副本名称列表”等。 |     *   `pc_rect`: 区域的矩形坐标，用于定位 UI 元素。 |     *   `text`:  区域显示的文本。 |     *   `lcs_percent`:  用于模板匹配的相似度百分比。 |     *   `template_sub_dir`, `template_id`:  模板相关信息。 |     *   `template_match_threshold`:  模板匹配阈值。 |     *   `color_range`:  颜色范围。 |     *   `goto_list`:  跳转列表。 | *   定义了多个 UI 元素，包括按钮（例如“下一步”、“出战”、“保存方案”、“确定并出战”），文本显示区域（例如“挑战等级”、“剩余电量”、“需要电量”）以及列表和卡片区域。
│   │       ├── commission_assistant.yml    ## 代码摘要 |  | **文件功能:** |  | 此 YAML 文件定义了游戏界面中“委托助手”界面的布局信息，包括各个区域的坐标、文本、模板匹配等信息，用于界面元素的定位和交互。 |  | **核心结构:** |  | *   YAML 文件结构：使用 YAML 格式定义界面元素，包含 `screen_id`, `screen_name`, `area_list` 等字段。 | *   `area_list`:  一个列表，包含多个区域的定义，每个区域定义了其在屏幕上的位置（`pc_rect`），文本（`text`），模板信息（`template_sub_dir`, `template_id`），以及其他属性。 |  | **重要功能点:** |  | *   界面区域定义：定义了对话框标题、右侧选项区域、中间选项区域、左上角街区、对话框确认、左上角返回、文本-剧情右上角、标题-短信、按钮-短信-关闭、区域-短信-文本框、按钮-自动等区域。 | *   坐标和尺寸信息：使用 `pc_rect` 字段定义了每个区域在 PC 屏幕上的坐标和尺寸。 | *   文本信息：使用 `text` 字段定义了区域内的文本内容。 | *   模板匹配：使用 `template_sub_dir`, `template_id` 和 `template_match_threshold` 定义了基于模板匹配的区域定位方式。 | *   界面元素：定义了界面中的各种元素，如按钮、文本框等。
│   │       ├── common_deploy.yml    這個 YAML 文件定義了遊戲中一個名為 "通用-出戰" 的屏幕的界面元素佈局信息。 |  | *   **主要功能:** 描述了遊戲界面中 "出戰" 屏幕的按鈕和其他交互區域的配置信息。 | *   **核心結構:**  使用 `screen_id`, `screen_name` 和 `area_list` 結構來組織數據。 `area_list` 包含多個字典，每個字典描述一個屏幕上的交互區域（例如按鈕）。 | *   **重要功能點:** |     *   定義了屏幕的名稱和 ID。 |     *   列出了屏幕上各個按鈕的詳細信息，包括： |         *   `area_name`: 區域的描述性名稱。 |         *   `pc_rect`: 區域的矩形坐標，用於定位。 |         *   `text`: 按鈕上的文本。 |         *   `lcs_percent`: 匹配百分比。 |         *   `template_id`, `template_sub_dir`, `template_match_threshold`: 模板匹配相關信息。 |         *   `color_range`: 顏色範圍。 |         *   `goto_list`: 導航列表。
│   │       ├── common_screen.yml    這個 YAML 文件定義了一個遊戲屏幕的通用信息，主要用於界面元素定位和識別。 |  | *   **主要功能:** 描述遊戲屏幕的通用信息，包括屏幕 ID、名稱和界面區域定義。 | *   **核心類/函數:**  沒有類或函數，主要由 YAML 數據結構構成。 | *   **重要功能點:** |     *   `screen_id`:  屏幕的唯一標識符 (`common_screen`)。 |     *   `screen_name`: 屏幕的顯示名稱 (`画面-通用`)。 |     *   `area_list`:  定義屏幕上的界面區域列表。 |         *   `area_name`: 區域名稱 (`左上角-街区`)。 |         *   `pc_rect`:  區域的矩形坐標 (左上角 x, y, 寬, 高)。 |         *   `text`:  區域的文本標籤 (`街区`)。 |         *   `lcs_percent`:  用於匹配的相似度百分比。 |         *   `template_sub_dir`, `template_id`, `template_match_threshold`:  與模板匹配相關的配置，用於圖像識別。
│   │       ├── compendium.yml    這個 YAML 文件定義了遊戲中“快捷手册”界面的屏幕信息。 |  | *   **主要功能:** 定義了“快捷手册”界面的各個區域的佈局和屬性，用於遊戲的 UI 呈現和交互。 | *   **核心結構:** 使用 `screen_id` 和 `screen_name` 標識屏幕，`area_list` 包含多個區域的定義。 | *   **重要功能點:** |     *   `area_name`: 定義了屏幕上各個區域的名稱，例如 "TAB列表", "分类列表", "传送确认" 等。 |     *   `pc_rect`: 定義了每個區域在 PC 屏幕上的矩形坐標，用於定位 UI 元素。 |     *   `text`: 區域內顯示的文本。 |     *   `lcs_percent`, `template_sub_dir`, `template_id`, `template_match_threshold`: 這些屬性可能與圖像識別或模板匹配相關，用於 UI 元素的識別和交互。
│   │       ├── compendium_combat.yml    這個 YAML 文件定義了遊戲中“快捷手册-作战”界面的屏幕信息。 |  | *   **主要功能**: 定義了屏幕的佈局和交互元素，包括標籤頁和按鈕。 | *   **核心結構**: 使用 `screen_id`, `screen_name`, `area_list` 等字段來描述屏幕的各個組成部分。`area_list` 包含了屏幕上各個區域的詳細信息，例如按鈕和標籤頁。 | *   **重要功能點**: |     *   定義了多個標籤頁，包括“训练”，“目标”，“日常”，“作战”，“战术”，以及一個“关闭”按鈕。 |     *   `id_mark` 字段標記了當前激活的標籤頁（“作战”）。 |     *   `goto_list` 字段定義了點擊每個區域後的操作，例如跳轉到其他界面。 |     *   `color_range` 字段定義了“作战”標籤頁的顏色範圍。
│   │       ├── compendium_errands.yml    這個 YAML 文件定義了遊戲中一個名為 "快捷手册-日常" 的屏幕的 UI 元素和交互信息。 |  | *   **主要功能:** 定義了 "快捷手册-日常" 屏幕的各個區域，包括選項卡和按鈕，以及它們的交互行為，例如跳轉到其他屏幕。 | *   **核心結構:** 文件使用 YAML 格式，包含 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 字段。 `area_list` 包含了屏幕上各個區域的詳細信息。 | *   **重要功能點:** |     *   定義了屏幕上各個選項卡 (TAB-训练, TAB-目标, TAB-日常, TAB-作战, TAB-战术) 和按鈕 (按钮-关闭) 的位置、文本、顏色範圍、以及跳轉目標 (goto_list)。 |     *   `id_mark` 字段可能用於標記特定區域。 |     *   `color_range` 字段用於定義顏色範圍，可能用於 UI 元素的視覺效果。 |     *   `goto_list` 字段定義了點擊區域後要跳轉到的屏幕。
│   │       ├── compendium_primer.yml    這個 YAML 文件定義了遊戲中一個名為 "快捷手册-目标" 的屏幕的界面元素和交互行為。 |  | *   **主要功能:** 定義了屏幕的佈局和導航，包括屏幕名稱、區域列表和每個區域的屬性。 | *   **核心結構:** 數據以 YAML 格式組織，使用 `screen_id` 和 `screen_name` 標識屏幕，`area_list` 定義了屏幕上的可交互區域。 | *   **重要功能點:** |     *   `area_name`: 定義了屏幕上的可交互區域的名稱，例如 "TAB-训练"、"TAB-目标" 等。 |     *   `pc_rect`: 定義了區域的坐標和尺寸。 |     *   `text`: 區域的文本標籤。 |     *   `goto_list`: 定義了點擊區域後導航到的屏幕。 |     *   `id_mark`: 標記了 "TAB-目标" 區域，可能用於識別或高亮顯示。 |     *   `color_range`: 定義了 "TAB-目标" 區域的顏色範圍，用於視覺提示。
│   │       ├── compendium_tactics.yml    這個 YAML 文件定義了遊戲中“快捷手册-战术”界面的屏幕信息。 |  | *   **主要功能:** 描述了“快捷手册-战术”界面的各個區域，包括標籤頁和按鈕的坐標、文本、跳轉目標等信息。 | *   **核心數據結構:**  使用 `area_list` 列表定義了界面中的各個區域，每個區域是一個字典，包含區域名稱、坐標 (`pc_rect`)、文本 (`text`)、跳轉目標 (`goto_list`) 等信息。 | *   **重要功能點:** |     *   定义了多个标签页，包括“训练”、“目标”、“日常”、“作战”和“战术”。 |     *   定义了一个“关闭”按钮，用于导航到其他界面。 |     *   `pc_rect` 属性定义了每个区域在屏幕上的位置和大小。 |     *   `goto_list` 属性定义了点击区域后要跳转到的目标界面。 |     *   `id_mark` 属性标识了当前激活的标签页。 |     *   `color_range` 属性定义了高亮标签页的颜色范围。
│   │       ├── compendium_training.yml    **摘要:** |  | 该 YAML 文件定义了游戏界面中“快捷手册-训练”界面的布局和交互信息。 |  | **核心信息:** |  | *   `screen_id`: `compendium_training` (界面 ID) | *   `screen_name`: 快捷手册-训练 (界面名称) | *   `area_list`: 定义了界面中各个区域的详细信息，包括： |     *   TAB 标签页 (训练、目标、日常、作战、战术) |     *   按钮 (关闭、奖励) |     *   文本 (电量) |     *   每个区域的 `pc_rect` (位置和大小), `text` (文本), `goto_list` (跳转目标) 等属性。 |  | **重要功能点:** |  | *   定义了界面中各个可交互区域的位置、文本内容和跳转目标。 | *   通过 `goto_list` 定义了点击不同区域后的跳转行为，例如切换标签页或关闭界面。 | *   `color_range` 属性可能用于图像识别或颜色匹配。 | *   `template_id` 和 `template_match_threshold` 属性可能用于模板匹配，以识别界面元素。
│   │       ├── drive_disc_dismantle.yml    這個 YAML 文件定義了遊戲中“驅動盤拆解”界面的屏幕信息。 |  | *   **主要功能:** 定義了遊戲界面中“驅動盤拆解”屏幕的元素和佈局。 | *   **核心元素:** |     *   `screen_id`: 屏幕的唯一標識符，為 `drive_disc_dismantle`。 |     *   `screen_name`: 屏幕的顯示名稱，為“倉庫-驅動倉庫-驅動盤拆解”。 |     *   `area_list`: 一個列表，定義了屏幕上各個區域的詳細信息，包括： |         *   `area_name`: 區域的名稱，例如“標題-驅動盤拆解”、“按鈕-快速選擇”等。 |         *   `id_mark`: 標識該區域是否用於標識。 |         *   `pc_rect`: 區域在 PC 屏幕上的坐標和尺寸。 |         *   `text`: 區域顯示的文本。 |         *   `lcs_percent`: 文本匹配的相似度。 |         *   `template_sub_dir`, `template_id`, `template_match_threshold`: 模板匹配相關的配置。 |         *   `goto_list`: 導航列表。 | *   **重要功能點:** |     *   定義了屏幕上各個按鈕的區域，包括“快速選擇”、“全選已棄置”、“A及以下”、“S及以下”、“確認”、“拆解”等。 |     *   定義了屏幕上標題區域的文本和位置。 |     *   通過 `pc_rect` 屬性定義了每個按鈕和文本區域在屏幕上的位置和大小。
│   │       ├── email.yml    這個 YAML 文件定義了遊戲中“郵件”界面的屏幕信息。 |  | *   **主要功能:** 描述了遊戲郵件界面的各個交互區域，包括按鈕和文本。 | *   **核心結構:**  YAML 文件使用 `screen_id`, `screen_name` 和 `area_list` 結構來組織數據。 `area_list` 包含多個區域的定義。 | *   **重要功能點:** |     *   定義了屏幕的 ID 和名稱。 |     *   `area_list` 中定義了界面上各個區域的屬性，包括： |         *   `area_name`: 區域的名稱 (例如 "全部领取", "确认", "标题-邮件", "按钮-返回")。 |         *   `pc_rect`: 區域在 PC 屏幕上的坐標和尺寸。 |         *   `text`: 區域的文本內容。 |         *   `template_id` 和 `template_sub_dir`: 用於識別界面的模板信息。 |         *   `goto_list`:  定義了點擊該區域後，遊戲將跳轉到的界面。 |         *   `id_mark`: 標記是否是標識區域。
│   │       ├── enter_game.yml    ## 代码摘要 |  | **1. 主要功能:** |  | 该 YAML 文件定义了游戏启动界面（"enter_game" 屏幕）的各个可交互区域，用于自动化测试或游戏辅助。它描述了不同服务器（国服、B服、国际服）的登录流程，包括账号密码输入、登录按钮、切换账号等操作。此外，还包含了退出登录和服务器选择等功能。 |  | **2. 核心类和函数:** |  | *   **无核心类和函数**: 这是一个数据配置文件，使用 YAML 格式定义屏幕元素信息。 |  | **3. 重要功能点:** |  | *   **屏幕区域定义:**  定义了屏幕上各个区域的名称 (area\_name)、坐标 (pc\_rect)、文本 (text) 和匹配阈值 (lcs\_percent, template\_match\_threshold)。 | *   **多服务器支持:** 包含了国服、B服和国际服的登录流程，以及国际服的服务器选择功能。 | *   **登录流程:**  定义了账号密码输入框、登录按钮、同意按钮等元素的位置和文本。 | *   **切换账号:**  定义了切换账号的区域和确定按钮。 | *   **退出登录:**  定义了退出登录的区域和确认按钮。 | *   **服务器选择:** 国际服的服务器选择区域，包括欧洲、美国、亚洲和港澳台。 | *   **重试:** 定义了重试按钮。
│   │       ├── expert_challenge.yml    這個 YAML 文件定義了遊戲中「專業挑戰室」屏幕的界面信息。 |  | *   **主要功能:** 描述了遊戲屏幕的佈局和元素，包括屏幕 ID、名稱以及屏幕上各個區域的定義。 | *   **核心數據結構:** 使用 YAML 格式，定義了 `screen_id`, `screen_name`, `area_list` 等關鍵字段。`area_list` 包含了屏幕上各個區域的詳細信息，例如 `area_name`, `pc_rect`, `text`, `lcs_percent` 等。 | *   **重要功能點:** |     *   定義了屏幕的 ID 和名稱。 |     *   通過 `area_list` 定義了屏幕上兩個區域：「剩余电量」和「需要电量」，並包含了它們的位置和相關屬性。 |     *   `pc_rect` 屬性定義了每個區域在 PC 屏幕上的坐標。 |     *   `lcs_percent` 屬性可能與圖像識別或匹配有關。
│   │       ├── fishing.yml    **摘要:** |  | 该文件 `fishing.yml` 定义了游戏内钓鱼界面的屏幕信息，包括各个区域的坐标、文本、模板匹配信息等。 |  | **核心功能:** |  | *   定义钓鱼界面的各个交互区域，包括按钮、文本区域等。 | *   使用 `pc_rect` 定义每个区域在 PC 屏幕上的坐标。 | *   使用 `template_id` 和 `template_sub_dir` 指定用于识别区域的模板。 |  | **重要功能点:** |  | *   定义了多个按钮，例如 "时机上鱼"、"左"、"右"、"返回"、"确定"、"强力-左"、"强力-右" 等。 | *   定义了 "挑战结果" 标题区域。 | *   定义了 "点击空白处关闭" 按钮。 | *   使用 `template_match_threshold` 定义模板匹配的阈值。
│   │       ├── hdd.yml    這個 YAML 文件定義了遊戲中名為 "HDD" 的屏幕的界面元素信息。 |  | *   **主要功能:** 描述了 "HDD" 屏幕的各個區域及其在 PC 上的位置和屬性。 | *   **核心結構:**  YAML 文件使用 `screen_id`, `screen_name` 和 `area_list` 來組織數據。`area_list` 包含多個字典，每個字典描述屏幕上的一個區域。 | *   **重要功能點:** |     *   定義了屏幕的名稱 ("HDD")。 |     *   `area_list` 中定義了屏幕上多個區域，包括 "章节显示", "章节列表", "委托区域", "下一步", "副本区域", "出战", "街区", "空白", "确定并出战" 等。 |     *   每個區域都包含 `pc_rect` (定義區域的坐標), `text`, `lcs_percent`, `template_sub_dir`, `template_id` 和 `template_match_threshold` 等屬性。
│   │       ├── hollow_zero_battle.yml    這個 YAML 文件定義了遊戲中「零號空洞-戰鬥」場景的屏幕信息。 |  | *   **主要功能:** 描述了戰鬥場景中不同區域的 UI 元素，包括按鈕和文本框，用於遊戲的交互和界面顯示。 | *   **核心元素:**  `screen_id`, `screen_name` 定義了屏幕的 ID 和名稱。 `area_list` 包含了多個區域的定義。 | *   **重要功能點:** |     *   `area_name`: 定義了屏幕上各個區域的名稱，例如 "鳴徽-確定", "退出戰鬥" 等。 |     *   `pc_rect`:  定義了每個區域的坐標和尺寸，用於定位 UI 元素。 |     *   `text`:  定義了區域中顯示的文本。 |     *   `lcs_percent`:  用於模板匹配的相似度百分比。 |     *   `template_sub_dir`, `template_id`, `template_match_threshold`:  用於模板匹配，識別 UI 元素。
│   │       ├── hollow_zero_entry.yml    這個 YAML 文件定義了遊戲中名為「零號空洞-入口」的屏幕的界面元素信息。 |  | *   **主要功能**: 描述了屏幕的佈局，包括不同區域的名稱、坐標（`pc_rect`）、文本、相似度百分比（`lcs_percent`）以及模板匹配相關的信息。 | *   **核心元素**:  `area_list` 包含了一系列定義屏幕上可交互區域的字典。每個字典代表一個區域，包含以下字段： |     *   `area_name`: 區域的名稱，例如 "街区"、"副本列表"、"下一步" 等。 |     *   `pc_rect`: 區域的矩形坐標，用於定位。 |     *   `text`: 區域的文本標籤。 |     *   `lcs_percent`: 相似度百分比，用於模板匹配。 |     *   `template_sub_dir`, `template_id`, `template_match_threshold`: 模板匹配相關的配置。 | *   **重要功能點**: |     *   定義了屏幕上多個可交互區域，包括按鈕和文本區域。 |     *   使用矩形坐標來定位屏幕上的元素。 |     *   使用文本和模板匹配來識別屏幕元素。 |     *   `pc_alt` 字段指示是否使用替代的 PC 佈局。
│   │       ├── hollow_zero_event.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏内名为 "零号空洞-事件" 的屏幕的 UI 元素布局和交互信息。它描述了屏幕上各个区域的名称、位置、文本、模板匹配信息以及跳转目标。 |  | **核心元素:** |  | *   `screen_id`: 屏幕的唯一标识符 ("hollow\_zero\_event")。 | *   `area_list`:  一个列表，包含屏幕上所有可交互区域的定义。 |     *   `area_name`: 区域的名称 (例如 "事件文本", "角色-1", "背包" 等)。 |     *   `pc_rect`: 区域的矩形坐标 (左上角和右下角坐标)。 |     *   `text`: 区域内显示的文本。 |     *   `template_id`, `template_sub_dir`, `template_match_threshold`: 用于模板匹配的配置，用于识别 UI 元素。 |     *   `goto_list`:  定义点击该区域后跳转到的目标。 |  | **重要功能点:** |  | *   **UI 布局定义:**  通过 `area_list` 精确定义了屏幕上各个 UI 元素的位置和大小。 | *   **文本和交互:**  定义了每个区域显示的文本，以及可能的交互行为（例如点击按钮）。 | *   **模板匹配:**  使用模板匹配来识别 UI 元素，用于更灵活的 UI 识别和处理。 | *   **屏幕导航:**  `goto_list`  定义了点击某些区域后，游戏应该跳转到的目标屏幕或状态。 | *   **事件处理:**  该文件描述了与 "零号空洞-事件" 相关的各种 UI 元素，包括角色、文本框、按钮等，暗示了该屏幕用于处理游戏事件和交互。
│   │       ├── hollow_zero_merchant.yml    這個 YAML 文件定義了遊戲中「零號空洞-商店」螢幕的 UI 元素區域。 |  | *   **主要功能:** 定義螢幕上各個 UI 元素的坐標、文本和模板匹配信息，用於遊戲的 UI 識別和交互。 | *   **核心類/函數:**  此文件是數據文件，沒有類或函數。它使用 YAML 格式來描述螢幕的 UI 元素。 | *   **重要功能點:** |     *   `screen_id`:  `hollow_zero_merchant` - 螢幕的唯一標識符。 |     *   `screen_name`:  `零号空洞-商店` - 螢幕的顯示名稱。 |     *   `area_list`:  包含多個 UI 元素區域的定義，例如： |         *   返回按鈕 (`right_top_back`) |         *   確定按鈕 |         *   二級標題 |         *   商品價格區域 |         *   商品描述區域 |         *   商品購買區域 (`merchant_add`) |         *   多個商品價格區域 (例如: 商品價格-3-1, 商品價格-3-2 等) |     *   每個 `area_name` 都有 `pc_rect` (坐標), `text`, `lcs_percent`, `template_sub_dir`, `template_id`, `template_match_threshold` 等屬性，用於定位和識別 UI 元素。
│   │       ├── life_on_line.yml    這個 YAML 文件定義了遊戲中名為 "life_on_line" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了遊戲屏幕的佈局，包括屏幕 ID、名稱、以及一系列可交互區域的定義。 | *   **核心結構:**  YAML 文件，使用 `screen_id` 和 `area_list` 組織數據。`area_list` 包含多個 `area_name` 及其對應的矩形區域 (`pc_rect`) 和文本信息 (`text`)。 | *   **重要功能點:** |     *   定義了屏幕的名稱 ("真拿命验收")。 |     *   定義了多個可交互區域，例如 "第二章间章"、"对话选项"、"对话人" 和 "确定并出战"，每個區域都有其位置信息 (pc_rect) 和文本內容。 |     *   使用 `lcs_percent` 和 `template_match_threshold` 描述了區域的匹配閾值。
│   │       ├── lost_void_bangboo_store.yml    **摘要:** |  | 该文件定义了游戏界面“迷失之地-邦布商店”的屏幕信息，使用 YAML 格式。 |  | **核心功能:** |  | *   定义屏幕的各个区域，包括文本、按钮、标识等。 | *   描述每个区域的属性，如名称、坐标、文本、模板信息等。 |  | **重要功能点:** |  | *   `screen_id`: 屏幕的唯一标识符。 | *   `area_list`: 定义屏幕上所有区域的列表。 | *   `area_name`: 区域的名称。 | *   `pc_rect`: 区域在 PC 屏幕上的矩形坐标。 | *   `text`: 区域显示的文本。 | *   `template_id` 和 `template_sub_dir`: 用于图像识别的模板信息。 | *   `goto_list`: 定义区域的跳转目标。 | *   定义了“详情”、“刷新”、“藏品名称”、“价格”、“购买按钮”、“购买-确认”、“返回”、“刷新-可用”、“刷新-确认”、“血量”、“金币”、“角色头像”等区域。
│   │       ├── lost_void_battle_fail.yml    這個 YAML 文件定義了遊戲中「迷失之地-戰鬥失敗」界面的屏幕信息。 |  | *   **主要功能:** 定義了戰鬥失敗界面，包括界面 ID、名稱和按鈕區域的配置。 | *   **核心元素:** |     *   `screen_id`: 屏幕的唯一標識符，為 `lost_void_battle_fail`。 |     *   `screen_name`: 屏幕的顯示名稱，為「迷失之地-戰鬥失敗」。 |     *   `area_list`:  一個列表，定義了屏幕上的交互區域（按鈕）。 | *   **重要功能點:** |     *   定義了三個按鈕區域：撤退、重播和分析。 |     *   每個按鈕區域都包含其名稱、標識符、位置（`pc_rect`）、文本、匹配閾值等信息。 |     *   `id_mark: true` 表明這些區域用於標識。 |     *   `goto_list` 屬性為空，表示這些按鈕不直接導航到其他界面，可能觸發其他遊戲邏輯。
│   │       ├── lost_void_battle_result.yml    這個 YAML 文件定義了遊戲中“迷失之地-挑战结果”界面的屏幕信息。 |  | *   **主要功能:** 描述了遊戲界面中各個區域的佈局和元素，包括標題、按鈕和獎勵。 | *   **核心元素:** |     *   `screen_id`: 屏幕的唯一標識符 ("lost\_void\_battle\_result")。 |     *   `screen_name`: 屏幕的顯示名稱 ("迷失之地-挑战结果")。 |     *   `area_list`:  一個列表，包含屏幕上各個區域的詳細信息，如位置 (pc\_rect), 文本 (text), 和模板信息 (template\_id, template\_sub\_dir)。 | *   **重要功能點:** |     *   定義了屏幕上各個區域的坐標和尺寸，用於界面元素定位。 |     *   定義了“确定”和“完成”按鈕。 |     *   定義了獎勵區域，並使用 `template_id` 和 `template_sub_dir` 引用了用於顯示獎勵的模板。
│   │       ├── lost_void_choose_common.yml    **摘要:** |  | 该 YAML 文件定义了游戏界面 "迷失之地-通用选择" 的屏幕布局和元素信息。 |  | **核心元素:** |  | *   `screen_id`: `lost_void_choose_common` - 屏幕的唯一标识符。 | *   `screen_name`: 迷失之地-通用选择 - 屏幕的显示名称。 | *   `area_list`: 包含屏幕上各个区域的定义，每个区域包含名称、矩形坐标、文本、模板匹配信息等。 |  | **重要功能点:** |  | *   定义了屏幕上各种UI元素的位置和属性，包括： |     *   文本区域（详情、藏品名称、武备名称、标题等） |     *   按钮（确定、刷新） |     *   TAB 标签 |     *   武备标识区域 | *   使用 `id_mark` 字段标识是否需要进行 ID 标记。 | *   使用 `template_id` 和 `template_match_threshold` 进行模板匹配。 | *   `goto_list` 字段定义了跳转目标。
│   │       ├── lost_void_choose_no_detail.yml    這個 YAML 文件定義了遊戲中一個名為 "迷失之地-无详情选择" 的屏幕的界面元素信息。 |  | *   **主要功能:** 描述了遊戲屏幕的佈局和交互元素，用於在迷失之地場景中進行選擇。 | *   **核心類/函數:**  該文件是數據文件，沒有類或函數。 | *   **重要功能點:** |     *   `screen_id`:  `lost_void_choose_no_detail`，屏幕的唯一標識符。 |     *   `area_list`:  定義了屏幕上的各個區域，包括按鈕、文本框等，每個區域包含其名稱、位置 ( `pc_rect` )、文本、以及用於識別的標記 (`id_mark`) 和模板匹配信息。 |     *   `pc_rect`:  定義了每個區域在 PC 屏幕上的坐標和尺寸。 |     *   `template_id` 和 `template_sub_dir`:  用於模板匹配，輔助識別屏幕元素。 |     *   `goto_list`:  定義了點擊區域後的操作，這裡為空。
│   │       ├── lost_void_choose_no_num.yml    這個 YAML 文件定義了遊戲中一個名為 "迷失之地-无数量选择" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了遊戲屏幕的佈局和交互元素，包括文本、按鈕和區域。 | *   **核心元素:** |     *   `screen_id`: 屏幕的唯一標識符。 |     *   `screen_name`: 屏幕的顯示名稱。 |     *   `area_list`:  一個列表，定義了屏幕上各個區域的詳細信息，包括： |         *   `area_name`: 區域的名稱。 |         *   `pc_rect`: 區域在 PC 屏幕上的坐標和尺寸。 |         *   `text`: 區域的文本內容。 |         *   `template_id`, `template_sub_dir`: 模板相關信息，用於圖像匹配。 | *   **重要功能點:** |     *   定義了屏幕上 "详情" 文本區域、"确定" 按鈕、"藏品名称" 區域和 "迷失之地-TAB" 區域的位置和屬性。 |     *   使用 `template_id` 和 `template_sub_dir` 進行圖像匹配，用於界面元素識別。 |     *   `goto_list` 屬性（雖然為空）暗示了可能存在的屏幕導航功能。
│   │       ├── lost_void_entry.yml    這個 YAML 文件定義了遊戲中一個名為 "迷失之地-入口" 的屏幕的界面信息。 |  | *   **主要功能**: 描述了 "迷失之地-入口" 屏幕的 UI 元素，包括按鈕的佈局、文本、坐標和導航目標。 | *   **核心元素**: |     *   `screen_id`:  `lost_void_entry`，屏幕的唯一標識符。 |     *   `screen_name`:  `迷失之地-入口`，屏幕的顯示名稱。 |     *   `area_list`:  一個列表，定義了屏幕上各個交互區域（按鈕）。 | *   **重要功能點**: |     *   定義了多個按鈕，例如 "街区"、"悬赏委托"、"战线肃清" 和 "全部领取" 等。 |     *   每個按鈕都包含 `pc_rect` (坐標和尺寸), `text` (按鈕文本), `goto_list` (導航目標) 等信息。 |     *   `goto_list` 描述了點擊按鈕後，遊戲將導航到的其他屏幕。 |     *   `id_mark` 標記了是否需要進行 ID 標記。
│   │       ├── lost_void_gear.yml    這個 YAML 文件定義了遊戲中“迷失之地-武备选择”屏幕的界面元素和交互信息。 |  | *   **主要功能:** 描述遊戲屏幕的佈局和交互元素，包括按鈕、文本區域和列表。 | *   **核心結構:**  YAML 文件使用 `screen_id` 和 `screen_name` 標識屏幕，`area_list` 包含屏幕上各個區域的定義。 | *   **重要功能點:** |     *   定義了屏幕上各個區域的名稱、位置 ( `pc_rect` )、文本 ( `text` ) 和模板信息 ( `template_sub_dir`, `template_id` )。 |     *   `id_mark` 標識是否需要進行 ID 標記。 |     *   `goto_list` (空列表) 預計用於定義導航目標。 |     *   包含“携带”、“详情”和“返回”按鈕的定義，以及“武备列表”和“等级列表”區域的定義。
│   │       ├── lost_void_lottery.yml    這個 YAML 文件定義了遊戲中“迷失之地-抽獎機”界面的屏幕信息。 |  | *   **主要功能:** 描述了遊戲界面中各個區域的屬性，包括按鈕和文本框的位置、文本內容、模板信息等。 | *   **核心結構:**  文件使用 YAML 格式，以 `screen_id` 和 `screen_name` 標識屏幕，`area_list` 包含了屏幕中各個區域的詳細信息。 | *   **重要功能點:** |     *   定義了屏幕的 ID 和名稱。 |     *   定義了多個區域，包括“返回”、“獎勵預覽”、“開始”、“剩余次數”和“確定”按鈕。 |     *   每個區域都包含了位置信息 ( `pc_rect` )、文本 ( `text` )、模板信息 ( `template_sub_dir`, `template_id` ) 和其他屬性。 |     *   `id_mark` 標識了是否需要進行 ID 標記。 |     *   `goto_list` 屬性用於定義點擊區域後的跳轉行為，但在此文件中為空。
│   │       ├── lost_void_normal_world.yml    這個 YAML 文件定義了遊戲中 "迷失之地-大世界" 屏幕的 UI 元素信息。 |  | *   **主要功能**: 描述遊戲屏幕上各個 UI 元素的位置、尺寸、文本、模板匹配信息等，用於遊戲的 UI 識別和交互。 | *   **核心類和函數**:  無特定類或函數，主要由數據結構組成，以 `screen_id` 和 `area_list` 為主。 | *   **重要功能點**: |     *   `screen_id`: 屏幕的唯一標識符。 |     *   `area_list`:  包含屏幕上所有 UI 元素的列表，每個元素包含: |         *   `area_name`: 元素的名稱。 |         *   `pc_rect`: 元素在 PC 屏幕上的矩形區域 (x1, y1, x2, y2)。 |         *   `text`: 元素的文本內容。 |         *   `template_sub_dir` 和 `template_id`:  用於模板匹配的子目錄和 ID。 |         *   `template_match_threshold`: 模板匹配的閾值。 |         *   `goto_list`:  定義了 UI 元素觸發後的操作，這裡為空。 |         *   `id_mark`: 標記是否為 ID 標記。
│   │       ├── lost_void_purge.yml    **摘要:** |  | 該 YAML 文件定義了遊戲中名為 "迷失之地-战线肃清" 的屏幕的 UI 元素信息。 |  | *   **主要功能:** 描述遊戲屏幕的 UI 元素，包括按鈕、文本和區域，以及它們的位置、文本內容和可能的導航目標。 | *   **核心結構:** 文件使用 `screen_id` 和 `screen_name` 標識屏幕，`area_list` 包含屏幕上各個 UI 元素的詳細信息。 | *   **重要功能點:** |     *   定義了屏幕上各個區域的名稱、矩形坐標、文本內容和標識符。 |     *   `goto_list` 屬性定義了 UI 元素可能的導航目標，例如跳轉到其他屏幕。 |     *   `lcs_percent`、`template_sub_dir`、`template_id`、`template_match_threshold` 和 `color_range` 屬性用於圖像識別和匹配。 |     *   `id_mark` 標記了重要的 UI 元素。
│   │       ├── lost_void_route_change.yml    這個 YAML 文件定義了遊戲中一個名為 "迷失之地-路径迭换" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了遊戲屏幕的佈局和交互元素。 | *   **核心元素:** |     *   `screen_id`:  `lost_void_route_change` (屏幕的唯一標識符) |     *   `screen_name`: `迷失之地-路径迭换` (屏幕的顯示名稱) |     *   `area_list`:  定義屏幕上各個交互區域的列表，例如按鈕。 | *   **重要功能點:** |     *   定義了兩個按鈕區域: "按钮-返回" 和 "按钮-图例详情"。 |     *   每個按鈕都包含其在屏幕上的位置 (`pc_rect`)、文本 (`text`)、模板信息 (`template_sub_dir`, `template_id`) 和其他相關配置。 |     *   `goto_list`:  按鈕點擊後可能觸發的導航列表，但在此文件中為空。
│   │       ├── map.yml    這是一個 YAML 配置文件，用於定義遊戲地圖屏幕的界面元素和交互區域。 |  | *   **主要功能:** 定義遊戲地圖屏幕的 UI 元素，包括區域名稱、矩形坐標、文本、模板匹配信息和跳转列表。 | *   **核心結構:**  `area_list` 包含多個區域定義，每個區域定義包含： |     *   `area_name`: 區域的名稱。 |     *   `pc_rect`: 區域的矩形坐標 (左上角 x, 左上角 y, 右下角 x, 右下角 y)。 |     *   `text`: 區域內顯示的文本。 |     *   `lcs_percent`:  可能與文本匹配相關的百分比。 |     *   `template_sub_dir`, `template_id`, `template_match_threshold`: 模板匹配相關信息。 |     *   `goto_list`:  定義區域的跳转目标。 | *   **重要功能點:** |     *   定義了地圖屏幕上不同區域的坐標和交互信息，例如“区域名称”、“上一个区域”、“下一个区域”、“传送点名称”和“街区详情”。 |     *   使用矩形坐標定義了每個區域的可點擊範圍。 |     *   包含了文本和模板匹配相關的配置，用於識別和交互。 |     *   `goto_list` 字段表明了區域可能具有的跳转功能。
│   │       ├── menu.yml    ## 摘要 |  | 该文件 (`menu.yml`) 定义了游戏菜单界面的布局信息，使用 YAML 格式存储。 |  | **核心功能:** |  | *   定义菜单界面的各个区域 (areas) 的位置、文本、模板信息和跳转目标。 |  | **核心数据结构:** |  | *   `screen_id`: 屏幕 ID，值为 "menu"。 | *   `screen_name`: 屏幕名称，值为 "菜单"。 | *   `area_list`:  一个列表，包含菜单界面中所有区域的详细信息，每个区域是一个字典，包含以下键: |     *   `area_name`: 区域名称，例如 "返回", "邮件", "底部列表" 等。 |     *   `pc_rect`:  PC 平台上的矩形区域坐标，定义了区域的位置和大小。 |     *   `text`: 区域内的文本内容。 |     *   `lcs_percent`:  匹配相似文本的百分比。 |     *   `template_sub_dir`: 模板子目录。 |     *   `template_id`: 模板 ID。 |     *   `template_match_threshold`: 模板匹配阈值。 |     *   `color_range`: 颜色范围 (未使用)。 |     *   `goto_list`:  点击该区域后跳转的目标界面列表。 |  | **重要功能点:** |  | *   定义了菜单界面中各种按钮、文本框和区域的位置和交互行为。 | *   通过 `goto_list` 定义了界面跳转逻辑，例如点击 "返回" 按钮后跳转到 "大世界-普通" 界面。 | *   使用 `template_sub_dir` 和 `template_id` 定义了界面元素的模板信息，用于界面元素的识别和匹配。 | *   包含 "返回", "邮件", "底部列表", "兑换码", "朋友", "仓库", "更多" 等多个功能区域的定义。
│   │       ├── menu_more.yml    這個 YAML 文件定義了遊戲中“更多功能”菜單的屏幕信息。 |  | *   **主要功能:** 描述了“更多功能”菜單的 UI 元素，包括標題、關閉按鈕和“預備編隊”按鈕。 | *   **核心結構:**  文件使用 YAML 格式，定義了 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 等關鍵字段。`area_list` 包含了屏幕上各個 UI 元素的詳細信息。 | *   **重要功能點:** |     *   定義了屏幕的標題和按鈕的文本、位置 (`pc_rect`) 和模板信息 (`template_id`, `template_sub_dir`)。 |     *   使用 `id_mark` 標記重要的 UI 元素。 |     *   `goto_list` 字段目前為空，可能用於定義按鈕的導航目標。 |     *   `template_match_threshold` 和 `color_range` 用於圖像識別和匹配。
│   │       ├── news_stand.yml    這個 YAML 文件定義了遊戲中名為“报刊亭”的屏幕的界面元素和交互區域。 |  | *   **主要功能:** 定義了報刊亭屏幕的 UI 元素，包括按鈕、文本區域和交互區域的坐標、文本描述和模板匹配參數。 | *   **核心元素:**  `area_list` 包含了屏幕上所有可交互區域的定義，每個區域由 `area_name`, `pc_rect`, `text`, `lcs_percent`, `template_sub_dir`, `template_id`, 和 `template_match_threshold` 屬性描述。 | *   **重要功能點:** |     *   定義了“刮刮卡”區域及其相關的交互。 |     *   定義了與“嗷呜”角色互動的區域，包括“叫醒他”和“嗷呜对话”等。 |     *   定義了多個刮層的區域，可能用於刮刮卡效果。 |     *   定義了“对话选项”區域，可能用於與角色的對話。 |     *   `pc_rect` 屬性定義了每個區域在屏幕上的位置和大小。 |     *   `text` 屬性提供了每個區域的文本描述。 |     *   `lcs_percent`, `template_sub_dir`, `template_id`, 和 `template_match_threshold` 屬性用於模板匹配，可能用於 UI 元素的識別和交互。
│   │       ├── noodle_shop.yml    這個 YAML 文件定義了遊戲中拉面店屏幕的界面信息。 |  | *   **主要功能:** 描述了拉面店屏幕的佈局和交互區域。 | *   **核心結構:** 使用 YAML 格式，包含 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 等鍵。`area_list` 包含屏幕上各個交互區域的詳細信息。 | *   **重要功能點:** |     *   定義了屏幕的 ID 和名稱。 |     *   `area_list` 描述了屏幕上各個區域的屬性，包括 `area_name`, `pc_rect` (屏幕坐標), `text`, `lcs_percent`, `template_sub_dir`, `template_id` 和 `template_match_threshold`。 |     *   定義了 "点单", "拉面列表", "点单确认" 和 "效果确认" 等區域，並指定了它們在屏幕上的位置和相關文本。
│   │       ├── normal_world.yml    這個 YAML 文件定義了遊戲中 "大世界" 屏幕的界面元素信息。 |  | *   **主要功能:** 描述了遊戲屏幕的佈局，包括不同區域的名稱、坐標、文本、模板信息等。 | *   **核心結構:**  YAML 文件使用鍵值對的形式，定義了屏幕的 `screen_id`, `screen_name` 和 `area_list`。`area_list` 是一個列表，包含屏幕上各個區域的詳細信息。 | *   **重要功能點:** |     *   `area_name`:  定義屏幕上的區域，如 "信息", "菜单", "地图" 等。 |     *   `pc_rect`:  定義區域的坐標和尺寸 (左上角和右下角的 x, y 坐標)。 |     *   `text`:  區域內顯示的文本。 |     *   `lcs_percent`:  用於模板匹配的相似度百分比。 |     *   `template_sub_dir` 和 `template_id`:  用於指定與該區域相關的模板文件。 |     *   `template_match_threshold`:  模板匹配的閾值。
│   │       ├── normal_world_basic.yml    這個 YAML 文件定義了遊戲中一個名為 "大世界-普通" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了遊戲屏幕的佈局，包括屏幕 ID、名稱以及屏幕上的交互區域。 | *   **核心類/函數:**  無特定類或函數，文件使用 YAML 格式定義數據結構。 | *   **重要功能點:** |     *   `screen_id`: 屏幕的唯一標識符 "normal_world_basic"。 |     *   `screen_name`: 屏幕的顯示名稱 "大世界-普通"。 |     *   `area_list`:  定義了屏幕上多個交互區域，每個區域包含： |         *   `area_name`: 區域的名稱，例如 "按钮-信息" 和 "按钮-菜单"。 |         *   `pc_rect`: 區域在 PC 屏幕上的矩形坐標。 |         *   `template_sub_dir` 和 `template_id`:  用於模板匹配的相關信息。 |         *   `goto_list`:  定義了區域觸發後導航到的目標，例如 "菜单"。
│   │       ├── notorious_hunt.yml    ## 代码摘要 |  | **主要功能:** |  | 该 YAML 文件定义了游戏界面 "恶名狩猎" 的屏幕信息，用于识别和定位屏幕上的各种元素。 |  | **核心类和函数:** |  | *   无显式类或函数定义，该文件使用 YAML 格式定义屏幕元素。 |  | **重要功能点:** |  | *   `screen_id`: 屏幕的唯一标识符 "notorious\_hunt"。 | *   `screen_name`: 屏幕的显示名称 "恶名狩猎"。 | *   `area_list`: 定义了屏幕上各个区域的详细信息，包括： |     *   `area_name`: 区域的名称，例如 "副本名称列表", "剩余次数" 等。 |     *   `pc_rect`: 区域的像素坐标 (x1, y1, x2, y2)。 |     *   `text`: 区域内显示的文本。 |     *   `lcs_percent`: 相似度匹配的百分比。 |     *   `template_sub_dir`, `template_id`: 模板相关信息，用于图像识别。 |     *   `template_match_threshold`: 模板匹配的阈值。 |     *   `color_range`: 颜色范围，用于颜色识别。 |     *   `goto_list`: 跳转目标列表。 | *   定义了诸如 "选择", "重新开始", "奖励入口", "难度选择入口" 等关键按钮和区域的位置和属性。 | *   包含了用于 "深度追猎" 和 "无报酬模式" 的按钮定义。 | *   定义了 "街区" 按钮和 "副本名称" 标题区域。
│   │       ├── random_play.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏界面 "影像店营业" 的屏幕信息，包括屏幕 ID、名称以及各个区域的坐标、文本和相关配置。 |  | **核心元素:** |  | *   **`screen_id`**:  `random_play` - 屏幕的唯一标识符。 | *   **`screen_name`**:  `影像店营业` - 屏幕的显示名称。 | *   **`area_list`**:  一个列表，定义了屏幕上所有可交互区域的详细信息。 |  | **重要功能点:** |  | *   定义了屏幕上各个区域的坐标 (`pc_rect`)，用于界面元素定位。 | *   每个区域都包含 `area_name` (区域名称) 和 `text` (文本内容)。 | *   `lcs_percent` 和 `template_match_threshold` 用于模板匹配，可能用于图像识别或 UI 自动化测试。 | *   定义了多个区域，包括 "昨日账本"、"返回"、"宣传员入口"、"录像带入口"、"经营状况"、"确认"、"上架筛选"、"主题筛选"、"上架"、"下架"、"选择宣传员"、"开始营业" 等，这些区域代表了游戏中的各种交互元素。
│   │       ├── ridu_weekly.yml    **摘要:** |  | 该 YAML 文件定义了游戏界面 "丽都周纪" 的屏幕信息，主要用于界面元素定位和交互。 |  | **核心数据结构:** |  | *   `screen_id`: 屏幕 ID，值为 "ridu_weekly"。 | *   `screen_name`: 屏幕名称，值为 "丽都周纪"。 | *   `area_list`: 包含多个区域信息的列表，每个区域定义了屏幕上的一个可交互或可识别的元素。 |  | **重要功能点:** |  | *   定义了屏幕上多个区域的坐标 (`pc_rect`)、文本 (`text`)、匹配阈值 (`template_match_threshold`) 等信息。 | *   `area_list` 中定义了如 "丽都周纪"、"代办列表"、"确认代办"、"领取"、"任务区域" 等区域，用于识别和定位屏幕上的关键元素。 | *   `goto_list` 字段为空，表示没有直接的跳转目标。 | *   `lcs_percent` 用于模板匹配的相似度。
│   │       ├── routine_cleanup.yml    這個 YAML 文件定義了遊戲中名為 "定期清剿" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了遊戲屏幕的佈局，包括屏幕名稱、以及屏幕上各個區域的定義。 | *   **核心數據結構:** 使用 YAML 格式定義了 `screen_id`, `screen_name`, `pc_alt` 和 `area_list`。`area_list` 包含了屏幕上各個區域的詳細信息，例如區域名稱、坐標、文本、匹配閾值等。 | *   **重要功能點:** |     *   定義了屏幕的名稱和 ID。 |     *   定義了屏幕上多個區域的坐標和屬性，用於界面元素識別和交互。 |     *   `area_list` 中的每個元素代表屏幕上的一個可識別區域，例如副本名稱列表、剩余電量和需要電量。 |     *   `pc_rect` 屬性定義了每個區域的坐標。 |     *   `template_match_threshold` 屬性定義了模板匹配的閾值，用於圖像識別。
│   │       ├── shiyu_defense.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏界面 "式舆防卫战" 的屏幕信息，用于定位屏幕上的各个区域。 |  | **核心元素:** |  | *   `screen_id`: 屏幕的唯一标识符，这里是 "shiyu\_defense"。 | *   `screen_name`: 屏幕的显示名称，这里是 "式舆防卫战"。 | *   `area_list`:  一个列表，包含了屏幕上所有区域的定义。每个区域定义包含以下信息： |     *   `area_name`: 区域的名称 (例如 "节点-01", "下一步" 等)。 |     *   `pc_rect`: 区域的像素坐标 (左上角 x, y 和右下角 x, y)。 |     *   `text`:  区域内显示的文本。 |     *   `lcs_percent`:  用于相似度匹配的参数。 |     *   `template_sub_dir`:  模板子目录。 |     *   `template_id`:  模板 ID。 |     *   `template_match_threshold`:  模板匹配的阈值。 |  | **重要功能点:** |  | *   定义了多个区域，包括游戏中的节点、弱点、抗性、按钮 (例如 "下一步", "退出战斗")、奖励相关区域、以及 "前次行动最佳记录" 相关的区域。 | *   部分区域定义了 `template_sub_dir` 和 `template_id`，用于基于模板的图像识别。 | *   通过 `pc_rect` 定义了每个区域的像素坐标，用于定位。 | *   `template_match_threshold` 用于控制模板匹配的严格程度。
│   │       ├── storage_drive_disc.yml    這個 YAML 文件定義了遊戲中一個名為 "仓库-驱动仓库" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了遊戲界面中 "仓库-驱动仓库" 屏幕的 UI 元素及其交互。 | *   **核心類和函數:**  該文件使用 YAML 格式，沒有類或函數。它定義了屏幕的屬性，以及屏幕上各個區域的配置。 | *   **重要功能點:** |     *   `screen_id`:  `storage_drive_disc`，屏幕的唯一標識符。 |     *   `screen_name`:  "仓库-驱动仓库"，屏幕的顯示名稱。 |     *   `area_list`:  定義了屏幕上各個 UI 元素的區域，包括： |         *   標題 "驱动仓库" |         *   按鈕 "拆解"，點擊後跳轉到 "仓库-驱动仓库-驱动盘拆解" 屏幕。 |         *   左上角的 "街区" 區域，點擊後跳轉到 "大世界-普通" 屏幕。 |     *   每個 `area_name` 包含 UI 元素的文本、位置 ( `pc_rect` )、以及跳轉目標 ( `goto_list` )。
│   │       └── storage_wengine.yml    這個 YAML 文件定義了遊戲中一個名為“仓库-音擎仓库”的屏幕的界面信息。 |  | *   **主要功能:** 描述了遊戲界面中“音擎仓库”屏幕的 UI 元素及其位置、文本和交互行為。 | *   **核心結構:** 文件使用 YAML 格式，包含 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 等字段。`area_list` 是一個列表，其中每個元素定義了屏幕上的一個 UI 區域。 | *   **重要功能點:** |     *   定義了屏幕的標題、按鈕（例如“回收”）和導航區域（例如“街区”和“驱动盘”）。 |     *   每個 UI 區域都包含其在屏幕上的坐標 (`pc_rect`)、文本 (`text`)、標識符 (`id_mark`) 和導航目標 (`goto_list`)。 |     *   `goto_list` 字段指定了點擊該區域後將導航到的其他屏幕。
│   ├── models/
│   │   └── onnx_ocr/
│   │       └── ppocr_keys_v1.txt    ## 摘要 |  | **1. 文件主要功能:** |  | 這個文件是一個文本文件，包含了一系列字符，很可能是用於 OCR (光學字符識別) 模型的詞彙表或字典。這些字符可能代表了 OCR 模型的識別範圍，例如用於 PPOCR 模型的關鍵字。 |  | **2. 核心類和函數:** |  | *   **核心類:** 無 (純文本文件) | *   **核心函數:** 無 (純文本文件) |  | **3. 重要功能點:** |  | *   **字符列表:** 文件包含大量字符，涵蓋了數字、標點符號、漢字、字母和其他特殊符號。 | *   **OCR 詞彙表:** 這些字符很可能被用於 OCR 模型的訓練或推理過程中，用於識別文本。 | *   **PPOCR 關鍵字:** 文件名暗示了它可能與 PPOCR (PaddlePaddle OCR) 模型有關，並包含了該模型可能使用的關鍵字。
│   └── template/
│       ├── agent_state/
│       │   ├── burnice_white_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程式的代理狀態模板。 |  | *   **主要功能:** 定義一個名為 "burnice\_white\_2\_2" 的角色狀態模板，用於視覺呈現。 | *   **核心元素:** |     *   `template_id`: "burnice\_white\_2\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-柏妮思-22" - 模板的顯示名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀。 |     *   `auto_mask`: `true` - 指示是否自動應用遮罩。 |     *   `point_list`:  `[614, 96], [667, 97]` -  定義用於模板定位或形狀的關鍵點。 | *   **重要功能點:**  定義了模板的形狀、遮罩設置和關鍵點，這些對於模板的視覺呈現和互動至關重要。
│       │   ├── burnice_white_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲或應用程序中角色的視覺狀態。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀（例如，矩形）。 |     *   `auto_mask`:  是否啟用自動遮罩。 |     *   `point_list`:  關鍵點坐標列表，用於定位或標記角色狀態。 | *   **重要功能點:**  定義了角色狀態的視覺表現和定位信息，用於在遊戲或其他應用程序中渲染和處理角色狀態。
│       │   ├── burnice_white_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲或應用程序中角色的視覺狀態。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡定義為矩形。 |     *   `auto_mask`: 布爾值，指示是否啟用自動遮罩。 |     *   `point_list`: 一個坐標列表，可能用於定義角色狀態的關鍵點。 | *   **重要功能點:** |     *   定義了角色狀態的視覺呈現方式。 |     *   包含了用於定位和處理角色狀態的關鍵信息。 |     *   `auto_mask` 屬性暗示了圖像處理或渲染方面的功能。
│       │   ├── burnice_white_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於遊戲或應用程序中。 |  | *   **主要功能:** 定義角色狀態模板的配置信息，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心配置項:** |     *   `template_id`:  模板的唯一標識符 (burnice\_white\_3\_3)。 |     *   `template_name`:  模板的描述性名稱 (角色状态-柏妮思-33)。 |     *   `template_shape`:  模板的形狀 (rectangle)。 |     *   `auto_mask`:  是否啟用自動遮罩 (true)。 |     *   `point_list`:  關鍵點坐標列表，用於定位或處理角色狀態元素。 | *   **重要功能點:**  定義了模板的視覺外觀、自動遮罩設置以及關鍵點，這些信息對於角色狀態的渲染和交互至關重要。
│       │   ├── ellen_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個代理狀態模板，用於描述遊戲角色艾蓮的狀態。 |  | *   **主要功能:** 定義代理狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 `ellen_2_2`。 |     *   `template_name`: 模板的描述性名稱，為 `角色状态-艾莲-22`。 |     *   `template_shape`: 模板的形狀，為 `rectangle`。 |     *   `auto_mask`:  是否啟用自動遮罩，為 `true`。 |     *   `point_list`:  定義關鍵點坐標列表，用於定位或識別角色狀態。 | *   **重要功能點:** |     *   定義了艾蓮角色狀態的模板，用於遊戲或其他應用場景。 |     *   `auto_mask: true` 表明系統會自動處理遮罩，可能用於圖像處理或顯示優化。 |     *   `point_list` 提供了關鍵點坐標，可用於精確定位角色狀態。
│       │   ├── ellen_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，名為 "角色状态-艾莲-31"，用於描述遊戲或應用程式中角色的視覺狀態。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 "ellen\_3\_1"。 |     *   `template_name`: 模板的顯示名稱，為 "角色状态-艾莲-31"。 |     *   `template_shape`: 模板的形狀，為 "rectangle"。 |     *   `auto_mask`:  是否自動遮罩，設為 `true`。 |     *   `point_list`:  包含兩個坐標點的列表，可能用於定義角色狀態的邊界或關鍵點。 | *   **重要功能點:** |     *   定義角色狀態的視覺呈現方式 (形狀)。 |     *   啟用自動遮罩功能，可能用於圖像處理或遮罩效果。 |     *   定義關鍵點，用於定位或標記角色狀態的特定區域。
│       │   ├── ellen_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個代理狀態模板，用於描述遊戲中角色艾蓮的狀態。 |  | *   **主要功能:** 定義代理狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 `ellen_3_2`。 |     *   `template_name`: 模板的描述性名稱，為 `角色状态-艾莲-32`。 |     *   `template_shape`: 模板的形狀，為 `rectangle`。 |     *   `auto_mask`:  是否啟用自動遮罩，為 `true`。 |     *   `point_list`: 定義關鍵點坐標列表。 | *   **重要功能點:**  定義了模板的形狀、遮罩行為和關鍵點，這些信息用於在遊戲中渲染和處理角色狀態。
│       │   ├── ellen_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-艾莲-33"。 |  | *   **主要功能:** 定義角色狀態的模板配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，值為 "ellen\_3\_3"。 |     *   `template_name`: 模板的名稱，值為 "角色状态-艾莲-33"。 |     *   `template_shape`: 模板的形狀，值為 "rectangle"。 |     *   `auto_mask`: 是否自動遮罩，值為 `true`。 |     *   `point_list`: 一個包含關鍵點坐標的列表。 | *   **重要功能點:** |     *   定義了模板的形狀為矩形。 |     *   啟用了自動遮罩功能。 |     *   指定了兩個關鍵點的坐標。
│       │   ├── energy_2_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序的角色狀態模板。 |  | *   **主要功能:** 定義一個名為 "角色状态-能量-21" 的角色狀態模板，用於視覺呈現和可能的自動遮罩。 | *   **核心元素:** |     *   `template_id`: "energy\_2\_1" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-能量-21" - 模板的描述性名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀，定義為矩形。 |     *   `auto_mask`: `true` - 啟用自動遮罩功能。 |     *   `point_list`:  定義矩形兩個頂點的坐標，用於繪製或定位模板。 | *   **重要功能點:**  定義了模板的形狀、名稱、自動遮罩設置以及用於定位或繪製的關鍵點。
│       │   ├── energy_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序的代理狀態模板。 |  | *   **主要功能:** 定義一個名為 "角色状态-能量-22" 的代理狀態模板，用於視覺化表示。 | *   **核心元素:** |     *   `template_id`: "energy\_2\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-能量-22" - 模板的顯示名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀。 |     *   `auto_mask`: `true` -  指示是否自動應用遮罩。 |     *   `point_list`:  定義矩形模板的兩個頂點坐標 (722, 74) 和 (780, 75)。 | *   **重要功能點:**  定義了模板的視覺屬性，包括形狀、遮罩和位置，用於在遊戲或應用程序中呈現代理的狀態。
│       │   ├── energy_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序的代理狀態模板。 |  | *   **主要功能:** 定義一個名為 "energy\_3\_1" 的代理狀態模板，用於視覺呈現。 | *   **核心元素:** |     *   `template_id`: "energy\_3\_1" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-能量-31" - 模板的顯示名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀。 |     *   `auto_mask`: `true` -  指示是否自動應用遮罩。 |     *   `point_list`:  定義了矩形的兩個頂點坐標 (379, 74) 和 (564, 75)，用於定義模板的邊界。 | *   **重要功能點:**  通過定義形狀、遮罩和坐標點，該文件配置了代理狀態的可視化表示。
│       │   ├── energy_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序中代理狀態的模板。 |  | *   **主要功能:** 定義一個名為 "角色状态-能量-32" 的代理狀態模板，用於視覺化表示。 | *   **核心配置:** |     *   `template_id`: `energy_3_2`，模板的唯一標識符。 |     *   `template_name`: "角色状态-能量-32"，模板的顯示名稱。 |     *   `template_shape`: `rectangle`，模板的形狀。 |     *   `auto_mask`: `true`，是否自動生成遮罩。 |     *   `point_list`:  `688, 74` 和 `745, 75`，定義了模板的關鍵點，用於定位和繪製。 | *   **重要功能點:**  定義了模板的視覺屬性，包括形狀、遮罩和關鍵點，這些信息用於在遊戲或應用程序中呈現代理的能量狀態。
│       │   ├── energy_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序的代理狀態模板。 |  | *   **主要功能:** 定義一個名為 "energy\_3\_3" 的代理狀態模板，用於視覺呈現。 | *   **核心元素:** |     *   `template_id`: "energy\_3\_3"，模板的唯一標識符。 |     *   `template_name`: "角色状态-能量-33"，模板的描述性名稱。 |     *   `template_shape`: "rectangle"，模板的形狀。 |     *   `auto_mask`: "true"，指示是否自動應用遮罩。 |     *   `point_list`:  定義矩形模板的兩個頂點坐標 (869, 74) 和 (927, 75)。 | *   **重要功能點:**  定義了模板的形狀、遮罩行為和用於繪製模板的關鍵點。
│       │   ├── evelyn_chevalier_1_2_2/
│       │   │   └── config.yml    這個 YAML 文件的摘要如下： |  | 1.  **主要功能:** 定義了一個用於角色狀態的模板配置，描述了角色伊芙琳的狀態信息。 | 2.  **核心元素:** |     *   `template_id`:  `evelyn_chevalier_1_2_2` - 模板的唯一標識符。 |     *   `template_name`: `角色状态-伊芙琳-燎火-22` - 模板的描述性名稱。 |     *   `template_shape`: `rectangle` - 模板的形狀。 |     *   `auto_mask`: `true` -  指示是否自動應用遮罩。 |     *   `point_list`:  `[609, 99], [645, 100]` -  定義了矩形區域的關鍵點坐標。 | 3.  **重要功能點:**  該文件配置了角色狀態模板的屬性，包括模板 ID、名稱、形狀、自動遮罩設置以及用於定義模板邊界的關鍵點坐標。 這些信息用於在遊戲或其他應用程序中呈現和處理角色狀態。
│       │   ├── evelyn_chevalier_1_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個 Agent 狀態模板。 |  | *   **主要功能:** 定義 Agent 狀態的模板配置，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡設定為 "rectangle"。 |     *   `auto_mask`:  是否啟用自動遮罩，這裡設定為 `true`。 |     *   `point_list`:  關鍵點坐標列表，用於定義模板的關鍵位置。 | *   **重要功能點:** |     *   定義 Agent 狀態模板的基礎信息。 |     *   配置自動遮罩功能。 |     *   定義模板的關鍵點，用於後續處理。
│       │   ├── evelyn_chevalier_1_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個代理狀態模板，用於遊戲或應用程序中的角色狀態顯示。 |  | *   **主要功能:**  配置代理狀態模板的屬性，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心元素:** |     *   `template_id`:  模板的唯一標識符。 |     *   `template_name`:  模板的描述性名稱。 |     *   `template_shape`:  模板的形狀（例如，矩形）。 |     *   `auto_mask`:  是否啟用自動遮罩。 |     *   `point_list`:  關鍵點坐標列表，用於定位或處理圖像元素。 | *   **重要功能點:**  定義了模板的視覺外觀和行為，例如形狀、遮罩和關鍵點，這些信息用於在遊戲或應用程序中渲染和處理角色狀態。
│       │   ├── evelyn_chevalier_1_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於遊戲或其他應用程序。 |  | *   **主要功能:** 描述角色狀態的模板配置，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡設定為 "rectangle"。 |     *   `auto_mask`:  是否啟用自動遮罩。 |     *   `point_list`:  定義了關鍵點坐標列表，用於定位或標記。 | *   **重要功能點:** |     *   定義了角色狀態模板的基礎屬性。 |     *   `auto_mask` 啟用自動遮罩功能，可能用於圖像處理或 UI 渲染。 |     *   `point_list` 提供了關鍵點坐標，用於定位或標記角色狀態元素。
│       │   ├── evelyn_chevalier_2_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板。 |  | *   **主要功能:** 配置一個角色狀態模板，用於標記和識別遊戲中的角色狀態。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡設定為 `multi_rect`，表示多個矩形。 |     *   `auto_mask`:  是否自動生成遮罩。 |     *   `point_list`:  定義了多個點的坐標，用於定義模板的形狀。 | *   **重要功能點:** 配置文件定義了模板的屬性，包括 ID、名稱、形狀、是否自動遮罩以及用於定義形狀的點坐標。
│       │   ├── evelyn_chevalier_2_3_1/
│       │   │   └── config.yml    這個 YAML 文件的摘要如下： |  | 1.  **主要功能:** 定義了一個角色狀態模板的配置，用於描述遊戲中角色的視覺狀態。 | 2.  **核心元素:** |     *   `template_id`: 模板的唯一標識符，例如 `evelyn_chevalier_2_3_1`。 |     *   `template_name`: 模板的描述性名稱，例如 `角色状态-伊芙琳-燎索点-31`。 |     *   `template_shape`: 模板的形狀，例如 `multi_rect`。 |     *   `auto_mask`:  是否自動生成遮罩，`true` 表示啟用。 |     *   `point_list`:  定義了一組坐標點，可能用於繪製角色狀態的邊界或區域。 | 3.  **重要功能點:**  定義了角色狀態模板的關鍵屬性，包括標識、名稱、形狀、自動遮罩設置以及用於定義視覺元素的坐標點。
│       │   ├── evelyn_chevalier_2_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於遊戲或其他應用程序。 |  | *   **主要功能:** 配置角色狀態模板的屬性，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡指定為 `multi_rect`。 |     *   `auto_mask`:  是否啟用自動遮罩。 |     *   `point_list`:  定義多個關鍵點的坐標列表，用於定位或識別角色狀態的特定區域。 | *   **重要功能點:**  定義了角色狀態模板的關鍵屬性，包括外觀、遮罩和關鍵點，這些信息用於在遊戲或其他應用程序中呈現和處理角色狀態。
│       │   ├── evelyn_chevalier_2_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-伊芙琳-燎索点-33"。 |  | *   **主要功能:** 配置角色狀態模板，用於定義遊戲中角色的視覺表現。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符 "evelyn\_chevalier\_2\_3\_3"。 |     *   `template_name`: 模板的描述性名稱 "角色状态-伊芙琳-燎索点-33"。 |     *   `template_shape`: 模板的形狀，設定為 "multi\_rect"。 |     *   `auto_mask`:  是否啟用自動遮罩，設定為 `true`。 |     *   `point_list`:  定義了一組坐標點，用於描述模板的形狀。 | *   **重要功能點:**  定義了模板的 ID、名稱、形狀、自動遮罩設置和用於定義形狀的點列表。
│       │   ├── guard_break/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲中角色狀態的模板，名為 "角色状态-格挡破碎" (Guard Break)。 |  | *   **主要功能:** 定義角色格擋破碎狀態的視覺模板，用於遊戲資源管理。 | *   **核心配置:** |     *   `template_id`: `guard_break`，模板的唯一標識符。 |     *   `template_name`: `角色状态-格挡破碎`，模板的顯示名稱。 |     *   `template_shape`: `rectangle`，模板的形狀。 |     *   `auto_mask`: `true`，是否自動生成遮罩。 |     *   `point_list`: 一個包含兩個坐標點的列表，用於定義模板的形狀或位置。
│       │   ├── hoshimi_miyabi_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲或應用程序中角色的視覺狀態。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀類型，這裡設定為 `multi_rect`。 |     *   `auto_mask`:  是否啟用自動遮罩功能。 |     *   `point_list`:  定義了一系列關鍵點的坐標，用於定位和識別角色狀態。 | *   **重要功能點:** |     *   定義了角色狀態的視覺表現，通過形狀和關鍵點來實現。 |     *   `auto_mask` 啟用，表明系統可能需要自動處理遮罩，以更好地顯示角色狀態。 |     *   `point_list` 提供了用於定位和識別角色狀態的關鍵點坐標。
│       │   ├── hoshimi_miyabi_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲或應用程序中角色的視覺狀態。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 `hoshimi_miyabi_3_1`。 |     *   `template_name`: 模板的描述性名稱，為 "角色状态-雅-31"。 |     *   `template_shape`: 模板的形狀，為 `multi_rect`。 |     *   `auto_mask`: 是否啟用自動遮罩，為 `true`。 |     *   `point_list`: 一個坐標列表，定義了角色狀態的關鍵點。 | *   **重要功能點:** |     *   配置了角色狀態模板的名稱和形狀。 |     *   啟用自動遮罩功能，用於圖像處理。 |     *   定義了一組關鍵點坐標，可能用於角色狀態的視覺效果或動畫。
│       │   ├── hoshimi_miyabi_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個代理狀態模板，用於描述遊戲中角色的狀態。 |  | *   **主要功能:** 定義一個名為「角色状态-雅-32」的代理狀態模板，用於多邊形區域的狀態檢測。 | *   **核心元素:** |     *   `template_id`: `hoshimi_miyabi_3_2`，模板的唯一標識符。 |     *   `template_name`: `角色状态-雅-32`，模板的名稱。 |     *   `template_shape`: `multi_rect`，模板的形狀，表示多邊形。 |     *   `auto_mask`: `true`，啟用自動遮罩。 |     *   `point_list`: 一個包含多個坐標點的列表，定義了多邊形的頂點，用於界定狀態檢測的區域。 | *   **重要功能點:**  定義了代理狀態模板的形狀和位置，以及是否啟用自動遮罩。
│       │   ├── hoshimi_miyabi_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板。 |  | *   **主要功能:** 配置一個角色狀態模板，用於識別和處理遊戲中的角色狀態。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的名稱。 |     *   `template_shape`: 模板的形狀，這裡定義為 `multi_rect` (多矩形)。 |     *   `auto_mask`:  是否自動生成遮罩，設為 `true`。 |     *   `point_list`:  定義了多個點的坐標，用於描述角色狀態的區域。 | *   **重要功能點:**  定義了模板的形狀和位置，以及是否自動生成遮罩，用於圖像識別或遊戲狀態分析。
│       │   ├── jane_attack_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於遊戲或其他應用程序。 |  | *   **主要功能:** 定義角色 "簡" 在 "薩霍夫跳" 狀態下的視覺表現和行為。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符 (jane\_attack\_2\_2)。 |     *   `template_name`: 模板的描述性名稱 ("角色状态-简-萨霍夫跳-22")。 |     *   `template_shape`: 模板的形狀 ("circle")。 |     *   `auto_mask`: 是否自動應用遮罩 (true)。 |     *   `point_list`: 定義形狀的點坐標列表。 | *   **重要功能點:**  定義了模板的形狀、遮罩設置和關鍵點坐標，這些信息用於渲染和處理角色狀態的視覺效果。
│       │   ├── jane_attack_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於遊戲或其他應用程序。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心數據結構:** YAML 文件本身，使用鍵值對存儲配置信息。 | *   **重要功能點:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡設置為 "circle"。 |     *   `auto_mask`:  是否啟用自動遮罩，設置為 `true`。 |     *   `point_list`:  定義關鍵點坐標列表，用於角色動畫或碰撞檢測。
│       │   ├── jane_attack_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於遊戲或其他應用程序。 |  | *   **主要功能:** 定義角色 "Jane" 在 "萨霍夫跳" 狀態下的視覺表現和行為。 | *   **核心元素:** |     *   `template_id`: "jane\_attack\_3\_2" 模板的唯一標識符。 |     *   `template_name`: "角色状态-简-萨霍夫跳-32" 模板的描述性名稱。 |     *   `template_shape`: "circle" 模板的形狀。 |     *   `auto_mask`: `true` 表示自動遮罩。 |     *   `point_list`:  定義了兩個點的坐標 (626, 98) 和 (626, 95)，可能用於定義形狀或碰撞區域。 | *   **重要功能點:**  定義了模板的形狀、遮罩設置和關鍵點，這些信息用於角色在特定狀態下的視覺呈現和交互。
│       │   ├── jane_attack_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於遊戲或動畫中的角色。 |  | *   **主要功能:** 定義角色狀態的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心類和函數:**  無，因為這是一個數據配置文件，而不是代碼文件。 | *   **重要功能點:** |     *   `template_id`:  `jane_attack_3_3`，模板的唯一標識符。 |     *   `template_name`: `角色状态-简-萨霍夫跳-33`，模板的描述性名稱。 |     *   `template_shape`: `circle`，定義了模板的形狀。 |     *   `auto_mask`: `true`，表示啟用自動遮罩。 |     *   `point_list`:  定義了兩個關鍵點的坐標，用於角色動畫或特效。
│       │   ├── jane_red_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個 Agent 狀態模板，名為 "角色状态-简-狂热心流-22"。 |  | *   **主要功能:** 描述 Agent 的狀態模板，包含模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，值為 "jane_red_2_2"。 |     *   `template_name`: 模板的描述性名稱，值為 "角色状态-简-狂热心流-22"。 |     *   `template_shape`: 模板的形狀，值為 "rectangle"。 |     *   `auto_mask`:  是否啟用自動遮罩，值為 "true"。 |     *   `point_list`:  定義關鍵點坐標的列表。 | *   **重要功能點:** |     *   定義 Agent 狀態模板的基礎信息。 |     *   指定模板的形狀和是否自動遮罩。 |     *   通過 `point_list` 定義關鍵點，可能用於定位或識別 Agent 狀態。
│       │   ├── jane_red_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個 Agent 狀態模板。 |  | *   **主要功能:** 配置 Agent 狀態模板的屬性，用於在遊戲或其他應用程序中呈現 Agent 的狀態。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀 (例如 "rectangle")。 |     *   `auto_mask`:  指示是否自動應用遮罩。 |     *   `point_list`:  定義模板的關鍵點坐標。 | *   **重要功能點:**  定義了模板的 ID、名稱、形狀、遮罩設置以及關鍵點坐標，這些信息共同構成了 Agent 狀態的可視化表現。
│       │   ├── jane_red_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個 Agent 狀態模板。 |  | *   **主要功能:** 配置 Agent 狀態模板的屬性，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀（例如 "rectangle"）。 |     *   `auto_mask`:  指示是否啟用自動遮罩。 |     *   `point_list`:  定義關鍵點坐標的列表。 | *   **重要功能點:**  定義了 Agent 狀態模板的視覺和行為屬性，用於在遊戲或其他應用程序中呈現 Agent 的狀態。
│       │   ├── jane_red_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個代理狀態模板，用於描述遊戲中角色的狀態。 |  | *   **主要功能:** 定義代理狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 `jane_red_3_3`。 |     *   `template_name`: 模板的描述性名稱，為 `角色状态-简-狂热心流-33`。 |     *   `template_shape`: 模板的形狀，為 `rectangle`。 |     *   `auto_mask`:  是否啟用自動遮罩，為 `true`。 |     *   `point_list`:  定義矩形區域的關鍵點坐標列表。 | *   **重要功能點:** |     *   定義了代理狀態模板的基本屬性，用於在遊戲中視覺化和管理角色狀態。 |     *   `auto_mask` 啟用自動遮罩，可能用於優化渲染或處理。 |     *   `point_list` 定義了模板的形狀，用於定位和繪製狀態元素。
│       │   ├── life_deduction_2_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序中角色狀態的模板，特別是關於血量扣減的視覺表現。 |  | *   **主要功能**: 定義了角色血量扣減狀態的視覺模板。 | *   **核心配置**: |     *   `template_id`: `life_deduction_2_1`，模板的唯一標識符。 |     *   `template_name`: `角色状态-血量扣减-21`，模板的名稱。 |     *   `template_shape`: `rectangle`，定義了模板的形狀為矩形。 |     *   `auto_mask`: `true`，表示自動應用遮罩。 |     *   `point_list`:  `[275, 51], [605, 52]`，定義了矩形的兩個頂點，用於定位和繪製矩形。 | *   **重要功能點**:  定義了模板的形狀、位置和遮罩設置，用於在界面上視覺化地呈現血量扣減的效果。
│       │   ├── life_deduction_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-血量扣减-31"，用於表示血量扣減的視覺效果。 |  | *   **主要功能:** 定義角色狀態模板的配置，用於血量扣減的可視化。 | *   **核心配置項:** |     *   `template_id`: `life_deduction_3_1`，模板的唯一標識符。 |     *   `template_name`: `角色状态-血量扣减-31`，模板的描述性名稱。 |     *   `template_shape`: `rectangle`，模板的形狀。 |     *   `auto_mask`: `true`，是否自動遮罩。 |     *   `point_list`:  `[274, 51], [572, 52]`，定義模板的關鍵點，用於定位和繪製。 | *   **重要功能點:**  定義了模板的形狀、名稱、遮罩設置和關鍵點，這些配置共同決定了血量扣減效果的視覺呈現。
│       │   ├── lighter_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-莱特-22"，模板形狀為矩形。它包含以下關鍵信息： |  | 1.  **主要功能:** 定義角色狀態的模板配置。 | 2.  **核心元素:** |     *   `template_id`: "lighter\_2\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-莱特-22" - 模板的名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀。 |     *   `auto_mask`: `true` -  指示是否自動生成遮罩。 |     *   `point_list`:  包含兩個點的列表，用於定義模板的幾何形狀或位置。 | 3.  **重要功能點:**  定義了模板的 ID、名稱、形狀、是否自動遮罩以及用於定位的點列表。
│       │   ├── lighter_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-莱特-31"。 |  | *   **主要功能:** 描述角色狀態的視覺模板，用於在遊戲或其他應用中呈現角色狀態。 | *   **核心配置:** |     *   `template_id`: "lighter\_3\_1" (模板 ID) |     *   `template_name`: "角色状态-莱特-31" (模板名稱) |     *   `template_shape`: "rectangle" (模板形狀) |     *   `auto_mask`: `true` (是否自動遮罩) |     *   `point_list`:  定義矩形模板的兩個頂點坐標 (135, 119) 和 (219, 120)。 | *   **重要功能點:** 定義模板的形狀、名稱、ID，以及是否自動遮罩和用於定位的關鍵點。
│       │   ├── lighter_3_2/
│       │   │   └── config.yml    這個 YAML 文件的摘要如下： |  | 1.  **主要功能：** 定義了用於角色狀態的模板配置，特別是針對名為 "lighter\_3\_2" 的角色。 | 2.  **核心元素：** |     *   `template_id`: "lighter\_3\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-莱特-32" - 模板的描述性名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀。 |     *   `auto_mask`: `true` - 指示是否自動應用遮罩。 |     *   `point_list`:  定義了一組坐標點，可能用於定位或定義模板的邊界。 | 3.  **重要功能點：** 該文件配置了模板的 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標，這些信息共同定義了角色狀態的可視化或處理方式。
│       │   ├── lighter_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序的角色狀態模板。 |  | *   **主要功能:** 定義了名為 "lighter\_3\_3" 的角色狀態模板的配置信息，包括模板的 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符 ("lighter\_3\_3")。 |     *   `template_name`: 模板的顯示名稱 ("角色状态-莱特-33")。 |     *   `template_shape`: 模板的形狀 ("rectangle")。 |     *   `auto_mask`: 是否啟用自動遮罩 ("true")。 |     *   `point_list`: 一個包含兩個坐標點的列表，用於定義模板的關鍵點。 | *   **重要功能點:** |     *   定義了角色狀態模板的基本屬性。 |     *   啟用自動遮罩功能，可能用於圖像處理或遊戲渲染。 |     *   通過 `point_list` 定義了模板的關鍵點，這些點可能用於定位、動畫或交互。
│       │   ├── pulchra_hunter_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-波可娜-22"。 |  | *   **主要功能:** 配置角色狀態模板，用於圖像處理。 | *   **核心元素:** |     *   `template_id`: "pulchra\_hunter\_2\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-波可娜-22" - 模板的名稱。 |     *   `template_shape`: "multi\_rect" - 模板的形狀類型。 |     *   `auto_mask`: `true` - 指示是否自動應用遮罩。 |     *   `point_list`: 一個包含多個坐標點的列表，用於定義模板的形狀。 | *   **重要功能點:** 定義了模板的形狀和位置，以及是否自動應用遮罩，這些信息對於圖像處理和角色狀態的識別至關重要。
│       │   ├── pulchra_hunter_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態檢測的模板。 |  | *   **主要功能:** 定義了角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡定義為 `multi_rect`。 |     *   `auto_mask`: 是否啟用自動遮罩。 |     *   `point_list`: 一個包含關鍵點坐標的列表，用於定位角色狀態。 | *   **重要功能點:**  定義了角色狀態檢測的關鍵點，以及是否啟用自動遮罩。
│       │   ├── pulchra_hunter_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲中角色「波可娜」的狀態。 |  | *   **主要功能:** 配置角色狀態模板，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符 (pulchra\_hunter\_3\_2)。 |     *   `template_name`: 模板的描述性名稱 (角色状态-波可娜-32)。 |     *   `template_shape`: 模板的形狀 (multi\_rect)。 |     *   `auto_mask`: 是否啟用自動遮罩 (true)。 |     *   `point_list`: 定義多個關鍵點的坐標，用於定位角色狀態。 | *   **重要功能點:** 配置文件定義了角色狀態的視覺表現和定位方式，通過 `point_list` 提供了用於繪製或識別角色狀態的關鍵點。
│       │   ├── pulchra_hunter_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲中角色「波可娜」的狀態。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀和關鍵點。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 `pulchra_hunter_3_3`。 |     *   `template_name`: 模板的描述性名稱，為「角色状态-波可娜-33」。 |     *   `template_shape`: 模板的形狀，為 `multi_rect`。 |     *   `auto_mask`:  是否自動生成遮罩，設為 `true`。 |     *   `point_list`:  定義了一組關鍵點的坐標，用於標識角色狀態的區域。 | *   **重要功能點:**  定義了角色狀態的視覺區域，以及是否自動生成遮罩。
│       │   ├── qingyi_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個 agent 狀態模板，用於描述遊戲中角色的狀態。 |  | *   **主要功能:** 定義 agent 狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心配置項:** |     *   `template_id`: 模板的唯一標識符，為 `qingyi_2_2`。 |     *   `template_name`: 模板的描述性名稱，為 `角色状态-青衣-22`。 |     *   `template_shape`: 模板的形狀，為 `rectangle`。 |     *   `auto_mask`: 是否自動遮罩，為 `true`。 |     *   `point_list`: 一個包含兩個坐標點的列表，用於定義模板的關鍵點。 | *   **重要功能點:**  定義了 agent 狀態模板的基本屬性，包括外觀和關鍵點，用於在遊戲中視覺化和定位 agent 狀態。
│       │   ├── qingyi_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲中角色的視覺狀態。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心元素:** |     *   `sub_dir`: 指定模板所屬的子目錄。 |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡設定為矩形。 |     *   `auto_mask`:  是否啟用自動遮罩。 |     *   `point_list`:  關鍵點坐標列表，用於定位角色狀態的視覺元素。 | *   **重要功能點:**  定義了模板的形狀、自動遮罩設置和關鍵點，這些配置共同決定了角色狀態在遊戲中的視覺呈現方式。
│       │   ├── qingyi_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-青衣-32"。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心配置:** |     *   `template_id`: `qingyi_3_2` (模板 ID) |     *   `template_name`: `角色状态-青衣-32` (模板名稱) |     *   `template_shape`: `rectangle` (模板形狀) |     *   `auto_mask`: `true` (是否自動遮罩) |     *   `point_list`:  `578, 96` 和 `631, 97` (關鍵點坐標) | *   **重要功能點:**  定義了模板的形狀、是否自動遮罩以及關鍵點，這些信息用於在圖像或其他視覺元素中定位和呈現角色狀態。
│       │   ├── qingyi_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-青衣-33"。 |  | *   **主要功能:** 定義角色狀態的模板配置，用於視覺化呈現。 | *   **核心元素:** |     *   `template_id`: "qingyi\_3\_3" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-青衣-33" - 模板的名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀。 |     *   `auto_mask`: `true` -  是否自動進行遮罩。 |     *   `point_list`:  `[760, 96], [813, 97]` - 定義模板的關鍵點坐標。 | *   **重要功能點:**  定義模板的形狀、遮罩設置和關鍵點，用於在視覺化中定位和呈現角色狀態。
│       │   ├── seth_lowell_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板。 |  | *   **主要功能:** 定義一個名為 "角色状态-赛斯-22" 的角色狀態模板，用於在應用程序中呈現或處理角色狀態信息。 | *   **核心元素:** |     *   `template_id`: "seth\_lowell\_2\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-赛斯-22" - 模板的顯示名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀。 |     *   `auto_mask`: `true` -  指示是否啟用自動遮罩。 |     *   `point_list`:  定義矩形模板的兩個頂點坐標 (613, 98) 和 (666, 99)。 | *   **重要功能點:**  定義了模板的形狀、名稱、自動遮罩設置以及用於定位模板的關鍵點。
│       │   ├── seth_lowell_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個 agent 狀態模板。 |  | *   **主要功能:**  配置一個 agent 狀態模板，用於描述 agent 的視覺呈現和行為。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡設定為 "rectangle"。 |     *   `auto_mask`:  是否自動應用遮罩。 |     *   `point_list`:  定義形狀的點坐標列表。 | *   **重要功能點:**  定義了模板的形狀、名稱、遮罩設置和關鍵點坐標，這些信息用於在界面上呈現 agent 的狀態。
│       │   ├── seth_lowell_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板。 |  | *   **主要功能:** 定義角色狀態的模板配置，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心配置項:** |     *   `sub_dir`: 模板所屬的子目錄 (agent\_state)。 |     *   `template_id`: 模板的唯一標識 (seth\_lowell\_3\_2)。 |     *   `template_name`: 模板的描述性名稱 (角色状态-赛斯-32)。 |     *   `template_shape`: 模板的形狀 (rectangle)。 |     *   `auto_mask`: 是否啟用自動遮罩 (true)。 |     *   `point_list`: 關鍵點坐標列表，用於定位角色狀態元素。 | *   **重要功能點:**  定義模板的形狀和關鍵點，以及是否啟用自動遮罩。
│       │   ├── seth_lowell_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個代理狀態模板。 |  | *   **主要功能:** 定義一個代理狀態模板的配置，用於描述遊戲中角色的狀態。 | *   **核心配置項:** |     *   `sub_dir`: 模板所屬的子目錄，值為 `agent_state`。 |     *   `template_id`: 模板的唯一標識符，值為 `seth_lowell_3_3`。 |     *   `template_name`: 模板的名稱，值為 `角色状态-赛斯-33`。 |     *   `template_shape`: 模板的形狀，值為 `rectangle`。 |     *   `auto_mask`: 是否自動生成遮罩，值為 `true`。 |     *   `point_list`: 一個包含兩個坐標點的列表，用於定義模板的邊界或關鍵點。 | *   **重要功能點:**  定義了模板的形狀、名稱、自動遮罩設置以及關鍵點坐標。
│       │   ├── soukaku_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-苍角-22"。 |  | *   **主要功能:** 定義角色狀態的視覺模板，包括形狀和坐標。 | *   **核心元素:** |     *   `template_id`: "soukaku\_2\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-苍角-22" - 模板的名稱。 |     *   `template_shape`: "polygon" - 模板的形狀類型。 |     *   `auto_mask`: true - 指示是否自動創建遮罩。 |     *   `point_list`:  定義多邊形頂點坐標的列表。 | *   **重要功能點:**  定義了模板的形狀和位置，用於在界面上呈現角色狀態。
│       │   ├── soukaku_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲或應用程序中的角色狀態。 |  | *   **主要功能:** 定義角色狀態的模板，包括模板 ID、名稱、形狀和用於遮罩的點列表。 | *   **核心元素:** |     *   `template_id`: `soukaku_3_1`，模板的唯一標識符。 |     *   `template_name`: `角色状态-苍角-31`，模板的描述性名稱。 |     *   `template_shape`: `polygon`，模板的形狀類型。 |     *   `auto_mask`: `true`，指示是否自動應用遮罩。 |     *   `point_list`: 一個包含多個坐標點的列表，用於定義多邊形的形狀，可能用於遮罩。 | *   **重要功能點:** |     *   定義了角色狀態的幾何形狀 (多邊形)。 |     *   包含了用於遮罩的點列表，這可能用於視覺效果或碰撞檢測。 |     *   `auto_mask` 標誌表明遮罩功能已啟用。
│       │   ├── soukaku_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個名為 "角色状态-苍角-32" 的代理狀態模板。 |  | *   **主要功能:** 定義代理狀態的模板配置，包括模板 ID、名稱、形狀、自動遮罩設置和點列表。 | *   **核心元素:** |     *   `template_id`: "soukaku\_3\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-苍角-32" - 模板的描述性名稱。 |     *   `template_shape`: "polygon" - 模板的形狀類型。 |     *   `auto_mask`: `true` - 指示是否啟用自動遮罩。 |     *   `point_list`:  定義多邊形形狀的坐標點列表。 | *   **重要功能點:**  定義了代理狀態的幾何形狀，用於視覺呈現或碰撞檢測。
│       │   ├── soukaku_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板。 |  | *   **主要功能:** 定義角色狀態的視覺模板，包括形狀和坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的名稱。 |     *   `template_shape`: 模板的形狀，這裡為 "polygon"。 |     *   `auto_mask`: 是否自動生成遮罩。 |     *   `point_list`: 定義多邊形形狀的頂點坐標列表。 | *   **重要功能點:**  定義了角色狀態的形狀和位置，用於在遊戲或其他應用程序中視覺化地表示角色狀態。
│       │   ├── special_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於遊戲或其他應用程序。 |  | *   **主要功能:** 定義一個名為 "角色状态-特殊技-31" 的角色狀態模板，包含模板 ID、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`:  "special\_3\_1" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-特殊技-31" - 模板的名稱。 |     *   `template_shape`: "circle" - 模板的形狀。 |     *   `auto_mask`: `true` -  指示是否啟用自動遮罩。 |     *   `point_list`:  包含兩個坐標點的列表，用於定義模板的關鍵點。 | *   **重要功能點:**  定義了角色狀態的外觀和行為，包括形狀、遮罩和關鍵點，這些信息用於遊戲或其他應用程序中角色的視覺表現和交互。
│       │   ├── trigger_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程式的模板，用於描述一個觸發器（trigger）的狀態。 |  | *   **主要功能:** 定義一個名為 "角色狀態-扳機-22" 的矩形觸發器模板，用於處理遊戲中的狀態變化。 | *   **核心元素:** |     *   `template_id`: "trigger\_2\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-扳机-22" - 模板的描述性名稱。 |     *   `template_shape`: "rectangle" - 觸發器的形狀。 |     *   `auto_mask`: `true` - 指示是否自動應用遮罩。 |     *   `point_list`:  定義矩形觸發器兩個頂點的坐標 (619, 98) 和 (662, 99)。 | *   **重要功能點:**  定義了觸發器的形狀、位置和自動遮罩的設置，這些設置用於在遊戲中檢測和響應玩家或其他實體進入觸發區域。
│       │   ├── trigger_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序的模板，用於描述一個矩形區域的角色狀態觸發器。 |  | *   **主要功能:** 定義一個角色狀態觸發器的配置，包括其形狀、位置和自動遮罩設置。 | *   **核心元素:** |     *   `template_id`: 觸發器的唯一標識符。 |     *   `template_name`: 觸發器的名稱。 |     *   `template_shape`: 觸發器的形狀，這裡為 "rectangle"。 |     *   `auto_mask`:  是否自動應用遮罩。 |     *   `point_list`:  定義矩形區域的兩個頂點坐標。 | *   **重要功能點:**  定義了觸發器的形狀和位置，以及是否自動遮罩，這些信息用於在遊戲或應用程序中檢測角色是否進入特定區域。
│       │   ├── trigger_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-扳机-32"。 |  | *   **主要功能:** 定義一個矩形形狀的模板，用於角色狀態的觸發。 | *   **核心元素:** |     *   `template_id`: "trigger\_3\_2" (模板 ID) |     *   `template_name`: "角色状态-扳机-32" (模板名稱) |     *   `template_shape`: "rectangle" (模板形狀) |     *   `auto_mask`: `true` (是否自動遮罩) |     *   `point_list`:  定義矩形兩個頂點的坐標 (585, 98) 和 (628, 99)。 | *   **重要功能點:**  定義了模板的形狀、名稱、ID，以及是否自動遮罩，並提供了用於定位矩形的兩個關鍵點坐標。
│       │   ├── trigger_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序的模板，用於描述一個名為 "角色状态-扳机-33" 的矩形區域的代理狀態觸發器。 |  | *   **主要功能:** 定義一個代理狀態觸發器的配置，包括其形狀、位置和自動遮罩設置。 | *   **核心元素:** |     *   `template_id`: "trigger\_3\_3" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-扳机-33" - 模板的描述性名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀。 |     *   `auto_mask`: `true` -  指示是否自動應用遮罩。 |     *   `point_list`:  定義矩形區域的兩個頂點坐標 (767, 98) 和 (809, 99)。 | *   **重要功能點:**  定義了觸發器的形狀、位置和遮罩行為，這些信息將用於在遊戲或應用程序中觸發代理狀態的變化。
│       │   ├── ultimate_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個 Agent 狀態模板，用於描述遊戲中角色的狀態。 |  | *   **主要功能:** 定義一個角色狀態模板，包含模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的名稱。 |     *   `template_shape`: 模板的形狀 (例如 "rectangle")。 |     *   `auto_mask`:  是否啟用自動遮罩。 |     *   `point_list`:  定義關鍵點坐標的列表。 | *   **重要功能點:**  定義了模板的基礎屬性，包括用於視覺呈現和交互的形狀和關鍵點。 `auto_mask` 參數暗示了可能用於圖像處理或視覺效果的功能。
│       │   ├── ultimate_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於遊戲或其他應用程序。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心配置項:** |     *   `sub_dir`: 模板所屬的子目錄。 |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的名稱。 |     *   `template_shape`: 模板的形狀，這裡定義為 "circle" (圓形)。 |     *   `auto_mask`: 是否啟用自動遮罩，設置為 `true`。 |     *   `point_list`: 一個包含兩個坐標點的列表，用於定義模板的關鍵點。 | *   **重要功能點:**  定義了角色狀態的視覺表現和行為，包括形狀、遮罩和關鍵點，這些信息將被用於渲染或處理角色狀態。
│       │   ├── ultimate_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲中角色的終結技狀態。 |  | *   **主要功能:** 定義角色狀態模板的配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心配置項:** |     *   `sub_dir`: 模板所屬的子目錄，為 `agent_state`。 |     *   `template_id`: 模板的唯一標識符，為 `ultimate_3_2`。 |     *   `template_name`: 模板的描述性名稱，為 `角色状态-终结技-32`。 |     *   `template_shape`: 模板的形狀，為 `rectangle`。 |     *   `auto_mask`: 是否自動遮罩，為 `true`。 |     *   `point_list`: 定義關鍵點坐標列表，用於定位和識別角色狀態。 | *   **重要功能點:**  定義了模板的形狀和關鍵點，以及是否啟用自動遮罩，這些配置共同決定了角色狀態的視覺表現和識別方式。
│       │   ├── ultimate_3_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序的角色狀態模板。 |  | *   **主要功能:** 定義了名為 "角色状态-终结技-33" 的角色狀態模板，用於視覺化呈現。 | *   **核心元素:** |     *   `template_id`: "ultimate\_3\_3" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-终结技-33" - 模板的名稱。 |     *   `template_shape`: "rectangle" - 模板的形狀。 |     *   `auto_mask`: `true` -  指示是否自動應用遮罩。 |     *   `point_list`:  定義了矩形模板的兩個頂點坐標 (831, 74) 和 (863, 75)。 | *   **重要功能點:**  定義了模板的形狀、名稱、遮罩設置和關鍵點坐標，這些信息用於在遊戲或應用程序中渲染和處理角色狀態。
│       │   ├── yanagi_blue_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個代理狀態模板。 |  | *   **主要功能:** 配置代理狀態模板，描述其外觀和形狀。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的描述性名稱。 |     *   `template_shape`: 模板的形狀，這裡設定為 `polygon` (多邊形)。 |     *   `auto_mask`:  是否自動生成遮罩，設定為 `true`。 |     *   `point_list`:  定義多邊形形狀的頂點坐標列表。 | *   **重要功能點:**  定義了代理狀態的視覺呈現，包括形狀和遮罩。
│       │   ├── zhu_yuan_2_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-朱鸢-22"。 |  | *   **主要功能:** 定義角色狀態的視覺模板，用於圖像處理或遊戲開發。 | *   **核心配置:** |     *   `template_id`: "zhu\_yuan\_2\_2" - 模板的唯一標識符。 |     *   `template_name`: "角色状态-朱鸢-22" - 模板的描述性名稱。 |     *   `template_shape`: "quadrilateral" - 模板的形狀，定義為四邊形。 |     *   `auto_mask`: `true` - 啟用自動遮罩功能。 |     *   `point_list`:  定義四邊形的四個頂點坐標，用於定位模板在圖像中的位置。
│       │   ├── zhu_yuan_3_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於角色狀態的模板，名為 "角色状态-朱鸢-31"。 |  | *   **主要功能:** 定義角色狀態的模板配置，包括模板 ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 "zhu\_yuan\_3\_1"。 |     *   `template_name`: 模板的名稱，為 "角色状态-朱鸢-31"。 |     *   `template_shape`: 模板的形狀，為 "quadrilateral" (四邊形)。 |     *   `auto_mask`:  是否自動遮罩，設為 `true`。 |     *   `point_list`:  定義四邊形四個頂點的坐標列表。 | *   **重要功能點:**  定義了模板的幾何形狀和關鍵點，用於在圖像或場景中定位和識別角色狀態。 啟用自動遮罩功能。
│       │   ├── zhu_yuan_3_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個角色狀態模板，用於描述遊戲中角色“朱鳶”的狀態。 |  | *   **主要功能:** 定義角色狀態模板的配置信息。 | *   **核心配置:** |     *   `sub_dir`: 模板所屬的子目錄。 |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的名稱。 |     *   `template_shape`: 模板的形狀，這裡定義為四邊形。 |     *   `auto_mask`: 是否自動生成遮罩，設為 true。 |     *   `point_list`: 定義四邊形的頂點坐標。 | *   **重要功能點:** 描述角色狀態模板的形狀和位置，以及是否自動生成遮罩。
│       │   └── zhu_yuan_3_3/
│       │       └── config.yml    這個 YAML 文件的摘要如下： |  | 1.  **主要功能：** 定義了一個角色狀態模板的配置，用於描述遊戲中朱鳶角色的狀態。 | 2.  **核心元素：** |     *   `template_id`:  `zhu_yuan_3_3`，模板的唯一標識符。 |     *   `template_name`: `角色状态-朱鸢-33`，模板的名稱。 |     *   `template_shape`: `quadrilateral`，定義了模板的形狀為四邊形。 |     *   `auto_mask`: `true`，表示啟用自動遮罩。 |     *   `point_list`:  定義了四邊形的四個頂點坐標，用於描述角色狀態的區域。 | 3.  **重要功能點：**  定義了角色狀態模板的形狀、自動遮罩設置以及用於定位狀態區域的關鍵點坐標。
│       ├── battle/
│       │   ├── avatar_1_rina/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於戰鬥場景中角色頭像的模板。 |  | *   **主要功能:** 描述了角色頭像的形狀和位置，用於在戰鬥場景中渲染角色頭像。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符 (`avatar_1_rina`)。 |     *   `template_name`: 模板的名稱 (`战斗-头像-3-1`)。 |     *   `template_shape`: 模板的形狀 (`polygon`)。 |     *   `auto_mask`: 是否自動生成遮罩 (`true`)。 |     *   `point_list`: 定義多邊形形狀的頂點坐標列表。 | *   **重要功能點:**  定義了頭像的形狀和位置，用於渲染。
│       │   ├── avatar_2_anby/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個戰鬥場景中頭像的模板配置。 |  | *   **主要功能:** 定義戰鬥中頭像的視覺模板，包括形狀、自動遮罩設置和關鍵點坐標。 | *   **核心配置項:** |     *   `template_id`: 模板 ID，`avatar_2_anby`。 |     *   `template_name`: 模板名稱，`战斗-头像-3-2`。 |     *   `template_shape`: 模板形狀，`quadrilateral` (四邊形)。 |     *   `auto_mask`: 是否啟用自動遮罩，`true`。 |     *   `point_list`: 定義四邊形四個頂點的坐標列表。 | *   **重要功能點:**  定義了頭像的形狀和位置，以及是否啟用自動遮罩，這些配置用於在戰鬥場景中渲染頭像。
│       │   ├── avatar_2_anton/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於戰鬥場景的頭像模板。 |  | *   **主要功能:** 定義戰鬥場景中頭像的配置，包括模板 ID、名稱、形狀和關鍵點。 | *   **核心元素:** |     *   `template_id`:  `avatar_2_anton`，模板的唯一標識符。 |     *   `template_name`:  `战斗-头像-3-3`，模板的名稱。 |     *   `template_shape`:  `quadrilateral`，頭像的形狀。 |     *   `auto_mask`:  `true`，是否自動應用遮罩。 |     *   `point_list`:  定義頭像邊界的四個點的坐標。 | *   **重要功能點:**  定義了頭像的形狀和位置，以及是否自動應用遮罩，用於在戰鬥場景中渲染頭像。
│       │   ├── avatar_2_piper/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個戰鬥場景中，名為 "avatar_2_piper" 的模板配置。 |  | *   **主要功能:**  配置戰鬥場景中頭像的模板，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心元素:** |     *   `template_id`:  "avatar_2_piper" - 模板的唯一標識符。 |     *   `template_name`: "战斗-头像-2-2" - 模板的名稱。 |     *   `template_shape`: "quadrilateral" - 模板的形狀（四邊形）。 |     *   `auto_mask`: true -  是否啟用自動遮罩。 |     *   `point_list`:  定義四邊形四個頂點的坐標列表。 | *   **重要功能點:**  定義了戰鬥場景中頭像的視覺呈現，包括形狀和位置，以及是否啟用自動遮罩。
│       │   ├── avatar_chain_anby/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於戰鬥場景的連攜技模板。 |  | *   **主要功能:** 定義一個名為 "連攜技-2" 的連攜技模板，用於戰鬥場景。 | *   **核心配置:** |     *   `template_id`: `chain_attack_anby` (模板 ID) |     *   `template_name`: `连携技-2` (模板名稱) |     *   `template_shape`: `circle` (模板形狀) |     *   `auto_mask`: `true` (是否自動遮罩) |     *   `point_list`:  定義了兩個點的坐標，用於定位模板。 | *   **重要功能點:**  定義了連攜技的形狀、名稱、遮罩設置和關鍵點坐標，這些信息用於在戰鬥場景中視覺化和控制連攜技的行為。
│       │   ├── avatar_chain_nicole/
│       │   │   └── config.yml    這個 YAML 配置文件定義了遊戲中一個名為 "连携技-1" 的角色連攜技能的視覺效果和觸發點。 |  | *   **主要功能:** 配置角色連攜技能的視覺效果和觸發點。 | *   **核心配置:** |     *   `template_id`: "avatar\_chain\_nicole" - 模板 ID。 |     *   `template_name`: "连携技-1" - 模板名稱。 |     *   `template_shape`: "circle" - 視覺形狀為圓形。 |     *   `auto_mask`: `true` - 啟用自動遮罩。 |     *   `point_list`:  定義了兩個觸發點的坐標 (538, 887) 和 (489, 887)。 | *   **重要功能點:** 定義了視覺模板的形狀、自動遮罩設置以及觸發點坐標，這些信息用於在遊戲中呈現和觸發該連攜技能。
│       │   ├── avatar_chain_trigger/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於戰鬥場景中的視覺效果模板，特別是關於角色連攜技能的觸發。 |  | *   **主要功能:** 定義一個連攜技能觸發的視覺效果模板。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 `avatar_chain_trigger`。 |     *   `template_name`: 模板的名稱，為 `连携技-1`。 |     *   `template_shape`: 模板的形狀，為 `circle`。 |     *   `auto_mask`: 是否自動應用遮罩，為 `true`。 |     *   `point_list`: 一個包含兩個坐標點的列表，用於定義視覺效果的位置。 | *   **重要功能點:**  定義了連攜技能視覺效果的基礎屬性，包括形狀、遮罩和位置。
│       │   ├── avatar_quick_trigger/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於戰鬥場景的快速支援觸發器模板。 |  | *   **主要功能:** 定義戰鬥中快速支援的觸發區域和相關屬性。 | *   **核心屬性:** |     *   `template_id`: `avatar_quick_trigger`，模板 ID。 |     *   `template_name`: `战斗-快速支援`，模板名稱。 |     *   `template_shape`: `circle`，觸發區域形狀為圓形。 |     *   `auto_mask`: `true`，啟用自動遮罩。 |     *   `point_list`:  定義了兩個點的坐標，用於定義觸發區域的位置。 | *   **重要功能點:**  定義了觸發器的基本屬性，包括形狀、自動遮罩以及觸發點的坐標。
│       │   ├── avatar_quick_zhu_yuan/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個戰鬥模板，用於快速支援。 |  | *   **主要功能:** 定義戰鬥場景的模板，用於快速支援。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的名稱。 |     *   `template_shape`: 模板的形狀，這裡設定為 `circle`。 |     *   `auto_mask`: 是否自動遮罩，設定為 `true`。 |     *   `point_list`: 一個坐標點列表，定義了模板的關鍵點。 | *   **重要功能點:**  定義了戰鬥模板的形狀、遮罩設置和關鍵點坐標。
│       │   ├── btn_assist_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個戰鬥場景中支援按鈕的模板配置。 |  | *   **主要功能:**  配置戰鬥場景中支援按鈕的外觀和行為。 | *   **核心元素:** |     *   `template_id`:  模板的唯一標識符，為 `assist_1`。 |     *   `template_name`:  模板的顯示名稱，為 `战斗-支援-1`。 |     *   `template_shape`:  按鈕的形狀，為 `circle`。 |     *   `auto_mask`:  是否自動應用遮罩，為 `true`。 |     *   `point_list`:  定義按鈕的坐標點列表。 | *   **重要功能點:**  定義了按鈕的 ID、名稱、形狀、是否自動遮罩以及坐標點，這些信息共同構成了按鈕的視覺和交互屬性。
│       │   ├── btn_assist_2/
│       │   │   └── config.yml    這個 YAML 配置文件定義了遊戲戰鬥場景中一個名為 "战斗-支援-2" 的輔助按鈕的配置。 |  | *   **主要功能:** 配置戰鬥場景中的輔助按鈕，包括外觀、形狀和位置。 | *   **核心配置項:** |     *   `template_id`:  `assist_2`，按鈕的唯一標識符。 |     *   `template_name`:  "战斗-支援-2"，按鈕的顯示名稱。 |     *   `template_shape`:  `circle`，按鈕的形狀為圓形。 |     *   `auto_mask`: `true`，表示自動遮罩。 |     *   `point_list`:  按鈕的兩個坐標點，定義了按鈕的位置。 | *   **重要功能點:**  定義了輔助按鈕的視覺樣式和位置，用於在戰鬥場景中呈現和交互。
│       │   ├── btn_dodge/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於戰鬥場景中閃避按鈕的模板。 |  | *   **主要功能:** 定義閃避按鈕的視覺模板，包括其形狀、位置和遮罩配置。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 "dodge"。 |     *   `template_name`: 模板的顯示名稱，為 "战斗-闪避"。 |     *   `template_shape`: 模板的形狀，為 "circle"。 |     *   `auto_mask`: 是否自動應用遮罩，為 `true`。 |     *   `point_list`: 定義按鈕位置的坐標點列表。 | *   **重要功能點:**  定義了閃避按鈕的視覺外觀和位置，用於遊戲中的戰鬥界面。
│       │   ├── btn_interact/
│       │   │   └── config.yml    這個 YAML 配置文件定義了戰鬥場景中一個交互按鈕的模板。 |  | *   **主要功能:** 定義戰鬥場景中交互按鈕的視覺和行為屬性。 | *   **核心元素:** |     *   `template_id`:  `btn_interact` (模板 ID) |     *   `template_name`: `战斗-交互` (模板名稱) |     *   `template_shape`: `circle` (按鈕形狀) |     *   `auto_mask`: `true` (是否自動遮罩) |     *   `point_list`:  `1454, 967` 和 `1413, 967` (按鈕的坐標點列表，可能用於定義按鈕的邊界或位置) | *   **重要功能點:** |     *   定義了按鈕的形狀、名稱和位置。 |     *   `auto_mask` 屬性指示是否需要自動遮罩，這可能與按鈕的視覺效果有關。
│       │   ├── btn_menu/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於戰鬥場景中菜單按鈕的模板。 |  | *   **主要功能:** 定義戰鬥場景中菜單按鈕的視覺外觀和形狀。 | *   **核心元素:** |     *   `template_id`: `btn_menu`，模板的唯一標識符。 |     *   `template_name`: `战斗-菜单`，模板的顯示名稱。 |     *   `template_shape`: `polygon`，定義按鈕的形狀為多邊形。 |     *   `auto_mask`: `true`，表示自動生成遮罩。 |     *   `point_list`: 定義多邊形按鈕的頂點坐標。 | *   **重要功能點:**  定義了按鈕的形狀 (多邊形) 和頂點，以及是否自動生成遮罩。
│       │   ├── btn_normal_attack/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲戰鬥場景中普通攻擊按鈕的模板。 |  | *   **主要功能:** 配置普通攻擊按鈕的視覺和行為。 | *   **核心配置項:** |     *   `template_id`:  `normal_attack`，按鈕的唯一標識符。 |     *   `template_name`: `战斗-普通攻击`，按鈕的顯示名稱。 |     *   `template_shape`: `circle`，按鈕的形狀。 |     *   `auto_mask`: `true`，指示是否自動應用遮罩。 |     *   `point_list`:  定義按鈕的坐標點列表，用於定位和繪製按鈕。 | *   **重要功能點:**  定義了按鈕的形狀、名稱、遮罩設置和坐標，這些信息共同構成了遊戲中普通攻擊按鈕的視覺表現和交互。
│       │   ├── btn_special_attack_1/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於戰鬥場景中特殊攻擊按鈕的模板。 |  | *   **主要功能:** 定義特殊攻擊按鈕的視覺和行為屬性。 | *   **核心元素:** |     *   `template_id`:  `special_attack_1`，按鈕的唯一標識符。 |     *   `template_name`: `战斗-特殊攻击-1`，按鈕的顯示名稱。 |     *   `template_shape`: `circle`，按鈕的形狀。 |     *   `auto_mask`: `true`，是否自動應用遮罩。 |     *   `point_list`:  包含兩個坐標點，可能用於定義按鈕的邊界或錨點。 | *   **重要功能點:**  定義了按鈕的視覺形狀、遮罩設置和位置。
│       │   └── btn_ultimate_1/
│       │       └── config.yml    這個 YAML 配置文件定義了一個用於遊戲戰鬥場景中終結技按鈕的模板。 |  | *   **主要功能:** 定義終結技按鈕的視覺和行為屬性。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符 ("ultimate\_1")。 |     *   `template_name`: 模板的顯示名稱 ("战斗-终结技-1")。 |     *   `template_shape`: 按鈕的形狀 ("circle")。 |     *   `auto_mask`: 是否自動應用遮罩 (true)。 |     *   `point_list`:  定義按鈕位置的坐標點列表。 | *   **重要功能點:**  定義了按鈕的形狀、名稱、遮罩設置以及位置。
│       ├── fishing/
│       │   ├── btn_left/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於釣魚遊戲的左側按鈕模板。 |  | *   **主要功能:** 定義釣魚遊戲中左側按鈕的視覺和行為屬性。 | *   **核心元素:** |     *   `template_id`:  `btn_left` (按鈕的唯一標識符) |     *   `template_name`: `钓鱼-按键-左` (按鈕的顯示名稱) |     *   `template_shape`: `circle` (按鈕的形狀為圓形) |     *   `auto_mask`: `true` (啟用自動遮罩) |     *   `point_list`:  `[320, 883], [263, 883]` (按鈕的關鍵點坐標，用於定位和交互) | *   **重要功能點:**  定義了按鈕的形狀、名稱、遮罩行為和關鍵點坐標，這些信息用於在遊戲中渲染和交互左側按鈕。
│       │   ├── btn_right/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於釣魚遊戲中右側按鈕的模板。 |  | *   **主要功能:** 定義釣魚遊戲中右側按鈕的視覺模板，包括形狀、位置和自動遮罩設置。 | *   **核心配置:** |     *   `template_id`:  `btn_right`，模板的唯一標識符。 |     *   `template_name`: `钓鱼-按键-右`，模板的中文名稱。 |     *   `template_shape`: `circle`，按鈕的形狀為圓形。 |     *   `auto_mask`: `true`，啟用自動遮罩。 |     *   `point_list`: 包含兩個坐標點，定義了按鈕的位置。 | *   **重要功能點:**  定義了按鈕的形狀、位置和是否啟用自動遮罩，這些配置共同決定了遊戲中右側按鈕的視覺呈現和交互行為。
│       │   └── interact_timing/
│       │       └── config.yml    這個 YAML 配置文件定義了一個名為 "钓鱼-时机上鱼" 的釣魚互動模板。 |  | *   **主要功能:** 定義釣魚遊戲中，玩家需要根據時機互動的模板配置。 | *   **核心元素:** |     *   `template_id`:  `interact_timing`，模板的唯一標識。 |     *   `template_name`:  `钓鱼-时机上鱼`，模板的名稱。 |     *   `template_shape`:  `circle`，模板的形狀。 |     *   `auto_mask`:  `true`，表示自動啟用遮罩。 |     *   `point_list`:  `[1600, 882], [1526, 880]`，定義了模板的關鍵點坐標。 | *   **重要功能點:**  定義了模板的類型、名稱、形狀、遮罩設置以及關鍵點坐標，這些信息用於在遊戲中呈現互動提示。
│       ├── hollow/
│       │   ├── avatar_anby/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於生成圖像的模板配置。 |  | *   **主要功能:** 描述了用於生成圖像的模板配置，包括模板的子目錄、ID、名稱、形狀、自動遮罩設置和關鍵點坐標。 | *   **核心元素:** |     *   `sub_dir`: 模板所在的子目錄。 |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的名稱。 |     *   `template_shape`: 模板的形狀。 |     *   `auto_mask`: 是否啟用自動遮罩。 |     *   `point_list`: 一個包含關鍵點坐標的列表，用於定義圖像的形狀或區域。 | *   **重要功能點:**  定義了模板的形狀和關鍵點，以及是否啟用自動遮罩。這些配置用於圖像生成過程，例如裁剪、變形或添加效果。
│       │   ├── avatar_nicole/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於生成圖像的模板配置，特別是針對一個名為 "avatar_nicole" 的角色頭像。 |  | *   **主要功能:** 配置圖像模板的參數，用於生成特定形狀的圖像。 | *   **核心配置:** |     *   `template_id`: 模板的唯一標識符 ("avatar_nicole")。 |     *   `template_name`: 模板的描述性名稱 ("零号空洞-角色头像-3")。 |     *   `template_shape`: 模板的形狀 ("quadrilateral"，即四邊形)。 |     *   `auto_mask`:  是否自動應用遮罩 (設為 `true`)。 |     *   `point_list`:  定義四邊形四個頂點的坐標列表。 | *   **重要功能點:**  定義了圖像的形狀和位置，以及是否自動應用遮罩。
│       │   ├── avatar_zhu_yuan/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於生成角色頭像的模板。 |  | *   **主要功能:** 配置角色頭像模板的屬性。 | *   **核心配置項:** |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的名稱。 |     *   `template_shape`: 模板的形狀，這裡定義為四邊形。 |     *   `auto_mask`: 是否自動生成遮罩。 |     *   `point_list`: 定義四邊形的四個頂點坐標。 | *   **重要功能點:** 定義了模板的形狀和用於遮罩的頂點坐標，以及是否自動生成遮罩。
│       │   ├── right_top_back/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個模板的配置，用於在右上角創建一個帶有返回按鈕的空心矩形。 |  | *   **主要功能:** 配置一個用於右上角返回按鈕的模板。 | *   **核心配置:** |     *   `template_id`: `right_top_back`，模板的唯一標識符。 |     *   `template_name`: `右上角-返回`，模板的名稱。 |     *   `template_shape`: `rectangle`，模板的形狀為矩形。 |     *   `auto_mask`: `true`，啟用自動遮罩。 |     *   `point_list`:  定義矩形右上角兩個點的坐標，用於定位返回按鈕。 | *   **重要功能點:**  定義了模板的形狀、名稱、自動遮罩設置以及用於定位的關鍵點坐標。
│       │   └── speed_up/
│       │       └── config.yml    這個 YAML 配置文件定義了一個用於「零号空洞-快进」模板的配置。 |  | *   **主要功能:** 配置模板的屬性，包括模板 ID、名稱、形狀、自動遮罩設置以及關鍵點坐標。 | *   **核心配置項:** |     *   `template_id`: 模板的唯一標識符，值為 "speed_up"。 |     *   `template_name`: 模板的顯示名稱，值為 "零号空洞-快进"。 |     *   `template_shape`: 模板的形狀，值為 "rectangle"。 |     *   `auto_mask`:  是否啟用自動遮罩，值為 `true`。 |     *   `point_list`:  定義關鍵點坐標的列表，用於模板的定位或變換。 | *   **重要功能點:**  定義了模板的基本屬性，以及是否啟用自動遮罩和關鍵點坐標。
│       ├── lost_void/
│       │   ├── gear_hoshimi_miyabi_3/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個遊戲模板，用於描述一個名為“迷失之地武备”的裝備。 |  | *   **主要功能:** 定義遊戲中裝備的外觀和行為。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 `agent_gear_hoshimi_miyabi_3`。 |     *   `template_name`: 模板的名稱，為“迷失之地武备”。 |     *   `template_shape`: 模板的形狀，為 `circle`。 |     *   `auto_mask`:  是否自動應用遮罩，設為 `true`。 |     *   `point_list`:  定義了兩個坐標點 (1112, 982) 和 (1176, 978)，可能用於定義裝備的某些視覺效果或碰撞區域。 | *   **重要功能點:**  定義了裝備的視覺形狀、遮罩設置和關鍵點坐標。
│       │   └── normal_world_tab/
│       │       └── config.yml    這個 YAML 配置文件定義了一個用於遊戲中的 UI 模板，主要功能是描述一個名為 "迷失之地-TAB" 的多邊形 UI 元素。 |  | *   **主要功能:** 定義一個 UI 模板的配置，用於在遊戲中呈現 "迷失之地-TAB" 元素。 | *   **核心配置項:** |     *   `sub_dir`: 模板所屬的子目錄 ("lost\_void")。 |     *   `template_id`: 模板的 ID ("normal\_world\_tab")。 |     *   `template_name`: 模板的名稱 ("迷失之地-TAB")。 |     *   `template_shape`: 模板的形狀 ("polygon")。 |     *   `auto_mask`: 是否自動應用遮罩 (true)。 |     *   `point_list`: 定義多邊形 UI 元素的頂點坐標列表。 | *   **重要功能點:**  定義了 UI 元素的形狀和位置，以及是否自動遮罩。
│       ├── menu/
│       │   ├── back/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個名為 "菜单-返回" 的模板，用於在 "menu" 子目錄下創建一個矩形形狀的模板。它指定了模板的 ID、名稱、形狀，以及是否自動進行遮罩處理。 配置文件還定義了兩個關鍵點坐標。 |  | *   **主要功能:** 定義菜單返回按鈕的模板配置。 | *   **核心元素:** |     *   `template_id`: "back" (模板 ID) |     *   `template_name`: "菜单-返回" (模板名稱) |     *   `template_shape`: "rectangle" (模板形狀) |     *   `auto_mask`: `true` (是否自動遮罩) |     *   `point_list`: 包含兩個點坐標的列表，用於定義模板的關鍵點。 | *   **重要功能點:**  定義模板的形狀、名稱、ID，以及是否自動遮罩和關鍵點坐標。
│       │   └── friends/
│       │       └── config.yml    這個 YAML 配置文件定義了一個菜單模板，用於在應用程序中顯示朋友相關的菜單。 |  | *   **主要功能:** 定義朋友菜單的配置，包括菜單的形狀、自動遮罩設置和關鍵點坐標。 | *   **核心配置項:** |     *   `template_id`: 模板 ID，為 "friends"。 |     *   `template_name`: 模板名稱，為 "菜单-朋友"。 |     *   `template_shape`: 菜單形狀，為 "circle"。 |     *   `auto_mask`: 是否自動遮罩，為 `true`。 |     *   `point_list`: 關鍵點坐標列表，用於定位菜單元素。 | *   **重要功能點:**  配置了菜單的外觀和行為，包括形狀、遮罩和關鍵點，這些信息將被用於渲染和定位菜單。
│       ├── normal_world/
│       │   ├── interact/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於大世界交互的模板。 |  | *   **主要功能:** 配置大世界交互模板的屬性。 | *   **核心元素:** |     *   `template_id`: 模板的唯一標識符，為 "interact"。 |     *   `template_name`: 模板的名稱，為 "大世界-交互"。 |     *   `template_shape`: 模板的形狀，為 "circle"。 |     *   `auto_mask`:  是否自動遮罩，為 `true`。 |     *   `point_list`:  定義了模板的點列表，用於定義交互區域的邊界。 | *   **重要功能點:**  定義了交互模板的形狀、名稱、遮罩設置和關鍵點坐標，用於在遊戲世界中創建交互區域。
│       │   ├── inter_knot/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個名為 "大世界-绳网" 的模板，用於在 "normal_world" 子目錄下創建一個 "inter_knot" 模板。 |  | *   **主要功能:** 配置一個用於生成繩網的模板。 | *   **核心配置:** |     *   `template_id`: "inter_knot" (模板 ID) |     *   `template_name`: "大世界-绳网" (模板名稱) |     *   `template_shape`: "circle" (模板形狀) |     *   `auto_mask`: true (是否自動遮罩) |     *   `point_list`:  定義了兩個點的坐標，用於模板的定位或生成。 | *   **重要功能點:**  定義了模板的形狀、名稱、遮罩行為以及用於定位或生成的關鍵點。
│       │   ├── map/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個地圖模板的配置。 |  | *   **主要功能:**  配置一個名為 "大世界-地图" 的地圖模板，用於 "normal\_world" 子目錄。 | *   **核心配置項:** |     *   `template_id`:  `map`，模板的唯一標識符。 |     *   `template_name`:  `大世界-地图`，模板的顯示名稱。 |     *   `template_shape`:  `circle`，模板的形狀。 |     *   `auto_mask`:  `true`，是否自動進行遮罩處理。 |     *   `point_list`:  `[1777, 827], [1738, 827]`，定義了地圖上的一些關鍵點坐標。 | *   **重要功能點:**  定義了地圖模板的基本屬性，包括形狀、遮罩設置和關鍵點坐標。
│       │   ├── message/
│       │   │   └── config.yml    這個 YAML 配置文件定義了一個用於遊戲或應用程序的模板，主要用於在 "normal_world" 子目錄下顯示信息。 |  | *   **主要功能:**  配置一個名為 "message" 的模板，用於在大世界中顯示信息，並定義了其外觀和位置。 | *   **核心配置項:** |     *   `sub_dir`:  "normal_world" - 模板所屬的子目錄。 |     *   `template_id`: "message" - 模板的唯一標識符。 |     *   `template_name`: "大世界-信息" - 模板的顯示名稱。 |     *   `template_shape`: "circle" - 模板的形狀。 |     *   `auto_mask`: `true` -  是否自動應用遮罩。 |     *   `point_list`:  `[1777, 967], [1738, 967]` -  模板的坐標點列表，定義了模板在屏幕上的位置。 | *   **重要功能點:**  定義了模板的形狀、名稱、自動遮罩設置以及在屏幕上的位置，這些配置共同決定了信息在遊戲中的視覺呈現方式。
│       │   └── run/
│       │       └── config.yml    這個 YAML 配置文件定義了一個名為 "大世界-疾跑" 的模板，用於在 "normal_world" 子目錄下生成。 |  | *   **主要功能:** 配置一個用於 "大世界-疾跑" 遊戲功能的模板。 | *   **核心配置:** |     *   `sub_dir`:  "normal_world" (子目錄) |     *   `template_id`: "run" |     *   `template_name`: "大世界-疾跑" |     *   `template_shape`: "circle" (模板形狀) |     *   `auto_mask`: `true` (是否自動遮罩) |     *   `point_list`:  定義了兩個坐標點 (1563, 967) 和 (1522, 967)，可能用於定義模板的關鍵點或邊界。 | *   **重要功能點:**  定義了模板的名稱、形狀、自動遮罩設置以及關鍵點坐標，這些信息共同構成了遊戲中 "疾跑" 功能的視覺和行為基礎。
│       ├── predefined_team/
│       │   └── avatar_anby/
│       │       └── config.yml    這個 YAML 配置文件定義了一個預定義團隊模板的配置，名為 "avatar_anby"。 |  | *   **主要功能:** 定義了用於創建團隊頭像的模板配置。 | *   **核心配置項:** |     *   `sub_dir`: 模板所屬的子目錄 ("predefined_team")。 |     *   `template_id`: 模板的唯一標識 ("avatar_anby")。 |     *   `template_name`: 模板的顯示名稱 ("预备编队-头像")。 |     *   `template_shape`: 模板的形狀 ("rectangle")。 |     *   `auto_mask`: 是否自動生成遮罩 (true)。 |     *   `point_list`: 一個包含兩個點的列表，可能用於定義模板的邊界或關鍵點。 | *   **重要功能點:** 定義了模板的形狀、遮罩設置和關鍵點，用於生成團隊頭像。
│       └── shiyu_defense/
│           ├── node_01/
│           │   └── config.yml    這個 YAML 配置文件定義了名為 "式舆防卫战-节点01" 的遊戲模板的配置。 |  | *   **主要功能:** 配置遊戲模板，包括模板 ID、名稱、形狀、自動遮罩設置和節點坐標。 | *   **核心元素:** |     *   `sub_dir`: 模板所屬的子目錄。 |     *   `template_id`: 模板的唯一標識符。 |     *   `template_name`: 模板的名稱。 |     *   `template_shape`: 模板的形狀，這裡設定為 "circle"。 |     *   `auto_mask`:  是否啟用自動遮罩，設定為 `true`。 |     *   `point_list`:  定義節點坐標的列表。 | *   **重要功能點:**  配置了模板的形狀、自動遮罩啟用狀態，以及節點的位置坐標，這些都是遊戲場景的重要組成部分。
│           └── node_02/
│               └── config.yml    這個 YAML 配置文件定義了一個名為 "式舆防卫战-节点02" 的模板，用於遊戲或應用程式中。 |  | *   **主要功能:** 配置遊戲模板的相關屬性。 | *   **核心元素:** |     *   `sub_dir`: 模板所屬的子目錄 (shiyu\_defense)。 |     *   `template_id`: 模板的唯一標識符 (node\_02)。 |     *   `template_name`: 模板的顯示名稱 ("式舆防卫战-节点02")。 |     *   `template_shape`: 模板的形狀 (circle)。 |     *   `auto_mask`:  是否自動應用遮罩 (true)。 |     *   `point_list`:  定義模板中關鍵點的坐標列表。 | *   **重要功能點:** |     *   定義了模板的形狀和名稱，用於遊戲場景的視覺呈現。 |     *   `auto_mask` 屬性暗示了自動遮罩功能，可能用於隱藏或顯示某些遊戲元素。 |     *   `point_list` 提供了模板中關鍵點的坐標，可能用於碰撞檢測、路徑規劃或其他遊戲邏輯。
├── config/
│   ├── format.py    **摘要:** |  | 该 Python 脚本用于格式化 YAML 文件，主要功能包括查找 YAML 文件、调整缩进、裁剪尾随空格、确保文件末尾有换行符，以及修复注释和标点符号的空格问题。 |  | **核心类和函数:** |  | *   `find_yml_files(directory)`: 递归查找指定目录及其子目录下的所有 .yml 和 .yaml 文件。 | *   `convert_indent_to_spaces(content, spaces=2)`: 将缩进转换为指定数量的空格。 | *   `trim_trailing_whitespace(content)`: 裁剪每行的尾随空格。 | *   `ensure_newline_at_end(content)`: 确保文件末尾以新行结束。 | *   `ensure_document_start(content)`: 确保文件以 "---" 开头 (已注释)。 | *   `fix_comment_spacing(content)`: 修复注释中 `#` 后面缺少空格的问题。 | *   `fix_comment_spacing_before(content)`: 修复注释中 `#` 前面缺少空格的问题。 | *   `fix_comma_spacing(content)`: 修复逗号后面缺少空格的问题。 | *   `fix_bracket_spacing(content)`: 修复括号内多余空格的问题。 | *   `process_file(file_path)`: 处理单个 YAML 文件，应用上述格式化操作。 | *   `main(directory)`: 主函数，查找 YAML 文件并调用 `process_file` 进行处理。 |  | **重要功能点:** |  | *   递归查找 YAML 文件。 | *   将缩进转换为空格。 | *   删除尾随空格。 | *   确保文件末尾有换行符。 | *   修复注释空格问题。 | *   修复逗号空格问题。 | *   修复括号内空格问题。 | *   使用正则表达式进行文本替换。
│   ├── project.yml    這個 YAML 配置文件 `project.yml` 儲存了關於名為 "ZenlessZoneZero-OneDragon" 專案的配置資訊。 |  | *   **主要功能:**  定義專案的配置，包括專案名稱、Python 版本、GitHub 和 Gitee 倉庫連結、Git 分支、依賴檔案、螢幕解析度、pip 來源以及 QQ 連結。 | *   **核心元素:**  配置文件本身，使用 YAML 格式。 | *   **重要功能點:** |     *   儲存專案的基本資訊，如名稱和版本。 |     *   提供 GitHub 和 Gitee 倉庫的 HTTPS 和 SSH 連結。 |     *   指定 Git 分支。 |     *   定義依賴檔案路徑。 |     *   設定螢幕解析度。 |     *   指定 pip 來源。 |     *   提供 QQ 連結。
│   ├── yaml_fixer.py    這個 Python 腳本用於修復 YAML 文件的格式問題。 |  | *   **主要功能:** 修正 YAML 文件中的換行符和行內註釋的格式。 | *   **核心函數:** |     *   `fix_yaml_file(file_path)`: 讀取 YAML 文件，統一換行符為 LF，修復行內註釋前的空格，然後將修改後的內容寫回文件。 |     *   `process_directory(directory)`: 遞歸遍歷指定目錄下所有 .yml 文件，並調用 `fix_yaml_file` 進行處理。 | *   **重要功能點:** |     *   統一換行符為 LF。 |     *   確保行內註釋前至少有一個空格。 |     *   遞歸處理指定目錄下的所有 .yml 文件。 |     *   包含錯誤處理，打印處理失敗的文件路徑和錯誤信息。 |     *   腳本的入口點，指定要處理的根目錄。
│   └── key_sim/
│       └── 真拿命验收.sample.yml    這個 YAML 配置文件定義了一系列遊戲操作，用於模擬遊戲中的角色動作。 |  | *   **主要功能:** 定義了遊戲操作的順序，包括按鍵按下和鬆開，以及延遲時間。 | *   **核心元素:** `operations` 列表包含一系列操作。每個操作是一個字典，包含 `op_name` (操作名稱), `way` (按下或鬆開), `post_delay` (操作後的延遲時間), 和 `press` (按住時長，可選)。 | *   **重要功能點:** |     *   模擬了妮可的滑行和平A連招。 |     *   切換角色到下一個角色，並模擬了比利的移動。 |     *   模擬了角色移動、閃避和普通攻擊。 |     *   包含了按鍵的按下、鬆開和延遲時間，用於模擬遊戲中的時序。
├── service/
│   ├── zzz_base_scheduler.py    這個 Python 腳本文件 `zzz_base_scheduler.py` 實現了一個基於 `apscheduler` 的後台任務調度器。 |  | *   **主要功能:** 定期執行 `SynBattle` 類中的 `fetch_data` 方法。 | *   **核心類和函數:** |     *   `AsyncIOScheduler`:  `apscheduler` 提供的異步任務調度器。 |     *   `SynBattle`: 假設的類，其 `fetch_data` 方法是需要定期執行的任務。 |     *   `scheduler.add_job()`:  添加一個定時任務。 |     *   `scheduler.start()`:  啟動調度器。 |     *   `asyncio.get_event_loop().run_forever()`:  運行事件循環，使調度器能夠持續執行。 | *   **重要功能點:** |     *   使用 `apscheduler` 實現了定時任務調度。 |     *   每 60 秒調用 `SynBattle` 實例的 `fetch_data` 方法。 |     *   在接收到 `KeyboardInterrupt` 或 `SystemExit` 信号時，關閉調度器。
│   ├── zzz_data_model.py    這個 Python 文件 `zzz_data_model.py` 定義了使用 SQLAlchemy 的數據模型，用於與 MySQL 數據庫交互。 |  | **主要功能:** |  | *   定義數據庫連接和會話管理。 | *   定義 `BattleInfo` 數據模型，用於存儲戰鬥信息。 | *   提供用於查詢和操作 `BattleInfo` 表的函數。 |  | **核心類和函數:** |  | *   `Base`:  `declarative_base()` 創建的基類，用於聲明數據模型。 | *   `BattleInfo`:  繼承自 `Base` 的數據模型類，定義了 `battle_info` 表的結構，包含 `id`, `battle_name`, `battle_url`, `creation_name`, `creation_date` 等字段。 | *   `get_db_session()`:  獲取當前線程的數據庫會話。 | *   `get_battle_info()`:  獲取所有戰鬥信息，按創建日期降序排列。 | *   `get_battle_url(bid)`:  根據 ID 獲取戰鬥信息。 | *   `get_battle_by_name(battle_name)`: 根據戰鬥名稱獲取戰鬥信息。 | *   `clear_battle_info_table()`: 清空 `battle_info` 表。 |  | **重要功能點:** |  | *   使用 `scoped_session` 確保線程安全。 | *   包含數據庫連接配置 (`DATABASE_URI`)。 | *   提供 CRUD (Create, Read, Update, Delete) 操作的函數，用於管理 `BattleInfo` 數據。 | *   包含錯誤處理，在查詢失敗時回滾事務。
│   ├── zzz_save_battle_class.py    這個 Python 腳本 `zzz_save_battle_class.py` 提供了保存戰鬥資訊的功能，包括從 URL 或上傳檔案儲存 YAML 格式的戰鬥資料，並將其儲存到資料庫中。 |  | *   **主要功能:** 儲存戰鬥資料，支援從 URL 下載或上傳 YAML 檔案，並將檔案路徑和相關資訊儲存到資料庫。 | *   **核心函數:** |     *   `save_battle(battle_name: str, file, creation_name: str, creation_date: datetime)`: 核心函數，處理檔案下載、儲存、YAML 格式驗證，以及資料庫的更新或插入操作。 | *   **重要功能點:** |     *   支援從 URL 下載檔案。 |     *   驗證上傳檔案的格式是否為 YAML。 |     *   在儲存檔案前檢查並刪除舊檔案（如果存在）。 |     *   使用 `yaml.safe_load` 驗證 YAML 檔案的有效性。 |     *   使用 `BattleInfo` 資料模型與資料庫交互，更新或插入戰鬥資訊。 |     *   使用 `get_db_session()` 獲取資料庫 session。 |     *   使用 `requests` 庫下載檔案。 |     *   使用 `fastapi.HTTPException` 處理錯誤並返回 HTTP 錯誤碼。 |     *   使用 `session.commit()` 和 `session.rollback()` 進行資料庫事務管理。
│   ├── zzz_shared_battle_service.py    這個 Python 文件定義了一個 FastAPI 應用程序，用於處理與戰鬥相關的數據。 |  | *   **主要功能:** 提供 API 接口，用於查詢戰鬥信息、上傳戰鬥配置和下載戰鬥文件。 | *   **核心類和函數:** |     *   `FastAPI()`: 初始化 FastAPI 應用程序。 |     *   `read_battle_info()`: 處理 `/getBattleInfo` 路由的 POST 請求，返回所有戰鬥信息。 |     *   `upload_battle_info()`: 處理 `/uploadBattleInfo` 路由的 POST 請求，用於上傳戰鬥配置文件，並調用 `save_battle` 函數保存文件。 |     *   `download_battle_info()`: 處理 `/downloadBattleInfo/{bid}` 路由的 GET 請求，根據 ID 下載戰鬥配置文件。 |     *   `get_battle_info()`: 從 `zzz_data_model` 模塊導入，用於獲取戰鬥信息。 |     *   `get_battle_url()`: 從 `zzz_data_model` 模塊導入，用於獲取戰鬥文件的 URL。 |     *   `save_battle()`: 從 `zzz_save_battle_class` 模塊導入，用於保存上傳的戰鬥文件。 | *   **重要功能點:** |     *   提供 API 接口，用於獲取、上傳和下載戰鬥相關的數據。 |     *   使用 FastAPI 框架構建，支持文件上傳和下載。 |     *   使用 `zzz_data_model` 和 `zzz_save_battle_class` 模塊來處理數據和文件保存。 |     *   包含錯誤處理，例如文件不存在時返回 HTTP 錯誤。 |     *   使用 `uvicorn` 運行 FastAPI 應用程序。
│   └── zzz_syn_battle_service.py    這個 Python 文件 `zzz_syn_battle_service.py` 實現了從遠程服務同步戰鬥數據的功能。 |  | *   **主要功能:** 定期檢查遠程服務上的群文件，如果文件有更新或不存在，則下載文件並保存戰鬥數據。 | *   **核心類:** |     *   `SynBattle`: 負責與遠程服務交互，獲取文件列表和文件 URL，並觸發數據保存。 | *   **核心函數:** |     *   `file_name_tool(file_name)`: 移除文件名中的文件擴展名。 |     *   `fetch_data(self)`: 從遠程服務獲取群文件列表，檢查文件是否需要更新，並調用 `getFileUrl` 獲取文件 URL。 |     *   `getFileUrl(self, file_id, busid, file_name, uploader_name, creation_date)`: 根據文件 ID 和 busid 從遠程服務獲取文件 URL，並調用 `save_battle` 保存戰鬥數據。 | *   **重要功能點:** |     *   使用 `requests` 庫與遠程服務進行 HTTP 通信。 |     *   使用 `datetime` 處理文件修改時間。 |     *   使用 `save_battle` 保存戰鬥數據 (來自 `zzz_save_battle_class`)。 |     *   使用 `get_battle_by_name` 檢查戰鬥數據是否存在 (來自 `zzz_data_model`)。 |     *   使用 `clear_battle_info_table` 清空戰鬥信息表 (來自 `zzz_data_model`)。 |     *   包含錯誤處理和日誌記錄。
└── src/
    ├── one_dragon/
    │   ├── README.md    這個文件的摘要如下： |  | *   **主要功能:** 描述了 `.\src\one_dragon\README.md` 文件的主要功能，即為一條龍項目共用的代碼，並計劃將其轉化為框架。 | *   **核心類和函數:**  由於文件是 README.md，所以沒有代碼，因此沒有核心類和函數。 | *   **重要功能點:**  代碼共享和框架化。
    │   ├── base/
    │   │   ├── conditional_operation/
    │   │   │   ├── atomic_op.py    這個 Python 文件定義了一個名為 `AtomicOp` 的類，它表示一個原子操作。 |  | *   **主要功能:**  定義一個基礎的原子操作，執行後會觸發事件。 | *   **核心類:** `AtomicOp` | *   **重要功能點:** |     *   `__init__`: 初始化原子操作，包含操作名稱和是否為異步操作的標誌。 |     *   `execute`: 執行原子操作。 |     *   `dispose`: 銷毀操作，解除事件監聽。 |     *   `stop`: 停止操作。
    │   │   │   ├── conditional_operator.py    ## 代码摘要 |  | **主要功能:** |  | 该文件定义了 `ConditionalOperator` 类，用于管理和执行基于状态变化的条件操作。它通过监听状态变化，触发相应的场景处理逻辑，并支持并发执行。该类从 YAML 配置文件加载场景和操作定义，并提供初始化、运行、停止和状态更新等功能。 |  | **核心类和函数:** |  | *   **`ConditionalOperator`**:  核心类，负责条件操作的整体管理。 |     *   `__init__`: 初始化，加载配置。 |     *   `init`: 初始化，设置场景处理逻辑。 |     *   `dispose`: 销毁，停止运行并释放资源。 |     *   `start_running_async`: 异步启动运行。 |     *   `stop_running`: 停止运行。 |     *   `update_state`: 更新单个状态并触发场景。 |     *   `batch_update_states`: 批量更新状态并触发场景。 |     *   `_trigger_scene`: 触发特定场景的处理逻辑。 |     *   `_normal_scene_loop`: 处理无状态触发的场景循环。 |     *   `_on_task_done`:  处理任务完成后的回调。 |     *   `get_state_recorder`: 获取状态记录器。 |     *   `_update_state_recorder`: 更新状态记录。 |  | **重要功能点:** |  | *   **场景触发:**  根据状态变化触发不同的场景处理逻辑，支持基于状态的触发和周期性触发。 | *   **并发执行:** 使用 `ThreadPoolExecutor` 并发执行操作任务。 | *   **优先级管理:**  支持任务优先级，可以中断低优先级的任务。 | *   **状态管理:**  通过 `StateRecorder` 管理状态，并提供更新和清除状态的功能。 | *   **配置加载:**  从 YAML 文件加载场景和操作定义。 | *   **线程安全:** 使用 `Lock` 和 `AtomicInt` 来保证线程安全。 | *   **打断机制:**  支持在满足特定条件时打断正在运行的任务。 | *   **批量更新:** 支持批量更新状态，并根据优先级触发场景。
    │   │   │   ├── operation_def.py    這個 Python 文件定義了一個名為 `OperationDef` 的類，用於表示條件操作的定義。 |  | *   **主要功能:** 儲存條件操作的配置信息，包括操作名稱、數據、模板、延遲、按鍵屬性、等待時間、狀態信息和代理人。 | *   **核心類:** `OperationDef` | *   **重要功能點:** |     *   `__init__`: 構造函數，初始化 `OperationDef` 實例的各個屬性，包括操作名稱、數據、模板、延遲、按鍵方式、按鍵時間、重複次數、等待秒數、狀態名稱、狀態列表、狀態觸發時間、狀態觸發偏移量、狀態值、狀態值偏移量和代理人名稱。 |     *   定義了多個屬性，用於配置不同類型的條件操作，例如按鍵操作、等待操作和狀態設置操作。
    │   │   │   ├── operation_task.py    這個 Python 文件定義了 `OperationTask` 類，用於管理和執行一系列 `AtomicOp` 對象。 |  | **核心類和函數:** |  | *   `OperationTask`: 包含一個 `op_list` (AtomicOp 列表)，用於定義要執行的操作。 |     *   `__init__(self, op_list: List[AtomicOp])`: 初始化 OperationTask。 |     *   `run_async(self) -> Future`: 異步執行操作。 |     *   `_run(self) -> bool`: 執行 `op_list` 中的操作。 |     *   `stop(self) -> bool`: 停止正在運行的操作。 |     *   `add_expr(self, expr: str, debug_name: Optional[str] = None) -> None`: 添加表達式及其調試名稱。 |     *   `set_priority(self, priority: Optional[int]) -> None`: 設置任務的優先級。 |     *   `set_trigger(self, trigger: Optional[str]) -> None`: 設置觸發器。 |     *   `add_interrupt_states(self, interrupt_states: Set[str]) -> None`: 添加可中斷的狀態。 |     *   `expr_display`: 顯示表達式。 |     *   `priority_display`: 顯示優先級。 |     *   `trigger_display`: 顯示觸發器。 |     *   `debug_name_display`: 顯示調試名稱。 |  | **重要功能點:** |  | *   **異步執行:** 使用 `ThreadPoolExecutor` 異步執行 `AtomicOp`。 | *   **停止機制:** 提供了 `stop()` 方法來停止正在運行的操作，並處理中斷。 | *   **優先級和中斷:** 支援設置任務的優先級和可中斷狀態。 | *   **觸發器:** 支援設置觸發器，用於觸發特定場景。 | *   **表達式和調試名稱:** 提供了添加表達式和調試名稱的功能，用於界面顯示和調試。
    │   │   │   ├── operation_template.py    這個 Python 文件定義了一個名為 `OperationTemplate` 的類，它繼承自 `YamlConfig`。 |  | *   **主要功能:**  `OperationTemplate` 類用於從 YAML 配置文件中加載配置，並初始化配置。 | *   **核心類:** `OperationTemplate` | *   **重要功能點:** |     *   `__init__` 方法：初始化 `OperationTemplate` 實例，它使用 `YamlConfig` 類來加載 YAML 配置文件。它接受子目錄 (`sub_dir`)、模板名稱 (`template_name`) 和實例索引 (`instance_idx`) 作為參數。它還設置了 `sample=True` 和 `copy_from_sample=False` 參數。
    │   │   │   ├── scene_handler.py    這個 Python 文件 `scene_handler.py` 實現了 `SceneHandler` 類，用於處理基於條件的場景操作。 |  | *   **主要功能:**  根據觸發時間和狀態處理程序，獲取符合條件的場景操作指令，管理狀態處理程序，並提供銷毀方法。 | *   **核心類和函數:** |     *   `SceneHandler`:  主類，管理場景操作。 |         *   `__init__(self, interval_seconds: float, state_handlers: List[StateHandler], priority: Optional[int] = None)`: 初始化 `SceneHandler`，包含間隔時間、狀態處理程序列表和優先級。 |         *   `get_operations(self, trigger_time: float) -> Optional[OperationTask]`: 根據觸發時間和優先級，獲取符合條件的操作任務。 |         *   `get_usage_states(self) -> set[str]`:  獲取所有使用的狀態。 |         *   `dispose(self) -> None`:  銷毀所有狀態處理程序。 | *   **重要功能點:** |     *   使用 `StateHandler` 列表來處理不同的狀態條件。 |     *   支持操作任務的優先級，用於控制任務的執行順序和中斷。 |     *   提供獲取使用狀態和銷毀資源的方法。
    │   │   │   ├── state_cal_tree.py    **摘要:** |  | 该 Python 文件定义了一个状态计算树，用于根据状态记录器和时间/值范围来评估复杂的条件表达式。 |  | **核心类和函数:** |  | *   **`StateCalNodeType` 和 `StateCalOpType` (Enum):** 定义了节点类型（操作符、状态、真）和操作符类型（AND、OR、NOT）。 | *   **`StateCalNode`:**  表示状态计算树中的一个节点，包含节点类型、操作符类型、子节点、状态记录器、时间/值范围等属性。 |     *   `in_time_range(now: float) -> bool`:  根据当前时间判断节点是否满足条件。 |     *   `get_usage_states() -> set[str]`: 获取树中使用的所有状态名称。 |     *   `dispose() -> None`: 销毁节点及其子节点。 | *   **`construct_state_cal_tree(expr_str: str, state_getter: Callable[[str], StateRecorder], debugname: Optional[str] = None) -> StateCalNode`:**  核心函数，根据给定的表达式字符串构建状态计算树。 |  | **重要功能点:** |  | *   **状态计算树的构建:**  `construct_state_cal_tree` 函数将字符串表达式解析成树状结构，支持 AND, OR, NOT 逻辑运算，以及时间/值范围的判断。 | *   **条件评估:** `in_time_range` 方法递归地评估树中的节点，根据状态记录器、时间范围和值范围来判断条件是否为真。 | *   **状态依赖分析:** `get_usage_states` 方法用于获取表达式中使用的所有状态记录器的名称。 | *   **资源释放:** `dispose` 方法用于释放节点及其子节点所占用的资源。 | *   **支持时间范围和值范围的判断:**  状态节点可以配置时间范围和值范围，用于更精确的条件判断。
    │   │   │   ├── state_event.py    這個 Python 文件定義了一個名為 `StateEvent` 的類，用於表示狀態事件。 |  | *   **主要功能:** 儲存和表示在特定時間發生的事件，這些事件可能與數值相關。 | *   **核心類:** `StateEvent` | *   **重要功能點:** |     *   `__init__`: 初始化 `StateEvent` 實例，包含觸發時間 (`trigger_time`) 以及可選的數值 (`value`) 和數值增加量 (`value_add`)。 |     *   `__str__`:  提供 `StateEvent` 實例的字符串表示，方便調試和顯示。
    │   │   │   ├── state_handler.py    這個 Python 文件定義了一個 `StateHandler` 類，用於處理基於狀態的條件操作。 |  | *   **主要功能:** 根據時間和狀態判斷，觸發相應的操作。它使用狀態計算樹來評估狀態，並執行相關的原子操作。 | *   **核心類和函數:** |     *   `StateHandler`: 核心類，用於管理狀態判斷和操作。 |         *   `__init__`: 初始化 `StateHandler`，包含狀態表達式、狀態計算樹、子處理器、操作列表、中斷狀態和調試名稱。 |         *   `get_operations`: 根據觸發時間獲取符合條件的操作任務。 |         *   `get_usage_states`: 獲取 `StateHandler` 使用的所有狀態。 |         *   `dispose`: 釋放資源。 | *   **重要功能點:** |     *   使用 `StateCalNode` 進行狀態判斷。 |     *   支持嵌套的 `StateHandler` (通過 `sub_handlers`)。 |     *   `OperationTask` 用於封裝要執行的操作。 |     *   `interrupt_states` 允許中斷其他狀態。 |     *   包含調試名稱 (`debug_name`)，用於更好地追蹤。
    │   │   │   ├── state_handler_template.py    這個 Python 文件定義了一個名為 `StateHandlerTemplate` 的類，它繼承自 `YamlConfig`。 |  | *   **主要功能:**  用於處理基於 YAML 配置的狀態，並從 YAML 文件加載配置。 | *   **核心類:** `StateHandlerTemplate` | *   **重要功能點:** |     *   `__init__`: 類的構造函數，初始化 `YamlConfig`，並設置模塊名稱、子目錄和實例索引。它使用 `sample=True` 和 `copy_from_sample=False` 參數來配置 `YamlConfig` 的行為。
    │   │   │   ├── state_recorder.py    這個 Python 文件定義了用於記錄和管理狀態的類。 |  | *   **主要功能:** 記錄狀態的觸發時間和值，並支持狀態的清除和更新。 | *   **核心類和函數:** |     *   `StateRecord`:  表示單個狀態記錄，包含狀態名稱、觸發時間、值、是否清除等信息。 |     *   `StateRecorder`:  用於記錄和管理特定狀態的類。 |         *   `update_state_record(self, record: StateRecord)`:  更新狀態記錄，包括觸發時間和值的更新。 |         *   `clear_state_record(self)`:  清空狀態記錄。 |         *   `dispose(self)`:  銷毀狀態記錄器，釋放資源。 | *   **重要功能點:** |     *   支持狀態的觸發時間和值的記錄。 |     *   支持狀態的清除，用於處理互斥狀態。 |     *   `trigger_time_add` 屬性允許修改觸發時間。 |     *   `mutex_list` 屬性用於定義互斥狀態。
    │   │   │   └── utils.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于构建和管理条件操作的工具函数，主要用于处理场景、状态和操作的定义、加载和执行。它支持基于模板的配置，允许嵌套和复用配置。 |  | **核心类和函数:** |  | *   `construct_scene_handler(...)`:  构建一个 `SceneHandler` 实例，用于管理场景的执行。 | *   `construct_state_handler(...)`: 构建一个 `StateHandler` 实例，用于处理特定状态下的条件和操作。 | *   `_get_state_handlers(...)`: 递归地获取 `StateHandler` 列表，支持模板嵌套。 | *   `_get_state_handlers_by_template(...)`:  根据模板名称获取 `StateHandler` 列表。 | *   `get_ops_from_data(...)`:  从配置数据中获取 `AtomicOp` 列表，支持模板嵌套。 | *   `get_ops_by_template(...)`:  根据模板名称获取 `AtomicOp` 列表。 |  | **重要功能点:** |  | *   **场景和状态处理:**  构建 `SceneHandler` 和 `StateHandler` 用于管理场景和状态逻辑。 | *   **模板支持:**  通过 `_get_state_handlers_by_template` 和 `get_ops_by_template` 支持状态和操作的模板化配置，实现配置的复用和嵌套。 | *   **循环引用检测:**  通过 `usage_states_handler_templates` 和 `usage_operation_templates` 集合，防止模板的循环引用。 | *   **状态表达式解析:** 使用 `construct_state_cal_tree` 解析状态表达式。 | *   **操作获取:**  使用 `op_getter` 和 `operation_template_getter` 获取 `AtomicOp` 实例。 | *   **中断状态:** 支持 `interrupt_states` 用于中断状态。 | *   **Debug Name:** 支持在状态处理器中添加 `debug_name` 用于调试。
    │   │   ├── config/
    │   │   │   ├── basic_game_config.py    **摘要:** |  | 该文件定义了游戏的基础配置类 `BasicGameConfig`，用于管理和存储游戏相关的配置信息，如输入方式、屏幕尺寸、全屏模式、HDR、启动参数等。它使用 `YamlConfig` 类来处理配置文件的读写，并定义了多个枚举类型来表示配置选项。 |  | **核心类和函数:** |  | *   **`BasicGameConfig(YamlConfig)`**: 继承自 `YamlConfig`，负责游戏的配置管理。 |     *   `__init__(self, instance_idx: int)`: 初始化函数，调用父类的初始化方法。 |     *   多个 `@property` 装饰的 getter 和 setter 方法: 用于获取和设置各种游戏配置项，如 `type_input_way`, `screen_size`, `full_screen` 等。 | *   **`TypeInputWay(Enum)`**: 定义了输入方式的枚举，包括 `INPUT` 和 `CLIPBOARD`。 | *   **`ScreenSizeEnum(Enum)`**: 定义了屏幕尺寸的枚举，包括多种分辨率。 | *   **`FullScreenEnum(Enum)`**: 定义了全屏模式的枚举，包括 `WINDOWED` 和 `FULL_SCREEN`。 | *   **`MonitorEnum(Enum)`**: 定义了显示器选择的枚举。 | *   **`YamlConfigAdapter`**: 用于适配 `YamlConfig` 的配置项。 |  | **重要功能点:** |  | *   通过枚举定义了游戏配置的选项，增强了代码的可读性和可维护性。 | *   使用 `YamlConfig` 类来持久化存储配置信息。 | *   提供了对各种游戏配置项的获取和设置接口。 | *   `type_input_way_adapter` 属性提供了配置项的适配器。
    │   │   │   ├── config_item.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件定義了用於配置選項的 `ConfigItem` 類，以及用於從枚舉中獲取配置項的輔助函數。 |  | **核心類和函數：** |  | *   `ConfigItem`:  表示一個配置選項，包含顯示文本 (label)、真實值 (value) 和描述 (desc)。 | *   `get_config_item_from_enum(enum: Iterable[Enum], value: Any) -> Optional[ConfigItem]`:  從給定的枚舉中查找具有特定值的 `ConfigItem`。 |  | **重要功能點：** |  | *   `ConfigItem` 類使用 `gt` 函數 (來自 `one_dragon.utils.i18_utils`) 實現了文本的國際化 (i18n)。 | *   `get_config_item_from_enum` 函數用於從枚舉中高效地檢索配置項，這在處理配置選項時非常有用。
    │   │   │   ├── custom_config.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | *   定義了自定義配置，用於存儲和管理應用程序的用户偏好設置，例如主題和主頁背景。 |  | **核心類和函數：** |  | *   `ThemeEnum`：一個枚舉類，定義了可用的主題選項（淺色、深色、自動）。 | *   `CustomConfig`：繼承自 `YamlConfig`，負責加載、保存和管理自定義配置。 |     *   `__init__(self)`：初始化 `CustomConfig`，指定配置模塊名稱為 'custom'。 |     *   `theme` (property)：獲取和設置應用程序的主題。 |     *   `banner` (property)：獲取和設置是否啟用自定義主頁背景。 |  | **重要功能點：** |  | *   使用 `YamlConfig` 讀取和寫入 YAML 格式的配置文件。 | *   使用枚舉 `ThemeEnum` 定義了主題選項，提供了類型安全和可讀性。 | *   提供了 `theme` 和 `banner` 屬性，方便訪問和修改配置項。 | *   `theme` 屬性默認值為 `ThemeEnum.AUTO`。 | *   `banner` 屬性默認值為 `False`。
    │   │   │   ├── game_account_config.py    這個 Python 文件定義了遊戲帳戶配置，使用 YAML 格式儲存和管理遊戲帳戶相關的設定。 |  | *   **核心類和函數:** |     *   `GamePlatformEnum`, `GameLanguageEnum`, `GameRegionEnum`: 使用 `Enum` 定義遊戲平台、語言和地區的枚舉。 |     *   `GameAccountConfig`: 繼承自 `YamlConfig`，用於管理遊戲帳戶配置，包括平台、地區、路徑、帳戶、密碼和語言等屬性，並提供了 getter 和 setter 方法。 |     *   `__init__`: 初始化 `GameAccountConfig`，設定預設值。 |     *   `platform`, `game_region`, `game_path`, `game_language`, `account`, `password`: 屬性，提供讀取和更新配置的能力。 |     *   `game_refresh_hour_offset`: 根據遊戲地區返回遊戲刷新時間的小時偏移量。 |  | *   **重要功能點:** |     *   使用 YAML 儲存配置，方便管理和修改。 |     *   使用枚舉定義遊戲平台、語言和地區，提高程式碼可讀性和可維護性。 |     *   提供 getter 和 setter 方法，方便讀取和更新配置。 |     *   根據遊戲地區計算刷新時間偏移量。
    │   │   │   ├── json_config.py    這個 Python 文件 `json_config.py` 定義了一個 `JsonConfig` 類，用於管理基於 JSON 的配置文件。 |  | **主要功能:** |  | *   加載、保存和管理 JSON 配置文件。 | *   支持多個實例配置，每個實例都有自己的配置。 | *   支持使用 sample 文件作為模板，如果配置文件不存在則複製 sample 文件。 | *   支持 mock 模式，在測試時不讀取或保存文件。 |  | **核心類和函數:** |  | *   `JsonConfig`: 繼承自 `JsonOperator`，負責配置文件的管理。 |     *   `__init__(self, module_name, instance_idx, sub_dir, sample, mock)`: 初始化 `JsonConfig` 實例，設置模塊名稱、實例索引、子目錄、是否使用 sample 文件和是否為 mock 模式。 |     *   `_get_json_file_path(self, sample)`: 根據配置生成 JSON 文件的路徑，如果 sample 文件存在且配置文件不存在，則複製 sample 文件。 |  | **重要功能點:** |  | *   支持實例配置，通過 `instance_idx` 區分不同的配置。 | *   使用 `sample` 文件作為模板，方便配置文件的初始化。 | *   `mock` 模式允許在不實際讀寫文件的情況下進行測試。 | *   使用 `os_utils.get_path_under_work_dir` 獲取配置文件路徑，確保路徑的正確性。
    │   │   │   ├── json_operator.py    這個 Python 文件 `json_operator.py` 實現了一個用於讀取、寫入和操作 JSON 配置文件的工具類。 |  | **主要功能:** |  | *   讀取 JSON 文件 | *   將數據保存到 JSON 文件 | *   獲取和更新 JSON 文件中的數據 | *   刪除 JSON 配置文件 |  | **核心類和函數:** |  | *   `JsonOperator`:  主類，用於操作 JSON 文件。 |     *   `__init__(self, file_path: Optional[str] = None)`: 初始化，讀取文件內容。 |     *   `__read_from_file(self) -> None`:  從 JSON 文件中讀取數據。 |     *   `save(self)`:  將 `self.data` 寫入 JSON 文件。 |     *   `save_diy(self, text: str)`: 以自定義文本格式保存數據。 |     *   `get(self, prop: str, value=None)`:  獲取指定屬性的值。 |     *   `update(self, key: str, value, save: bool = True)`:  更新指定鍵的值，並可選擇是否保存。 |     *   `delete(self)`: 刪除配置文件。 |  | **重要功能點:** |  | *   支持讀取和寫入 JSON 格式的配置文件。 | *   提供 `get` 和 `update` 方法方便訪問和修改配置數據。 | *   `save_diy` 方法允許以自定義文本格式保存數據。 | *   包含錯誤處理，例如文件不存在或讀取失敗時的處理。 | *   `file_path` 為 `None` 時，模擬操作，用於測試。
    │   │   │   ├── one_dragon_app_config.py    這個 Python 文件的主要功能是管理 OneDragon 應用程序的配置，這些配置存儲在 YAML 文件中。 |  | 核心類： |  | *   `OneDragonAppConfig`：繼承自 `YamlConfig`，用於加載和管理 OneDragon 應用程序的配置。 |  | 重要功能點： |  | *   `app_order` 屬性：獲取和設置應用程序的運行順序（列表）。 | *   `move_up_app` 方法：將指定應用程序的運行順序提前一位。 | *   `app_run_list` 屬性：獲取和設置應用程序的運行列表。 | *   `set_app_run` 方法：根據 `to_run` 標誌，將應用程序 ID 添加或移除到運行列表中。
    │   │   │   ├── one_dragon_config.py    這個 Python 文件定義了 `OneDragonConfig` 類，用於管理與 "一条龙" 應用相關的配置，特別是遊戲實例的設置。 |  | **核心類和函數:** |  | *   `OneDragonConfig`: 繼承自 `YamlConfig`，負責加載、保存和管理配置數據。 |     *   `__init__`: 初始化配置，加載實例列表。 |     *   `_init_instance_list`: 從配置中初始化 `instance_list` 屬性。 |     *   `create_new_instance`: 創建新的遊戲實例。 |     *   `update_instance`: 更新現有遊戲實例的配置。 |     *   `active_instance`: 激活指定的遊戲實例。 |     *   `delete_instance`: 刪除遊戲實例。 |     *   `dict_instance_list`: 屬性，用於獲取和設置實例列表的字典表示。 |     *   `current_active_instance`: 屬性，獲取當前激活的遊戲實例。 |     *   `instance_list_in_od`: 屬性，獲取需要在 "一条龙" 中運行的實例列表。 |     *   `instance_run`: 屬性，獲取和設置實例運行模式 (全部或當前)。 |     *   `after_done`: 屬性，獲取和設置完成操作 (無，關閉遊戲，關機)。 | *   `OneDragonInstance`: 表示一個遊戲實例的數據結構，包含索引、名稱、激活狀態等。 | *   `RunInOneDragonApp`, `AfterDoneOpEnum`, `InstanceRun`: 枚舉類型，定義了配置中的選項。 |  | **重要功能點:** |  | *   管理遊戲實例的創建、更新、激活和刪除。 | *   從 YAML 文件加載和保存配置。 | *   確定哪些實例需要在 "一条龙" 應用中運行。 | *   配置完成操作 (例如，遊戲結束後的操作)。 | *   支持多個遊戲實例的管理。
    │   │   │   ├── yaml_config.py    這個 Python 文件定義了一個 `YamlConfig` 類，用於管理和讀取 YAML 配置文件。 |  | **核心類和函數：** |  | *   **`YamlConfig`**: 繼承自 `YamlOperator`，負責加載、保存和管理 YAML 配置文件。 |     *   `__init__`: 初始化 `YamlConfig` 實例，包括模塊名稱、實例索引、子目錄、是否為 sample 文件、是否從 sample 複製等。 |     *   `_get_yaml_file_path`: 根據配置參數生成 YAML 文件的路徑，如果配置文件不存在且存在 sample 文件，則複製 sample 文件。 |     *   `is_sample`: 判斷當前文件是否為 sample 文件。 |     *   `get_prop_adapter`: 獲取一個配置適配器，用於讀寫 YAML 配置文件的特定屬性。 |  | **重要功能點：** |  | *   支持多個實例的配置，通過 `instance_idx` 區分。 | *   支持子目錄配置，通過 `sub_dir` 指定。 | *   支持 mock 模式，用於測試，不讀取和保存文件。 | *   如果配置文件不存在，可以從 sample 文件複製。 | *   提供 `get_prop_adapter` 方法，用於方便地讀寫配置項。
    │   │   │   └── yaml_operator.py    這個 Python 文件 `yaml_operator.py` 提供了用於讀取、寫入和管理 YAML 配置文件的功能。 |  | **主要功能:** |  | *   讀取 YAML 文件並將其緩存以提高性能。 | *   提供讀取、更新、保存和刪除 YAML 配置文件的接口。 |  | **核心類和函數:** |  | *   `read_cache_or_load(file_path: str)`: 讀取 YAML 文件，使用緩存機制避免重複讀取，並在文件修改時更新緩存。 | *   `YamlOperator`: 核心類，用於操作 YAML 文件。 |     *   `__init__(self, file_path: Optional[str] = None)`: 初始化，接收 YAML 文件路徑。 |     *   `__read_from_file(self) -> None`: 從 YAML 文件中讀取數據。 |     *   `save(self)`: 將數據保存到 YAML 文件。 |     *   `save_diy(self, text: str)`: 以自定義文本格式保存數據。 |     *   `get(self, prop: str, value=None)`: 獲取 YAML 文件中指定屬性的值。 |     *   `update(self, key: str, value, save: bool = True)`: 更新 YAML 文件中的屬性。 |     *   `delete(self)`: 刪除 YAML 配置文件。 |     *   `is_file_exists(self) -> bool`: 檢查配置文件是否存在。 |  | **重要功能點:** |  | *   緩存機制 (`cached_yaml_data`) 提高讀取效率。 | *   提供 `save_diy` 函數，允許以自定義文本格式保存 YAML 文件。 | *   提供 `update` 函數，更新配置並可選擇是否立即保存。 | *   包含錯誤處理，例如文件讀取失敗時使用默認值。 | *   提供 `delete` 函數，用於刪除配置文件。
    │   │   ├── controller/
    │   │   │   ├── controller_base.py    **摘要:** |  | 该文件定义了 `ControllerBase` 类，作为游戏控制器的基类，提供了截图、点击、滚动、拖拽、输入文本等基本操作的接口，并管理截图的历史记录。 |  | **核心类和函数:** |  | *   `ScreenshotWithTime`: 用于存储截图及其创建时间。 | *   `ControllerBase`: |     *   `__init__`: 初始化控制器，设置截图的存活时间和最大截图数量。 |     *   `screenshot`: 截图并保存到历史记录，同时处理历史记录的清理。 |     *   `click`: 点击指定位置。 |     *   `scroll`: 滚动操作。 |     *   `drag_to`: 拖拽操作。 |     *   `input_str`: 输入文本。 |     *   `close_game`: 关闭游戏。 |     *   `get_screenshot`: 获取截图，由子类实现。 |     *   `fill_uid_black`: 遮挡UID，由子类实现。 |     *   `before_screenshot`: 截图前的操作，由子类实现。 |     *   `init_before_context_run`: 运行前初始化。 |     *   `is_game_window_ready`: 游戏窗口是否准备好。 |     *   `delete_all_input`: 删除所有输入文本。 |  | **重要功能点:** |  | *   截图管理：维护截图历史记录，并根据存活时间和最大数量进行清理。 | *   基本游戏操作：提供点击、滚动、拖拽、输入文本等基本操作的接口。 | *   扩展性：通过虚方法 `get_screenshot`, `fill_uid_black`, `before_screenshot` 允许子类实现特定平台的截图和处理逻辑。
    │   │   │   ├── pc_clipboard.py    這個 Python 腳本 `pc_clipboard.py` 提供了與 Windows 剪貼板交互的功能。 |  | *   **主要功能:** 提供了複製文本到剪貼板、從剪貼板粘貼文本以及清空剪貼板的功能。 | *   **核心類和函數:** |     *   `PcClipboard` 類: 封裝了剪貼板操作的靜態方法。 |         *   `copy_and_paste(text: str)`: 將文本複製到剪貼板，然後粘貼出來。 |         *   `empty_clipboard()`: 清空剪貼板。 |         *   `copy_string(text: str)`: 將文本複製到剪貼板。 |         *   `paste_text()`: 從剪貼板粘貼文本，並使用 `pynput` 模擬 Ctrl+V 組合鍵。 | *   **重要功能點:** |     *   使用 `win32clipboard` 庫與 Windows 剪貼板交互。 |     *   使用 `pynput` 庫模擬 Ctrl+V 鍵盤輸入進行粘貼操作。 |     *   包含日誌記錄，用於記錄剪貼板操作和文本的脫敏處理。 |     *   在剪貼板操作中使用了 `try...finally` 塊來確保剪貼板被正確關閉。
    │   │   │   ├── pc_controller_base.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 文件定义了一个 `PcControllerBase` 类，用于控制 PC 游戏，包括窗口管理、鼠标键盘操作、截图、手柄支持等。它提供了基础的 PC 游戏控制功能，如点击、截图、滚动、拖拽、输入文本等。 |  | **核心类和函数:** |  | *   **`PcControllerBase`**:  核心类，继承自 `ControllerBase`，负责 PC 游戏控制。 |     *   `__init__`: 初始化，设置游戏窗口信息、键盘鼠标控制器、手柄控制器等。 |     *   `init_before_context_run`: 初始化，禁用 Fail-Safe，初始化 mss 截图库，激活游戏窗口。 |     *   `active_window`: 激活游戏窗口。 |     *   `enable_xbox`, `enable_ds4`, `enable_keyboard`: 启用不同的控制器（Xbox, DS4, 键盘鼠标）。 |     *   `is_game_window_ready`: 检查游戏窗口是否准备就绪。 |     *   `click`:  模拟鼠标点击。 |     *   `get_screenshot`:  获取游戏截图，支持缩放。 |     *   `scroll`:  模拟鼠标滚轮滚动。 |     *   `drag_to`:  模拟鼠标拖拽。 |     *   `close_game`: 关闭游戏窗口。 |     *   `input_str`:  输入文本。 |     *   `mouse_move`:  移动鼠标到指定位置。 | *   **`win_click`**:  模拟鼠标点击。 | *   **`win_scroll`**:  模拟鼠标滚轮滚动。 | *   **`get_mouse_sensitivity`**:  获取鼠标灵敏度。 | *   **`drag_mouse`**:  模拟鼠标拖拽。 | *   **`get_current_mouse_pos`**:  获取当前鼠标位置。 |  | **重要功能点:** |  | *   **游戏窗口管理:**  使用 `PcGameWindow` 类管理游戏窗口，包括激活窗口、获取窗口信息等。 | *   **多种控制器支持:** 支持键盘鼠标、Xbox 手柄和 DS4 手柄，通过切换 `btn_controller` 实现。 | *   **截图:**  使用 `mss` 库进行截图，并支持根据游戏窗口
    │   │   │   ├── pc_game_window.py    **文件摘要** |  | *   **主要功能:**  该文件定义了一个 `PcGameWindow` 类，用于管理和操作 PC 游戏窗口，包括获取窗口信息、激活窗口、获取窗口位置和缩放比例，以及坐标转换。 | *   **核心类和函数:** |     *   `PcGameWindow`:  主类，用于封装游戏窗口的操作。 |         *   `__init__(self, win_title: str, standard_width: int = 1920, standard_height: int = 1080)`: 初始化窗口，获取窗口标题、标准分辨率等信息。 |         *   `init_win(self) -> None`: 初始化窗口，通过窗口标题查找窗口句柄。 |         *   `get_win(self) -> Optional[Win32Window]`: 获取窗口对象。 |         *   `get_hwnd(self) -> int`: 获取窗口句柄。 |         *   `is_win_valid(self) -> bool`: 检查窗口是否有效。 |         *   `is_win_active(self) -> bool`: 检查窗口是否处于激活状态。 |         *   `is_win_scale(self) -> bool`: 检查窗口是否被缩放。 |         *   `active(self) -> bool`: 激活游戏窗口。 |         *   `win_rect(self) -> Optional[Rect]`: 获取游戏窗口在屏幕上的位置和大小。 |         *   `get_scaled_game_pos(self, game_pos: Point) -> Optional[Point]`: 将标准分辨率下的游戏坐标转换为当前窗口的坐标。 |         *   `is_valid_game_pos(self, s_pos: Point, rect: Rect = None) -> bool`: 检查游戏坐标是否在游戏窗口内。 |         *   `game2win_pos(self, game_pos: Point) -> Optional[Point]`: 将游戏坐标转换为屏幕坐标。 | *   **重要功能点:** |     *   窗口初始化和获取。 |     *   窗口激活和状态检查（是否有效、是否激活、是否缩放）。 |     *   坐标转换，包括缩放和屏幕坐标转换，用于处理不同分辨率下的游戏。
    │   │   │   └── pc_button/
    │   │   │       ├── backend_keyboard_mouse_contoller.py    该文件实现了通过 Windows API 模拟键盘输入的功能，主要用于控制 PC 上的应用程序。 |  | *   **主要功能:** 模拟键盘按键和文本输入，查找目标窗口，并将其线程附加到当前线程。 | *   **核心函数:** |     *   `send_key(hwnd, key)`: 模拟按下和释放指定键。 |     *   `send_text(hwnd, text)`: 模拟输入文本。 |     *   `find_window(class_name, window_name)`: 查找指定窗口。 |     *   `attach_to_window_thread(hwnd)`: 将当前线程附加到目标窗口的线程。 |     *   `detach_from_window_thread(current_id, target_id)`: 解除线程附加。 | *   **重要功能点:** |     *   使用 `ctypes` 库调用 Windows API 函数。 |     *   定义了键盘映射 `VK_CODE`，将字符映射到虚拟键码。 |     *   `main()` 函数演示了如何查找窗口、附加线程、模拟按键输入和解除线程附加。 |     *   通过 `WM_KEYDOWN` 和 `WM_KEYUP` 消息模拟键盘事件。
    │   │   │       ├── ds4_button_controller.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个用于模拟 DualShock 4 (DS4) 手柄按键操作的控制器类。它使用 `vgamepad` 库来模拟手柄输入，并提供按键触发、按键按下、按键释放等功能。 |  | **核心类和函数:** |  | *   **`Ds4ButtonEnum(Enum)`:**  定义了 DS4 手柄的按键枚举，将按键名称映射到配置项。 | *   **`Ds4ButtonController(PcButtonController)`:**  继承自 `PcButtonController`，是 DS4 手柄控制器的核心类。 |     *   `__init__()`: 初始化控制器，创建 `vgamepad` 实例，并定义按键处理函数列表。 |     *   `tap(self, key: str)`: 触发单个按键。 |     *   `tap_a`, `tap_b`, `tap_x`, `tap_y`, `tap_lt`, `tap_rt`, `tap_lb`, `tap_rb`, `tap_l_stick_w`, `tap_l_stick_s`, `tap_l_stick_a`, `tap_l_stick_d`, `tap_l_thumb`, `tap_r_thumb`:  分别对应触发不同的 DS4 手柄按键。 |     *   `press(self, key: str, press_time: Optional[float] = None)`:  模拟按键按下并保持一段时间。 |     *   `release(self, key: str)`: 释放按键。 |     *   `release_a`, `release_b`, `release_x`, `release_y`, `release_lt`, `release_rt`, `release_lb`, `release_rb`, `release_l_stick`, `release_l_thumb`, `release_r_thumb`: 分别对应释放不同的 DS4 手柄按键。 |     *   `_press_button(self, btn, press: bool = False, press_time: Optional[float] = None)`: 模拟按下或释放一个按钮。 |     *   `_release_btn(self, btn)`: 释放一个按钮。 |     *   `reset(self)`: 重置手柄状态。
    │   │   │       ├── keyboard_mouse_controller.py    這個 Python 文件定義了一個 `KeyboardMouseController` 類，它繼承自 `PcButtonController`，用於模擬鍵盤和鼠標操作。 |  | *   **主要功能:** 模擬鍵盤按鍵和鼠標按鈕的點擊、按下和釋放操作。 | *   **核心類和函數:** |     *   `KeyboardMouseController`: 負責控制鍵盤和鼠標操作的類。 |         *   `__init__`: 初始化鍵盤和鼠標控制器。 |         *   `tap(self, key: str)`: 模擬單次按鍵或鼠標點擊。 |         *   `press(self, key: str, press_time: Optional[float] = None)`: 模擬按下按鍵或鼠標按鈕，可選擇持續時間。 |         *   `release(self, key: str)`: 模擬釋放按鍵或鼠標按鈕。 | *   **重要功能點:** |     *   使用 `pynput` 庫來控制鍵盤和鼠標。 |     *   使用 `pc_button_utils` 模塊來處理按鍵和鼠標按鈕的轉換。 |     *   `press` 方法支持按鍵持續時間。 |     *   包含一個 `if __name__ == '__main__':` 塊，用於測試 `press` 和 `release` 方法。
    │   │   │       ├── pc_button_controller.py    這個 Python 文件定義了一個名為 `PcButtonController` 的類，用於模擬 PC 上的按鍵操作。 |  | *   **主要功能:** 提供按鍵模擬功能，包括單擊、按下、釋放按鍵，以及設置按鍵持續時間。 | *   **核心類:** `PcButtonController` | *   **重要功能點:** |     *   `tap(key: str)`: 模擬單擊按鍵。 |     *   `press(key: str, press_time: Optional[float] = None)`: 模擬按下按鍵，可指定按鍵持續時間。 |     *   `release(key: str)`: 模擬釋放按鍵。 |     *   `reset()`: 重置控制器狀態。 |     *   `set_key_press_time(key_press_time: float)`: 設置按鍵的預設持續時間。 |     *   `key_press_time`: 屬性，表示按鍵的預設持續時間，默認值為 0.02。
    │   │   │       ├── pc_button_listener.py    這個 Python 文件定義了一個 `PcButtonListener` 類，用於監聽 PC 上的鍵盤、鼠標和遊戲手柄按鈕事件，並在按鈕被 "點擊" 時觸發回調函數。 |  | *   **主要功能:** 監聽鍵盤、鼠標和遊戲手柄按鈕事件，並在按鈕被按下時調用指定的回調函數。 | *   **核心類:** `PcButtonListener` | *   **重要功能點:** |     *   `__init__`: 初始化監聽器，接收一個 `on_button_tap` 回調函數，以及標誌位用於控制是否監聽鍵盤、鼠標和遊戲手柄。 |     *   `_on_keyboard_press`: 處理鍵盤按鍵按下事件，提取按鍵名稱，並調用回調函數。 |     *   `_on_mouse_click`: 處理鼠標點擊事件，提取鼠標按鈕名稱，並調用回調函數。 |     *   `_call_button_tap_callback`: 使用線程池提交回調函數，並處理回調結果。 |     *   `start`: 啟動鍵盤和鼠標監聽器。 |     *   `stop`: 停止鍵盤和鼠標監聽器。 |     *   使用 `pynput` 庫來監聽鍵盤和鼠標事件。 |     *   使用線程池來執行回調函數，避免阻塞主線程。
    │   │   │       ├── pc_button_utils.py    這個 Python 文件 `pc_button_utils.py` 提供了用於處理 PC 按鈕（包括鼠標和鍵盤）的工具函數。 |  | **主要功能:** |  | *   判斷按鍵類型（鼠標、Xbox、DS4）。 | *   獲取按鍵對象，將字符串按鍵名稱轉換為 `pynput` 庫中的按鍵對象。 | *   檢查是否安裝了虛擬手柄庫 `vgamepad`。 |  | **核心類和函數:** |  | *   `is_mouse_button(key: str)`: 判斷是否為鼠標按鍵。 | *   `is_xbox_button(key: str)`: 判斷是否為 Xbox 按鍵。 | *   `is_ds4_button(key: str)`: 判斷是否為 DS4 按鍵。 | *   `get_button(key: str)`: 獲取按鍵對象，根據按鍵類型調用 `get_mouse_button` 或 `get_keyboard_button`。 | *   `get_mouse_button(key: str)`: 獲取鼠標按鍵對象。 | *   `get_keyboard_button(key: str)`: 獲取鍵盤按鍵對象。 | *   `is_vgamepad_installed()`: 判斷是否安裝了 `vgamepad` 庫。 |  | **重要功能點:** |  | *   使用 `lru_cache` 進行緩存，提高函數的執行效率。 | *   使用 `pynput` 庫來表示鼠標和鍵盤按鍵。 | *   提供了將字符串按鍵名稱轉換為 `pynput` 按鍵對象的功能。 | *   檢查 `vgamepad` 庫的安裝狀態，用於支持虛擬手柄功能。
    │   │   │       └── xbox_button_controller.py    **摘要:** |  | 该文件定义了一个用于模拟 Xbox 游戏手柄按键操作的控制器。 |  | **核心类和函数:** |  | *   **XboxButtonEnum**:  定义了 Xbox 游戏手柄的按键枚举，将按键名称映射到配置项。 | *   **XboxButtonController**: 继承自 `PcButtonController`，负责模拟 Xbox 游戏手柄的按键操作。 |     *   `__init__()`: 初始化控制器，创建 vgamepad 实例（如果已安装），并设置按键处理程序。 |     *   `tap(key: str)`: 模拟按下并释放一个按键。 |     *   `press(key: str, press_time: Optional[float] = None)`: 模拟按下按键，可以选择按住一段时间。 |     *   `release(key: str)`: 模拟释放按键。 |     *   `tap_*()`:  针对每个按键的 `tap` 操作的具体实现，包括摇杆和扳机。 |     *   `release_*()`:  针对每个按键的 `release` 操作的具体实现。 |     *   `_press_button(btn, press: bool = False, press_time: Optional[float] = None)`:  用于按下和释放按钮的内部函数。 |     *   `_release_btn(btn)`:  用于释放按钮的内部函数。 |     *   `reset()`: 重置游戏手柄状态。 |  | **重要功能点:** |  | *   使用 `vgamepad` 库模拟 Xbox 游戏手柄。 | *   支持按下、释放以及按住按键操作。 | *   通过 `tap`、`press` 和 `release` 方法提供统一的按键操作接口。 | *   针对不同按键类型（按钮、摇杆、扳机）有不同的处理逻辑。 | *   可以设置按键的按住时间。
    │   │   ├── geometry/
    │   │   │   ├── point.py    這個 Python 文件定義了一個 `Point` 類，用於表示二維空間中的點。 |  | *   **主要功能:**  提供一個表示二維點的類，支持坐標初始化、坐標轉換為元組、字符串表示，以及點的加減運算。 | *   **核心類:** `Point` | *   **重要功能點:** |     *   `__init__(self, x, y)`: 初始化點的 x 和 y 坐標，並將其轉換為整數。 |     *   `tuple(self)`:  返回點的坐標作為一個元組 (x, y)。 |     *   `__repr__(self)`:  返回點的字符串表示，例如 "(x, y)"。 |     *   `__add__(self, other)`:  定義點的加法運算。 |     *   `__sub__(self, other)`:  定義點的減法運算。
    │   │   │   └── rectangle.py    這個 Python 文件定義了一個 `Rect` 類，用於表示二維空間中的矩形。 |  | *   **核心類:** `Rect` | *   **核心函數:** |     *   `__init__(self, x1, y1, x2, y2)`: 矩形的構造函數，接受左上角和右下角的坐標，並將其轉換為整數。 |     *   `center`: 屬性，返回矩形的中心點 `Point`。 |     *   `__repr__(self)`:  返回矩形的字符串表示。 |     *   `left_top`: 屬性，返回矩形的左上角點 `Point`。 |     *   `right_bottom`: 屬性，返回矩形的右下角點 `Point`。 |     *   `width`: 屬性，返回矩形的寬度。 |     *   `height`: 屬性，返回矩形的高度。 |     *   `add_offset(self, p)`:  將矩形移動一個偏移量。 | *   **重要功能點:**  提供矩形的坐標、中心點、寬度、高度等屬性的訪問，以及移動矩形的功能。
    │   │   ├── matcher/
    │   │   │   ├── match_result.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于存储和处理图像匹配结果的类，包括单个匹配结果 (`MatchResult`) 和匹配结果列表 (`MatchResultList`)。主要用于计算机视觉 (cv2) 和 OCR 结果的处理。 |  | **核心类和函数:** |  | *   **`MatchResult`**: |     *   `__init__(self, c, x, y, w, h, template_scale: float = 1, data: Any = None)`: 初始化匹配结果，包含置信度、坐标、宽高、模板缩放比例和附加数据。 |     *   `__repr__(self)`:  返回匹配结果的字符串表示。 |     *   `left_top`, `center`, `right_bottom`, `rect`:  属性，用于获取匹配结果的几何信息 (Point, Rect)。 |     *   `add_offset(self, p: Point)`:  对匹配结果的坐标进行偏移。 | *   **`MatchResultList`**: |     *   `__init__(self, only_best: bool = True)`: 初始化匹配结果列表，可以选择只保留最佳结果。 |     *   `__repr__(self)`:  返回匹配结果列表的字符串表示。 |     *   `__iter__(self)`, `__next__(self)`, `__len__(self)`:  实现迭代器协议，方便遍历结果列表。 |     *   `append(self, a: MatchResult, auto_merge: bool = True, merge_distance: float = 10)`:  添加匹配结果，支持自动合并功能，合并相同位置的匹配结果，保留置信度更高的结果。 |     *   `__getitem__(self, item)`:  通过索引访问匹配结果。 |     *   `add_offset(self, lt: Point)`:  对列表中所有匹配结果进行坐标偏移。 |  | **重要功能点:** |  | *   存储和表示单个匹配结果的几何信息和置信度。 | *   管理多个匹配结果，支持只保留最佳结果。 | *   提供结果合并功能，避免重复检测。 | *   支持对结果进行坐标偏移，方便处理图像裁剪等操作。 | *   提供迭代器接口，方便遍历结果列表。
    │   │   │   ├── template_matcher.py    這個 Python 腳本定義了一個 `TemplateMatcher` 類，用於在圖像中匹配模板。 |  | *   **主要功能:** 該腳本提供了兩種匹配模板的方法： |     *   `match_template`: 使用 OpenCV 的模板匹配功能，支持掩碼和閾值。 |     *   `match_one_by_feature`: 使用特徵匹配，通過檢測和匹配圖像特徵來找到模板位置。 | *   **核心類和函數:** |     *   `TemplateMatcher`: 核心類，負責模板匹配。 |         *   `__init__(self, template_loader: TemplateLoader)`: 初始化，接收一個 `TemplateLoader` 實例。 |         *   `match_template(...) -> MatchResultList`: 執行模板匹配，返回匹配結果列表。 |         *   `match_one_by_feature(...) -> Optional[MatchResult]`: 執行基於特徵的匹配，返回最佳匹配結果。 |     *   `TemplateLoader`: 外部依賴，用於加載模板信息。 |     *   `MatchResultList`, `MatchResult`: 數據結構，用於存儲匹配結果。 | *   **重要功能點:** |     *   支持使用掩碼進行模板匹配，可以與模板自身的掩碼和額外的掩碼結合使用。 |     *   可以設置匹配閾值，控制匹配的嚴格程度。 |     *   提供基於特徵的匹配方法，使用特徵檢測和匹配來定位模板。 |     *   `ignore_inf` 參數用於忽略無限大的匹配結果。 |     *   `only_best` 參數用於只返回最佳匹配結果。
    │   │   │   └── ocr/
    │   │   │       ├── ocr_matcher.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了一個 `OcrMatcher` 類，用於執行 OCR (光學字符識別) 任務，從圖像中提取文本。 |  | **核心類和函數:** |  | *   `OcrMatcher`:  OCR 匹配器的主要類。 |     *   `__init__(self)`:  構造函數。 |     *   `init_model(self) -> bool`:  初始化 OCR 模型。 |     *   `run_ocr_single_line(self, image: MatLike, threshold: float = None, strict_one_line: bool = True) -> str`:  對單行文本進行 OCR 識別。 |     *   `run_ocr(self, image: MatLike, threshold: float = None, merge_line_distance: float = -1) -> dict[str, MatchResultList]`:  對圖像進行 OCR，返回所有匹配結果。 |  | **重要功能點:** |  | *   提供單行和多行文本的 OCR 識別功能。 | *   支持設置匹配閾值。 | *   `run_ocr` 函數支持合併多行文本結果，以處理多行文本的情況。 | *   `init_model` 函數用於初始化 OCR 模型。
    │   │   │       ├── ocr_utils.py    這個 Python 文件 `ocr_utils.py` 提供了用於處理 OCR 結果的工具函數，主要用於將 OCR 文本結果合併成單行或多行。 |  | *   **主要功能:**  處理 OCR 文本結果，將其合併成單行或多行，以處理換行和文本排列問題。 | *   **核心函數:** |     *   `merge_ocr_result_to_single_line(ocr_map, join_space: bool = True) -> str`:  將 OCR 結果合併成單行字符串。 |     *   `merge_ocr_result_to_multiple_line(ocr_map, join_space: bool = True, merge_line_distance: float = 40) -> dict[str, MatchResultList]`: 將 OCR 結果合併成多行，並返回一個字典，其中鍵是合併後的文本，值是 `MatchResultList`。 | *   **重要功能點:** |     *   `merge_ocr_result_to_single_line`:  根據 y 坐標判斷是否在同一行，並根據 x 坐標排序，最後合併成單行文本。 |     *   `merge_ocr_result_to_multiple_line`:  根據 y 坐標的距離判斷是否在同一行，然後合併成多行文本。包含合併結果的邊界框計算。 |     *   `join_space`:  控制合併文本時是否加入空格。 |     *   `merge_line_distance`:  控制合併行的最大 y 軸距離。
    │   │   │       ├── onnx_ocr_matcher.py    **摘要:** |  | 该文件定义了 `OnnxOcrMatcher` 类，它使用 ONNX 版本的 PaddleOCR 模型进行 OCR 文本识别。 |  | **核心类和函数:** |  | *   **`OnnxOcrMatcher`**:  继承自 `OcrMatcher`，负责使用 ONNX 模型进行 OCR 识别。 |     *   `init_model()`:  初始化并加载 ONNX OCR 模型。 |     *   `run_ocr_single_line()`:  对单行文本进行 OCR 识别。 |     *   `run_ocr()`:  对图像进行 OCR 识别，返回所有匹配结果。 |     *   `_run_ocr_without_det()`:  不使用检测模型进行 OCR 识别。 |     *   `match_words()`:  在图像中查找关键词，返回匹配结果。 |  | **重要功能点:** |  | *   使用 ONNX 加速 OCR 识别。 | *   支持单行和多行文本识别。 | *   提供关键词匹配功能，支持忽略大小写、完全匹配和最长公共子序列匹配。 | *   可以设置匹配阈值和行距合并参数。
    │   │   │       └── paddle_ocr_matcher.py    **摘要:** |  | 该文件定义了 `PaddleOcrMatcher` 类，它继承自 `OcrMatcher`，使用 PaddleOCR 库进行 OCR 文本识别。 |  | **核心类和函数:** |  | *   **`PaddleOcrMatcher`**:  核心类，负责初始化 PaddleOCR 模型并执行 OCR 识别。 |     *   **`__init__(self)`**: 初始化函数，调用父类初始化。 |     *   **`init_model(self) -> bool`**:  初始化 PaddleOCR 模型，从指定目录加载模型文件。 |     *   **`run_ocr_single_line(self, image: MatLike, threshold: float = None, strict_one_line: bool = True) -> str`**:  对单行文本进行 OCR 识别。 |     *   **`run_ocr(self, image: MatLike, threshold: float = None, merge_line_distance: float = -1) -> dict[str, MatchResultList]`**:  对图片进行 OCR 识别，返回匹配结果。 |     *   **`_run_ocr_without_det(self, image: MatLike, threshold: float = None) -> str`**:  不使用检测模型进行 OCR 识别。 |  | **重要功能点:** |  | *   使用 PaddleOCR 进行文本识别。 | *   支持单行和多行文本识别。 | *   可以设置置信度阈值。 | *   可以合并多行识别结果。 | *   提供了两种 OCR 模式：使用检测模型和不使用检测模型。 | *   包含模型加载和错误处理。
    │   │   ├── operation/
    │   │   │   ├── application_base.py    這個 Python 文件定義了一個 `Application` 類，該類繼承自 `Operation`，用於表示一個應用程序在一個更大的操作流程中的執行。 |  | **核心類和函數:** |  | *   **`Application` 類:**  代表一個應用程序，繼承自 `Operation`，負責應用程序的啟動、停止和生命週期管理。 |     *   `__init__`: 初始化應用程序，包括應用程序 ID、運行記錄、上下文初始化和停止標誌等。 |     *   `_init_before_execute`: 在執行前初始化，更新運行記錄，初始化應用程序，啟動上下文，並分發應用程序啟動事件。 |     *   `handle_resume`: 恢復運行後的處理，由子類實現。 |     *   `after_operation_done`: 在操作完成後處理，更新運行記錄，停止上下文，並分發應用程序停止事件。 |     *   `_update_record_after_stop`: 根據運行結果更新運行記錄。 |     *   `current_execution_desc`:  返回當前運行的描述。 |     *   `next_execution_desc`:  返回下一步運行的描述。 |     *   `get_preheat_executor`: 獲取用於預熱的線程池執行器。 |     *   `init_for_application`: 初始化應用程序，包括 OCR 模型的初始化。 | *   **`ApplicationEventId` 枚舉:**  定義了應用程序啟動和停止的事件 ID。 | *   **`get_preheat_executor` 函數:**  返回一個用於預熱的線程池執行器。 |  | **重要功能點:** |  | *   應用程序的啟動和停止流程管理。 | *   上下文的初始化和停止控制。 | *   運行記錄的更新。 | *   事件的分發，用於通知應用程序的狀態變化。 | *   OCR 模型的初始化。 | *   使用線程池進行預熱。
    │   │   │   ├── application_desc.py    這個 Python 文件的摘要如下： |  | *   **主要功能:**  定義 `ApplicationDesc` 類，用於描述和管理應用程序的相關信息。 | *   **核心類:** |     *   `ApplicationDesc`:  用於封裝應用程序的 ID、名稱、`Application` 實例和運行記錄 `AppRunRecord`。 | *   **重要功能點:** |     *   `ApplicationDesc` 類的初始化方法 `__init__`，接收應用程序的 ID、名稱、`Application` 實例和運行記錄作為參數，並將它們保存為實例變量。
    │   │   │   ├── application_run_record.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AppRunRecord` 类，用于记录应用程序的运行状态和相关信息，例如运行时间、状态等，并提供方法来更新和重置这些记录。它还定义了 `AppRunRecordPeriod` 枚举，用于指定记录的周期（每日或每周）。 |  | **核心类和函数:** |  | *   **`AppRunRecordPeriod` (Enum):** 定义了记录周期，包括 `DAILY` 和 `WEEKLY`。 | *   **`AppRunRecord` (Class):** |     *   `__init__(self, app_id: str, instance_idx: Optional[int] = None, game_refresh_hour_offset: int = 0, record_period: AppRunRecordPeriod = AppRunRecordPeriod.DAILY)`: 构造函数，初始化应用程序 ID、实例索引、游戏刷新小时偏移和记录周期。 |     *   `_init_after_read_file(self)`: 从配置文件中读取并初始化记录信息。 |     *   `check_and_update_status(self)`: 检查并更新运行状态，如果需要则重置记录。 |     *   `update_status(self, new_status: int, only_status: bool = False)`: 更新运行状态，并可以选择是否更新时间信息。 |     *   `reset_record(self)`: 重置运行记录，将状态设置为 `STATUS_WAIT`。 |     *   `run_status_under_now(self)`: 根据当前时间返回运行状态。 |     *   `_should_reset_by_dt(self) -> bool`: 根据时间判断是否应该重置状态。 |     *   `get_current_dt(self) -> str`: 获取当前时间的日期字符串。 |     *   `app_record_now_time_str() -> str`: 获取当前时间的字符串表示。 |  | **重要功能点:** |  | *   记录应用程序的运行状态（WAIT, SUCCESS, FAIL, RUNNING）。 | *   支持每日或每周的记录周期。 | *   根据时间自动重置运行状态。 | *   提供更新状态、重置记录等方法。 | *   使用 `YamlConfig` 存储和加载运行记录。 | *   `game_refresh_hour_offset` 属性
    │   │   │   ├── context_event_bus.py    這個 Python 文件的主要功能是實現一個基於事件的上下文事件總線。 |  | 核心類和函數： |  | *   **ContextEventItem**: 封裝事件 ID 和事件數據的類。 | *   **ContextEventBus**: 負責事件的發布、監聽和取消監聽。 |     *   `dispatch_event(event_id, event_obj)`: 發布事件，將事件分發給已註冊的回調函數，使用線程池執行回調。 |     *   `listen_event(event_id, callback)`: 註冊事件監聽器。 |     *   `unlisten_event(event_id, callback)`: 取消單個事件監聽器。 |     *   `unlisten_all_event(obj)`: 取消特定對象的所有事件監聽器。 |     *   `after_app_shutdown()`: 在應用程序關閉時關閉線程池。 |  | 重要功能點： |  | *   使用線程池 (`ThreadPoolExecutor`) 異步執行事件回調，避免阻塞。 | *   支持事件的註冊、取消註冊和發布。 | *   提供取消特定對象所有監聽器的功能。 | *   在應用程序關閉時關閉線程池，釋放資源。
    │   │   │   ├── one_dragon_app.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `OneDragonApp` 类，它是一个用于管理和运行多个应用程序的类，这些应用程序按照特定的顺序执行，并支持实例切换和重试失败的任务。 |  | **核心类和函数:** |  | *   **`OneDragonApp`**: 继承自 `Application`，是核心类，负责协调和执行其他应用程序。 |     *   `__init__`: 初始化 `OneDragonApp` 实例，设置上下文、应用程序 ID、操作名称等。 |     *   `get_app_list`: 获取应用程序列表（由子类实现）。 |     *   `get_app_order_list`: 获取应用程序的运行顺序。 |     *   `update_app_order_list`: 更新应用程序的运行顺序。 |     *   `handle_init`: 初始化，根据配置设置需要运行的实例。 |     *   `get_one_dragon_apps_in_order`:  根据配置获取按顺序排列的应用程序列表。 |     *   `check_app`: 检查需要运行的应用程序，并筛选出未完成的应用程序。 |     *   `run_app`: 运行选定的应用程序。 |     *   `run_retry_app`: 重试失败的应用程序。 |     *   `switch_instance`: 切换到下一个实例。 |     *   `switch_account`: 切换账号。 |     *   `after_switch_account`: 切换账号后的处理。 |     *   `after_operation_done`:  在操作完成后执行，用于恢复应用程序的上下文设置。 |  | **重要功能点:** |  | *   **应用程序排序和运行:**  根据配置的顺序运行应用程序，并支持动态更新运行顺序。 | *   **实例切换:**  支持在不同的游戏实例之间切换，以实现多账号操作。 | *   **失败重试:**  能够重试运行失败的应用程序。 | *   **状态管理:**  跟踪应用程序的运行状态，并根据状态进行相应的处理。 | *   **上下文控制:**  控制应用程序在运行前后的上下文初始化和停止。
    │   │   │   ├── one_dragon_context.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `OneDragonContext` 类，作为整个 OneDragon 应用程序的核心上下文，负责管理应用程序的运行状态、配置、事件处理、控制器、屏幕截图、OCR 等功能。它还集成了键盘和鼠标监听器，并提供了启动、停止、暂停和恢复运行的方法。 |  | **核心类和函数:** |  | *   **`OneDragonContext`**:  核心类，继承自 `ContextEventBus` 和 `OneDragonEnvContext`。 |     *   `__init__(self, controller: Optional = None)`:  初始化上下文，包括配置加载、控制器初始化、键盘和鼠标监听器启动。 |     *   `start_running(self) -> bool`:  启动应用程序运行。 |     *   `stop_running(self)`:  停止应用程序运行。 |     *   `switch_context_pause_and_run(self)`:  切换暂停和运行状态。 |     *   `_on_key_press(self, key: str)`:  处理键盘按键事件，触发相关操作。 |     *   `screenshot_and_save_debug(self) -> None`:  截取屏幕截图并保存到调试目录。 |     *   `switch_instance(self, instance_idx: int) -> None`: 切换实例 |     *   `async_init_ocr(self) -> None`: 异步初始化OCR |     *   `after_app_shutdown(self) -> None`: App关闭后进行的操作 |  | *   **`ContextRunStateEnum`**:  定义了应用程序运行状态的枚举（STOP, RUN, PAUSE）。 | *   **`ContextRunningStateEventEnum`**: 定义了运行状态相关的事件。 | *   **`ContextKeyboardEventEnum`**: 定义了键盘事件。 | *   **`ContextInstanceEventEnum`**: 定义了实例相关的事件。 |  | **重要功能点:** |  | *   **状态管理**:  管理应用程序的运行状态（启动、停止、暂停、恢复）。 | *   **事件处理**:  通过 `ContextEventBus` 处理和分发事件。 | *   **配置管理**:  加载和管理各种配置，例如 `OneDragonConfig`, `CustomConfig`, `OneDragonAppConfig`, `GameAccountConfig`。 | *   **控制器集成**:  与 `
    │   │   │   ├── one_dragon_env_context.py    這個 Python 文件定義了 `OneDragonEnvContext` 類，用於管理 OneDragon 專案的環境和配置資訊。 |  | *   **主要功能:** 儲存和管理專案配置、環境配置以及與 Git、Python 和 GitHub Proxy 相關的服務。 提供非同步更新 GitHub Proxy 的功能，並在應用程式關閉時釋放資源。 | *   **核心類和函數:** |     *   `OneDragonEnvContext`:  主要類，負責初始化和管理環境上下文。 |     *   `__init__(self)`: 初始化 `OneDragonEnvContext`，建立 `ProjectConfig`, `EnvConfig`, `GitService`, `PythonService`, 和 `GhProxyService` 實例。 |     *   `async_update_gh_proxy(self)`: 非同步更新 GitHub Proxy URL。 |     *   `after_app_shutdown(self)`: 在應用程式關閉後關閉執行緒池。 | *   **重要功能點:** |     *   使用 `ThreadPoolExecutor` 進行非同步操作，提高效率。 |     *   整合了多個環境服務，如 Git, Python 和 GitHub Proxy。 |     *   提供在應用程式關閉時清理資源的機制。
    │   │   │   ├── operation.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `Operation` 类，它是所有游戏操作的基类。它负责管理操作的执行流程、节点网络、错误处理、超时控制、屏幕截图以及与游戏上下文的交互。 |  | **核心类和函数:** |  | *   **`Operation` 类:**  所有游戏操作的基类，包含操作的执行流程控制、节点管理、错误处理等。 |     *   `__init__`: 初始化操作的上下文、超时时间、回调函数等。 |     *   `execute`:  执行操作的主循环，处理节点执行、重试、超时等。 |     *   `_execute_one_round`:  执行操作的单轮，调用当前节点的函数或指令。 |     *   `_get_next_node`:  根据当前轮的结果获取下一个节点。 |     *   `round_success`, `round_wait`, `round_retry`, `round_fail`:  用于设置单轮操作的结果。 |     *   `round_by_find_and_click_area`, `round_by_find_area`, `round_by_click_area`, `round_by_ocr_and_click`, `round_by_ocr`, `round_by_goto_screen`:  提供各种游戏操作的封装，例如查找并点击区域、OCR识别等。 |     *   `check_game_window`, `open_and_enter_game`:  用于检测游戏窗口和打开游戏。 |     *   `add_edges_and_nodes`, `_add_edges_and_nodes_by_annotation`, `add_edge`, `_init_network`:  用于构建操作的节点网络。 |     *   `handle_init`, `handle_pause`, `handle_resume`:  用于子类实现初始化、暂停和恢复逻辑。 |     *   `screenshot`, `save_screenshot`:  用于截图和保存截图。 |     *   `check_and_update_current_screen`, `check_screen_with_can_go`, `check_current_can_go`:  用于识别和判断当前游戏画面。 |  | **重要功能点:** |  | *   **操作流程控制:**  通过节点网络定义操作的执行流程，支持重试、超时和暂停。 | *   **节点网络
    │   │   │   ├── operation_base.py    這個 Python 文件定義了一個基礎指令框架，用於執行操作並返回結果。 |  | *   **主要功能:** 提供一個基類 `OperationBase`，用於定義指令的執行流程，以及 `OperationResult` 類，用於封裝指令的執行結果。 | *   **核心類和函數:** |     *   `OperationResult`: 封裝指令的執行結果，包含 `success` (是否成功), `status` (狀態), 和 `data` (返回數據)。 |     *   `OperationBase`: 基礎指令類，包含 `execute` 方法 (由子類實現) 和 `op_success`, `op_fail` 靜態方法，用於創建成功和失敗的執行結果。 | *   **重要功能點:** |     *   `execute` 方法是指令執行的入口，由子類覆寫實現具體的操作邏輯。 |     *   `op_success` 和 `op_fail` 方法用於方便地創建成功和失敗的 `OperationResult` 實例。
    │   │   │   ├── operation_edge.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了 `OperationEdge` 和 `OperationEdgeDesc` 類，用於表示操作流程中的邊，並提供了一個裝飾器 `node_from`，用於將邊的描述信息附加到函數上。 |  | **核心類和函數:** |  | *   **`OperationEdge`:**  表示操作流程中的一條邊，包含起始節點、結束節點、成功標誌、狀態和是否忽略狀態等屬性。 | *   **`OperationEdgeDesc`:**  用於描述 `OperationEdge`，包含節點名稱、成功標誌、狀態和是否忽略狀態等屬性。 | *   **`node_from`:**  一個裝飾器，用於將 `OperationEdgeDesc` 附加到函數上，描述函數的輸入邊。 |  | **重要功能點:** |  | *   `OperationEdge` 類定義了操作流程中邊的關鍵屬性，用於控制流程的執行。 | *   `OperationEdgeDesc` 類用於描述邊，方便在流程定義中使用。 | *   `node_from` 裝飾器允許將邊的描述信息與函數關聯起來，方便構建和管理操作流程。 | *   `ignore_status` 屬性允許忽略狀態，提供靈活性，但通常用於兜底情況。
    │   │   │   ├── operation_node.py    這個 Python 文件定義了 `OperationNode` 類，用於表示帶有狀態的指令節點，以及一個用於裝飾函數的 `operation_node` 裝飾器。 |  | *   **主要功能:** 創建和管理操作節點，這些節點封裝了用於執行操作的函數或指令。 | *   **核心類和函數:** |     *   `OperationNode`:  表示一個操作節點，包含節點名稱、處理函數、操作指令、重試策略、等待時間和超時時間等屬性。 |     *   `operation_node`:  一個裝飾器，用於將函數標記為操作節點，並將 `OperationNode` 實例附加到函數的註釋中。 | *   **重要功能點:** |     *   `OperationNode` 類允許配置節點的行為，例如重試失敗的操作、在操作後等待一段時間以及設置超時。 |     *   `operation_node` 裝飾器簡化了創建操作節點的過程，允許通過裝飾函數來定義節點的屬性。 |     *   `mute` 屬性控制是否顯示過程結果日誌。 |     *   `is_start_node` 屬性標記起始節點。 |     *   `node_max_retry_times` 屬性定義節點重試次數。
    │   │   │   └── operation_round_result.py    這個 Python 文件定義了 `OperationRoundResult` 類，用於表示指令單輪執行的結果。 |  | *   **主要功能:** 封裝指令執行結果，包含成功、失敗、重試和等待等狀態。 | *   **核心類和函數:** |     *   `OperationRoundResultEnum`:  一個枚舉，定義了指令執行結果的可能狀態 (RETRY, SUCCESS, WAIT, FAIL)。 |     *   `OperationRoundResult`:  類，用於儲存單輪執行結果，包含 `result` (OperationRoundResultEnum 類型), `status` (狀態訊息), 和 `data` (返回數據)。 |     *   `is_success`:  屬性，判斷結果是否為成功。 |     *   `is_fail`:  屬性，判斷結果是否為失敗。 |     *   `status_display`:  屬性，返回結果的中文描述。 | *   **重要功能點:** |     *   使用枚舉定義了結果狀態，增加了代碼的可讀性和可維護性。 |     *   `OperationRoundResult` 類封裝了結果、狀態和數據，方便在框架中傳遞和處理指令執行結果。 |     *   提供了便捷的屬性 `is_success`, `is_fail` 和 `status_display`，方便判斷和顯示結果。
    │   │   └── screen/
    │   │       ├── screen_area.py    **文件摘要** |  | *   **主要功能:** 定义 `ScreenArea` 类，用于表示屏幕上的一个区域，包含区域的名称、矩形位置、文本、模板信息、颜色范围等属性，以及用于访问这些属性的便捷方法。 | *   **核心类和函数:** |     *   `ScreenArea`:  表示屏幕区域的类，包含区域的各种属性。 |     *   `__init__`:  `ScreenArea` 类的构造函数，初始化屏幕区域的各种属性。 |     *   `rect`, `center`, `left_top`, `x1`, `x2`, `y1`, `y2`, `width`, `height`:  属性，用于访问 `ScreenArea` 的矩形相关信息。 |     *   `template_id_display_text`, `goto_list_display_text`, `color_range_display_text`:  属性，用于生成属性的显示文本。 |     *   `is_text_area`, `is_template_area`:  属性，用于判断区域是否为文本或模板区域。 |     *   `color_range_lower`, `color_range_upper`:  属性，用于获取颜色范围的上下限。 |     *   `to_order_dict`:  将 `ScreenArea` 对象的属性转换为有序字典。 | *   **重要功能点:** |     *   定义屏幕区域的各种属性，包括名称、矩形、文本、模板、颜色范围等。 |     *   提供便捷的属性访问方法，例如获取矩形、中心点、宽高等等。 |     *   提供判断区域类型的属性，例如是否为文本区域或模板区域。 |     *   提供将 `ScreenArea` 对象转换为有序字典的方法，方便数据存储和展示。 |     *   支持模板匹配和颜色范围识别。 |     *   包含跳转画面列表和PC端ALT点击标识。
    │   │       ├── screen_info.py    這個 Python 文件定義了 `ScreenInfo` 類，用於管理遊戲屏幕的資訊，包括屏幕圖像、區域定義和相關配置。 |  | **核心類和函數:** |  | *   **`ScreenInfo` 類:** |     *   `__init__`: 初始化 ScreenInfo 實例，從 YAML 文件加載數據或創建新實例。 |     *   `get_dir_path`: 獲取存儲 screen_info 文件的目錄路徑。 |     *   `get_yml_file_path`: 獲取 YAML 配置文件的路徑。 |     *   `get_image_file_path`: 獲取屏幕圖像文件的路徑。 |     *   `_init_from_data`: 從 YAML 文件中加載數據，初始化 screen_name, screen_image, pc_alt 和 area_list。 |     *   `get_image_to_show`: 獲取帶有高亮區域的屏幕圖像，用於顯示。 |     *   `remove_area_by_idx`: 根據索引刪除 area_list 中的 ScreenArea。 |     *   `save`: 保存 ScreenInfo 數據到 YAML 文件，並處理 screen_id 更改時的文件刪除。 |     *   `delete`: 刪除 ScreenInfo 相關的 YAML 文件。 |  | **重要功能點:** |  | *   從 YAML 文件加載和保存屏幕信息，包括屏幕名稱、圖像、PC 端 ALT 鍵狀態和區域列表。 | *   管理屏幕上的區域，每個區域由 `ScreenArea` 類定義。 | *   提供高亮顯示區域的屏幕圖像，用於視覺化。 | *   支持刪除和修改屏幕區域。 | *   處理 screen_id 更改時的舊文件刪除。
    │   │       ├── screen_loader.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于加载和管理游戏屏幕信息和导航路径的类。它负责加载屏幕定义文件，构建屏幕之间的跳转路径，并提供获取屏幕信息和导航路径的接口。 |  | **核心类和函数:** |  | *   **`ScreenRouteNode`**:  表示一个画面跳转的节点，记录了从哪个画面，点击哪个区域，可以跳转到哪个目标画面。 | *   **`ScreenRoute`**:  表示两个画面之间的跳转路径，包含一系列 `ScreenRouteNode`。 |     *   `can_go`:  判断是否可以到达目标画面。 | *   **`ScreenContext`**:  管理所有屏幕信息和导航路径的上下文。 |     *   `load_all()`:  加载所有屏幕信息，包括屏幕定义和区域信息，并初始化屏幕跳转路径。 |     *   `get_screen(screen_name)`:  根据名称获取屏幕信息。 |     *   `get_area(screen_name, area_name)`:  根据屏幕名称和区域名称获取区域信息。 |     *   `init_screen_route()`:  初始化屏幕之间的跳转路径，包括直接跳转和通过Floyd算法计算间接跳转。 |     *   `get_screen_route(from_screen, to_screen)`:  获取两个画面之间的跳转路径。 |     *   `update_current_screen_name(screen_name)`:  更新当前屏幕名称。 |  | **重要功能点:** |  | *   **屏幕信息加载**: 从YAML文件加载屏幕信息，包括屏幕名称、区域等。 | *   **屏幕跳转路径构建**:  根据屏幕区域的 `goto_list` 构建屏幕之间的跳转路径。 | *   **Floyd算法**: 使用Floyd算法计算任意两个屏幕之间的最短路径，支持多步跳转。 | *   **路径查询**:  提供获取两个屏幕之间跳转路径的接口。 | *   **当前屏幕管理**:  记录当前和上一个屏幕的名称。
    │   │       ├── screen_utils.py    ## 代码摘要 |  | **主要功能:** |  | 该文件定义了一系列用于屏幕截图分析和交互的工具函数，主要用于在游戏中查找特定区域、识别文本、匹配模板，并进行点击操作。 |  | **核心类和函数:** |  | *   **`OcrClickResultEnum`**:  定义了OCR点击操作的结果枚举。 | *   **`FindAreaResultEnum`**: 定义了查找区域的结果枚举。 | *   **`find_area(ctx, screen, screen_name, area_name)`**:  在屏幕上查找指定区域。 | *   **`find_area_in_screen(ctx, screen, area)`**:  在屏幕上查找指定区域，基于`ScreenArea`对象。 | *   **`find_and_click_area(ctx, screen, screen_name, area_name)`**:  查找区域并进行点击操作。 | *   **`get_match_screen_name(ctx, screen, screen_name_list)`**:  根据截图匹配最合适的画面名称。 | *   **`get_match_screen_name_from_last(ctx, screen)`**:  从上次记录的画面开始匹配最合适的画面名称。 | *   **`is_target_screen(ctx, screen, screen_name, screen_info)`**:  判断截图是否是目标画面。 | *   **`find_by_ocr(ctx, screen, target_cn, area, lcs_percent, color_range)`**:  使用OCR查找文本。 |  | **重要功能点:** |  | *   **区域查找:**  支持基于文本OCR和模板匹配的区域查找。 | *   **点击操作:**  在找到区域后，进行点击操作，包括OCR结果的点击和模板匹配结果的点击。 | *   **画面匹配:**  根据截图内容，自动匹配当前游戏画面，支持从上次记录的画面开始匹配。 | *   **OCR文本识别:**  使用OCR技术识别屏幕上的文本，并支持基于最长公共子序列(LCS)的文本匹配。 | *   **颜色过滤:**  支持通过颜色范围过滤图像，用于更精确的OCR识别。 | *   **上下文依赖:**  依赖于`OneDragonContext`对象，用于访问OCR、模板匹配等功能。
    │   │       ├── template_info.py    **摘要:** |  | 该 Python 文件定义了 `TemplateInfo` 类，用于管理和操作游戏模板的图像、配置和特征。它提供了创建、加载、保存和修改模板信息的功能，包括模板图像、掩码、形状、关键点和配置。 |  | **核心类和函数:** |  | *   **`TemplateInfo`**:  核心类，用于处理模板信息。 |     *   `__init__`: 初始化模板信息，包括从配置文件加载数据和图像。 |     *   `get_yml_file_path`: 获取模板配置文件的路径。 |     *   `remove_point_by_idx`, `add_point`: 管理模板的坐标点。 |     *   `get_image`: 获取模板图像（原图、灰度图、掩码）。 |     *   `gray`: 灰度图的属性。 |     *   `features`: 特征点和描述符的属性。 |     *   `make_template_dir`: 创建模板目录，并处理旧目录的移动。 |     *   `save_config`, `save_raw`, `save_mask`: 保存模板配置、原图和掩码。 |     *   `get_template_rect_by_point`: 根据坐标点获取模板矩形区域。 |     *   `get_template_raw_by_screen_point`, `get_template_mask_by_screen_point`: 根据坐标点从屏幕图像中提取模板原图和掩码。 |     *   `get_template_raw_to_display`, `get_template_mask_to_display`, `get_template_merge_to_display`, `get_template_reversed_merge_to_display`, `get_screen_image_to_display`: 获取用于显示的图像。 |     *   `update_template_shape`: 更新模板形状，并进行坐标转换。 |     *   `get_template_features`: 获取模板的特征。 |     *   `copy_new`: 复制模板。 |     *   `update_all_points`: 移动所有坐标点。 | *   **`get_template_xxx_path` 系列函数**:  用于获取模板文件路径的辅助函数。 | *   **`is_template_existed`, `is_template_config_existed`**:  用于
    │   │       └── template_loader.py    這個 Python 文件的主要功能是從硬碟加載和管理模板圖像。 |  | 核心類： |  | *   `TemplateLoader`: 負責加載、儲存和獲取模板信息。 |  | 核心函數： |  | *   `get_all_template_info_from_disk()`: 從硬碟中加載所有模板信息。 | *   `load_template()`: 加載特定模板到內存。 | *   `get_template()`: 從內存中獲取模板，如果不存在則加載。 | *   `get_template_mask()`: 獲取特定模板的掩碼。 |  | 重要功能點： |  | *   從 `assets/template` 目錄下的子目錄中加載模板。 | *   使用 `TemplateInfo` 類來儲存模板信息。 | *   緩存已加載的模板以提高效率。 | *   提供獲取模板圖像和掩碼的功能。
    │   ├── devtools/
    │   │   ├── compile_po.py    這個 Python 腳本 `compile_po.py` 的主要功能是將 `.po` 文件編譯成 `.mo` 文件，用於多語言支持。 |  | *   **核心函數:** |     *   `compile_lang(model: str, lang: str)`:  編譯特定模塊和語言的 `.po` 文件到 `.mo` 文件。 |     *   `compile_po_files()`: 遍歷不同的模塊和語言，調用 `compile_lang` 進行編譯。 |  | *   **重要功能點:** |     *   使用 `polib` 庫讀取和處理 `.po` 文件。 |     *   根據模塊（例如 `game`, `ui`）和語言（例如 `cn`, `en`）組織文件路徑。 |     *   將編譯後的 `.mo` 文件保存到 `LC_MESSAGES` 目錄下。 |     *   `if __name__ == '__main__':` 塊調用 `compile_po_files()` 啟動編譯過程。
    │   │   └── python_launcher.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 脚本是一个启动器，用于配置 Python 运行环境、执行 Python 脚本，并管理日志。它主要用于自动化构建和运行 Python 项目，特别是在存在依赖管理和代码更新的场景下。 |  | **核心类和函数:** |  | *   `print_message(message, level="INFO")`: 打印带有时间戳和日志级别的消息。 | *   `delay(seconds)`: 暂停指定秒数。 | *   `verify_path_issues()`: 验证当前路径是否存在中文或空格。 | *   `load_yaml_config(file_path)`: 从 YAML 文件加载配置。 | *   `get_python_path_from_yaml(yaml_file_path)`: 从 YAML 文件中获取 Python 解释器路径。 | *   `configure_environment()`: 配置 Python 运行环境，设置 `PYTHON`, `PYTHONPATH`, 和 `PYTHONUSERBASE` 环境变量。 | *   `create_log_folder()`: 创建日志文件夹。 | *   `clean_old_logs(log_folder)`: 清理旧的日志文件。 | *   `execute_python_script(app_path, log_folder, no_windows)`: 执行 Python 脚本，并将输出重定向到日志文件。 | *   `fetch_latest_code(ctx: OneDragonEnvContext)`: 从 Git 获取最新代码。 | *   `check_dependencies(ctx: OneDragonEnvContext)`: 检查并安装最新的依赖。 | *   `run_python(app_path, no_windows=True)`: 主函数，协调整个启动流程。 |  | **重要功能点:** |  | *   **环境配置:**  从 YAML 文件读取 Python 解释器路径，并设置环境变量。 | *   **日志管理:**  创建日志目录，清理旧日志，并将 Python 脚本的输出重定向到日志文件。 | *   **脚本执行:** 使用 PowerShell 启动 Python 脚本，支持无窗口模式。 | *   **代码更新:**  从 Git 获取最新代码，并安装依赖。 | *   **错误处理:**  包含异常处理机制，确保程序在出现问题时能够优雅退出。 | *   **依赖管理:**  检查并安装最新的依赖。
    │   ├── envs/
    │   │   ├── env_config.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于配置环境的类和枚举，包括 Git、Python、代理、Pip 源等相关设置。它使用 `YamlConfig` 类来管理配置文件的读写，并提供了一系列属性来访问和修改配置项。 |  | **核心类和函数:** |  | *   `EnvConfig`: 继承自 `YamlConfig`，用于管理环境配置。 |     *   `__init__()`: 初始化，设置模块名称为 'env'。 |     *   一系列 `@property` 装饰的 getter 和 setter 方法，用于访问和修改各种配置项，如 `git_path`, `python_path`, `proxy_type` 等。 |     *   `write_env_bat()`: 写入环境变量的 bat 文件。 | *   `ProxyTypeEnum`, `RepositoryTypeEnum`, `GitMethodEnum`, `PipSourceEnum`, `GitBranchEnum`: 枚举类，定义了配置中使用的选项，如代理类型、仓库类型、Git 方法、Pip 源和 Git 分支。 |  | **重要功能点:** |  | *   **配置管理:** 使用 `YamlConfig` 读写配置文件，存储和加载环境配置。 | *   **环境变量设置:**  `write_env_bat()` 函数用于生成 `env.bat` 文件，设置 Python 环境变量。 | *   **代理设置:** 支持多种代理类型，包括个人代理和 Github 免费代理，并提供相关配置项。 | *   **Git 相关配置:**  配置 Git 路径、仓库类型、Git 方法（HTTPS/SSH）和 Git 分支。 | *   **Pip 源配置:**  配置 pip 源，包括官方、清华大学、阿里云等。 | *   **调试模式和快捷键设置:**  配置调试模式和快捷键。 | *   **自动更新和强制更新:**  配置代码自动更新和强制更新选项。 | *   **默认路径定义:** 定义了多个默认路径，如 Git、Python、虚拟环境等。
    │   │   ├── ghproxy_service.py    這個 Python 文件 `ghproxy_service.py` 實現了一個從 ghproxy.link 獲取免費代理 URL 的服務。 |  | *   **主要功能:** 從 ghproxy.link 網站抓取 JavaScript 文件，解析其中的 HTML 鏈接，提取免費代理 URL，並將其更新到 `EnvConfig` 中。 | *   **核心類和函數:** |     *   `GhProxyService`: 負責獲取和更新代理 URL。 |         *   `__init__(self, env_config: EnvConfig)`: 初始化，接收 `EnvConfig` 實例。 |         *   `update_proxy_url(self) -> None`: 核心函數，執行獲取和更新代理 URL 的邏輯。 | *   **重要功能點:** |     *   使用 `urllib.request.urlopen` 獲取 JavaScript 文件內容。 |     *   使用字符串查找方法定位 URL。 |     *   使用正則表達式驗證提取的 URL 是否有效。 |     *   將獲取的代理 URL 更新到 `EnvConfig` 實例中。 |     *   包含一個 `__debug()` 函數用於測試，以及一個 `if __name__ == '__main__':` 塊，用於在腳本直接運行時執行調試。
    │   │   ├── git_service.py    **摘要:** |  | 该 Python 脚本定义了一个 `GitService` 类，用于管理与 Git 仓库的交互，包括下载、安装 Git 工具、克隆、更新代码、获取版本信息等。 |  | **核心类和函数:** |  | *   **`GitLog`**: 用于存储 Git 提交信息的类。 | *   **`GitService`**:  核心类，负责 Git 操作。 |     *   `download_env_file()`: 下载环境文件。 |     *   `get_git_version()`: 获取 Git 版本。 |     *   `install_default_git()`: 安装默认的 Git。 |     *   `fetch_latest_code()`: 获取最新代码（克隆或更新）。 |     *   `clone_repository()`: 克隆仓库。 |     *   `checkout_latest_project_branch()`: 切换到最新的分支。 |     *   `get_current_branch()`: 获取当前分支。 |     *   `is_current_branch_clean()`: 检查当前分支是否干净。 |     *   `get_requirement_time()`: 获取 requirements.txt 的最后更新时间。 |     *   `fetch_total_commit()`: 获取提交总数。 |     *   `fetch_page_commit()`: 获取分页的提交记录。 |     *   `get_git_repository()`: 获取仓库地址。 |     *   `init_git_proxy()`: 初始化 Git 代理。 |     *   `update_git_remote()`: 更新远程仓库地址。 |     *   `set_safe_dir()`: 设置安全目录。 |     *   `reset_to_commit()`: 回滚到特定提交。 |     *   `get_current_version()`: 获取当前代码版本。 |  | **重要功能点:** |  | *   **Git 工具管理:**  能够下载和安装 Git。 | *   **代码更新:**  支持克隆和更新代码，包括分支切换和合并。 | *   **代理设置:**  可以配置和使用代理进行 Git 操作。 | *   **版本控制:**  获取 Git 版本、当前分支、提交历史和代码状态。 | *   **错误处理:**  包含一些错误处理机制，例如在克隆或更新失败时进行重试。 | *   **进度回调:**  提供进度回调，
    │   │   ├── project_config.py    這個 Python 文件定義了 `ProjectConfig` 類，用於讀取和管理項目的配置信息。 |  | *   **主要功能:** 讀取並提供項目的配置信息，這些信息來自於 YAML 配置文件。 | *   **核心類:** `ProjectConfig` 繼承自 `YamlConfig`。 | *   **重要功能點:** |     *   初始化時，使用 `YamlConfig` 加載名為 "project" 的配置文件。 |     *   定義了多個屬性，用於存儲從配置文件中讀取的項目配置，例如 `project_name`, `python_version`, Git 倉庫地址等。 |     *   將 `screen_standard_width` 和 `screen_standard_height` 轉換為整數。
    │   │   └── python_service.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 文件定义了一个 `PythonService` 类，用于管理 Python 环境的安装、配置和依赖安装。它提供了安装 Python 解释器、pip、virtualenv，创建虚拟环境，以及安装项目依赖的功能。 |  | **核心类和函数:** |  | *   **`PythonService` 类:** |     *   `__init__(self, project_config: ProjectConfig, env_config: EnvConfig, git_service: GitService)`: 初始化函数，接收项目配置、环境配置和 Git 服务。 |     *   `install_default_python(...)`: 安装默认的 Python 解释器。 |     *   `install_default_pip(...)`: 安装默认的 pip。 |     *   `install_default_virtualenv(...)`: 安装默认的 virtualenv。 |     *   `create_default_venv(...)`: 创建默认的虚拟环境。 |     *   `install_default_python_venv(...)`: 完整流程安装 Python 环境。 |     *   `install_requirements(...)`: 安装项目依赖。 |     *   `get_python_version(...)`: 获取当前 Python 版本。 |     *   `get_pip_version(...)`: 获取当前 pip 版本。 |     *   `choose_best_pip_source(...)`: 选择最佳的 pip 源。 |     *   `is_virtual_python(...)`: 检查是否在虚拟环境中运行。 |     *   `get_os_python_path(...)`: 获取系统环境变量中的 Python 路径。 |     *   `get_os_pip_path(...)`: 获取系统环境变量中的 pip 路径。 |     *   `get_module_version(...)`: 获取模块版本。 |  | **重要功能点:** |  | *   **Python 和 Pip 的安装:**  下载并解压 Python，安装 pip，支持重试机制和进度回调。 | *   **虚拟环境管理:**  创建和管理虚拟环境。 | *   **依赖安装:**  使用 pip 安装项目所需的依赖，并支持更新 pip。 | *   **Pip 源选择:**  通过测速选择最佳的 pip 源，提高下载速度。 | *   **环境配置:**  使用 `EnvConfig` 管理 Python 路径和 pip 源等环境配置。 | *   **进度回调:**  使用 `progress_callback` 提供安装过程的进度更新。 | *   **
    │   ├── thread/
    │   │   ├── atomic_bool.py    這個 Python 文件定義了一個 `AtomicBool` 類，它提供了一個線程安全的布爾值。 |  | *   **主要功能**: 提供線程安全的布爾值讀取和設置操作。 | *   **核心類**: `AtomicBool` | *   **重要功能點**: |     *   `__init__(self, value: bool = False)`: 初始化布爾值，默認值為 `False`，並創建一個 `threading.Lock` 用於線程同步。 |     *   `get(self)`: 獲取當前布爾值，使用鎖來保證線程安全。 |     *   `set(self, value: bool)`: 設置布爾值，使用鎖來保證線程安全。 |     *   `set_true(self)`: 將布爾值設置為 `True`，使用鎖來保證線程安全。 |     *   `set_false(self)`: 將布爾值設置為 `False`，使用鎖來保證線程安全。
    │   │   └── atomic_int.py    這個 Python 文件實現了一個線程安全的原子整數類 `AtomicInt`。 |  | *   **主要功能:** 提供線程安全的整數操作，包括獲取、設置、增加和減少。 | *   **核心類:** `AtomicInt` | *   **重要功能點:** |     *   `__init__(self, value=0)`: 初始化原子整數，默認值為 0，並創建一個 `threading.Lock` 用於線程同步。 |     *   `get(self)`: 獲取當前原子整數的值，使用鎖保護。 |     *   `set(self, value)`: 設置原子整數的值，使用鎖保護。 |     *   `inc(self)`: 原子地增加原子整數的值，使用鎖保護。 |     *   `dec(self)`: 原子地減少原子整數的值，使用鎖保護。
    │   ├── utils/
    │   │   ├── app_utils.py    這個 Python 腳本 `app_utils.py` 提供了啟動和重啟 "OneDragon" 應用程序的功能。 |  | *   **主要功能:** 啟動和重啟 "OneDragon" 應用程序。 | *   **核心函數:** |     *   `start_one_dragon(restart: bool)`: 啟動 "OneDragon Launcher.exe" 應用程序。如果 `restart` 為 True，則在啟動後退出腳本。 |     *   `restart_one_dragon()`: 啟動 `restart_app.bat` 腳本，用於重啟 "OneDragon" 應用程序。 | *   **重要功能點:** |     *   使用 `subprocess.Popen` 執行外部命令來啟動應用程序。 |     *   使用 `os_utils.get_work_dir()` 獲取工作目錄。 |     *   `if __name__ == '__main__':` 块在腳本直接執行時，會啟動 "OneDragon" 並立即重啟。
    │   │   ├── cal_utils.py    代码摘要： |  | 该文件定义了一系列用于几何计算的实用函数。 |  | 核心函数： |  | *   `distance_between(pos1: Point, pos2: Point) -> float`: 计算两点之间的距离。 | *   `get_angle_by_pts(from_pos: Point, to_pos: Point) -> float`: 计算两点形成向量的角度。 | *   `angle_delta(from_angle: float, to_angle: float) -> float`: 计算从一个角度转到另一个角度需要的角度。 | *   `angle_add(current_angle: float, delta_angle: float) -> float`: 计算一个角度加上一个偏移角度后的结果。 | *   `in_rect(point: Point, rect: Rect) -> bool`: 判断点是否在矩形内。 | *   `calculate_overlap_area(rect1, rect2)`: 计算两个矩形的重叠面积。 | *   `distance_to_line(target: Point, p1: Point, p2: Point) -> float`: 计算点到直线的距离。 | *   `random_in_range(r: Union[List[float], float]) -> float`: 在范围内随机一个数。 | *   `coalesce(*args)`: 返回第一个非空元素。 |  | 重要功能点： |  | *   提供了计算点、角度、矩形等几何相关的常用函数。 | *   包含计算重叠面积和点到直线距离的功能。 | *   包含随机数生成函数。
    │   │   ├── cmd_utils.py    這個 Python 腳本 `cmd_utils.py` 提供了用於執行命令行命令的工具函數。 |  | **主要功能:** |  | *   執行命令行命令，捕獲 stdout 和 stderr 輸出，並提供回調函數。 | *   提供關閉和取消關閉系統的函數。 |  | **核心類和函數:** |  | *   `run_command(commands: List[str], cwd: Optional[str] = None, message_callback: Optional[Callable[[str], None]] = None) -> Optional[str]`:  執行給定的命令行命令，支持指定工作目錄和消息回調。使用多線程處理 stdout 和 stderr，並返回命令的 stdout 輸出。 | *   `shutdown_sys(seconds: int)`: 使用 `shutdown` 命令關閉系統，延遲指定秒數。 | *   `cancel_shutdown_sys()`: 使用 `shutdown /a` 命令取消計劃的關機。 |  | **重要功能點:** |  | *   使用 `subprocess.Popen` 執行命令，並捕獲 stdout 和 stderr。 | *   使用多線程處理 stdout 和 stderr，避免阻塞。 | *   提供消息回調，用於實時顯示命令輸出。 | *   處理 Windows 系統下 `subprocess` 的特殊參數，例如 `startupinfo` 和 `creationflags`，以避免彈出控制台窗口。 | *   包含錯誤處理，捕獲命令執行失敗的異常。 | *   提供關機和取消關機的功能。
    │   │   ├── cv2_utils.py    **摘要:** |  | 该 Python 脚本 `cv2_utils.py` 提供了基于 OpenCV (cv2) 的图像处理工具函数，主要用于图像的读取、保存、显示、变换、匹配和分析。 |  | **核心类和函数:** |  | *   **`read_image(file_path)`**: 读取图片，支持多种颜色空间转换。 | *   **`save_image(img, file_path)`**: 保存图片。 | *   **`show_image(img, rects=None, win_name='DEBUG', wait=None, destroy_after=False)`**: 显示图片，可绘制矩形框。 | *   **`image_rotate(img, angle, show_result=False)`**: 旋转图片。 | *   **`mark_area_as_color(image, pos, color, new_image=False)`**: 将图片的一个区域变颜色。 | *   **`match_template(source, template, threshold, mask=None, only_best=True, ignore_inf=False)`**: 模板匹配。 | *   **`concat_vertically(img, next_img, decision_height=150)`**: 垂直拼接图片。 | *   **`concat_horizontally(img, next_img, decision_width=200)`**: 水平拼接图片。 | *   **`is_same_image(i1, i2, threshold=1)`**: 判断两张图片是否相同。 | *   **`color_similarity_2d(image, color)`**: 计算颜色相似度。 | *   **`show_overlap(source, template, x, y, template_scale=1, win_name='DEBUG', wait=1)`**: 在原图上覆盖模板图。 | *   **`feature_detect_and_compute(img, mask=None)`**: 特征检测和计算。 | *   **`feature_match(source_kp, source_desc, template_kp, template_desc, source_mask=None)`**: 特征匹配。 | *   **`feature_match_for_one(...)`**: 使用特征匹配找到一个匹配结果。 | *   **`feature_match_for_multi(...)`**: 使用特征匹配找到多个匹配结果。 | *   **`connection_erase(
    │   │   ├── debug_utils.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件提供用於調試的工具函數，主要用於在工作目錄下創建和管理調試文件夾，以及保存和讀取調試圖像。 |  | **核心類和函數：** |  | *   `get_debug_dir_path()`:  獲取調試目錄的路徑。使用 `lru_cache` 進行緩存。 | *   `get_debug_image_dir_path()`: 獲取調試圖像目錄的路徑。使用 `lru_cache` 進行緩存。 | *   `get_debug_image_path(filename, suffix)`:  獲取調試圖像文件的完整路徑。 | *   `get_debug_image(filename, suffix)`:  從文件路徑讀取調試圖像。 | *   `save_debug_image(image, file_name, prefix)`:  保存調試圖像到指定路徑，支持自動生成文件名。 |  | **重要功能點：** |  | *   使用 `lru_cache` 緩存調試目錄路徑，提高效率。 | *   提供方便的函數用於創建調試圖像文件路徑。 | *   `save_debug_image` 函數將 RGB 圖像轉換為 BGR 格式後保存，並支持生成帶時間戳的文件名。 | *   使用 `log.debug` 記錄保存圖像的操作。
    │   │   ├── file_utils.py    這個 Python 文件 `file_utils.py` 提供了用於解壓縮 ZIP 文件的工具函數。 |  | *   **主要功能:** 解壓縮 ZIP 壓縮包。 | *   **核心函數:** `unzip_file(zip_file_path, unzip_dir_path)`: 接收 ZIP 文件路徑和解壓目標文件夾路徑，將 ZIP 文件解壓縮到指定文件夾。 | *   **重要功能點:** |     *   使用 `zipfile` 模塊進行 ZIP 文件處理。 |     *   包含錯誤處理，如果解壓縮失敗，則返回 `False`。
    │   │   ├── http_utils.py    這個 Python 文件 `http_utils.py` 提供了下載文件的功能。 |  | *   **主要功能:**  從給定的 URL 下載文件並保存到指定路徑，支持代理和進度回調。 | *   **核心函數:** |     *   `download_file(download_url, save_file_path, proxy=None, progress_callback=None)`:  下載文件的主要函數。 | *   **重要功能點:** |     *   支持使用代理下載文件。 |     *   提供進度回調，用於實時監控下載進度。 |     *   包含下載進度的日誌記錄。 |     *   處理下載過程中可能發生的異常。
    │   │   ├── i18_utils.py    這個 Python 文件 `i18_utils.py` 提供了多語言支持的工具函數。 |  | **主要功能:** |  | *   加載和管理不同模塊和語言的翻譯文本。 | *   提供獲取翻譯文本的函數，並支持默認值。 | *   管理和設置默認語言。 |  | **核心類和函數:** |  | *   `get_translations(model: str, lang: str)`: 加載指定模塊和語言的翻譯。 | *   `gt(msg: str, model: str = 'game', lang: str = _default_lang) -> str`: 獲取指定文本的翻譯。 | *   `coalesce_gt(msg: Optional[str], default: str, model: str = 'game', lang: str = _default_lang) -> str`: 獲取翻譯文本，如果原始文本為空，則返回默認值。 | *   `update_default_lang(lang: str)`: 更新默認語言。 | *   `get_default_lang() -> str`: 獲取默認語言。 |  | **重要功能點:** |  | *   使用 `gettext` 庫進行翻譯。 | *   根據模塊 (model) 和語言 (lang) 區分翻譯。 | *   緩存已加載的翻譯，提高效率。 | *   提供默認語言支持。 | *   `coalesce_gt` 函數提供了方便的默認值處理。
    │   │   ├── log_utils.py    這個 Python 文件 `log_utils.py` 提供了用於配置和使用日誌記錄的功能。 |  | *   **主要功能:** 設置和管理日誌記錄器，包括文件和控制台輸出，以及文本脫敏功能。 | *   **核心類和函數:** |     *   `get_logger()`:  配置並返回一個 `logging.Logger` 實例，包含文件和控制台處理程序，設置日誌格式和級別。 |     *   `set_log_level(level: int)`:  設置日誌記錄器的全局日誌級別。 |     *   `mask_text(text: str)`:  對文本進行脫敏處理，隱藏中間字符。 | *   **重要功能點:** |     *   使用 `TimedRotatingFileHandler` 實現基於時間的日誌文件輪換。 |     *   同時將日誌輸出到文件和控制台。 |     *   提供文本脫敏功能，用於保護敏感信息。 |     *   定義了全局日誌記錄器實例 `log`，方便在其他模塊中使用。
    │   │   ├── os_utils.py    ```python | # 摘要 | # 文件功能：提供与操作系统交互和时间相关的实用工具函数，包括文件路径处理、环境变量获取、时间日期格式化和计算，以及清理过期文件。 | # 核心类和函数： | #   - join_dir_path_with_mk: 拼接目录路径，如果不存在则创建。 | #   - get_path_under_work_dir: 获取当前工作目录下的子目录路径。 | #   - run_in_exe: 判断是否在exe中运行。 | #   - get_work_dir: 获取项目根目录。 | #   - get_env, get_env_def: 获取环境变量。 | #   - now_timestamp_str: 获取当前时间字符串。 | #   - get_dt: 获取当前日期字符串，支持UTC偏移。 | #   - add_dt_offset: 根据日期和偏移量计算新日期。 | #   - get_sunday_dt, get_monday_dt: 获取对应星期天/星期一的日期。 | #   - is_monday: 判断是否为星期一。 | #   - get_current_day_of_week: 获取当前星期几。 | #   - dt_day_diff: 计算两个日期之间的天数差。 | #   - clear_outdated_debug_files: 清理过期的调试文件。 | # 重要功能点： | #   - 提供了方便的路径拼接和目录创建功能。 | #   - 能够判断程序运行环境（是否为exe）。 | #   - 提供了获取环境变量的工具，并支持默认值。 | #   - 提供了多种日期和时间相关的格式化和计算函数，包括时区处理。 | #   - 能够清理过期的调试文件。 | ```
    │   │   ├── str_utils.py    這個 Python 文件 `str_utils.py` 提供了多種字符串處理工具函數。 |  | *   **主要功能:** 字符串查找、比較、數字提取和相似度匹配。 | *   **核心類和函數:** |     *   `find(source, target, ignore_case)`: 在字符串中查找子字符串。 |     *   `find_by_lcs(source, target, percent, ignore_case)`: 使用最長公共子序列 (LCS) 判斷字符串是否包含。 |     *   `longest_common_subsequence_length(str1, str2)`: 計算兩個字符串的 LCS 長度。 |     *   `get_positive_digits(v, err)`: 提取字符串中的正整數。 |     *   `get_positive_float(v, err)`: 提取字符串中的正浮點數。 |     *   `remove_not_digit(v)`: 移除字符串中的非數字字符。 |     *   `find_best_match_by_lcs(word, target_word_list, lcs_percent_threshold)`: 根據 LCS 找到最匹配的字符串。 |     *   `find_best_match_by_difflib(word, target_word_list, cutoff)`: 使用 difflib 找到最匹配的字符串。 |     *   `find_most_similar(str_list1, str_list2)`: 在兩個字符串列表中找到最匹配的一對。 |     *   `with_chinese(s)`: 判斷字符串是否包含中文。 | *   **重要功能點:** |     *   基於 LCS 的字符串相似度比較，用於 OCR 結果匹配。 |     *   使用 `difflib` 進行字符串相似度匹配。 |     *   提取字符串中的數字。 |     *   判斷字符串是否包含中文。
    │   │   ├── thread_utils.py    這個 Python 文件 `thread_utils.py` 包含用於處理線程相關操作的工具函數。 |  | *   **主要功能:** 提供一個用於處理 `concurrent.futures.Future` 執行結果的函數，用於捕獲和記錄線程執行期間發生的異常。 | *   **核心函數:** |     *   `handle_future_result(future: Future)`: 嘗試獲取 `Future` 的結果，如果發生異常，則記錄錯誤信息。 | *   **重要功能點:** |     *   異常處理：使用 `try-except` 塊捕獲 `Future` 執行期間的異常，並使用 `log.error` 記錄錯誤信息，包括堆棧跟踪。
    │   │   └── yolo_config_utils.py    這個 Python 文件 `yolo_config_utils.py` 提供了用於管理 YOLO 模型配置的工具函數。 |  | *   **主要功能:**  管理和查找 YOLO 模型文件，包括獲取模型目錄、列出可用模型以及檢查模型是否存在。 | *   **核心函數:** |     *   `get_model_category_dir(category: str) -> str`:  獲取特定類別模型的目錄路徑。 |     *   `get_available_models(category: str) -> List[str]`:  獲取指定類別下可用的模型列表。 |     *   `is_model_existed(category: str, model_name: str) -> bool`:  檢查特定模型是否存在，通過檢查 `labels.csv` 和 `model.onnx` 文件來判斷。 | *   **重要功能點:**  文件主要用於定位和驗證 YOLO 模型文件，方便後續的模型加載和使用。
    │   └── yolo/
    │       ├── detect_utils.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了用于目标检测的工具类和函数，包括检测结果的数据结构、非极大值抑制 (NMS) 算法、边界框转换以及在图像上绘制检测结果的函数。 |  | **核心类和函数:** |  | *   **DetectContext:**  存储推理过程的上下文信息，如原始图像、运行时间、图像尺寸、检测阈值等。 | *   **DetectClass:**  定义检测到的类别，包含类别 ID、名称和类别类别。 | *   **DetectObjectResult:**  表示单个检测到的目标，包含边界框坐标、置信度得分和检测类别。 | *   **DetectFrameResult:**  表示一帧图像的检测结果，包含原始图像和检测到的目标列表。 | *   **nms(boxes, scores, iou_threshold):**  执行非极大值抑制，用于过滤重叠的边界框。 | *   **multiclass\_nms(boxes, scores, class\_ids, iou\_threshold):** 执行多类别非极大值抑制。 | *   **compute\_iou(box, boxes):**  计算两个边界框之间的交并比 (IoU)。 | *   **xywh2xyxy(x):**  将边界框从 (x, y, w, h) 格式转换为 (x1, y1, x2, y2) 格式。 | *   **draw\_detections(detect\_result, mask\_alpha=0.3):**  在图像上绘制检测结果，包括边界框和标签。 | *   **draw\_text(image, text, result, font\_size, text\_thickness):** 在图像上绘制文本标签。 | *   **draw\_masks(image, results, mask\_alpha):** 在图像上绘制检测到的目标的mask。 |  | **重要功能点:** |  | *   定义了目标检测结果的数据结构，方便存储和处理检测结果。 | *   实现了 NMS 算法，用于消除冗余的检测结果。 | *   提供了边界框格式转换的工具函数。 | *   提供了在图像上可视化检测结果的函数，包括绘制边界框、标签和mask。
    │       ├── log_utils.py    這個 Python 腳本 `log_utils.py` 實現了一個用於 OneDragon-YOLO 模型的自定義日誌記錄器。 |  | *   **主要功能:**  配置和提供一個用於記錄日誌消息的全局日誌記錄器。 | *   **核心類和函數:** |     *   `get_logger()`:  創建並配置日誌記錄器。它設置了日誌級別（INFO 或 ERROR，取決於環境變量 `OD_YOLO_VERBOSE`），格式化程序，以及將日誌消息輸出到控制台的處理程序。 |     *   `log`:  `get_logger()` 函數創建的日誌記錄器實例，供其他模塊使用。 | *   **重要功能點:** |     *   基於環境變量 `OD_YOLO_VERBOSE` 決定日誌級別，控制日誌的詳細程度。 |     *   使用標準的 `logging` 模塊。 |     *   日誌消息包含時間戳、文件名、行號和日誌級別。 |     *   將日誌消息輸出到控制台。
    │       ├── onnx_model_loader.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个用于加载和管理 ONNX 模型的类 `OnnxModelLoader`。它负责从指定的 URL 下载模型，解压缩，加载到 ONNX Runtime 中，并提供获取模型输入输出信息的功能。同时支持使用备用模型，以及通过代理下载。 |  | **核心类和函数:** |  | *   **`OnnxModelLoader`**:  核心类，用于加载、下载和管理 ONNX 模型。 |     *   `__init__`: 初始化函数，设置模型名称、下载地址、代理等参数，并尝试下载和加载模型。 |     *   `check_and_download_model`: 检查模型是否存在，如果不存在则下载。 |     *   `check_model_exists`: 检查模型文件是否存在。 |     *   `download_model`: 从指定 URL 下载模型。 |     *   `unzip_model`: 解压下载的 zip 文件。 |     *   `load_model`: 加载 ONNX 模型到 ONNX Runtime。 |     *   `get_input_details`: 获取模型的输入信息，包括输入名称和尺寸。 |     *   `get_output_details`: 获取模型的输出信息，包括输出名称。 |  | **重要功能点:** |  | *   **模型下载与管理:**  支持从 URL 下载模型，并在本地存储。 | *   **代理支持:**  支持使用个人代理和 GitHub 代理进行下载。 | *   **备用模型:**  如果主模型下载失败，则使用备用模型。 | *   **GPU 加速:**  可以选择使用 GPU (DirectML) 进行推理，如果可用。 | *   **模型加载:**  使用 ONNX Runtime 加载模型。 | *   **输入/输出信息获取:**  提供获取模型输入和输出名称和尺寸的功能。 | *   **下载进度显示:**  在下载过程中显示下载进度。
    │       ├── onnx_utils.py    這個 Python 文件的主要功能是**按照 Ultralytics 的方式，將輸入圖像縮放至 ONNX 模型所需的尺寸**。 |  | 核心函數： |  | *   `scale_input_image_u(image, onnx_input_width, onnx_input_height)`：接收輸入圖像和 ONNX 模型所需的寬高，返回縮放後的圖像張量、縮放後的高度和寬度。 |  | 重要功能點： |  | *   使用 `cv2.resize` 進行圖像縮放。 | *   使用填充（padding）來保持圖像的長寬比，填充值為 114。 | *   將圖像歸一化到 0-1 範圍。 | *   將圖像轉換為模型所需的張量格式 (NCHW)。
    │       ├── yolov8_onnx_cls.py    這個 Python 文件定義了一個使用 ONNX 模型的 YOLOv8 分類器。 |  | **主要功能:** |  | *   使用 ONNX 模型進行圖像分類。 | *   提供圖像預處理、推理和後處理流程。 | *   管理識別結果的歷史記錄。 |  | **核心類和函數:** |  | *   **`RunContext`**: 儲存推理過程中的上下文信息，如圖像、時間和配置。 | *   **`ClassificationResult`**: 儲存分類結果，包括原始圖像、分類索引和運行時間。 | *   **`Yolov8Classifier`**: 繼承自 `OnnxModelLoader`，負責模型的加載、推理和結果處理。 |     *   `__init__`: 初始化分類器，加載 ONNX 模型。 |     *   `run`: 對給定的圖像進行分類，返回 `ClassificationResult`。 |     *   `prepare_input`: 預處理圖像，調整大小。 |     *   `inference`: 使用 ONNX 模型進行推理。 |     *   `process_output`: 處理推理結果，獲取分類索引和置信度。 |     *   `record_result`: 記錄識別結果的歷史記錄。 |     *   `last_run_result`: 獲取最後一次的識別結果。 |  | **重要功能點:** |  | *   使用 `OnnxModelLoader` 加載 ONNX 模型。 | *   圖像預處理包括縮放。 | *   使用置信度閾值篩選分類結果。 | *   管理識別結果的歷史記錄，並根據 `keep_result_seconds` 進行清理。
    │       ├── yolov8_onnx_det.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个 `Yolov8Detector` 类，用于使用 ONNX 格式的 YOLOv8 模型进行目标检测。它封装了模型的加载、输入预处理、推理、后处理以及结果记录等流程。 |  | **核心类和函数:** |  | *   **`Yolov8Detector(OnnxModelLoader)`**:  继承自 `OnnxModelLoader`，用于加载和运行 YOLOv8 ONNX 模型。 |     *   `__init__()`: 初始化模型，加载分类信息，并设置结果保留时间。 |     *   `run(image, conf, iou, run_time, label_list, category_list)`:  对输入图像进行目标检测，返回检测结果。 |     *   `prepare_input(context)`:  对输入图像进行预处理，包括缩放。 |     *   `inference(input_tensor)`:  使用 ONNX 运行时进行推理。 |     *   `process_output(output, context)`:  处理推理结果，进行 NMS 等后处理，生成检测结果列表。 |     *   `record_result(context, results)`:  记录检测结果。 |     *   `last_run_result`:  获取最近一次的检测结果。 |     *   `_load_detect_classes(model_dir_path)`:  从 `labels.csv` 文件加载类别信息。 |  | **重要功能点:** |  | *   **模型加载和管理**:  继承 `OnnxModelLoader`，负责模型的下载、加载和管理。 | *   **图像预处理**:  使用 `onnx_utils.scale_input_image_u` 对输入图像进行缩放。 | *   **推理**:  使用 ONNX 运行时进行推理。 | *   **后处理**:  包括置信度过滤、类别选择、边界框转换和 NMS (非极大值抑制)。 | *   **结果记录**:  保留历史检测结果，并提供获取最近结果的接口。 | *   **类别过滤**: 支持通过 `label_list` 和 `category_list` 过滤检测类别。
    │       └── yolo_utils.py    這個 Python 文件 `yolo_utils.py` 包含用於 OneDragon-YOLO 模型的下載 URL。 |  | *   **主要功能:** 定義了用於下載超分辨率 (SR) 模型和 ZZZ 模型的 URL。 | *   **核心變量:** |     *   `SR_MODEL_DOWNLOAD_URL`:  超分辨率模型的下載鏈接。 |     *   `ZZZ_MODEL_DOWNLOAD_URL`: ZZZ 模型的下載鏈接。 | *   **重要功能點:**  提供了預訓練模型的下載鏈接，方便用戶獲取模型文件。
    ├── one_dragon_qt/
    │   ├── README.md    這個文件的摘要如下： |  | *   **主要功能:** 描述了如何使用 `pyside6-rcc` 工具將資源文件 (`.qrc`) 打包成 Python 模塊 (`.py`)。 | *   **核心類和函數:**  無，此文件主要提供命令行指令。 | *   **重要功能點:** |     *   使用 `pyside6-rcc` 工具打包資源。 |     *   指定輸入文件 (`resource.qrc`) 和輸出文件 (`resource.py`)。 |     *   需要在 `_rc` 目錄下執行命令。
    │   ├── app/
    │   │   └── installer.py    **摘要：** |  | 该文件定义了一个基于 `PySide6` 和 `qfluentwidgets` 的安装程序窗口基类 `InstallerWindowBase`。它负责创建和管理安装程序的用户界面，包括窗口初始化、子界面切换和样式设置。 |  | **核心类和函数：** |  | *   `InstallerWindowBase`:  继承自 `AppWindowBase`，是安装程序的主窗口类。 |     *   `__init__`:  初始化窗口，设置标题、图标、启动画面，并创建子界面。 |     *   `create_sub_interface`:  用于创建子界面的占位符。 |     *   `add_sub_interface`:  添加子界面到导航栏。 |     *   `init_interface_on_shown`:  在子界面切换时初始化界面显示。 |     *   `init_window`:  初始化窗口的尺寸、位置、对象名称和样式。 |  | **重要功能点：** |  | *   窗口初始化：设置窗口标题、图标、启动画面和初始大小。 | *   子界面管理：添加、切换和初始化子界面。 | *   样式设置：应用预定义的样式表，包括窗口、导航栏、堆叠窗口和标题栏。 | *   事件处理：处理子界面显示和隐藏事件。 | *   配置加载：从 `OneDragonEnvContext` 加载项目配置，并设置问题报告链接。
    │   ├── services/
    │   │   └── styles_manager.py    這個 Python 文件定義了一個用於管理 One Dragon Qt 應用程式樣式的類。 |  | *   **主要功能:** 提供樣式表管理，包括定義樣式表類型和獲取樣式表文件路徑。 | *   **核心類和函數:** |     *   `OdQtStyleSheet` (繼承自 `StyleSheetBase` 和 `Enum`):  一個枚舉類，定義了各種樣式表類型，例如 `SAMPLE_CARD`, `LINK_CARD` 等，以及窗口相關的樣式。 |     *   `path(self, theme=Theme.AUTO)`:  根據主題（淺色或深色）返回對應的 `.qss` 樣式表文件路徑。 | *   **重要功能點:** |     *   使用枚舉定義樣式表類型，方便管理和引用。 |     *   根據主題動態獲取樣式表文件路徑，實現主題切換。 |     *   依賴於 `qfluentwidgets` 庫和資源文件 (`_rc`) 來加載和應用樣式。
    │   ├── utils/
    │   │   └── layout_utils.py    這個 Python 文件定義了兩個用於 GUI 佈局的簡單數據結構： |  | *   **主要功能：** 提供用於管理邊距和圖標大小的數據結構。 | *   **核心類：** |     *   `Margins`:  用於表示四個方向的邊距 (左、上、右、下)。 |     *   `IconSize`:  用於表示圖標的寬度和高度。 | *   **重要功能點：** 提供了 `Margins` 和 `IconSize` 兩個類，用於儲存和管理佈局相關的數值。
    │   ├── view/
    │   │   ├── app_run_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AppRunInterface` 类，用于在 Qt 界面中展示和控制应用程序的运行状态。它提供了一个用户界面，用于启动、停止和暂停应用程序，并显示运行状态和日志信息。 |  | **核心类和函数:** |  | *   **`AppRunner(QThread)`:** |     *   `__init__(self, ctx: OneDragonContext, app: Optional[Application] = None)`: 初始化线程，接收 `OneDragonContext` 和 `Application` 实例。 |     *   `run(self)`: 线程的运行方法，监听运行状态事件，并执行应用程序的 `execute()` 方法。 |     *   `_on_state_changed(self, ignored)`: 响应运行状态改变的槽函数，触发 `state_changed` 信号。 | *   **`AppRunInterface(VerticalScrollInterface)`:** |     *   `__init__(self, ctx: OneDragonContext, object_name: str, nav_text_cn: str, nav_icon: Union[FluentIconBase, QIcon, str] = None, parent=None)`: 初始化界面，接收 `OneDragonContext` 实例。 |     *   `get_content_widget(self) -> QWidget`: 构建界面的主要内容，包括状态显示、开始/停止按钮、日志显示卡片。 |     *   `get_widget_at_top(self) -> QWidget`:  用于获取顶部部件，留给子类实现。 |     *   `get_widget_at_bottom(self) -> QWidget`:  用于获取底部部件，留给子类实现。 |     *   `on_interface_shown(self) -> None`: 界面显示时，监听键盘事件。 |     *   `on_interface_hidden(self) -> None`: 界面隐藏时，取消所有事件监听。 |     *   `_on_key_press(self, event: ContextEventItem) -> None`: 响应键盘按键事件，触发开始运行。 |     *   `run_app(self) -> None`: 启动应用程序运行。 |     *   `get_app(self) -> Application`:  获取要运行的应用程序实例，由子类实现。 |     *   `on_context_
    │   │   ├── code_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `CodeInterface` 类，用于在 OneDragon Qt 应用程序中展示和管理代码同步相关的功能，包括 Git 代码更新、代码安装、Venv 环境管理以及 Git 日志的显示和回滚。 |  | **核心类和函数:** |  | *   **`FetchTotalRunner`**:  继承自 `QThread`，用于在后台线程中获取 Git 提交总数。 |     *   `run()`: 执行获取总数的方法，并发出 `finished` 信号。 | *   **`FetchPageRunner`**: 继承自 `QThread`，用于在后台线程中获取 Git 提交分页数据。 |     *   `run()`: 执行获取分页数据的方法，并发出 `finished` 信号。 | *   **`CodeInterface`**: 继承自 `VerticalScrollInterface`，是代码同步界面的主类。 |     *   `__init__()`: 初始化界面，包括设置界面布局、添加各种设置卡片（强制更新、Git 安装、代码安装、分支选择、Venv 安装）、创建日志表格、分页器，并连接信号和槽。 |     *   `on_interface_shown()`:  界面显示时进行初始化，包括初始化设置卡片，开始获取总数，并更新 Git、代码和 Venv 卡片的显示。 |     *   `start_fetch_total()`:  启动获取总数的线程。 |     *   `update_total()`:  更新分页器总页数，并启动获取第一页数据。 |     *   `start_fetch_page()`:  启动获取分页数据的线程。 |     *   `fetch_page()`:  从 Git 服务获取分页数据。 |     *   `update_page()`:  更新日志表格的内容。 |     *   `on_page_changed()`:  处理分页器翻页事件，重新获取并显示对应页的数据。 |     *   `_on_git_updated()`:  Git 更新完成后，更新 Git 和代码安装卡片的显示。 |     *   `on_code_updated()`:  代码同步完成后，更新 Venv 卡片的显示，重置分页，并重新获取总数。 |     *   `on_reset_commit_clicked()`:  处理回滚到特定 commit 的点击事件，执行
    │   │   ├── context_event_signal.py    這個 Python 文件定義了一個名為 `ContextEventSignal` 的類，它繼承自 `QObject`，用於在上下文事件發生時發出信號。 |  | *   **主要功能:** 提供一個信號，用於通知其他組件上下文實例已更改。 | *   **核心類:** `ContextEventSignal` 繼承自 `QObject`。 | *   **重要功能點:** |     *   `instance_changed`:  一個 `Signal`，當上下文實例發生變化時發出。 |     *   `__init__`:  初始化 `ContextEventSignal` 實例。
    │   │   ├── installer_setting_interface.py    這個 Python 文件的摘要如下： |  | *   **主要功能：** `InstallerSettingInterface` 是一個用於安裝程式設置的界面，它繼承自 `PivotNavigatorInterface`，並負責管理和顯示設置相關的子界面。 | *   **核心類和函數：** |     *   `InstallerSettingInterface`: 核心類，繼承自 `PivotNavigatorInterface`，用於管理安裝程式的設置界面。 |     *   `__init__(self, ctx: OneDragonEnvContext, parent=None)`: 構造函數，初始化界面，接收 `OneDragonEnvContext` 作為上下文。 |     *   `create_sub_interface(self)`: 創建子界面，添加 `SettingEnvInterface` 到界面中。 | *   **重要功能點：** |     *   使用 `PivotNavigatorInterface` 提供導航功能。 |     *   添加 `SettingEnvInterface` 作為子界面，用於顯示和管理環境設置。 |     *   使用 `OneDragonEnvContext` 作為上下文，提供環境相關的數據和操作。
    │   │   ├── install_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `InstallerInterface` 类，用于构建一个一键安装界面，该界面集成了 Git、代码、Python 环境和虚拟环境的安装功能，并提供进度显示和日志输出。 |  | **核心类和函数:** |  | *   **`InstallerInterface(VerticalScrollInterface)`**:  主界面类，继承自 `VerticalScrollInterface`。 |     *   `__init__(self, ctx: OneDragonEnvContext, parent=None)`: 初始化界面，接收 `OneDragonEnvContext` 上下文。 |     *   `get_content_widget(self) -> QWidget`: 构建界面内容，包括进度条、安装卡片（Git、代码、Python、Venv、AllInstallCard）和日志显示卡片。 |     *   `on_interface_shown(self) -> None`: 界面显示时，检查并更新各个组件的状态，并启动日志更新。 |     *   `on_interface_hidden(self) -> None`: 界面隐藏时，停止日志更新。 |     *   `update_progress(self, progress: float, message: str) -> None`: 更新进度条显示。 |     *   `_on_code_updated(self, success: bool) -> None`: 代码更新完成后，更新 Venv 组件的状态。 |  | **重要功能点:** |  | *   **集成安装功能**:  界面整合了 Git、代码、Python 环境和虚拟环境的安装功能，通过不同的 `InstallCard` 实现。 | *   **进度显示**:  使用 `ProgressBar` 和 `IndeterminateProgressBar` 显示安装进度。 | *   **日志显示**:  使用 `LogDisplayCard` 显示安装日志。 | *   **界面状态更新**:  `on_interface_shown` 和 `on_interface_hidden` 用于在界面显示和隐藏时更新组件状态。 | *   **组件联动**:  `_on_code_updated` 函数用于在代码更新完成后，更新 Venv 组件的状态，实现组件间的联动。 | *   **多语言支持**: 使用 `gt` 函数进行多语言支持。
    │   │   ├── like_interface.py    這個 Python 文件定義了一個名為 `LikeInterface` 的 Qt 界面，用於展示點贊相關的信息和選項。 |  | *   **主要功能:** 提供用戶點贊、支持項目的方式，包括 GitHub Star、訪問指南和贊賞。 | *   **核心類和函數:** |     *   `LikeInterface`: 繼承自 `VerticalScrollInterface`，是主要的界面類。 |     *   `get_content_widget()`: 構建界面內容，包括 `HyperlinkCard` 用於展示鏈接，`ImageLabel` 用於展示圖片。 |     *   `on_interface_shown()`: 界面顯示時的處理函數。 | *   **重要功能點:** |     *   使用 `HyperlinkCard` 展示 GitHub Star、訪問指南和贊賞鏈接。 |     *   使用 `ImageLabel` 展示贊賞的二維碼圖片。 |     *   使用 `Column` 佈局管理界面元素。 |     *   使用 `OneDragonEnvContext` 獲取項目配置信息。
    │   │   ├── devtools/
    │   │   │   ├── devtools_screen_manage_interface.py    ```python | """ | 该文件定义了 DevtoolsScreenManageInterface 类，用于在开发者工具中管理屏幕信息。 |  | 主要功能： | 1.  管理屏幕信息的创建、保存、删除和编辑。 | 2.  提供界面用于选择和显示屏幕截图。 | 3.  允许用户定义和编辑屏幕区域，包括区域名称、位置、文本、模板匹配等。 |  | 核心类和函数： | *   DevtoolsScreenManageInterface:  主界面类，继承自 VerticalScrollInterface，负责界面布局和交互。 |     *   _init_left_part(): 初始化左侧界面，包含按钮、文本框和区域表格。 |     *   _init_right_part(): 初始化右侧界面，包含图片显示和设置选项。 |     *   on_interface_shown():  界面显示时初始化，更新显示。 |     *   _update_display_by_screen():  根据屏幕信息更新界面显示。 |     *   _update_area_table_display():  更新区域表格的显示。 |     *   _update_image_display():  更新图片显示。 |     *   _on_choose_existed_yml():  选择已有的yml文件。 |     *   _on_create_clicked():  创建新的屏幕信息。 |     *   _on_save_clicked():  保存屏幕信息。 |     *   _on_delete_clicked():  删除屏幕信息。 |     *   _on_cancel_clicked():  取消编辑。 |     *   choose_existed_image():  选择已有的图片。 |     *   _on_image_chosen():  选择图片后的回调。 |     *   choose_existed_template():  选择已有的模板。 |     *   _on_template_chosen():  选择模板后的回调，导入模板区域。 |     *   _on_screen_id_changed():  屏幕ID改变。 |     *   _on_screen_name_changed():  屏幕名称改变。 |     *   _on_pc_alt_changed():  PC Alt 状态改变。 |     *   _on_area_add_clicked():  添加区域。 |     *   _on_row_delete_clicked():  删除区域。 |     *   _on_area_table_cell_changed():
    │   │   │   └── devtools_template_helper_interface.py    **摘要:** |  | *   **主要功能:**  `DevtoolsTemplateHelperInterface` 是一個用於管理和編輯模板的界面，主要用於開發工具中，允許用戶創建、修改、保存和刪除模板，並提供圖片顯示和點位編輯功能。 | *   **核心類和函數:** |     *   `DevtoolsTemplateHelperInterface`:  主界面類，繼承自 `VerticalScrollInterface`。 |     *   `_init_left_part`, `_init_mid_part`, `_init_right_part`:  初始化界面各個部分的函數，分別負責按鈕、圖片顯示和設置區域的佈局。 |     *   `_update_whole_display`:  根據模板狀態更新整個界面的顯示。 |     *   `_on_choose_existed_yml`:  處理選擇已存在模板的事件。 |     *   `_on_create_clicked`:  處理創建新模板的事件。 |     *   `_on_copy_clicked`:  處理複製模板的事件。 |     *   `_on_save_config_clicked`, `_on_save_raw_clicked`, `_on_save_mask_clicked`:  處理保存配置、原始圖片和掩碼的事件。 |     *   `_on_delete_clicked`:  處理刪除模板的事件。 |     *   `choose_existed_image`:  打開文件對話框選擇圖片。 |     *   `_on_image_clicked`:  處理在圖片上點擊事件，添加點位。 |     *   `_on_h_move_clicked`, `_on_v_move_clicked`:  處理水平和垂直移動所有點位的事件。 | *   **重要功能點:** |     *   模板的創建、複製、刪除和取消操作。 |     *   選擇和顯示模板的原始圖片、掩碼和摳圖結果。 |     *   編輯模板的子目錄、ID、名稱和形狀。 |     *   自動生成掩碼的開關。 |     *   點位的添加、刪除和編輯（通過表格）。 |     *   圖片顯示大小的調整。 |     *   通過滑鼠點擊圖片添加點位。 |     *   批量移動所有點位。
    │   │   ├── one_dragon/
    │   │   │   └── one_dragon_run_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `OneDragonRunInterface` 类，该类是用于在用户界面中管理和控制“一条龙”运行流程的界面。它提供了启动、停止、配置应用程序运行顺序和设置运行参数的功能。 |  | **核心类和函数:** |  | *   **`OneDragonRunInterface(VerticalScrollInterface)`**:  主界面类，继承自 `VerticalScrollInterface`。 |     *   `__init__`: 初始化界面，包括上下文 ( `OneDragonContext` )、导航文本、多实例和结束操作选项。 |     *   `get_content_widget`: 构建界面内容，包括左右布局，以及 `AppRunner` 实例。 |     *   `_get_left_layout`:  创建左侧布局，包含应用列表。 |     *   `_get_right_layout`: 创建右侧布局，包含运行设置、状态显示、启动/停止按钮和日志显示。 |     *   `_init_app_list`: 初始化应用列表，并根据配置设置应用运行状态。 |     *   `on_interface_shown`:  界面显示时初始化应用列表，注册事件监听器，设置配置选项。 |     *   `on_interface_hidden`:  界面隐藏时取消事件监听。 |     *   `_on_after_done_changed`: 处理“结束后”选项的更改。 |     *   `run_app`: 运行指定的应用程序。 |     *   `_on_start_clicked`:  处理“开始”按钮的点击事件。 |     *   `_on_stop_clicked`:  处理“停止”按钮的点击事件。 |     *   `_on_key_press`:  处理键盘按键事件，实现快捷键启动。 |     *   `on_context_state_changed`:  根据运行状态更新界面显示。 |     *   `_on_app_state_changed`:  处理应用状态变化。 |     *   `on_app_card_move_up`:  处理应用在列表中的上移操作。 |     *   `_on_app_card_run`:  处理运行特定应用的操作。 |     *   `on_app_switch_run`:  处理应用运行状态切换。 |     *   `_on_instance_event`:
    │   │   └── setting/
    │   │       ├── setting_custom_interface.py    ```python | 文件摘要： | 该文件定义了 `SettingCustomInterface` 类，用于在 OneDragon 应用程序中提供自定义设置界面。该界面允许用户更改主题、设置自定义主页背景。 |  | 核心类和函数： | *   `SettingCustomInterface`: 继承自 `VerticalScrollInterface`，是自定义设置界面的主类。 |     *   `__init__`: 初始化界面，设置上下文和导航文本。 |     *   `get_content_widget`: 构建界面内容，包括主题设置和自定义背景设置。 |     *   `_init_basic_group`: 初始化基本设置组，包含主题选择和自定义背景开关。 |     *   `on_interface_shown`: 初始化界面显示时，从配置适配器加载设置。 |     *   `_on_theme_changed`: 当主题改变时，更新应用程序主题。 |     *   `_on_banner_changed`: 当自定义背景开关改变时，验证密码并启用/禁用选择按钮。 |     *   `_on_banner_select_clicked`: 选择背景图片，复制到指定目录，并显示提示对话框。 |     *   `_show_dialog_after_banner_updated`: 显示设置主页背景后的对话框，提示重启。 |  | 重要功能点： | *   主题设置：使用 `ComboBoxSettingCard` 提供主题选择功能，并根据选择更新应用程序主题。 | *   自定义背景设置：使用 `SwitchSettingCard` 启用/禁用自定义背景功能，并提供密码验证和文件选择功能。 | *   密码验证：使用 SHA256 算法对密码进行哈希，验证用户输入的密码。 | *   文件选择：使用 `QFileDialog` 选择背景图片，并复制到指定目录。 | *   重启提示：在更新背景后，提示用户重启应用程序以应用更改。 | ```
    │   │       ├── setting_env_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `SettingEnvInterface` 类，用于在 Qt 界面中展示和管理脚本环境的设置。它提供了用户界面，允许用户配置调试模式、代码源、拉取方式、更新策略、Pip 源、网络代理、个人代理、GitHub 代理以及快捷键等环境相关设置。 |  | **核心类和函数:** |  | *   **`SettingEnvInterface(ctx: OneDragonEnvContext, parent=None)`**:  主界面类，继承自 `VerticalScrollInterface`，用于展示设置界面。 |     *   `__init__`: 初始化界面，接收 `OneDragonEnvContext` 实例。 |     *   `get_content_widget()`: 构建设置界面的内容，包括多个 `SettingCardGroup`。 |     *   `_init_basic_group()`: 初始化“基础”设置组，包含调试模式开关。 |     *   `_init_code_group()`: 初始化“Git 相关”设置组，包含代码源、拉取方式、强制更新、自动更新和 Pip 源设置。 |     *   `_init_web_group()`: 初始化“网络相关”设置组，包含代理类型、个人代理、GitHub 代理设置和自动获取 GitHub 代理地址。 |     *   `_init_key_group()`: 初始化“脚本按键”设置组，包含开始运行、停止运行、截图和调试快捷键设置。 |     *   `on_interface_shown()`:  界面显示时，从 `OneDragonEnvContext` 加载配置并初始化 UI 控件。 |     *   `_on_debug_changed(value: bool)`: 调试模式改变时的处理函数。 |     *   `_on_repo_type_changed(index: int, value: str)`: 代码源改变时的处理函数。 |     *   `_on_git_method_changed(index: int, value: str)`: 拉取方式改变时的处理函数。 |     *   `_on_force_update_changed(value: bool)`: 强制更新改变时的处理函数。 |     *   `_on_auto_update_changed(value: bool)`: 自动更新改变时的处理函数。 |     *   `_on_proxy_type_changed(index: int,
    │   │       └── setting_instance_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于管理和配置多个游戏实例的界面，包括实例的创建、删除、启用、登录，以及游戏路径、区服、账号和密码的设置。 |  | **核心类和函数:** |  | *   **`InstanceSettingCard`**: |     *   继承自 `MultiPushSettingCard`，用于显示和管理单个游戏实例的设置。 |     *   包含实例名称输入框、运行方式选择框、启用、登录和删除按钮。 |     *   `changed`、`active`、`login`、`delete` 信号用于与父界面交互。 |     *   `_on_name_changed`、`_on_run_changed`、`_on_active_clicked`、`_on_login_clicked`、`_on_delete_clicked` 处理用户交互事件。 |     *   `check_active` 用于更新实例的启用状态显示。 | *   **`SettingInstanceInterface`**: |     *   继承自 `VerticalScrollInterface`，是多账户管理界面的主界面。 |     *   `get_content_widget` 构建界面内容，包括引导卡片、实例设置组和实例切换组。 |     *   `_init_content_widget` 初始化界面内容，包括创建 `InstanceSettingCard` 实例。 |     *   `_get_instanceSwitch_group` 构建实例切换组，包含所有 `InstanceSettingCard` 和新增按钮。 |     *   `_get_instanceSettings_group` 构建当前账户设置组，包含游戏路径、区服、账号和密码的设置。 |     *   `_on_add_clicked` 创建新的游戏实例。 |     *   `_on_instance_changed`、`_on_instance_active`、`_on_instance_login`、`_on_instance_delete` 处理实例相关的事件。 |     *   `_on_game_path_clicked` 弹出文件选择对话框，选择游戏路径。 |     *   `_on_game_path_chosen` 更新游戏路径设置。 |     *   `init_game_account_config` 初始化游戏账号配置。 |  | **重要功能点:** |  | *   **多实例管理:** 支持创建、删除、启用和切换多个游戏实例
    │   ├── widgets/
    │   │   ├── banner.py    這個 Python 文件的主要功能是創建一個帶有圓角的橫幅小部件，用於在 Qt 應用程序中顯示圖像。 |  | 核心類： |  | *   `Banner`：繼承自 `QWidget`，負責加載、縮放和繪製橫幅圖片，並提供設置大小的方法。 |  | 核心函數： |  | *   `__init__(self, image_path: str, parent=None)`：初始化 Banner，加載圖片，並初始化縮放後的圖片。 | *   `load_banner_image(self, image_path: str)`：加載橫幅圖片，如果文件不存在，則創建一個灰色的備用圖片。 | *   `_create_fallback_image(self)`：創建一個灰色的備用圖片。 | *   `update_scaled_image(self)`：根據控件大小縮放圖片。 | *   `paintEvent(self, event)`：重載 `paintEvent`，用於繪製帶有圓角的縮放後的圖片。 | *   `resizeEvent(self, event)`：重載 `resizeEvent`，在控件大小改變時更新縮放後的圖片。 | *   `set_percentage_size(self, width_percentage, height_percentage)`：設置 Banner 的大小為父窗口大小的百分比。 |  | 重要功能點： |  | *   加載圖片，如果圖片不存在，則使用備用圖片。 | *   按比例縮放圖片，並裁剪超出部分。 | *   繪製帶有圓角的橫幅。 | *   根據控件大小變化更新圖片。 | *   支持設置橫幅大小為父窗口的百分比。
    │   │   ├── base_interface.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 定義了一個 `BaseInterface` 類，用於包裝應用程式中子頁面的基本功能，包括導航文本、圖標和生命週期回調。 |  | **核心類和函數：** |  | *   `BaseInterface`: 繼承自 `QWidget`，是所有子頁面的基類。 |     *   `__init__(self, object_name: str, nav_text_cn: str, nav_icon: Union[FluentIconBase, QIcon, str] = None, parent=None)`: 構造函數，初始化頁面的導航相關屬性。 |     *   `on_interface_shown(self) -> None`: 子界面顯示時的回調函數，用於初始化。 |     *   `on_interface_hidden(self) -> None`: 子界面隱藏時的回調函數。 |  | **重要功能點：** |  | *   提供了一個基類，用於統一管理子頁面的導航信息（文本和圖標）。 | *   定義了子頁面顯示和隱藏時的回調函數，方便子頁面的初始化和清理工作。 | *   使用 `gt` 函數進行文本國際化。
    │   │   ├── click_image_label.py    這個 Python 文件定義了一個名為 `ClickImageLabel` 的自定義 `ImageLabel` 小部件，它擴展了 `qfluentwidgets` 庫中的 `ImageLabel`。 |  | *   **主要功能:** 實現帶有鼠標點擊和拖動事件處理的圖像顯示。 | *   **核心類和函數:** |     *   `ImageScaleEnum`: 是一個枚舉，用於定義圖像縮放比例。 |     *   `ClickImageLabel`: 繼承自 `ImageLabel`，重寫了 `mousePressEvent` 和 `mouseReleaseEvent` 方法，以處理鼠標點擊和拖動事件。 |         *   `clicked_with_pos`:  信號，在鼠標點擊時發射，傳遞點擊位置的 x 和 y 坐標。 |         *   `drag_released`: 信號，在鼠標釋放時發射，傳遞拖動的起始和結束位置的 x 和 y 坐標。 |         *   `mousePressEvent(self, event: QMouseEvent)`: 處理鼠標按下事件，記錄按下位置，並發射 `clicked_with_pos` 信號。 |         *   `mouseReleaseEvent(self, event: QMouseEvent)`: 處理鼠標釋放事件，記錄釋放位置，並發射 `drag_released` 信號。 | *   **重要功能點:** |     *   鼠標點擊事件處理，發射 `clicked_with_pos` 信號。 |     *   鼠標拖動事件處理，發射 `drag_released` 信號，提供拖動的起始和結束位置。
    │   │   ├── column.py    這個 Python 文件定義了一個名為 `Column` 的自定義 Qt widget，它使用垂直佈局 (`QVBoxLayout`) 來排列其子 widget。 |  | *   **核心類:** `Column` (繼承自 `QWidget`) | *   **核心函數:** |     *   `__init__`: 初始化 `Column` widget，創建垂直佈局。 |     *   `add_widget`: 將 widget 添加到垂直佈局中，可以設置 stretch 和對齊方式。 |     *   `remove_widget`: 從垂直佈局中移除指定的 widget。 |     *   `add_stretch`: 在垂直佈局中添加 stretch。 |     *   `clear_widgets`: 移除垂直佈局中的所有 widget。 | *   **重要功能點:** 提供了一個方便的方式來創建具有垂直佈局的自定義 widget，方便添加、移除和管理子 widget。
    │   │   ├── combo_box.py    這個 Python 文件定義了一個自定義的 `ComboBox` 控件，它繼承自 `qfluentwidgets.ComboBox`，並增加了處理 `ConfigItem` 列表的功能。 |  | *   **主要功能:**  提供一個可更新選項的下拉框，並支持根據目標值初始化。 | *   **核心類和函數:** |     *   `ComboBox`: 自定義的下拉框控件。 |     *   `set_items(self, items: List[ConfigItem], target_value: Any = None)`:  更新下拉框的選項，盡量複用現有選項，並設置當前選中的值。 |     *   `init_with_value(self, target_value: Any = None)`: 根據目標值初始化下拉框，禁用信號以避免觸發事件。 | *   **重要功能點:** |     *   高效的選項更新，嘗試複用現有選項以提高性能。 |     *   支持根據 `ConfigItem` 列表更新選項，`ConfigItem` 包含 `ui_text` 和 `value` 屬性。 |     *   提供初始化方法，允許在不觸發信號的情況下設置選定的值。 |     *   使用 `blockSignals` 禁用和啟用信號，以避免在更新選項時觸發不必要的事件。
    │   │   ├── cv2_image.py    這個 Python 文件 `cv2_image.py` 定義了一個 `Cv2Image` 類，它繼承自 `QImage`，用於將 OpenCV (cv2) 的圖像轉換為 Qt 的 `QImage` 格式，以便在 Qt 應用程序中顯示。 |  | *   **核心類:** `Cv2Image` | *   **核心函數:** `__init__(self, cv_image: MatLike)` 構造函數，接收一個 OpenCV 的圖像 (`MatLike` 類型) 作為輸入。 | *   **重要功能點:** |     *   根據 OpenCV 圖像的通道數和類型（灰度、BGR、BGRA）進行轉換。 |     *   使用 `cv2.cvtColor` 函數將灰度圖像轉換為 RGB 圖像。 |     *   直接使用 BGR 或 BGRA 圖像。 |     *   使用轉換後的 OpenCV 圖像的數據、寬度、高度和格式（`Format_RGB888`）創建 `QImage` 對象。
    │   │   ├── editable_combo_box.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了一個自定義的 `EditableComboBox` 小部件，它繼承自 `qfluentwidgets.EditableComboBox`，並增加了根據 `ConfigItem` 列表更新選項、初始化值以及設置自動補全器的功能。 |  | **核心類和函數:** |  | *   **`EditableComboBox`**:  繼承自 `qtEditableComboBox`，是主要的小部件類。 |     *   `__init__(self, parent=None)`:  初始化函數。 |     *   `set_items(self, items: List[ConfigItem], target_value: Any = None)`:  更新下拉列表的選項，並盡量複用現有選項，同時設置當前選中的值。 |     *   `init_with_value(self, target_value: Any = None)`:  根據目標值初始化下拉列表，不觸發信號。 |     *   `set_completer_options(self, options_list: List[ConfigItem])`:  初始化自動補全器，設置大小寫不敏感和包含匹配模式。 |  | **重要功能點:** |  | *   **選項更新**:  `set_items` 方法高效地更新下拉列表的選項，通過複用現有選項來優化性能。 | *   **值初始化**:  `init_with_value` 方法允許在不觸發信號的情況下初始化下拉列表的選定值。 | *   **自動補全**:  `set_completer_options` 方法為下拉列表設置了自動補全功能，包括大小寫不敏感的匹配和包含匹配模式，提升了用戶體驗。
    │   │   ├── game_dialog.py    這個 Python 文件定義了一個 `GameDialog` 類，它是一個用於在遊戲加載時顯示的自定義對話框。 |  | *   **主要功能:** 顯示帶有跳躍動畫的文本，用於指示遊戲正在加載。 | *   **核心類和函數:** |     *   `GameDialog`: 繼承自 `MaskDialogBase`，用於創建對話框。 |         *   `__init__(self, text: str, parent=None)`: 初始化對話框，設置陰影、遮罩顏色，創建文本標籤，並啟動計時器。 |         *   `animate_text(self)`: 觸發文本動畫。 |         *   `jump_start(self)`: 開始跳躍動畫。 |         *   `jump_end(self)`: 結束跳躍動畫。 |         *   `update_index(self)`: 更新當前文本標籤的索引。 |         *   `close_dialog(self)`: 關閉對話框並停止計時器。 | *   **重要功能點:** |     *   使用 `QTimer` 定時觸發文本動畫。 |     *   使用 `QPropertyAnimation` 實現文本標籤的跳躍動畫。 |     *   使用 `OdQtStyleSheet.GAME_DIALOG.apply(self)` 應用樣式。 |     *   循環顯示文本，每個字符交替跳躍。
    │   │   ├── icon_button.py    這個 Python 文件定義了一個名為 `IconButton` 的自定義按鈕小部件，它繼承自 `TransparentToolButton` 並添加了工具提示功能。 |  | *   **主要功能:** 創建一個帶有圖標的按鈕，並在鼠標懸停時顯示工具提示。 | *   **核心類:** `IconButton` 繼承自 `TransparentToolButton`。 | *   **重要功能點:** |     *   `__init__`: 具有多個重載，用於初始化按鈕，可以接受圖標、工具提示的標題和內容作為參數。 |     *   `eventFilter`: 監聽鼠標進入和離開事件，並分別調用 `_show_tooltip` 和 `_hide_tooltip`。 |     *   `_show_tooltip`: 創建並顯示 `TeachingTip` 作為工具提示，並設置其位置。 |     *   `_hide_tooltip`: 關閉工具提示。 |     *   `__hash__` 和 `__eq__`: 實現了對象的哈希和相等性比較。
    │   │   ├── label.py    這個 Python 文件定義了一個名為 `EllipsisLabel` 的自定義 QLabel 小部件，它會在文本超出其可用寬度時自動添加省略號。 |  | *   **核心類:** `EllipsisLabel` (繼承自 QLabel) | *   **核心函數:** |     *   `__init__`: 初始化 QLabel 並設置文本。 |     *   `setText`: 設置文本，並調用 `updateText`。 |     *   `resizeEvent`: 處理調整大小事件，並調用 `updateText`。 |     *   `updateText`:  根據 QLabel 的寬度截斷文本，並添加省略號。 | *   **重要功能點:**  當文本過長時，使用省略號截斷文本以適應 QLabel 的寬度。
    │   │   ├── log_display_card.py    這個 Python 文件定義了一個用於在 Qt 應用程序中顯示和管理日誌的 `LogDisplayCard` 小部件。 |  | *   **主要功能:** 實時顯示來自 `logging` 模塊的日誌消息，支持啟動、暫停、停止和自動滾動功能，並提供日誌格式化和顏色高亮顯示。 | *   **核心類和函數:** |     *   `LogSignal`:  用於發射新日誌信號的 `QObject`。 |     *   `LogReceiver`:  繼承自 `logging.Handler`，用於接收日誌消息，緩存日誌，並獲取新日誌。 |         *   `emit(self, record)`:  將新日誌記錄添加到日誌隊列。 |         *   `get_new_logs(self) -> list[str]`:  獲取新的日誌。 |         *   `clear_logs(self)`:  清空日誌隊列。 |     *   `LogDisplayCard`:  繼承自 `PlainTextEdit`，用於顯示日誌。 |         *   `init_color(self)`:  根據主題設置文本顏色。 |         *   `start(self, clear_log: bool = False)`:  啟動日誌顯示。 |         *   `pause(self)`:  暫停日誌顯示。 |         *   `stop(self)`:  停止日誌顯示。 |         *   `update_logs(self) -> None`:  更新日誌顯示區域。 |         *   `_format_logs(self, log_list: list[str]) -> str`:  格式化日誌，包括顏色高亮顯示。 | *   **重要功能點:** |     *   使用 `LogReceiver` 接收和緩存日誌。 |     *   使用 `QTimer` 定期更新日誌顯示。 |     *   支持自動滾動到最新的日誌消息。 |     *   提供啟動、暫停和停止日誌顯示的功能。 |     *   對日誌消息中的特定文本（例如方括號內的文本）進行顏色高亮顯示。 |     *   限制顯示的日誌行數。
    │   │   ├── notice_card.py    ## 摘要 |  | 該 Python 文件定義了一個用於在 Qt 應用程式中顯示遊戲公告的 `NoticeCard` 控件。它從米哈遊的 API 獲取公告數據，並以輪播橫幅和列表的形式顯示。 |  | **核心類和函數:** |  | *   **`DataFetcher`**: 繼承自 `QThread`，負責從 API 獲取公告數據，包括橫幅圖片和文章列表。它使用緩存機制（文件緩存，有效期 3 天）來減少 API 調用，並處理網絡錯誤。 |     *   `run()`: 執行數據獲取，包括 API 請求、數據解析、緩存保存和相關文件下載。 |     *   `is_cache_valid()`: 檢查緩存是否有效。 |     *   `save_cache()`: 保存數據到緩存文件。 |     *   `download_related_files()`: 下載與公告相關的文件。 |     *   `data_fetched`:  信號，用於發布獲取的數據。 | *   **`NoticeCard`**: 繼承自 `SimpleCardWidget`，是顯示公告的主控件。 |     *   `__init__()`: 初始化控件，設置佈局，並啟動數據獲取。 |     *   `fetch_data()`: 創建並啟動 `DataFetcher` 執行數據獲取。 |     *   `handle_data()`: 處理從 `DataFetcher` 接收到的數據，更新 UI。 |     *   `load_banners()`: 加載橫幅圖片。 |     *   `load_posts()`: 加載公告文章。 |     *   `setup_ui()`: 設置 UI 元素，包括橫幅輪播、文章列表和導航標籤。 |     *   `update_ui()`: 更新 UI，例如在數據加載後重新添加橫幅和文章。 |     *   `scrollNext()`: 輪播到下一張橫幅。 |     *   `addSubInterface()`: 添加子界面到堆疊窗口和導航標籤。 |     *   `onCurrentIndexChanged()`: 當堆疊窗口的索引更改時更新導航標籤。 |     *   `open_banner_link()`: 打開橫幅鏈接。 |     *   `open_
    │   │   ├── pivot.py    這個 Python 文件定義了用於構建導航欄和選項卡的自定義 Qt 小部件。 |  | **主要功能:** |  | *   創建自定義的 Pivot 控件，用於導航和選項卡。 | *   提供 PivotItem 的自定義實現，用於顯示導航選項。 | *   提供一個容器小部件，用於管理 Pivot 控件和 StackedWidget，實現頁面切換。 |  | **核心類和函數:** |  | *   **PhosPivot:** 繼承自 `qfluentwidgets.Pivot`，用於創建自定義的 Pivot 控件。 |     *   `insertItem()`: 插入 PivotItem。 |     *   `insertWidget()`: 插入 PivotItem 和間隔。 |     *   `paintEvent()`: 繪製指示器。 | *   **PhosPivotItem:** 繼承自 `qfluentwidgets.components.navigation.pivot.PivotItem`，表示 Pivot 中的單個選項。 |     *   `setSelected()`: 設置選項的選擇狀態。 | *   **CustomListItemDelegate:** 繼承自 `qfluentwidgets.ListItemDelegate`，用於自定義列表項的繪製。 | *   **PivotNavigatorContainer:** 包含 Pivot 和 StackedWidget，用於管理頁面導航。 |     *   `add_sub_interface()`: 添加子界面到 StackedWidget 和 Pivot。 |     *   `on_current_index_changed()`: 處理 StackedWidget 的 currentChanged 信號，更新 Pivot 的選擇狀態和路由。 |  | **重要功能點:** |  | *   自定義 Pivot 控件的樣式和行為。 | *   使用動畫來指示當前選中的選項。 | *   通過 `PivotNavigatorContainer` 實現頁面導航和切換。 | *   使用 `qrouter` 進行路由管理。 | *   使用 `OdQtStyleSheet` 應用樣式。
    │   │   ├── pivot_navi_interface.py    這個 Python 文件定義了一個 `PivotNavigatorInterface` 類，它是一個用於管理多個子界面的導航界面，使用 `Pivot` 和 `QStackedWidget` 實現。 |  | *   **主要功能:** 提供一個帶有導航欄的界面，用於在多個子界面之間切換。 | *   **核心類和函數:** |     *   `PivotNavigatorInterface`: 繼承自 `BaseInterface`，是主要的導航界面類。 |         *   `__init__`: 初始化界面，包括 `Pivot`、`QStackedWidget` 和佈局。 |         *   `add_sub_interface`: 添加子界面到 `QStackedWidget` 和 `Pivot`。 |         *   `create_sub_interface`: 創建子界面的虛擬函數，需要子類實現。 |         *   `on_current_index_changed`: 當 `QStackedWidget` 的當前索引改變時，更新 `Pivot` 的選中項和觸發界面顯示/隱藏的回調。 |         *   `on_interface_shown`: 子界面顯示時的回調。 |         *   `on_interface_hidden`: 子界面隱藏時的回調。 | *   **重要功能點:** |     *   使用 `Pivot` 實現導航欄。 |     *   使用 `QStackedWidget` 管理子界面。 |     *   `add_sub_interface` 函數用於添加子界面，並將其添加到 `Pivot` 和 `QStackedWidget` 中。 |     *   `on_current_index_changed` 函數用於處理界面切換時的邏輯，包括更新 `Pivot` 的選中項和觸發界面顯示/隱藏的回調。 |     *   使用 `qrouter` 進行路由管理。
    │   │   ├── row.py    這個 Python 文件定義了一個名為 `Row` 的自定義 Qt widget，用於水平排列其他 widget。 |  | *   **核心類:** `Row` (繼承自 `QWidget`) | *   **核心函數:** |     *   `__init__(self, parent=None)`: 初始化 `Row` widget，並創建一個 `QHBoxLayout`。 |     *   `add_widget(self, widget: QWidget, stretch: int = 0, alignment: Qt.AlignmentFlag = Qt.AlignmentFlag.AlignLeft)`:  將給定的 widget 添加到水平佈局中，可以指定拉伸因子和對齊方式。 |     *   `add_stretch(self, stretch: int)`:  向水平佈局添加彈簧，用於控制 widget 之間的間距。 | *   **重要功能點:**  提供一個水平佈局容器，方便在 Qt 應用程序中組織和排列 widget。
    │   │   ├── shared_battle_dialog.py    ## 摘要 |  | 该文件定义了一个 `SharedConfigDialog` 类，用于显示和管理共享的自动战斗配置。它允许用户从远程服务器下载配置，并管理本地存储的配置。 |  | **核心类和函数:** |  | *   **`SharedConfigDialog(FramelessDialog)`**:  主对话框，用于显示在线和本地配置列表，并提供下载和删除功能。 |     *   `init_ui()`: 初始化 UI 界面，包括搜索栏、在线配置表格、本地配置表格和按钮。 |     *   `load_data_from_api()`: 从 API 获取在线配置信息，并填充在线配置表格。 |     *   `populate_online_table(data: list[BattleInfo])`: 将从 API 获取的配置数据填充到在线配置表格中。 |     *   `on_download_clicked()`:  处理下载按钮点击事件，从服务器下载选定的配置。 |     *   `load_local_configs()`: 加载本地配置文件，并在本地配置表格中显示。 |     *   `delete_local_config(file_path)`:  删除本地配置文件。 |     *   `filter_table(text: str)`: 根据搜索栏的输入过滤在线配置表格。 |     *   `show_error(title: str, content: str)`: 显示错误提示对话框。 |     *   `find_project_root(start_path, marker="src")`: 查找项目根目录。 |     *   `save_downloaded_file(file_name, data, base_folder)`: 保存下载的文件。 |  | *   **`BattleInfo`**:  一个数据类，用于存储战斗配置的信息。 |  | **重要功能点:** |  | *   **在线配置列表**: 从远程服务器获取并显示可用的配置列表。 | *   **本地配置列表**: 显示本地存储的配置，并提供删除功能。 | *   **下载功能**:  允许用户下载选定的在线配置。 | *   **搜索功能**:  允许用户搜索在线配置。 | *   **错误处理**:  提供错误提示，处理网络请求和文件操作中的异常。 | *   **文件管理**:  下载和保存配置文件到本地，并提供删除本地文件的功能。
    │   │   ├── vertical_scroll_interface.py    這個 Python 文件定義了一個名為 `VerticalScrollInterface` 的類，它繼承自 `BaseInterface`，用於創建具有垂直滾動功能的子頁面。 |  | **主要功能:** |  | *   提供一個可垂直滾動的界面，用於顯示內容。 | *   在子頁面顯示時進行初始化，包括佈局設置。 |  | **核心類和函數:** |  | *   `VerticalScrollInterface`:  主要的類，用於創建垂直滾動的子頁面。 |     *   `__init__(...)`:  初始化函數，接收內容部件、對象名稱、導航文本和圖標等參數。 |     *   `on_interface_shown()`:  子界面顯示時調用的函數，用於初始化佈局。 |     *   `_init_layout()`:  初始化佈局，包括創建垂直佈局、滾動區域，並將內容部件添加到滾動區域。 |     *   `get_content_widget()`:  抽象方法，由子類實現，用於提供子界面中的內容部件。 |  | **重要功能點:** |  | *   使用 `SingleDirectionScrollArea` 實現垂直滾動。 | *   在子界面顯示時才進行佈局初始化，提高性能。 | *   `get_content_widget()` 方法允許子類自定義內容部件。 | *   設置了內容部件和滾動區域的樣式，使其背景透明，並移除邊框。
    │   │   ├── welcome_dialog.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个欢迎对话框，用于在应用程序首次运行时向用户展示重要信息和操作指引。 |  | **核心类和函数:** |  | *   `WelcomeDialog`:  继承自 `MessageBoxBase`，是欢迎对话框的主类。 |     *   `__init__(self, parent=None)`: 初始化对话框，设置标题、内容和按钮。 |     *   `_setup_buttons(self)`:  创建并设置“快速开始”、“自助排障”和“开源地址”等按钮，并绑定点击事件，打开相应的 URL。 |     *   `_start_countdown(self)`:  启动一个 5 秒倒计时，用于启用“确定”按钮。 |     *   `_update_countdown(self)`:  更新“确定”按钮上的倒计时文本，并在倒计时结束后启用该按钮。 |  | **重要功能点:** |  | *   显示欢迎信息，强调软件的开源免费性质，并提醒用户注意安全。 | *   提供“快速开始”、“自助排障”和“开源地址”等按钮，方便用户获取帮助和了解项目。 | *   实现 5 秒倒计时，在倒计时结束后启用“确定”按钮，引导用户继续操作。
    │   │   ├── install_card/
    │   │   │   ├── all_install_card.py    這個 Python 文件定義了一個名為 `AllInstallCard` 的 Qt 窗口部件，用於一次性安裝多個組件。 |  | **主要功能:** |  | *   提供一個“一鍵安裝”功能，按順序安裝多個 `BaseInstallCard` 實例。 | *   提供“啟動一條龍”按鈕，用於啟動應用程式。 |  | **核心類和函數:** |  | *   `AllInstallCard`: 繼承自 `BaseInstallCard`，負責管理多個安裝卡片的安裝流程。 |     *   `__init__`: 初始化，接收一個 `OneDragonEnvContext` 和一個 `BaseInstallCard` 列表。 |     *   `install_all`: 啟動所有安裝卡片的安裝流程。 |     *   `on_install_done`: 處理單個安裝卡片完成的回調，啟動下一個安裝或更新 UI。 |     *   `_on_run_clicked`: 處理“啟動一條龍”按鈕的點擊事件，啟動應用程式。 |  | **重要功能點:** |  | *   使用 `BaseInstallCard` 的 `finished` 信號來觸發安裝完成的回調。 | *   按順序安裝 `install_cards` 列表中的卡片。 | *   提供安裝指南的超連結。 | *   提供“啟動一條龍”按鈕。
    │   │   │   ├── base_install_card.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于安装和状态检查的自定义 Qt 界面组件，主要用于在用户界面中展示安装进度、状态信息和执行安装操作。 |  | **核心类和函数:** |  | *   **`InstallRunner(QThread)`:**  一个 QThread，用于在后台执行安装方法。 |     *   `run()`:  执行安装方法，并处理进度更新和完成信号。 |     *   `progress_callback()`:  进度回调函数，用于将进度信息传递给主线程。 | *   **`DisplayChecker(QThread)`:**  一个 QThread，用于在后台检查并获取显示内容。 |     *   `run()`: 执行获取显示内容的方法，并发送完成信号。 | *   **`BaseInstallCard(MultiPushSettingCard)`:**  继承自 `MultiPushSettingCard` 的基类，用于创建安装卡片。 |     *   `__init__()`:  初始化卡片，包括设置标题、按钮、安装运行器和显示检查器。 |     *   `start_progress()`:  启动安装进程。 |     *   `update_progress()`:  更新安装进度。 |     *   `on_progress_done()`:  安装完成后处理。 |     *   `after_progress_done()`:  安装完成后的回调函数，由子类实现。 |     *   `check_and_update_display()`:  检查并更新显示状态。 |     *   `get_display_content()`:  获取显示内容，由子类实现。 |     *   `update_display()`:  更新显示。 |  | **重要功能点:** |  | *   **多线程操作:** 使用 `QThread` 在后台执行安装和状态检查，避免阻塞 UI 线程。 | *   **进度更新:**  通过信号和槽机制，将安装进度和信息传递给 UI。 | *   **状态显示:**  支持显示安装状态，包括图标和文本。 | *   **可扩展性:**  `BaseInstallCard` 提供了抽象方法，允许子类自定义安装行为和状态显示。 | *   **用户交互:**  包含一个安装按钮，用于触发安装操作。
    │   │   │   ├── code_install_card.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | `CodeInstallCard` 是一個用於在 One Dragon 應用程序中顯示和管理代碼版本安裝狀態的 UI 卡片。它允許用戶同步代碼，並顯示代碼的當前狀態，包括是否已同步、是否為最新版本以及分支信息。 |  | **核心類和函數:** |  | *   `CodeInstallCard`: 繼承自 `BaseInstallCard`，負責顯示代碼安裝狀態的 UI 元素。 |     *   `__init__(self, ctx: OneDragonEnvContext, parent=None)`: 初始化卡片，設置標題、安裝方法（`ctx.git_service.fetch_latest_code`）和按鈕文本。 |     *   `after_progress_done(self, success: bool, msg: str) -> None`:  在代碼同步完成後的回調函數，更新顯示狀態。 |     *   `get_display_content(self) -> Tuple[QIcon, str]`: 獲取要顯示的狀態信息，包括圖標和文本，根據 Git 狀態（例如分支、是否為最新版本）進行顯示。 |  | **重要功能點:** |  | *   **代碼同步:** 使用 `ctx.git_service.fetch_latest_code` 同步代碼。 | *   **狀態顯示:** 根據 Git 狀態顯示不同的信息，包括是否已同步、分支信息和更新提示。 | *   **國際化:** 使用 `gt` 函數進行文本的國際化。 | *   **更新提示:** 在代碼更新後，提示用戶需要重啟腳本。 | *   **錯誤處理:** 針對 Git 未配置或未同步的情況，提供相應的提示。
    │   │   │   ├── git_install_card.py    這個 Python 文件定義了一個名為 `GitInstallCard` 的 Qt 窗口部件，用於處理 Git 的安裝和配置。 |  | **核心類和函數:** |  | *   **`GitInstallCard(ctx: OneDragonEnvContext)`**:  繼承自 `WithExistedInstallCard`，初始化 Git 安裝卡片，並設置安裝方法。 | *   **`get_existed_os_path() -> Optional[str]`**:  獲取系統環境變量中 Git 的路徑。 | *   **`on_existed_chosen(file_path: str) -> None`**:  當選擇本地 Git 文件後的回調，更新環境配置。 | *   **`after_progress_done(success: bool, msg: str) -> None`**:  安裝完成後的回調，更新顯示狀態。 | *   **`get_display_content() -> Tuple[QIcon, str]`**:  根據 Git 的安裝狀態，返回顯示的圖標和文本信息。 |  | **重要功能點:** |  | *   集成 `WithExistedInstallCard`，提供已存在安裝的處理邏輯。 | *   使用 `OneDragonEnvContext` 獲取環境配置和 Git 服務。 | *   根據 Git 的安裝狀態（未安裝、文件不存在、版本獲取失敗、已安裝）顯示不同的狀態信息。 | *   支持選擇已存在的 Git 執行文件，並更新配置。 | *   使用 i18n 進行多語言支持。
    │   │   │   ├── python_install_card.py    這個 Python 腳本定義了一個名為 `PythonInstallCard` 的 Qt 窗口部件，用於管理和顯示 Python 虛擬環境的安裝狀態。 |  | *   **主要功能:** 顯示 Python 虛擬環境的安裝狀態，並提供安裝選項。 | *   **核心類和函數:** |     *   `PythonInstallCard`: 繼承自 `WithExistedInstallCard`，負責管理 Python 虛擬環境的顯示和安裝。 |     *   `__init__(self, ctx: OneDragonEnvContext)`: 初始化函數，設置標題和安裝方法。 |     *   `get_existed_os_path(self) -> Optional[str]`: 獲取系統環境變量中的 Python 路徑。 |     *   `on_existed_chosen(self, file_path: str) -> None`: 選擇本地 Python 文件後的回調函數。 |     *   `after_progress_done(self, success: bool, msg: str) -> None`: 安裝完成後的回調函數。 |     *   `get_display_content(self) -> Tuple[QIcon, str]`: 根據 Python 環境狀態返回顯示的圖標和文本。 | *   **重要功能點:** |     *   檢查 Python 虛擬環境是否已安裝，以及版本是否匹配。 |     *   根據 Python 環境狀態顯示不同的圖標和提示信息。 |     *   提供選擇本地 Python 文件或默認安裝的選項。
    │   │   │   ├── venv_install_card.py    這個 Python 文件定義了一個名為 `VenvInstallCard` 的 Qt 界面組件，用於顯示和管理 Python 虛擬環境的依賴項安裝狀態。 |  | *   **主要功能:** 顯示虛擬環境依賴項的安裝狀態，並提供安裝功能。 | *   **核心類:** `VenvInstallCard` 繼承自 `BaseInstallCard`，負責處理依賴項安裝的 UI 展示和狀態更新。 | *   **重要功能點:** |     *   `__init__`: 初始化卡片，設置標題和安裝方法。 |     *   `after_progress_done`: 安裝完成後的回調函數，根據安裝結果更新顯示，並更新依賴項時間戳。 |     *   `get_display_content`: 獲取要顯示的狀態信息，包括圖標和文本，用於指示依賴項是否需要更新。
    │   │   │   └── wtih_existed_install_card.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件定義了一個 `WithExistedInstallCard` 類，用於在 OneDragon 應用程序中處理已存在安裝的安裝卡。它允許用戶選擇已安裝的可執行文件，並提供相應的回調處理。 |  | **核心類和函數：** |  | *   `WithExistedInstallCard`: 繼承自 `BaseInstallCard`，負責處理已存在安裝的邏輯。 |     *   `__init__`: 初始化卡片，包括選擇文件按鈕。 |     *   `choose_existed_file`: 彈出文件選擇對話框，讓用戶選擇已安裝的可執行文件。 |     *   `get_existed_os_path`: 獲取系統環境變量中的路徑（由子類實現）。 |     *   `on_existed_chosen`: 選擇文件後的回調函數（由子類實現）。 |  | **重要功能點：** |  | *   提供一個按鈕，用於選擇已安裝的可執行文件。 | *   使用 `QFileDialog` 讓用戶選擇 `.exe` 文件。 | *   提供 `get_existed_os_path` 和 `on_existed_chosen` 兩個抽象方法，供子類實現特定於環境的邏輯。 | *   在選擇文件後，觸發 `finished` 信號。
    │   │   └── setting_card/
    │   │       ├── app_run_card.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | `AppRunCard` 是一個用於在應用程式設定介面中顯示和控制應用程式運行的卡片。它展示了應用程式的名稱、運行狀態，並提供了向上移動、運行和切換啟動狀態的功能。 |  | **核心類和函數:** |  | *   **`AppRunCard`**: 繼承自 `MultiPushSettingCard`，負責顯示應用程式的資訊和控制元件。 |     *   `__init__(self, app: Application, switch_on: bool = False, parent: Optional[QWidget] = None)`: 初始化卡片，設置應用程式、按鈕和信號連接。 |     *   `update_display(self) -> None`: 更新卡片的顯示，包括標題、內容和圖標，反映應用程式的運行狀態。 |     *   `_on_move_up_clicked(self) -> None`: 處理向上移動按鈕的點擊事件，發射 `move_up` 信號。 |     *   `_on_run_clicked(self) -> None`: 處理運行按鈕的點擊事件，發射 `run` 信號。 |     *   `_on_switch_changed(self, value: bool) -> None`: 處理開關按鈕的狀態變化事件，發射 `switched` 信號。 |     *   `set_app(self, app: Application)`: 更新卡片關聯的應用程式，並更新顯示。 |     *   `setDisabled(self, arg__1: bool) -> None`: 禁用卡片及其子元件。 |     *   `set_switch_on(self, on: bool) -> None`: 設置開關按鈕的狀態。 | *   **`MultiPushSettingCard`**: 來自 `one_dragon_qt.widgets.setting_card.multi_push_setting_card`，是 `AppRunCard` 的父類，提供多按鈕設置卡片的基本結構。 | *   **`Application`**: 來自 `one_dragon.base.operation.application_base`，表示應用程式的基類。 | *   **`AppRunRecord`**: 來自 `one_dragon.base.operation.application_run_record`，用於記錄
    │   │       ├── check_box_setting_card.py    這個 Python 文件的主要功能是創建一個帶有複選框的設置卡片，用於在 Qt 應用程序中顯示和修改布爾值設置。 |  | 核心類和函數： |  | *   **CheckBoxSettingCard**: 繼承自 `SettingCardBase`，是主要的設置卡片類。 |     *   `__init__`: 初始化卡片，包括設置圖標、標題、內容、邊距和複選框。 |     *   `_on_value_changed`: 當複選框狀態改變時，發射 `value_changed` 信號。 |     *   `setContent`: 覆蓋父類的 `setContent` 方法，用於更新左側的詳細文本，並支持國際化。 |     *   `setValue`: 設置複選框的值。 | *   `value_changed`:  `Signal(bool)`，當複選框的值改變時發射的信號。 |  | 重要功能點： |  | *   使用 `CheckBox` 控件來顯示和修改布爾值。 | *   通過信號和槽機制，將複選框的狀態變化與 `value_changed` 信號連接起來，以便外部可以監聽值的變化。 | *   提供 `setContent` 方法，用於更新卡片的內容，並支持國際化。 | *   提供 `setValue` 方法，用於設置複選框的狀態。
    │   │       ├── combo_box_setting_card.py    **摘要:** |  | 该文件定义了 `ComboBoxSettingCard` 类，它是一个自定义的设置卡片，用于在 Qt 应用程序中显示带有下拉框的设置选项。 |  | **核心类和函数:** |  | *   **`ComboBoxSettingCard`**: 继承自 `SettingCardBase`，用于创建包含下拉框的设置卡片。 |     *   `__init__()`: 初始化卡片，包括创建 `ComboBox` 控件，设置选项，连接信号与槽。 |     *   `_initialize_options()`: 从枚举或 `ConfigItem` 列表初始化下拉框选项。 |     *   `eventFilter()`: 处理标题标签的鼠标事件，用于显示和隐藏工具提示。 |     *   `with_tooltip`: 属性，判断是否有工具提示。 |     *   `_show_tooltip()`: 显示工具提示。 |     *   `_hide_tooltip()`: 隐藏工具提示。 |     *   `set_options_by_list()`: 通过 `ConfigItem` 列表设置下拉框选项。 |     *   `init_with_adapter()`: 初始化配置适配器。 |     *   `_on_index_changed()`: 当下拉框索引改变时，更新描述并发射 `value_changed` 信号。 |     *   `_update_desc()`: 更新描述显示。 |     *   `setValue()`: 设置下拉框的值。 |     *   `getValue()`: 获取当前选中的值。 |  | **重要功能点:** |  | *   使用下拉框选择配置选项。 | *   支持从枚举或 `ConfigItem` 列表初始化下拉框选项。 | *   提供工具提示功能，用于显示选项的详细信息。 | *   通过 `YamlConfigAdapter` 与配置文件交互。 | *   当下拉框的值改变时，发射 `value_changed` 信号。 | *   支持设置和获取下拉框的值。
    │   │       ├── editable_combo_box_setting_card.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个 `EditableComboBoxSettingCard` 类，用于创建包含可编辑下拉框的设置卡片。它继承自 `SettingCardBase`，并提供了从枚举或列表初始化下拉框选项、处理工具提示、设置自动补全、响应值变化等功能。 |  | **核心类和函数:** |  | *   **`EditableComboBoxSettingCard`**:  核心类，继承自 `SettingCardBase`，用于创建可编辑下拉框设置卡片。 |     *   `__init__`: 初始化卡片，包括创建 `EditableComboBox`，设置选项，连接信号与槽。 |     *   `_initialize_options`:  从枚举或列表初始化下拉框选项。 |     *   `eventFilter`:  处理标题标签的鼠标事件，用于显示和隐藏工具提示。 |     *   `_show_tooltip`:  显示工具提示。 |     *   `_hide_tooltip`:  隐藏工具提示。 |     *   `set_options_by_list`:  通过 `ConfigItem` 列表设置下拉框选项。 |     *   `init_with_adapter`: 初始化配置适配器。 |     *   `set_completer_options`:  设置自动补全器。 |     *   `_on_index_changed`:  当下拉框索引改变时，发射 `value_changed` 信号。 |     *   `_update_desc`:  更新描述显示。 |     *   `setValue`:  设置下拉框的值。 |     *   `getValue`:  获取当前选中的值。 |  | **重要功能点:** |  | *   **可编辑下拉框**: 使用 `EditableComboBox` 组件，允许用户输入自定义值。 | *   **选项初始化**:  支持从 `Enum` 或 `List[ConfigItem]` 初始化下拉框选项。 | *   **工具提示**:  在标题上显示工具提示，提供额外信息。 | *   **自动补全**:  提供自动补全功能，方便用户选择。 | *   **值改变信号**:  `value_changed` 信号，用于通知外部值已更改。 | *   **配置适配器集成**:  与 `YamlConfigAdapter` 集成，用于配置值的存储和加载。 | *   **动态描述更新**:  根据选中的选项更新描述。
    │   │       ├── key_setting_card.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个 `KeySettingCard` 类，用于在设置界面中显示和编辑键盘按键设置。它继承自 `SettingCardBase`，并使用 `PushButton` 来触发按键监听，从而允许用户设置键盘快捷键。 |  | **核心类和函数:** |  | *   **`KeyEventWorker`**:  一个 `QObject`，用于在按键按下时发出 `key_pressed` 信号。 |     *   `on_key_press(self, key: str)`: 接收按键，并发出 `key_pressed` 信号。 | *   **`KeySettingCard`**: 继承自 `SettingCardBase`，用于显示和编辑键盘按键设置。 |     *   `__init__(...)`:  初始化 `KeySettingCard`，包括设置 UI 元素（`PushButton`），连接信号和槽，以及初始化按键监听器。 |     *   `_on_btn_clicked()`:  当按钮被点击时，启动按键监听器。 |     *   `_on_key_press(self, key)`:  当监听到按键时，停止监听器，并将按键传递给 `key_worker`。 |     *   `_on_key_signal(self, key: str)`:  接收来自 `key_worker` 的信号，设置 `value`，并使用 `YamlConfigAdapter` 保存设置。 |     *   `init_with_adapter(self, adapter: YamlConfigAdapter)`:  使用 `YamlConfigAdapter` 初始化值。 |     *   `setContent(self, content: str)`:  设置卡片内容文本，并进行国际化翻译。 |     *   `setValue(self, value: str, emit_signal: bool = True)`:  设置按键值，更新按钮文本，并发出 `value_changed` 信号。 |     *   `_stop_listener()`:  停止键盘和鼠标的监听。 |  | **重要功能点:** |  | *   **按键监听:**  使用 `PcButtonListener` 监听键盘和鼠标事件，获取按键输入。 | *   **信号和槽机制:**  使用信号和槽来处理按键事件，更新 UI 和保存设置。 | *   **配置适配器:**  使用 `
    │   │       ├── multi_push_setting_card.py    這個 Python 文件定義了兩個自定義的設置卡片類，用於在 Qt 應用程序中顯示帶有多個按鈕的設置選項。 |  | *   **主要功能:** 創建具有自定義圖標、標題、內容和按鈕的設置卡片，並支持多個按鈕的水平或多行排列。 | *   **核心類和函數:** |     *   `MultiPushSettingCard`: 繼承自 `SettingCardBase`，用於創建帶有多個水平排列按鈕的設置卡片。 |     *   `MultiLineSettingCard`: 繼承自 `SettingCardBase`，用於創建帶有多行按鈕的設置卡片。 |     *   `__init__`: 兩個類都重寫了初始化函數，用於設置卡片的屬性，包括圖標、標題、內容、邊距和按鈕。 | *   **重要功能點:** |     *   使用 `QHBoxLayout` 和 `QVBoxLayout` 佈局管理按鈕的排列。 |     *   `MultiPushSettingCard` 水平排列按鈕，並在右側對齊。 |     *   `MultiLineSettingCard` 垂直排列多行按鈕，每行按鈕水平排列，並在右側對齊。 |     *   `MultiLineSettingCard` 根據按鈕行數調整卡片高度。
    │   │       ├── push_setting_card.py    這個 Python 文件定義了一個名為 `PushSettingCard` 的自定義設置卡片小部件，它繼承自 `SettingCardBase`。 |  | *   **主要功能:** 創建一個帶有推送按鈕的設置卡片，用於在 UI 中顯示設置信息。 | *   **核心類和函數:** |     *   `PushSettingCard`: 繼承自 `SettingCardBase`，負責創建和管理帶有按鈕的設置卡片。 |     *   `__init__(...)`: 構造函數，初始化卡片的 UI 元素，包括圖標、標題、內容和按鈕。 | *   **重要功能點:** |     *   `clicked` 信號:  當按鈕被點擊時發射的信號。 |     *   使用 `QPushButton` 創建按鈕，並將其添加到卡片的水平布局中。 |     *   將按鈕的 `clicked` 信號連接到 `PushSettingCard` 的 `clicked` 信號，以便外部可以響應按鈕點擊事件。
    │   │       ├── setting_card_base.py    這個 Python 文件定義了一個名為 `SettingCardBase` 的自定義設置卡片小部件，它繼承自 `qfluentwidgets.SettingCard`。 |  | *   **主要功能:** 創建一個可定制的設置卡片，用於在 Qt 應用程序中顯示設置選項。它支持標題、內容和可選的圖標。 | *   **核心類和函數:** |     *   `SettingCardBase`:  繼承自 `SettingCard`，是主要的設置卡片類。 |     *   `__init__(self, icon, title, content, icon_size, margins, parent)`:  初始化設置卡片，設置布局，添加標題、內容和圖標。 |     *   `setContent(self, content)`:  設置卡片的內容文本，並根據內容是否為空來設置其可見性。 |     *   `setIconSize(self, width, height)`:  設置圖標的固定大小。 | *   **重要功能點:** |     *   使用 `QHBoxLayout` 和 `QVBoxLayout` 進行布局。 |     *   支持自定義圖標、標題和內容。 |     *   使用 `gt` 函數進行國際化。 |     *   使用 `FluentStyleSheet.SETTING_CARD.apply(self)` 應用 Fluent UI 樣式。 |     *   根據內容是否為空來控制內容標籤的可見性。 |     *   提供設置圖標大小的功能。
    │   │       ├── switch_setting_card.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 此文件定義了一個 `SwitchSettingCard` 類，它是一個帶有切換開關的設置卡片，用於在 Qt 應用程序中顯示和管理布爾值設置。它繼承自 `SettingCardBase`，並集成了 `SwitchButton`。 |  | **核心類和函數:** |  | *   `SwitchSettingCard`:  繼承自 `SettingCardBase`，實現了帶有切換開關的設置卡片。 |     *   `__init__`: 初始化卡片，包括設置圖標、標題、內容、邊距，創建 `SwitchButton`，並將其添加到布局中。 |     *   `_on_value_changed`:  當切換開關的值改變時觸發，更新配置適配器中的值，並發出 `value_changed` 信號。 |     *   `init_with_adapter`: 使用配置適配器初始化切換開關的值。 |     *   `setValue`: 設置切換開關的狀態，並更新文本。 | *   `SettingCardBase`:  基類，提供設置卡片的基本結構。 | *   `SwitchButton`:  來自 `qfluentwidgets` 庫的切換按鈕。 | *   `YamlConfigAdapter`:  用於從 YAML 配置文件讀取和寫入設置的適配器。 |  | **重要功能點:** |  | *   使用 `SwitchButton` 實現切換開關。 | *   使用 `YamlConfigAdapter` 讀取和寫入設置值。 | *   `value_changed` 信號用於通知外部，切換開關的值已更改。 | *   支持自定義圖標、標題、內容和邊距。 | *   支持本地化文本。
    │   │       ├── text_setting_card.py    **摘要:** |  | 该文件定义了一个 `TextSettingCard` 类，用于在 Qt 界面中创建带有文本输入框的设置卡片。它继承自 `SettingCardBase`，并提供了文本输入、密码模式切换、以及与配置适配器交互的功能。 |  | **核心类和函数:** |  | *   **`TextSettingCard`**:  继承自 `SettingCardBase`，用于创建带文本输入框的设置卡片。 |     *   `__init__`: 初始化卡片，创建 `LineEdit` 输入框，并根据 `is_password` 参数设置密码模式。 |     *   `_toggle_password_visibility`: 切换密码显示模式（明文/密文）。 |     *   `_on_text_changed`:  处理文本更改事件，更新配置适配器中的值，并发出 `value_changed` 信号。 |     *   `init_with_adapter`: 使用配置适配器初始化输入框的值。 |     *   `setValue`: 设置输入框的值，并可以选择是否发出信号。 |  | **重要功能点:** |  | *   **文本输入框**:  使用 `LineEdit` 控件提供文本输入功能。 | *   **密码模式**:  通过 `is_password` 参数启用密码模式，并提供切换显示/隐藏明文的按钮。 | *   **配置适配器集成**:  与 `YamlConfigAdapter` 集成，用于保存和加载设置值。 | *   **信号**:  `value_changed` 信号，用于在文本值更改时发出通知。 | *   **可定制性**:  支持自定义图标、标题、内容、输入框占位符、最大宽度和边距。
    │   │       ├── yaml_config_adapter.py    這個 Python 文件定義了一個 `YamlConfigAdapter` 類，用於適配和操作 `YamlConfig` 實例中的特定配置字段。 |  | *   **主要功能:** 提供一個接口，用於獲取和設置 `YamlConfig` 中的配置值，並支持數據類型轉換。 | *   **核心類:** `YamlConfigAdapter` | *   **重要功能點:** |     *   `__init__`: 初始化 `YamlConfigAdapter` 實例，接收 `YamlConfig` 實例、字段名、默認值以及可選的 getter 和 setter 轉換器。 |     *   `get_value`: 獲取 `YamlConfig` 中指定字段的值，並根據 `getter_convert` 進行類型轉換（`str`, `int`, `float`）。 |     *   `set_value`: 設置 `YamlConfig` 中指定字段的值，並根據 `setter_convert` 進行類型轉換，然後使用 `config.update` 更新配置。
    │   │       └── yolo_model_card.py    這個 Python 文件定義了一個用於下載 YOLO 模型的自定義設置卡。 |  | **主要功能:** |  | *   提供一個下拉框，用於選擇不同的 YOLO 模型。 | *   提供一個下載按鈕，用於下載所選模型。 | *   顯示模型下載狀態。 |  | **核心類和函數:** |  | *   `DownloadRunner`:  一個 QThread，用於在後台下載模型。 |     *   `run()`:  執行模型下載，使用 `OnnxModelLoader`。 |     *   `finished`:  信號，指示下載完成並帶有成功/失敗狀態和消息。 | *   `ModelDownloadSettingCard`:  繼承自 `MultiPushSettingCard`，用於顯示模型選擇和下載控件。 |     *   `__init__()`:  初始化卡片，包括下拉框、下載按鈕和連接信號。 |     *   `set_options_by_list()`:  使用給定的選項列表更新下拉框。 |     *   `_on_index_changed()`:  當下拉框的選中項更改時發送信號。 |     *   `setContent()`:  更新卡片的內容文本。 |     *   `setValue()`:  設置下拉框的選中值。 |     *   `getValue()`:  獲取下拉框的當前選中值。 |     *   `check_and_update_display()`:  檢查模型是否已下載，並更新下載按鈕的狀態。 |     *   `_on_download_click()`:  處理下載按鈕的點擊事件，啟動下載線程。 |     *   `_on_download_finish()`:  處理下載完成信號，更新 UI。 |  | **重要功能點:** |  | *   使用 `QThread` 在後台執行模型下載，避免阻塞 UI。 | *   使用 `OnnxModelLoader` 進行模型下載。 | *   提供下載狀態指示，包括“下載中”、“已下載”和錯誤消息。 | *   使用 `MultiPushSettingCard` 佈局，包含下拉框和按鈕。 | *   使用 `ConfigItem` 存儲下拉框選項的值。
    │   ├── windows/
    │   │   ├── app_window_base.py    這個 Python 文件定義了一個名為 `AppWindowBase` 的基類，用於創建應用程序的主窗口。 |  | **主要功能:** |  | *   創建和初始化應用程序的主窗口，包括設置窗口標題、圖標和大小。 | *   管理子界面的創建和顯示，並在界面切換時觸發初始化操作。 | *   提供添加子界面的方法。 |  | **核心類和函數:** |  | *   `AppWindowBase`: 繼承自 `PhosWindow`，是主窗口的基類。 |     *   `__init__(self, win_title: str, project_config: ProjectConfig, app_icon: Optional[str] = None, parent=None)`: 初始化窗口，設置標題、圖標，創建啟動頁面，並初始化子界面。 |     *   `create_sub_interface(self) -> None`: 虛擬函數，用於創建子界面，由子類實現。 |     *   `add_sub_interface(self, interface: BaseInterface, position=NavigationItemPosition.TOP)`: 添加子界面到導航欄。 |     *   `init_window(self)`: 初始化窗口大小和位置。 |     *   `init_interface_on_shown(self, index: int) -> None`: 在子界面顯示時觸發初始化操作，包括隱藏上一個界面和顯示當前界面。 |  | **重要功能點:** |  | *   使用 `SplashScreen` 顯示啟動頁面。 | *   使用 `stackedWidget` 管理子界面，並在界面切換時觸發 `on_interface_hidden` 和 `on_interface_shown` 方法。 | *   提供添加子界面的方法，並設置導航欄中的位置。 | *   設置窗口的標題和圖標。
    │   │   └── window.py    **摘要:** |  | 该 Python 文件定义了用于构建 One Dragon 应用程序窗口的自定义窗口部件。它基于 `qfluentwidgets` 库，并提供了 Fluent Design 风格的界面。 |  | **核心类和函数:** |  | *   **`PhosFluentWindowBase`**:  一个基类，继承自 `BackgroundAnimationWidget` 和 `FramelessWindow`，用于提供窗口的基础功能。 | *   **`PhosWindow`**:  主窗口类，继承自 `MSFluentWindow` 和 `PhosFluentWindowBase`。它负责窗口的整体布局，包括导航栏 (`PhosNavigationBar`)、堆叠部件 (`PhosStackedWidget`) 和标题栏 (`PhosTitleBar`)。 |     *   `setAeroEffectEnabled(self, isEnabled: bool)`:  控制 Aero 磨砂效果的启用和禁用。 |     *   `_onThemeChangedFinished(self)`:  响应主题变化，更新 Aero 效果。 |     *   `resizeEvent(self, e)`:  重写调整大小事件，调整标题栏的位置和大小。 | *   **`PhosNavigationBar`**:  自定义导航栏，继承自 `NavigationBar`。它包含导航项，并管理路由切换。 |     *   `insertItem(...)`:  插入导航项。 |     *   `_onWidgetClicked(self)`:  处理导航按钮的点击事件，进行路由切换。 | *   **`PhosNavigationBarPushButton`**:  自定义导航按钮，继承自 `NavigationBarPushButton`。它定义了按钮的样式和外观，包括图标、文本和背景颜色。 |     *   `paintEvent(self, event)`:  重写绘制事件，自定义按钮的绘制。 |     *   `_get_bg_color(self)`: 获取自适应主题的背景颜色 |     *   `_get_icon_color(self)`: 获取图标颜色(含选中状态处理) |     *   `_get_text_color(self)`: 获取文本颜色 |     *   `setSelected(self, isSelected)`: 更新选中状态 | *   **`PhosTitleBar`**:  自定义标题栏，继承自 `SplitTitleBar`。它包含窗口图标、标题、版本信息和反馈按钮。 |     *   `setIcon(self, icon: QIcon)`:  设置
    │   └── _rc/
    │       └── resource.py    ## 摘要 |  | **1. 文件主要功能:** |  | 這個 Python 文件定義了 Qt 資源，包含 CSS 樣式表和二進制數據，用於設定應用程式的 UI 外觀。它使用 PySide6 庫來管理和註冊這些資源。 |  | **2. 核心類和函數:** |  | *   **`qInitResources()`**:  初始化資源，將 CSS 樣式表和二進制數據註冊到 Qt 資源系統中。 | *   **`qCleanupResources()`**: 清理資源，從 Qt 資源系統中取消註冊。 | *   **`qt_resource_data`**:  包含 CSS 樣式表的二進制數據。 | *   **`qt_resource_name`**: 包含資源名稱的二進制數據。 | *   **`qt_resource_struct`**: 包含資源結構的二進制數據。 |  | **3. 重要功能點:** |  | *   **CSS 樣式表:**  定義了多個 UI 元素的樣式，例如標題、日期、列表、堆疊部件、錯誤提示、導航界面、按鈕等。 樣式表包含淺色和深色兩種主題。 | *   **資源管理:** 使用 `QtCore.qRegisterResourceData` 和 `QtCore.qUnregisterResourceData` 函數來管理 Qt 資源。 | *   **UI 外觀定制:**  通過 CSS 樣式表，可以定制應用程式的 UI 外觀，包括顏色、字體、邊框、背景等。 | *   **主題切換:** 包含淺色和深色兩種主題的樣式，可能用於支持應用程序的主題切換功能。
    ├── onnxocr/
    │   ├── cls_postprocess.py    這個 Python 文件 `cls_postprocess.py` 實現了一個用於文本分類的後處理類 `ClsPostProcess`。 |  | *   **主要功能:** 將分類模型的預測結果轉換為可讀的文本標籤，並可選擇與真實標籤進行比較。 | *   **核心類和函數:** |     *   `ClsPostProcess`: 類，用於執行分類後處理。 |     *   `__init__`: 初始化函數，接收標籤列表和可選的 key。 |     *   `__call__`: 核心函數，接收模型的預測結果，將其轉換為文本標籤，並可選地與真實標籤進行比較。 | *   **重要功能點:** |     *   使用 `argmax` 找到每個預測的最高概率標籤的索引。 |     *   使用 `label_list` 將索引轉換為文本標籤。 |     *   如果提供了真實標籤，則返回預測結果和真實標籤。
    │   ├── db_postprocess.py    ## 摘要 |  | 該 Python 文件定義了用於 DB (Differentiable Binarization) 後處理的類，主要用於文本檢測任務。 |  | **核心類和函數:** |  | *   **DBPostProcess:**  執行 DB 模型的後處理，包括： |     *   `__init__`: 初始化後處理參數，如閾值、框閾值、unclip 比例等。 |     *   `polygons_from_bitmap`: 從二值化圖像中提取多邊形框。 |     *   `boxes_from_bitmap`: 從二值化圖像中提取矩形框。 |     *   `unclip`:  對框進行擴張操作。 |     *   `get_mini_boxes`:  獲取最小外接矩形框。 |     *   `box_score_fast`:  快速計算框的置信度分數。 |     *   `box_score_slow`:  慢速計算框的置信度分數。 |     *   `__call__`:  執行整個後處理流程，從模型輸出中提取文本框。 | *   **DistillationDBPostProcess:**  用於蒸餾場景的 DB 後處理，它包裝了 DBPostProcess，並處理多個模型的輸出。 |  | **重要功能點:** |  | *   從模型輸出（二值化圖）中提取文本框。 | *   支持多邊形框和矩形框的提取。 | *   使用 unclip 操作擴張文本框。 | *   計算框的置信度分數。 | *   支持蒸餾場景，處理多個模型的輸出。
    │   ├── imaug.py    這個 Python 文件 `imaug.py` 實現了圖像增強（augmentation）的功能，主要用於 OCR 領域。 |  | *   **主要功能:** 提供圖像轉換和操作符創建的工具，用於圖像預處理和數據增強。 | *   **核心類和函數:** |     *   `transform(data, ops=None)`: 應用一系列操作符 `ops` 到輸入數據 `data` 上。 |     *   `create_operators(op_param_list, global_config=None)`: 根據配置列表 `op_param_list` 創建一系列操作符。 | *   **重要功能點:** |     *   使用 `onnxocr.operators` 模塊中的操作符。 |     *   `transform` 函數支持鏈式操作，允許將多個圖像處理操作串聯起來。 |     *   `create_operators` 函數動態創建操作符，並支持全局配置。 |     *   通過 `eval` 函數根據字符串名稱實例化操作符，增加了配置的靈活性。
    │   ├── logger.py    這個 Python 文件 `logger.py` 實現了一個自定義的日誌記錄器。 |  | *   **主要功能:** 提供一個全局的日誌記錄器，用於記錄程序運行時的調試信息和錯誤信息。 | *   **核心類和函數:** |     *   `Logger` 類：初始化和配置日誌記錄器。 |     *   `initLogger()` 方法：配置日誌記錄器的格式、輸出目標（控制台和文件）。 |     *   `GetLog()` 函數：返回全局的日誌記錄器實例。 | *   **重要功能點:** |     *   使用 `logging` 模塊創建和配置日誌記錄器。 |     *   日誌輸出到控制台和文件 (目前文件輸出被註釋掉)。 |     *   定義了日誌的格式，包括級別、時間、消息、文件、函數、行號和線程信息。 |     *   提供一個全局的 `LOG` 實例，方便在其他模塊中使用。
    │   ├── onnx_paddleocr.py    代码摘要： |  | 该Python文件定义了一个基于ONNX的PaddleOCR文本识别系统，并提供了OCR功能。 |  | *   **主要功能:** |     *   使用ONNX模型进行文本检测、识别和分类。 |     *   提供 `ocr` 函数，用于对图像进行OCR处理，支持检测、识别和分类的组合。 |     *   提供 `sav2Img` 函数，用于将OCR结果绘制到图像上并保存。 |     *   包含一个 `ONNXPaddleOcr` 类，用于初始化模型并执行OCR。 | *   **核心类和函数:** |     *   `ONNXPaddleOcr` 类: 继承自 `TextSystem`，用于初始化模型和执行OCR。 |         *   `__init__`: 初始化模型，加载参数。 |         *   `ocr`: 执行OCR，根据参数选择是否进行检测、识别和分类。 |     *   `sav2Img` 函数: 将OCR结果绘制到图像上并保存。 | *   **重要功能点:** |     *   支持自定义模型路径、是否使用GPU等参数。 |     *   `ocr` 函数根据参数灵活控制OCR流程。 |     *   提供示例代码，演示如何使用 `ONNXPaddleOcr` 类进行OCR。 |     *   使用 `draw_ocr` 函数将结果可视化。
    │   ├── operators.py    此 Python 文件定義了用於圖像預處理的自定義操作符，主要用於 OCR 任務。 |  | *   **主要功能:** 實現圖像的歸一化、調整大小和通道順序轉換，以及選擇性地保留數據中的特定鍵。 | *   **核心類和函數:** |     *   `NormalizeImage`: 歸一化圖像，包括縮放、減去均值和除以標準差。 |     *   `DetResizeForTest`: 調整圖像大小，支持多種調整大小類型，包括保持比例。 |         *   `resize_image_type0`: 調整圖像大小，使圖像的邊長是 32 的倍數。 |         *   `resize_image_type1`: 調整圖像大小，保持比例。 |         *   `resize_image_type2`: 調整圖像大小，根據長邊進行調整。 |     *   `ToCHWImage`: 將圖像的通道順序從 HWC 轉換為 CHW。 |     *   `KeepKeys`: 保留數據字典中指定的鍵。 | *   **重要功能點:** |     *   支持不同的調整大小策略，包括保持比例和調整到特定尺寸。 |     *   `DetResizeForTest` 類中的調整大小操作會計算圖像的縮放比例，並將其儲存在 `data['shape']` 中。 |     *   `NormalizeImage` 類使用預定義的均值和標準差進行歸一化。 |     *   `ToCHWImage` 類用於將圖像的通道順序轉換為模型所需的格式。
    │   ├── predict_base.py    這個 Python 文件 `predict_base.py` 定義了一個基類 `PredictBase`，用於使用 ONNX Runtime 進行模型預測。 |  | *   **主要功能:** 提供基礎功能，用於加載 ONNX 模型、獲取輸入/輸出名稱，以及構建輸入 feed。 | *   **核心類:** `PredictBase` | *   **核心函數:** |     *   `get_onnx_session(self, model_dir, use_gpu)`: 根據 `use_gpu` 參數選擇 CPU 或 GPU 執行提供者，並加載 ONNX 模型。 |     *   `get_output_name(self, onnx_session)`: 獲取 ONNX 模型的所有輸出名稱。 |     *   `get_input_name(self, onnx_session)`: 獲取 ONNX 模型的所有輸入名稱。 |     *   `get_input_feed(self, input_name, image_numpy)`: 構建用於模型推理的輸入 feed 字典。 | *   **重要功能點:** |     *   支持 GPU 和 CPU 執行。 |     *   獲取模型的輸入和輸出名稱，為後續推理做準備。 |     *   構建輸入 feed，將圖像數據與輸入名稱關聯起來。
    │   ├── predict_cls.py    這個 Python 文件定義了一個 `TextClassifier` 類，用於使用 ONNX 模型對文本圖像進行分類，主要用於文字方向校正。 |  | **核心類和函數:** |  | *   **`TextClassifier(PredictBase)`**: 繼承自 `PredictBase`，負責文本圖像的分類。 |     *   `__init__(self, args)`: 初始化分類器，包括模型路徑、圖像形狀、批次大小、置信度閾值和後處理操作。 |     *   `resize_norm_img(self, img)`: 調整圖像大小並進行歸一化處理，以符合模型的輸入要求。 |     *   `__call__(self, img_list)`: 核心函數，接收圖像列表，對圖像進行預處理，使用 ONNX 模型進行預測，並進行後處理以獲取分類結果。它還根據分類結果旋轉圖像。 |  | **重要功能點:** |  | *   **圖像預處理**: 調整圖像大小、歸一化和填充，以符合模型的輸入形狀。 | *   **ONNX 模型推理**: 使用 ONNX 運行時加載和執行分類模型。 | *   **後處理**: 使用 `ClsPostProcess` 類處理模型的輸出，獲取文本方向的預測結果。 | *   **圖像旋轉**: 如果預測到文本方向為 180 度，則旋轉圖像。 | *   **批次處理**: 為了提高效率，對圖像進行批次處理。 | *   **排序優化**: 根據圖像的寬高比對圖像進行排序，以加速分類過程。
    │   ├── predict_det.py    這個 Python 腳本定義了一個文本檢測器，它使用 ONNX 模型來檢測圖像中的文本區域。 |  | **主要功能：** |  | *   文本檢測：使用 ONNX 模型預測圖像中的文本框。 | *   預處理和後處理：對圖像進行預處理，並對模型輸出進行後處理以提取文本框。 | *   邊界框過濾：過濾掉過小或超出圖像邊界的邊界框。 |  | **核心類和函數：** |  | *   `TextDetector(PredictBase)`：繼承自 `PredictBase`，用於初始化模型、預處理和後處理操作，以及執行文本檢測。 |     *   `__init__(self, args)`：初始化檢測器，包括加載模型、設置預處理和後處理操作。 |     *   `__call__(self, img)`：對輸入圖像執行文本檢測，返回檢測到的文本框。 |     *   `order_points_clockwise(self, pts)`：將邊界框的點按順時針排序。 |     *   `clip_det_res(self, points, img_height, img_width)`：將邊界框的點裁剪到圖像邊界內。 |     *   `filter_tag_det_res(self, dt_boxes, image_shape)`：過濾掉過小或不合理的邊界框。 |     *   `filter_tag_det_res_only_clip(self, dt_boxes, image_shape)`：僅裁剪邊界框到圖像邊界內。 |  | **重要功能點：** |  | *   使用 `onnxruntime` 運行 ONNX 模型。 | *   使用 `transform` 和 `create_operators` 進行圖像預處理。 | *   使用 `DBPostProcess` 進行後處理，提取文本框。 | *   支持多種邊界框類型（'poly'）。 | *   邊界框過濾，以提高檢測質量。
    │   ├── predict_rec.py    ## 摘要 |  | 該 Python 腳本定義了一個 `TextRecognizer` 類，用於使用 ONNX 模型進行文本識別。它繼承自 `PredictBase` 類，並使用不同的圖像預處理方法，具體取決於所使用的識別算法。 |  | **核心類和函數:** |  | *   **`TextRecognizer(PredictBase)`**: 文本識別器類，初始化模型、圖像形狀、批次大小和後處理操作。 |     *   `__init__(self, args)`: 初始化 TextRecognizer，加載模型，設置參數。 |     *   `resize_norm_img(self, img, max_wh_ratio)`: 根據不同的識別算法，對圖像進行調整大小和歸一化處理。 |     *   `__call__(self, img_list)`: 核心函數，接收圖像列表，預處理圖像，使用 ONNX 模型進行預測，並使用後處理操作解碼結果。 |     *   `resize_norm_img_vl(self, img, image_shape)`: 圖像預處理函數，用於 ViL 算法。 |     *   `resize_norm_img_srn(self, img, image_shape)`: 圖像預處理函數，用於 SRN 算法。 |     *   `srn_other_inputs(self, image_shape, num_heads, max_text_length)`: SRN 算法的輔助輸入生成。 |     *   `process_image_srn(self, img, image_shape, num_heads, max_text_length)`: SRN 算法的圖像處理流程。 |     *   `resize_norm_img_sar(self, img, image_shape, width_downsample_ratio=0.25)`: 圖像預處理函數，用於 SAR 算法。 |     *   `resize_norm_img_spin(self, img)`: 圖像預處理函數，用於 SPIN 算法。 |     *   `resize_norm_img_svtr(self, img, image_shape)`: 圖像預處理函數，用於 SVTR 算法。 |     *   `resize_norm_img_abinet(self, img, image_shape)`: 圖像預處理函數，用於 ABINet 算法。 |     *
    │   ├── predict_system.py    這個 Python 腳本 `predict_system.py` 實現了一個文本檢測和識別系統。 |  | *   **主要功能:** 整合文本檢測、方向分類（可選）和文本識別，用於從圖像中提取文本。 | *   **核心類和函數:** |     *   `TextSystem`: 系統的主類，初始化文本檢測器、文本識別器和（可選）文本分類器。`__call__` 方法執行整個流程，包括檢測、裁剪、分類（如果啟用）和識別。 |     *   `sorted_boxes`: 對檢測到的文本框進行排序，從上到下，從左到右。 | *   **重要功能點:** |     *   使用 `TextDetector` 檢測文本框。 |     *   使用 `get_rotate_crop_image` 或 `get_minarea_rect_crop` 裁剪文本區域。 |     *   可選地使用 `TextClassifier` 進行方向分類。 |     *   使用 `TextRecognizer` 識別文本。 |     *   根據 `drop_score` 篩選結果。 |     *   `draw_crop_rec_res` 函數用於保存裁剪後的圖像。
    │   ├── readme.md    這個文件的摘要如下： |  | **主要功能：** |  | *   說明文件，描述了 OnnxOCR 專案的相關資訊。 |  | **核心類和函數：** |  | *   無程式碼，只有說明文字。 |  | **重要功能點：** |  | *   說明文件指出專案是從 GitHub 上的 OnnxOCR 專案複製而來。 | *   更新時間為 2024.08.08。 | *   說明了將模型、字體和文本放置在 `assets/models/onnx_ocr` 目錄中的變更。
    │   ├── rec_postprocess.py    這個 Python 腳本定義了多個用於光學字符識別 (OCR) 後處理的類，主要功能是將模型預測的索引轉換為文本標籤。 |  | 核心類和函數： |  | *   **BaseRecLabelDecode**: 基礎類，定義了字符字典的初始化、特殊字符的添加、以及將索引解碼為文本的基本方法 `decode`。 | *   **CTCLabelDecode**: 繼承自 `BaseRecLabelDecode`，專門用於 CTC (Connectionist Temporal Classification) 模型，處理 CTC 模型的輸出，並移除重複字符。 | *   **DistillationCTCLabelDecode**: 繼承自 `CTCLabelDecode`，用於蒸餾訓練，處理多個模型的輸出。 | *   **AttnLabelDecode**: 繼承自 `BaseRecLabelDecode`，用於 Attention 模型，處理 Attention 模型的輸出，包含開始和結束標記。 | *   **RFLLabelDecode**: 繼承自 `BaseRecLabelDecode`，用於 RFL 模型，處理 RFL 模型的輸出。 | *   **SEEDLabelDecode**: 繼承自 `BaseRecLabelDecode`，用於 SEED 模型，處理 SEED 模型的輸出。 | *   **SRNLabelDecode**: 繼承自 `BaseRecLabelDecode`，用於 SRN 模型，處理 SRN 模型的輸出。 | *   **SARLabelDecode**: 繼承自 `BaseRecLabelDecode`，用於 SAR 模型，處理 SAR 模型的輸出，包含特殊字符處理和可選的符號移除。 | *   **DistillationSARLabelDecode**: 繼承自 `SARLabelDecode`，用於蒸餾訓練，處理多個模型的輸出。 | *   **PRENLabelDecode**: 繼承自 `BaseRecLabelDecode`，用於 PREN 模型，處理 PREN 模型的輸出。 | *   **NRTRLabelDecode**: 繼承自 `BaseRecLabelDecode`，用於 NRTR 模型，處理 NRTR 模型的輸出。 | *   **ViTSTRLabelDecode**: 繼承自 `NRTRLabelDecode`，用於 ViTSTR 模型，處理 ViTSTR 模型的輸出。 | *   **ABINetLabelDecode**: 繼承自 `NRTRLabelDecode`，用於 ABINet 模型，處理 ABINet 模型的輸出。 | *   **SP
    │   └── utils.py    **摘要:** |  | 該 Python 腳本 `utils.py` 提供了用於 OCR 任務的實用函數，包括圖像處理、文本可視化和參數解析。 |  | **核心類和函數:** |  | *   `get_rotate_crop_image(img, points)`: 根據給定的四邊形坐標，從圖像中裁剪並旋轉校正文本區域。 | *   `get_minarea_rect_crop(img, points)`: 使用最小外接矩形裁剪圖像。 | *   `resize_img(img, input_size=600)`: 調整圖像大小，限制最長邊長。 | *   `str_count(s)`: 計算字符串中中文字符的數量。 | *   `text_visual(texts, scores, img_h=400, img_w=600, threshold=0., font_path="./onnx/fonts/simfang.ttf")`: 創建空白圖像，並在其上繪製文本和分數。 | *   `draw_ocr(image, boxes, txts=None, scores=None, drop_score=0.5, font_path="./onnxocr/fonts/simfang.ttf")`: 視覺化 OCR 結果，在圖像上繪製邊框和文本。 | *   `base64_to_cv2(b64str)`: 將 base64 編碼的字符串轉換為 OpenCV 圖像。 | *   `str2bool(v)`: 將字符串轉換為布爾值。 | *   `infer_args()`: 使用 `argparse` 創建並返回一個參數解析器，用於配置 OCR 推理。 |  | **重要功能點:** |  | *   圖像裁剪和旋轉校正，用於處理傾斜的文本。 | *   文本可視化，用於顯示 OCR 檢測和識別結果。 | *   參數解析，用於配置 OCR 模型的推理。 | *   提供圖像大小調整功能。 | *   提供將 base64 編碼的字符串轉換為 OpenCV 圖像的功能。
    └── zzz_od/
        ├── action_recorder/
        │   ├── monitor.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件实现了用于记录游戏战斗过程中的动作和状态的模块，主要用于自动战斗的录制和分析。它集成了键盘、鼠标事件的监听，以及游戏内状态的识别，如角色信息、闪避、连携技等，并将这些信息保存到文件中。 |  | **核心类和函数:** |  | *   **`BattleAgentContext4Recording`**: 继承自 `AutoBattleAgentContext`，重写了 `init_battle_agent_context` 和 `check_agent_related` 方法，用于识别和记录战斗中角色相关信息。 | *   **`BattleDodgeContext4Recording`**: 继承自 `AutoBattleDodgeContext`，重写了 `init_battle_dodge_context` 和 `check_dodge_flash` 方法，用于识别和记录闪避相关信息。 | *   **`BattleContext4Recording`**: 继承自 `AutoBattleContext`，用于整合角色信息、闪避信息，并提供 `check_battle_state` 方法作为战斗状态的总入口。 | *   **`PcButtonListener`**: 监听键盘和鼠标事件，记录用户操作。 | *   **`RecordContext`**:  核心类，负责初始化战斗上下文、启动录制、收集状态和动作数据，并将数据输出到文件。 | *   **`_debug()`**:  用于调试的函数，初始化上下文，启动录制，并输出记录。 | *   **`records_status_and_action()`**: 核心函数，循环获取游戏截图，识别战斗状态，记录动作和状态数据。 | *   **`output_records()`**: 将录制的数据（键盘、鼠标动作，以及战斗状态）保存到文件中。 |  | **重要功能点:** |  | *   **动作记录**: 监听键盘和鼠标事件，记录用户操作的时间戳和事件类型。 | *   **状态识别**:  使用 `BattleContext4Recording` 识别游戏内的战斗状态，包括角色信息、闪避、连携技、快速支援等。 | *   **异步处理**: 使用 `ThreadPoolExecutor` 并行处理状态识别任务，提高效率。 | *   **数据输出**: 将录制的数据保存为 pickle 文件，方便后续分析。 | *   **战斗流程控制**:  通过 `is_normal_attack_btn
        │   └── template_generator.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 脚本用于从录制的键盘、鼠标和游戏状态数据中生成自动战斗的 YAML 模板。它通过预处理数据、使用 Word2Vec 模型进行聚类分析，并结合特殊状态识别，最终生成可用于自动战斗的 YAML 配置文件。 |  | **核心类和函数:** |  | *   **`ImportantOperation(Enum)`**: 定义了游戏中重要的操作，如鼠标点击、键盘按键、闪避状态等，以及它们之间的映射关系。 | *   **`PreProcessor`**: |     *   `__init__`: 从文件中加载键盘、鼠标和状态数据。 |     *   `keyboard_pre_process`: 预处理键盘按键数据，识别长按和短按。 |     *   `mouse_pre_process`: 预处理鼠标按键数据，识别长按和短按。 |     *   `status_pre_process`: 预处理游戏状态数据，提取关键状态信息。 |     *   `_merge_status_and_ops`: 将状态和操作合并，并根据状态优先级更新操作。 |     *   `_drop_duplicates`: 去除重复的操作。 |     *   `pre_process`: 整合所有预处理步骤，生成合并后的状态和操作列表。 | *   **`SelfAdaptiveGenerator`**: |     *   `__init__`: 初始化，接收预处理后的数据。 |     *   `_groupby_agents`: 按角色分组操作。 |     *   `_prepare_sentences`: 准备用于 Word2Vec 模型训练的句子。 |     *   `_word2vec`: 使用 Gensim 的 Word2Vec 模型训练词向量。 |     *   `_estimate_cluster`: 对操作进行聚类，生成动作模板。 |     *   `_get_special_status_freq`: 获取特定状态下对应的动作频率。 |     *   `_get_switch_habit`: 获取换人习惯。 |     *   `get_templates`: 生成动作模板和特殊状态信息。 |     *   `_reserved_states`: 保留特定状态动作。 |     *   `_not_reserved_states`: 不保留特定状态动作。 |     *   `_default_setting`: 设置默认配置。 |     *   `_generate_dodge_template`: 生成
        ├── application/
        │   ├── zzz_application.py    這個 Python 文件定義了一個名為 `ZApplication` 的類，它繼承自 `Application` 類，用於處理與遊戲相關的操作。 |  | **主要功能:** |  | *   管理遊戲應用程序的生命週期，包括啟動、運行和停止。 | *   處理遊戲進入流程，並在需要時進行重試。 | *   提供上下文管理和回調功能。 |  | **核心類和函數:** |  | *   `ZApplication`: 繼承自 `Application`，是應用程序的主要類。 |     *   `__init__`: 初始化 `ZApplication` 實例，包括上下文、應用程序 ID、重試次數、超時時間、回調函數等。它還初始化了 `OpenAndEnterGame` 操作。 |     *   `handle_resume`: 恢復應用程序的操作，激活窗口並調用父類的 `handle_resume` 方法。 | *   `OpenAndEnterGame`: 是一個操作類，用於打開並進入遊戲。 (從初始化中推斷) | *   `Application`:  基類，提供應用程序的基本功能。 (繼承自) | *   `ZContext`:  上下文類，提供應用程序的上下文信息。 (參數) |  | **重要功能點:** |  | *   初始化時使用 `OpenAndEnterGame` 類來處理遊戲進入流程。 | *   `handle_resume` 方法用於恢復應用程序，激活窗口並調用父類的恢復方法。 | *   支持配置重試次數、超時時間和回調函數。 | *   `init_context_before_start` 和 `stop_context_after_stop` 標誌控制上下文的初始化和停止。 | *   `need_ocr` 和 `retry_in_od` 標誌控制 OCR 和 OD 內的重試行為。
        │   ├── zzz_one_dragon_app.py    這個 Python 文件定義了 `ZOneDragonApp` 類，它是一個整合了多個子應用程序的總應用程序，用於執行與遊戲相關的任務。 |  | **主要功能:** |  | *   整合並管理多個子應用程序，例如兌換碼、隨機遊戲、刮刮卡等。 | *   初始化上下文環境，包括配置加載、OCR 初始化和代理更新。 | *   根據配置執行自動更新。 | *   執行所有子應用程序。 | *   在完成後根據配置執行關機或關閉遊戲。 |  | **核心類和函數:** |  | *   `ZOneDragonApp`: 繼承自 `OneDragonApp` 和 `ZApplication`，是主應用程序類。 |     *   `__init__(self, ctx: ZContext)`: 初始化應用程序，包括應用程序 ID 和進入遊戲/切換賬號的操作。 |     *   `get_app_list(self) -> List[ZApplication]`: 返回一個包含所有子應用程序實例的列表。 | *   `ZContext`: 應用程序的上下文，包含環境配置、OCR 服務、Git 服務等。 | *   `OpenAndEnterGame`: 進入遊戲的操作。 | *   `SwitchAccount`: 切換賬號的操作。 | *   `__debug()`: 測試函數，用於初始化上下文、執行應用程序和處理完成後的動作。 |  | **重要功能點:** |  | *   **應用程序整合:**  `ZOneDragonApp` 將多個子應用程序（如 `RedemptionCodeApp`, `RandomPlayApp` 等）組合在一起，提供一個統一的入口點。 | *   **上下文管理:** 使用 `ZContext` 管理應用程序的環境配置、資源和服務。 | *   **自動更新:** 根據配置，可以自動從 Git 獲取最新代碼。 | *   **完成後操作:** 根據配置，在應用程序完成後可以關機或關閉遊戲。 | *   **測試入口:** `__debug()` 函數提供了一個方便的測試和調試入口。
        │   ├── battle_assistant/
        │   │   ├── auto_battle_app.py    這個 Python 文件定義了一個名為 `AutoBattleApp` 的應用程式，用於自動化遊戲中的戰鬥。 |  | **主要功能:** |  | *   自動化遊戲戰鬥流程，包括手柄檢測、加載戰鬥指令、畫面識別和執行操作。 |  | **核心類和函數:** |  | *   `AutoBattleApp`: 繼承自 `ZApplication`，是自動戰鬥應用程式的主類。 |     *   `__init__`: 初始化應用程式，設置應用程式 ID、名稱和是否需要 OCR。 |     *   `handle_init`: 初始化函數，由子類實現。 |     *   `check_gamepad`: 檢測手柄類型並啟用相應的控制器。 |     *   `load_op`: 加載自動戰鬥指令，並啟動 `AutoBattleOperator`。 |     *   `check_screen`: 截取螢幕畫面，並由 `AutoBattleOperator` 處理戰鬥狀態。 |     *   `_on_pause`: 暫停時停止自動戰鬥。 |     *   `_on_resume`: 恢復時恢復自動戰鬥。 |     *   `after_operation_done`: 在操作完成後清理資源。 |  | **重要功能點:** |  | *   手柄檢測和控制器啟用。 | *   加載和啟動 `AutoBattleOperator`，用於執行自動戰鬥邏輯。 | *   週期性地截取螢幕畫面，並根據畫面狀態執行操作。 | *   處理應用程式的暫停和恢復事件，以控制自動戰鬥的運行狀態。
        │   │   ├── auto_battle_config.py    這個 Python 文件定義了用於自動戰鬥配置的功能。 |  | *   **主要功能:** 加載、獲取和管理自動戰鬥指令的配置信息。 | *   **核心類和函數:** |     *   `get_auto_battle_op_config_list(sub_dir: str)`: 獲取用於配置頁面顯示的指令列表。 |     *   `get_all_auto_battle_op(sub_dir: str)`: 加載所有自動戰鬥指令，從配置文件中讀取。 |     *   `get_auto_battle_op_by_name(sub_dir: str, template_name: str)`: 根據名稱獲取特定的自動戰鬥指令。 |     *   `get_auto_battle_config_file_path(sub_dir: str, template_name: str)`: 獲取自動戰鬥配置文件的路徑。 | *   **重要功能點:** |     *   從指定目錄下的 `.yml` 文件中加載自動戰鬥指令配置。 |     *   使用 `ConditionalOperator` 類來表示自動戰鬥指令。 |     *   提供按名稱獲取特定指令的功能。 |     *   提供獲取配置文件路徑的功能。
        │   │   ├── auto_battle_debug_app.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AutoBattleDebugApp` 类，用于调试自动战斗功能。它继承自 `ZApplication`，并实现了自动战斗的初始化、手柄检测、战斗指令加载和画面识别等功能。 |  | **核心类和函数:** |  | *   **`AutoBattleDebugApp(ZContext)`**:  `ZApplication` 的子类，负责自动战斗调试。 |     *   `check_gamepad()`:  检测手柄类型并启用相应的控制器。 |     *   `load_op()`:  加载自动战斗指令。 |     *   `check_screen()`:  识别当前画面并执行相应的操作。 |     *   `_on_pause(e=None)`: 暂停时停止自动战斗。 |     *   `_on_resume(e=None)`: 恢复时继续自动战斗。 |     *   `after_operation_done(result: OperationResult)`:  在操作完成后清理资源。 |  | **重要功能点:** |  | *   手柄检测和控制器初始化。 | *   加载自动战斗指令，并触发 `AutoBattleApp.EVENT_OP_LOADED` 事件。 | *   画面识别，调用 `auto_battle_context.check_battle_state` 进行状态检查，并执行相关操作。 | *   支持暂停和恢复自动战斗。 | *   在操作完成后清理自动战斗操作符。
        │   │   ├── battle_assistant_config.py    這個 Python 文件的主要功能是定義和管理戰鬥助手 (Battle Assistant) 的配置。 |  | *   **核心類:** `BattleAssistantConfig` 繼承自 `YamlConfig`，用於從 YAML 文件中加載和保存戰鬥助手的配置。 | *   **重要功能點:** |     *   提供多個 `@property` 裝飾器，用於獲取和設置戰鬥助手的配置選項，例如閃避配置、是否使用 GPU、截圖間隔、手柄類型、自動戰鬥配置、調試操作配置以及調試操作重複。 |     *   使用 `YamlConfig` 的 `get` 方法從配置文件中讀取配置值，並使用 `update` 方法更新配置值。 |     *   使用 `GamepadTypeEnum` 枚舉定義手柄類型。
        │   │   ├── dodge_assistant_app.py    **摘要:** |  | 该文件定义了 `DodgeAssistantApp` 类，它是一个用于在游戏中执行闪避操作的应用程序。它基于 `ZApplication` 类，并使用自动战斗逻辑。 |  | **核心类和函数:** |  | *   **`DodgeAssistantApp(ZContext)`:**  主类，负责闪避助手的初始化和运行。 |     *   `check_gamepad()`: 检查并启用游戏手柄。 |     *   `load_op()`: 加载自动战斗指令，特别是与闪避相关的指令。 |     *   `check_dodge()`:  截取屏幕截图，并根据自动战斗逻辑判断是否需要闪避。 |     *   `_on_pause(e=None)`: 暂停时停止自动战斗。 |     *   `_on_resume(e=None)`: 恢复时继续自动战斗。 |  | **重要功能点:** |  | *   **手柄检测:**  根据配置检测并启用游戏手柄（Xbox 或 DS4）或键盘。 | *   **自动战斗指令加载:**  加载与闪避相关的自动战斗操作。 | *   **闪避判断:**  根据游戏画面和自动战斗逻辑，判断是否需要执行闪避操作。 | *   **暂停/恢复功能:**  在应用程序暂停和恢复时，正确地停止和启动自动战斗。
        │   │   ├── log_app.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 這個文件定義了一個名為 `LogTestApp` 的應用程式，用於測試在戰鬥中記錄日誌的功能。它模擬了通過發送移動按鈕事件來觸發日誌記錄。 |  | **核心類和函數:** |  | *   `LogTestApp`: 繼承自 `ZApplication`，是主要的應用程式類。 |     *   `__init__(self, ctx: ZContext)`: 初始化應用程式，設置應用程式 ID、名稱，並禁用遊戲勝利檢查。 |     *   `add_edges_and_nodes(self) -> None`: 添加操作節點，這裡添加了一個用於打印日誌的節點。 |     *   `log(self) -> OperationRoundResult`: 模擬發送移動按鈕事件（W、S、A、D），並等待一小段時間。 |  | **重要功能點:** |  | *   模擬了戰鬥中的按鈕事件，用於測試日誌記錄。 | *   使用了 `OperationNode` 和 `OperationRoundResult` 類，表明它與戰鬥流程中的操作相關。 | *   `check_game_win=False` 表明此應用程式不關心遊戲的勝負狀態，專注於日誌記錄。
        │   │   ├── operation_debug_app.py    **摘要:** |  | 该文件定义了 `OperationDebugApp` 类，用于调试自动战斗指令。它继承自 `ZApplication`，并提供了一系列方法来加载、执行和调试战斗操作。 |  | **核心类和函数:** |  | *   **`OperationDebugApp(ctx: ZContext)`**:  构造函数，初始化应用，设置应用ID、名称和是否需要OCR。 | *   **`add_edges_and_nodes()`**:  定义了应用的状态转换流程，包括手柄检测、加载指令、初始化上下文和执行指令。 | *   **`check_gamepad()`**:  检测手柄类型并启用相应的控制器。 | *   **`load_op()`**:  加载指定的自动战斗指令模板。 | *   **`init_context()`**:  初始化上下文。 | *   **`run_operations()`**:  执行加载的战斗指令，并支持循环执行。 |  | **重要功能点:** |  | *   **手柄检测和控制**:  根据配置检测并启用不同的手柄类型（键盘、Xbox、DS4）。 | *   **指令加载**:  从模板加载自动战斗指令。 | *   **指令执行**:  顺序执行加载的指令，并支持循环执行。 | *   **调试模式**:  用于调试自动战斗指令，方便开发者测试和优化。
        │   │   └── operation_template_config.py    這個 Python 文件定義了用於自動戰鬥的指令模板配置。 |  | *   **主要功能:** 加載和管理自動戰鬥指令模板，並提供獲取配置選項和文件路徑的功能。 | *   **核心類和函數:** |     *   `get_operation_template_config_list()`: 獲取用於配置頁面顯示的指令列表。 |     *   `get_all_operation_template()`: 加載所有自動戰鬥指令模板，支持子目錄。 |     *   `get_operation_template_config_file_path(template_name: str)`: 獲取指定模板的完整文件路徑。 |     *   `OperationTemplate`:  (來自 `one_dragon.base.conditional_operation.operation_template`) 表示一個指令模板。 |     *   `ConfigItem`: (來自 `one_dragon.base.config.config_item`)  用於配置頁面選項。 | *   **重要功能點:** |     *   支持從 `config/auto_battle_operation` 目錄及其子目錄中加載 `.yml` 模板文件。 |     *   使用 `os.walk` 递归遍历目录。 |     *   使用 `os.path.relpath` 處理相對路徑。 |     *   生成用於配置頁面的選項列表。
        │   ├── charge_plan/
        │   │   ├── charge_plan_app.py    ## 代码摘要 |  | **文件功能:**  该文件定义了 `ChargePlanApp` 类，用于根据配置的体力计划，在游戏中自动执行各种副本（如实战模拟室、定期清剿等）的刷取任务。 |  | **核心类和函数:** |  | *   **`ChargePlanApp(ZApplication)`:**  主类，继承自 `ZApplication`，负责体力计划的执行流程。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用，设置应用ID、名称和运行记录。 |     *   `goto_menu()`:  打开游戏菜单。 |     *   `check_charge_power()`:  识别并获取当前剩余电量。 |     *   `transport()`:  根据体力计划传送至指定副本。 |     *   `check_mission_type()`: 识别副本类型。 |     *   `combat_simulation()`: 执行实战模拟室副本。 |     *   `routine_cleanup()`: 执行定期清剿副本。 |     *   `expert_challenge()`: 执行专业挑战室副本。 |     *   `notorious_hunt()`: 执行恶名狩猎副本。 |     *   `back_to_world()`:  返回大世界。 |  | **重要功能点:** |  | *   **体力计划管理:**  从 `ZContext` 中获取体力计划配置，并根据计划执行任务。 | *   **电量检测:**  在执行任务前，检测剩余电量是否足够。 | *   **副本传送:**  使用 `TransportByCompendium` 操作传送至指定副本。 | *   **副本执行:**  根据副本类型，调用相应的操作类（如 `CombatSimulation`、`RoutineCleanup` 等）执行副本。 | *   **循环执行:**  支持循环执行体力计划，直到计划完成或电量不足。 | *   **状态处理:**  处理各种状态，如“未配置体力计划”、“已完成一轮计划”等。 | *   **错误处理:**  处理电量不足等错误情况，并返回大世界。
        │   │   ├── charge_plan_config.py    此 Python 腳本定義了用於管理遊戲中收費計劃的配置。 |  | **主要功能:** |  | *   管理和儲存收費計劃配置，包括任務、運行次數和卡片數量等。 | *   提供添加、刪除、更新和重新排序計劃的功能。 | *   追蹤計劃的運行狀態，並提供獲取下一個計劃和判斷所有計劃是否完成的方法。 |  | **核心類和函數:** |  | *   `CardNumEnum`:  定義卡片數量選項的枚舉。 | *   `ChargePlanItem`:  表示單個收費計劃項，包含任務、配置和運行次數等信息。 |     *   `uid`:  生成計劃項的唯一標識符。 | *   `ChargePlanConfig(YamlConfig)`:  繼承自 `YamlConfig`，用於管理收費計劃的配置。 |     *   `__init__`:  初始化配置，從 YAML 文件加載計劃列表。 |     *   `save`:  保存配置到 YAML 文件。 |     *   `add_plan`, `delete_plan`, `update_plan`:  添加、刪除和更新計劃。 |     *   `move_up`, `move_top`:  重新排序計劃。 |     *   `reset_plans`:  根據運行次數重置運行計劃。 |     *   `get_next_plan`:  獲取下一個要執行的計劃。 |     *   `all_plan_finished`:  檢查是否所有計劃都已完成。 |     *   `add_plan_run_times`:  增加計劃的運行次數。 |     *   `_is_same_plan`:  判斷兩個計劃是否相同。 |     *   `history_list`:  獲取歷史計劃列表。 |     *   `get_history_by_uid`:  根據 UID 獲取歷史計劃。 |  | **重要功能點:** |  | *   使用 `YamlConfig` 儲存和加載配置。 | *   支持循環執行計劃。 | *   提供計劃的運行狀態管理，包括重置和獲取下一個計劃。 | *   支持添加運行次數，並保存。 | *   提供了計劃的歷史記錄。
        │   │   └── charge_plan_run_record.py    這個 Python 文件的摘要如下： |  | *   **主要功能:**  `ChargePlanRunRecord` 類別用於記錄和管理計費方案的運行狀態。它繼承自 `AppRunRecord`，並提供特定於計費方案的初始化和狀態更新功能。 | *   **核心類和函數:** |     *   `ChargePlanRunRecord`: 核心類，繼承自 `AppRunRecord`，用於管理計費方案的運行記錄。 |     *   `__init__`:  `ChargePlanRunRecord` 的建構子，初始化父類 `AppRunRecord`，並設定相關參數。 |     *   `check_and_update_status`:  重置運行記錄。 | *   **重要功能點:** |     *   繼承自 `AppRunRecord`，表明它使用了基礎的應用程式運行記錄框架。 |     *   `check_and_update_status` 函數用於重置運行記錄，這表明它可能用於在每次運行時清理或初始化運行狀態。
        │   ├── city_fund/
        │   │   ├── city_fund_app.py    這個 Python 文件定義了一個名為 `CityFundApp` 的應用程式，用於在遊戲中自動執行麗都城募相關的操作。 |  | **主要功能:** |  | *   自動化麗都城募的流程，包括打開菜單、點擊相關按鈕、領取任務和等級回饋。 |  | **核心類和函數:** |  | *   `CityFundApp`: 繼承自 `ZApplication`，是應用程式的主類。 |     *   `__init__(self, ctx: ZContext)`: 初始化應用程式，設置應用程式 ID、名稱和運行記錄。 |     *   `open_menu(self) -> OperationRoundResult`: 打開遊戲菜單。 |     *   `click_fund(self) -> OperationRoundResult`: 點擊麗都城募按鈕。 |     *   `click_task(self) -> OperationRoundResult`: 點擊成長任務按鈕。 |     *   `click_task_claim(self) -> OperationRoundResult`: 領取所有任務獎勵。 |     *   `click_level(self) -> OperationRoundResult`: 點擊等級回饋按鈕。 |     *   `click_level_claim(self) -> OperationRoundResult`: 領取所有等級回饋獎勵。 |     *   `back_to_world(self) -> OperationRoundResult`: 返回大世界。 | *   `ZContext`: 遊戲上下文，提供遊戲環境的相關信息。 | *   `OperationRoundResult`: 操作結果的類。 | *   `GotoMenu`: 導航到菜單的類。 | *   `BackToNormalWorld`: 返回正常世界的類。 |  | **重要功能點:** |  | *   使用 `@operation_node` 裝飾器定義操作節點，構建操作流程。 | *   使用 `round_by_ocr_and_click`、`round_by_find_and_click_area` 等方法實現基於 OCR 和圖像識別的點擊操作。 | *   根據不同的狀態和結果，執行不同的操作，例如在任務關閉時返回成功。 | *   `__debug()` 函數用於測試應用程式。
        │   │   └── city_fund_run_record.py    這個 Python 文件的摘要如下： |  | *   **主要功能:**  定義了一個用於記錄城市基金應用程序運行狀態的類。 | *   **核心類和函數:** |     *   `CityFundRunRecord`: 繼承自 `AppRunRecord`，用於記錄城市基金的運行信息。 |     *   `__init__`:  `CityFundRunRecord` 的構造函數，初始化父類 `AppRunRecord`，並設置應用程序名稱和實例索引。 | *   **重要功能點:**  初始化 `CityFundRunRecord` 實例，並將應用程序名稱設置為 'city\_fund'。它還接受可選的實例索引和遊戲刷新小時偏移量作為參數，用於配置運行記錄。
        │   ├── coffee/
        │   │   ├── coffee_app.py    ## 代码摘要 |  | **1. 主要功能:** |  | 该 Python 文件定义了 `CoffeeApp` 类，用于自动化处理游戏《ZZZ》中的咖啡店相关操作。主要功能包括： |  | *   自动传送至咖啡店。 | *   选择并点单咖啡。 | *   根据配置和体力计划，选择是否进行挑战。 | *   执行相应的挑战操作（实战模拟室、定期清剿、专业挑战室）。 | *   返回大世界。 | *   可选地在完成后运行体力计划。 |  | **2. 核心类和函数:** |  | *   **`CoffeeApp(ZContext)`:**  继承自 `ZApplication`，是咖啡店操作的主类。 |     *   `__init__(self, ctx: ZContext)`: 初始化，设置应用 ID、名称、运行记录等。 |     *   `transport(self)`: 传送至咖啡店。 |     *   `wait_world(self)`: 等待大世界加载。 |     *   `move_and_interact(self)`: 移动并交互。 |     *   `wait_coffee_shop(self)`: 等待咖啡店加载。 |     *   `choose_coffee(self)`: 选择咖啡，使用 OCR 识别咖啡列表，并根据配置和体力计划筛选。 |     *   `order_coffee(self)`: 点单咖啡。 |     *   `extra_order_confirm(self)`: 确认不占用上限的咖啡点单。 |     *   `skip_after_order(self)`: 点单后跳过。 |     *   `charge_confirm(self)`: 电量确认。 |     *   `choose_go(self)`: 选择是否前往挑战。 |     *   `tp_mission(self)`: 传送至副本。 |     *   `combat_simulation(self)`: 执行实战模拟室挑战。 |     *   `routine_cleanup(self)`: 执行定期清剿挑战。 |     *   `expert_challenge(self)`: 执行专业挑战室挑战。 |     *   `back_to_world(self)`: 返回大世界。 |     *   `charge_plan_afterwards(self)`: 运行体力计划。 |     *   `_get_coffee_to_choose(self, day
        │   │   ├── coffee_config.py    ## 代码摘要 |  | **主要功能:** |  | 该文件定义了咖啡相关的配置类，用于存储和管理咖啡相关的设置，例如咖啡选择方式、挑战方式、卡片数量、自动战斗设置以及每日咖啡选择等。 |  | **核心类和函数:** |  | *   **`CoffeeChooseWay`**:  枚举类，定义了咖啡选择方式，包括优先体力计划和汀曼特调。 | *   **`CoffeeChallengeWay`**: 枚举类，定义了咖啡挑战方式，包括全部挑战、只挑战体力计划和不挑战。 | *   **`CoffeeCardNumEnum`**: 枚举类，定义了咖啡挑战时卡片数量的选项。 | *   **`CoffeeConfig`**:  继承自 `YamlConfig`，是核心配置类，负责加载、存储和管理咖啡相关的配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化函数，继承父类并设置模块名称。 |     *   `choose_way`, `challenge_way`, `card_num`, `auto_battle`, `day_coffee_1` - `day_coffee_7`, `predefined_team_idx`, `run_charge_plan_afterwards`:  属性，用于获取和设置各种咖啡配置选项。 |     *   `get_coffee_by_day(self, day: int) -> str`:  根据星期几获取对应的咖啡名称。 |     *   `run_charge_plan_afterwards_adapter`:  用于适配 `run_charge_plan_afterwards` 配置项的 `YamlConfigAdapter` 实例。 |  | **重要功能点:** |  | *   定义了咖啡选择、挑战和卡片数量的多种配置选项。 | *   提供了每日咖啡的配置，可以根据星期几选择不同的咖啡。 | *   支持预设编队和咖啡后再次挑战体力计划的配置。 | *   使用 `YamlConfig` 存储配置，方便配置文件的加载和保存。
        │   │   └── coffee_run_record.py    這個 Python 文件定義了一個名為 `CoffeeRunRecord` 的類，用於記錄和管理與 "coffee" 應用程序相關的運行信息。 |  | *   **主要功能:** 記錄和管理 "coffee" 應用程序的運行記錄。 | *   **核心類:** `CoffeeRunRecord` 繼承自 `AppRunRecord`。 | *   **重要功能點:** |     *   `CoffeeRunRecord` 的初始化方法 `__init__`，它繼承了 `AppRunRecord` 的初始化方法，並設置了應用程序名稱為 'coffee'，以及實例索引和遊戲刷新小時偏移量。
        │   ├── commission_assistant/
        │   │   ├── commission_assistant_app.py    ## 摘要 |  | **文件功能:** |  | 该文件定义了 `CommissionAssistantApp` 类，该类是用于自动化游戏内委托任务的应用程序。它主要功能包括自动对话、自动战斗和钓鱼。 |  | **核心类和函数:** |  | *   **`CommissionAssistantApp(ZContext)`**:  主应用程序类，继承自 `ZApplication`。 |     *   `__init__`: 初始化应用程序，设置运行模式、自动战斗操作器等。 |     *   `handle_init`: 初始化时监听键盘事件。 |     *   `_on_key_press`: 响应键盘事件，切换运行模式（对话、闪避、自动战斗）。 |     *   `dialog_mode`:  自动对话模式，处理对话框、选项点击等。 |     *   `_check_dialog`: 检查屏幕上是否有对话框。 |     *   `_click_dialog_options`: 点击对话选项。 |     *   `check_same_opts`: 检查对话选项是否与上次相同。 |     *   `_handle_hollow`: 处理空洞内的逻辑。 |     *   `check_knock_knock`: 检查短信。 |     *   `auto_mode`: 自动战斗模式，控制自动战斗操作器。 |     *   `_load_auto_op`: 加载自动战斗操作器。 |     *   `check_fishing`: 检查是否进入钓鱼界面。 |     *   `check_story_mode`: 检查是否进入剧情模式。 |     *   `on_finishing`:  钓鱼操作，根据屏幕上的指令进行操作。 |     *   `handle_pause`: 暂停时取消键盘事件监听和停止自动战斗。 |     *   `handle_resume`: 恢复时重新监听键盘事件和恢复自动战斗。 |     *   `after_operation_done`: 操作完成后清理资源。 |  | **重要功能点:** |  | *   **自动对话:**  识别对话框和选项，并自动选择选项。 | *   **自动战斗:**  根据配置启动和控制自动战斗。 | *   **钓鱼:**  识别钓鱼界面指令，并执行相应的操作。 | *   **模式切换:**  通过键盘快捷键切换自动对话、闪避和自动战斗模式。 | *   **空洞处理:**  处理空洞
        │   │   └── commission_assistant_config.py    這個 Python 文件的主要功能是定義和管理委託助手 (Commission Assistant) 的配置。它使用 `YamlConfig` 類來讀取和寫入 YAML 配置文件。 |  | 核心類和函數: |  | *   `DialogOptionEnum`:  一個枚舉，定義了對話選項，例如 "第一個" 和 "最後一個"。 | *   `StoryMode`:  一個枚舉，定義了劇情模式，例如 "自動點擊"、"等待劇情自動播放" 和 "跳過劇情"。 | *   `CommissionAssistantConfig`:  繼承自 `YamlConfig`，負責管理委託助手的配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化配置，指定模塊名稱和實例索引。 |     *   多個屬性 (使用 `@property` 和 setter):  定義了配置項，例如 `dialog_click_interval`, `story_mode`, `dialog_option`, `dodge_config`, `dodge_switch`, `auto_battle` 和 `auto_battle_switch`，它們用於獲取和設置配置值。 |  | 重要功能點: |  | *   使用 `YamlConfig` 讀取和寫入 YAML 配置文件，實現配置的持久化。 | *   使用枚舉 `DialogOptionEnum` 和 `StoryMode` 來定義配置選項，提高代碼的可讀性和可維護性。 | *   提供 getter 和 setter 方法來訪問和修改配置項，方便配置的管理和修改。
        │   ├── devtools/
        │   │   └── screenshot_helper/
        │   │       ├── screenshot_helper_app.py    這個 Python 腳本定義了一個名為 `ScreenshotHelperApp` 的應用程式，用於在遊戲中檢測閃避動作並截圖，以用於訓練模型。 |  | **主要功能:** |  | *   持續截圖並檢測閃避動作。 | *   通過按鍵觸發保存截圖。 |  | **核心類和函數:** |  | *   `ScreenshotHelperApp`: 繼承自 `ZApplication`，是應用程式的主類。 |     *   `__init__`: 初始化應用程式，設置截圖相關的參數。 |     *   `add_edges_and_nodes`: 定義操作流程，包括初始化上下文、持續截圖和保存截圖。 |     *   `handle_init`: 初始化應用程式，設置截圖的相關配置。 |     *   `init_context`: 初始化上下文，加載自動戰鬥操作。 |     *   `repeat_screenshot`: 執行持續截圖，檢測閃避動作，並根據配置決定是否保存截圖。 |     *   `_on_key_press`: 監聽按鍵事件，當按下保存按鍵時，觸發保存截圖。 |     *   `do_save_screenshot`: 保存截圖。 |     *   `after_operation_done`: 應用程式結束後的清理工作。 |  | **重要功能點:** |  | *   使用 `AutoBattleOperator` 檢測閃避動作。 | *   使用 `debug_utils.save_debug_image` 保存截圖。 | *   通過按鍵觸發保存截圖，並限制保存頻率。 | *   使用 `ContextKeyboardEventEnum` 監聽按鍵事件。
        │   │       └── screenshot_helper_config.py    這個 Python 文件定義了 `ScreenshotHelperConfig` 類，用於管理截圖工具的配置。 |  | *   **主要功能:** 讀取和管理截圖工具的配置，例如截圖頻率、截圖長度、保存按鍵和躲避檢測。 | *   **核心類:** `ScreenshotHelperConfig` 繼承自 `YamlConfig`，用於從 YAML 文件加載配置。 | *   **重要功能點:** |     *   `frequency_second`: 截圖頻率（秒）。 |     *   `length_second`: 截圖持續時間（秒）。 |     *   `key_save`: 保存截圖的按鍵。 |     *   `dodge_detect`: 是否啟用躲避檢測。 |     *   使用 `@property` 裝飾器定義了配置項的 getter 和 setter 方法，方便配置的讀取和修改。
        │   ├── drive_disc_dismantle/
        │   │   ├── drive_disc_dismantle_app.py    此 Python 文件定义了 `DriveDiscDismantleApp` 类，该类实现了在游戏 `zzz_od` 中拆解驱动盘的自动化流程。 |  | **核心类和函数:** |  | *   `DriveDiscDismantleApp`: 继承自 `ZApplication`，负责驱动盘拆解的整个流程。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用，设置应用名称和运行记录。 |     *   `back_at_first()`:  流程开始时返回主界面。 |     *   `goto_salvage()`:  导航到驱动盘拆解界面。 |     *   `click_filter()`:  点击快速选择按钮。 |     *   `choose_level()`:  选择拆解等级。 |     *   `choose_abandon()`:  选择是否弃置已弃置的驱动盘。 |     *   `click_filter_confirm()`: 确认快速选择。 |     *   `click_salvage()`:  点击拆解按钮。 |     *   `click_salvage_confirm()`: 确认拆解操作。 |     *   `back_at_last()`:  流程结束时返回主界面。 | *   `__debug()`:  用于调试，创建 `ZContext` 实例并运行 `DriveDiscDismantleApp`。 |  | **重要功能点:** |  | *   自动化流程：通过一系列 `operation_node` 装饰的函数，定义了拆解驱动盘的步骤。 | *   界面交互：使用 `round_by_goto_screen` 和 `round_by_find_and_click_area` 等方法与游戏界面交互，实现点击和导航。 | *   配置驱动：使用 `self.ctx.drive_disc_dismantle_config` 来配置拆解等级和是否弃置已弃置的驱动盘。 | *   错误处理：使用 `success` 参数处理流程中的分支情况，例如可能没有需要拆解的驱动盘。
        │   │   ├── drive_disc_dismantle_config.py    這個 Python 文件定義了用於驅動器拆卸的配置。 |  | *   **主要功能:** 讀取和管理驅動器拆卸的配置，包括拆卸級別和是否拆卸已棄置的驅動器。 | *   **核心類和函數:** |     *   `DismantleLevelEnum`: 枚舉類，定義了拆卸級別（LEVEL\_B, LEVEL\_A, LEVEL\_S）。 |     *   `DriveDiscDismantleConfig`: 繼承自 `YamlConfig`，用於管理拆卸配置。 |         *   `__init__`: 初始化配置，從 YAML 文件加載配置。 |         *   `dismantle_level`: 屬性，獲取和設置拆卸級別。 |         *   `dismantle_abandon`: 屬性，獲取和設置是否拆卸已棄置的驅動器。 | *   **重要功能點:** |     *   使用 `YamlConfig` 讀取和存儲配置。 |     *   提供拆卸級別的配置選項。 |     *   提供是否拆卸已棄置驅動器的配置選項。
        │   │   └── drive_disc_dismantle_run_record.py    這個 Python 文件定義了一個用於記錄「Drive Disc Dismantle」應用程式運行情況的類別。 |  | *   **主要功能:** 記錄「Drive Disc Dismantle」應用程式的運行資訊。 | *   **核心類:** `DriveDiscDismantleRunRecord` 繼承自 `AppRunRecord`。 | *   **重要功能點:** |     *   `DriveDiscDismantleRunRecord` 的建構子 (`__init__`) 初始化了應用程式名稱，並可以接收實例索引和遊戲刷新小時偏移量。
        │   ├── email_app/
        │   │   ├── email_app.py    這個 Python 文件的主要功能是實現一個自動接收郵件獎勵的應用程式。 |  | 核心類： |  | *   `EmailApp`: 繼承自 `ZApplication`，負責處理郵件相關的操作。 |  | 核心函數： |  | *   `__init__(self, ctx: ZContext)`: 初始化 `EmailApp`，設置應用程式 ID、名稱和運行記錄。 | *   `handle_init(self) -> None`: 初始化函數，目前為空。 | *   `goto_email(self) -> OperationRoundResult`: 打開郵件界面。 | *   `click_get_all(self) -> OperationRoundResult`: 在郵件界面點擊“全部領取”。 | *   `click_confirm(self) -> OperationRoundResult`: 在領取後點擊“確認”。 | *   `back_to_menu(self) -> OperationRoundResult`: 返回主菜單。 |  | 重要功能點： |  | *   使用 `operation_node` 和 `node_from` 裝飾器定義操作流程，實現自動化。 | *   通過截圖和查找區域的方式與界面交互。 | *   處理了“全部領取”按鈕不可用的情況。 | *   處理了領取後點擊“確認”按鈕的情況。 | *   提供了返回主菜單的功能。
        │   │   └── email_run_record.py    這個 Python 文件定義了一個名為 `EmailRunRecord` 的類，用於記錄與郵件應用程序相關的運行信息。 |  | *   **主要功能:** 記錄郵件應用程序的運行記錄。 | *   **核心類:** `EmailRunRecord` 繼承自 `AppRunRecord`。 | *   **重要功能點:** |     *   `EmailRunRecord` 的構造函數初始化了父類 `AppRunRecord`，並指定了應用程序類型為 'email'。 |     *   構造函數接受 `instance_idx` 和 `game_refresh_hour_offset` 作為參數，用於配置運行記錄。
        │   ├── engagement_reward/
        │   │   ├── engagement_reward_app.py    這個 Python 腳本定義了一個應用程式 `EngagementRewardApp`，用於自動領取遊戲中的活躍度獎勵。 |  | **主要功能:** |  | *   自動導航到活躍度獎勵界面。 | *   識別活躍度。 | *   點擊領取獎勵。 | *   檢查獎勵結果。 | *   如果沒有獎勵或領取完成，則返回遊戲主界面。 |  | **核心類和函數:** |  | *   `EngagementRewardApp`: 繼承自 `ZApplication`，是主要的應用程式類，負責整個領取獎勵的流程。 |     *   `__init__(self, ctx: ZContext)`: 初始化應用程式，設置應用程式 ID、名稱和運行記錄。 |     *   `handle_init(self) -> None`: 初始化，設置 `idx`。 |     *   `goto_compendium_daily(self) -> OperationRoundResult`: 導航到快捷手册-日常界面。 |     *   `check_engagement(self) -> OperationRoundResult`: 識別活躍度。 |     *   `click_reward(self) -> OperationRoundResult`: 點擊領取獎勵。 |     *   `check_reward(self) -> OperationRoundResult`: 檢查獎勵結果。 |     *   `back_afterwards(self) -> OperationRoundResult`: 完成後返回大世界。 | *   `ZContext`: 遊戲上下文，包含遊戲環境的相關信息。 | *   `OperationRoundResult`: 操作回合結果。 | *   `BackToNormalWorld`: 返回大世界的操作。 |  | **重要功能點:** |  | *   使用 `operation_node` 裝飾器定義操作流程中的節點。 | *   使用 `node_from` 裝飾器定義節點之間的依賴關係。 | *   使用 OCR 識別活躍度。 | *   根據活躍度點擊相應的獎勵按鈕。 | *   處理領取失敗或沒有獎勵的情況。 | *   `__debug()` 函數用於測試。
        │   │   └── engagement_reward_run_record.py    這個 Python 文件定義了 `EngagementRewardRunRecord` 類，用於記錄和管理與互動獎勵相關的應用程式運行記錄。 |  | *   **核心類:** `EngagementRewardRunRecord` 繼承自 `AppRunRecord`。 | *   **重要功能點:** |     *   `__init__` 方法初始化 `EngagementRewardRunRecord` 實例，並調用父類 `AppRunRecord` 的初始化方法，設定應用程式名稱和實例索引等參數。 |     *   `game_refresh_hour_offset` 參數用於指定遊戲刷新的小時偏移量。
        │   ├── hollow_zero/
        │   │   ├── lost_void/
        │   │   │   ├── lost_void_app.py    ## 摘要 |  | 該 Python 腳本定義了一個名為 `LostVoidApp` 的應用程式，用於自動化遊戲《崩壞：星穹鐵道》中「迷失之地」的挑戰。 |  | **主要功能：** |  | *   自動執行「迷失之地」的挑戰流程，包括初始化、進入戰鬥、完成關卡、領取獎勵等。 | *   處理各種遊戲畫面，根據畫面內容執行相應的操作，例如點擊按鈕、選擇選項等。 | *   記錄挑戰進度，並在完成每日挑戰次數後停止。 |  | **核心類和函數：** |  | *   `LostVoidApp`: 繼承自 `ZApplication`，是整個應用程式的核心，定義了挑戰的流程和邏輯。 |     *   `init_for_lost_void`: 初始化，檢查是否已完成當日挑戰。 |     *   `check_initial_screen`: 識別初始畫面，判斷當前狀態。 |     *   `back_at_first`: 返回大世界。 |     *   `goto_compendium`: 前往快捷手冊。 |     *   `choose_hollow_zero`: 選擇零號空洞。 |     *   `choose_lost_void`: 選擇迷失之地。 |     *   `goto_purge`: 前往戰線肅清。 |     *   `choose_buff`: 選擇增益。 |     *   `click_next`: 點擊下一步。 |     *   `deploy`: 部署。 |     *   `run_level`: 執行關卡。 |     *   `after_complete`: 通關後處理。 |     *   `open_reward_list`: 打開懸賞委託。 |     *   `claim_all`: 全部領取。 |     *   `back_at_last`: 完成後返回。 | *   `ZContext`: 遊戲上下文，包含遊戲狀態和配置信息。 | *   `OperationRoundResult`: 操作結果。 | *   `LostVoidRunLevel`: 執行關卡的操作。 | *   `BackToNormalWorld`: 返回普通世界的操作。 | *   `CompendiumChooseCategory`: 選擇類別的操作。 | *   `CompendiumChooseMissionType`: 選擇任務類型的操作。 | *   `Deploy
        │   │   │   ├── lost_void_challenge_config.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 脚本定义了用于管理“虚空遗失挑战”配置的类和函数，这些配置基于 YAML 文件。它提供了加载、保存、更新和创建配置文件的功能，并定义了与挑战相关的枚举类型。 |  | **核心类和函数:** |  | *   **`LostVoidRegionType`**:  一个枚举类，定义了虚空遗失挑战中的区域类型。 | *   **`LostVoidPeriodBuffNo`**:  一个枚举类，定义了周期性增益编号。 | *   **`LostVoidBuyOnlyPriority`**:  一个枚举类，定义了购买优先级。 | *   **`LostVoidChallengeConfig(YamlConfig)`**:  核心类，继承自 `YamlConfig`，用于加载、保存和管理虚空遗失挑战的配置。 |     *   `__init__`: 初始化配置，加载 YAML 文件。 |     *   `copy_new`: 复制配置并创建一个新的配置文件。 |     *   `remove_sample`: 将配置文件标记为非示例文件。 |     *   `update_module_name`: 更新配置文件的模块名称。 |     *   `save`: 保存配置。 |     *   一系列 `@property` 和 `@*.setter` 方法，用于访问和修改配置中的各种属性，如 `auto_battle`, `artifact_priority` 等。 | *   **`get_all_lost_void_challenge_config(with_sample: bool = True)`**:  从配置文件目录中加载所有虚空遗失挑战配置。 | *   **`get_lost_void_challenge_new_name()`**:  生成一个新的配置文件名。 |  | **重要功能点:** |  | *   **配置加载和保存**:  使用 `YamlConfig` 加载和保存 YAML 格式的配置文件。 | *   **枚举类型**:  使用 `Enum` 定义了区域类型、周期性增益编号和购买优先级，增强了代码的可读性和可维护性。 | *   **配置属性访问**:  通过属性访问器（`@property` 和 `@*.setter`）来方便地获取和设置配置参数。 | *   **配置文件管理**:  提供了复制、重命名和删除配置文件的功能。 | *   **批量加载配置**:  `get_all_lost_void_challenge_config` 函数用于批量
        │   │   │   ├── lost_void_config.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件定義了用於配置「虚空遗忘」功能的配置類。它使用 `YamlConfig` 類來讀取和管理配置數據。 |  | **核心類和函數：** |  | *   `LostVoidExtraTask` (Enum):  定義了額外任務的枚舉，包括 `NONE`, `EVAL_POINT`, 和 `PERIOD_REWARD`。 | *   `LostVoidConfig` (YamlConfig):  繼承自 `YamlConfig`，負責加載和管理與「虚空遗忘」相關的配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化 `LostVoidConfig` 實例。 |     *   `daily_plan_times` (property):  配置每日計劃次數，包含 getter 和 setter。 |     *   `weekly_plan_times` (property):  配置每周計劃次數，包含 getter 和 setter。 |     *   `extra_task` (property):  配置額外任務，包含 getter 和 setter。 |     *   `mission_name` (property):  配置任務名稱，包含 getter 和 setter。 |     *   `challenge_config` (property): 配置挑戰配置，包含 getter 和 setter。 |  | **重要功能點：** |  | *   使用 `YamlConfig` 讀取和管理配置，配置數據來自 YAML 文件。 | *   定義了 `LostVoidExtraTask` 枚舉，用於指定額外任務類型。 | *   提供了多個屬性 (property) 來訪問和修改配置，例如每日計劃次數、每周計劃次數、額外任務、任務名稱和挑戰配置。 | *   每個配置屬性都提供了 getter 和 setter 方法，方便讀取和更新配置。
        │   │   │   ├── lost_void_run_record.py    這個 Python 文件定義了 `LostVoidRunRecord` 類，用於記錄和管理遊戲 "Lost Void" 的運行狀態。 |  | **核心類和函數:** |  | *   `LostVoidRunRecord`: 繼承自 `AppRunRecord`，用於記錄 Lost Void 的運行數據。 |     *   `__init__`: 初始化 LostVoidRunRecord，設置遊戲名稱、實例索引、刷新時間偏移和記錄週期。 |     *   `daily_run_times`, `weekly_run_times`: 屬性，用於獲取和設置每日和每週的運行次數。 |     *   `add_complete_times`: 增加每日和每週的完成次數。 |     *   `eval_point_complete`, `period_reward_complete`: 屬性，用於獲取和設置是否完成業績點和週期獎勵。 |     *   `is_finished_by_week`: 判斷是否按週完成。 |     *   `is_finished_by_day`: 判斷是否按天完成。 |     *   `run_status_under_now`: 根據當前時間判斷運行狀態。 |     *   `check_and_update_status`: 檢查並更新運行狀態，包括重置記錄。 |     *   `reset_for_weekly`: 重置每週的運行數據。 |  | **重要功能點:** |  | *   記錄每日和每週的運行次數。 | *   追蹤是否完成業績點和週期獎勵。 | *   根據配置和運行次數判斷遊戲是否完成（按天和按週）。 | *   根據時間判斷和更新運行狀態，包括重置數據。
        │   │   │   ├── context/
        │   │   │   │   ├── lost_void_artifact.py    這個 Python 文件定義了一個名為 `LostVoidArtifact` 的類，用於表示遊戲中遺失虛空的物品。 |  | *   **核心類:** `LostVoidArtifact` | *   **核心函數:** `__init__` (構造函數) | *   **重要功能點:** |     *   儲存物品的分類、名稱、等級和模板 ID (可選)。 |     *   `display_name` 屬性，用於生成物品的顯示名稱，格式為 "分類 名稱"。
        │   │   │   │   ├── lost_void_context.py    ```python | # 摘要 |  | # 主要功能： | # 负责管理《迷失之地》游戏中的上下文信息，包括藏品、挑战配置、自动战斗指令和目标检测。 |  | # 核心类和函数： | # - LostVoidContext:  主类，管理迷失之地相关的上下文。 | #   - init_before_run(): 初始化环境，包括加载模型、数据和配置。 | #   - load_artifact_data(): 加载藏品数据。 | #   - init_lost_void_det_model(): 初始化目标检测模型。 | #   - init_auto_op(): 初始化自动战斗指令。 | #   - load_challenge_config(): 加载挑战配置。 | #   - detect_to_go(): 检测需要前往的目标。 | #   - check_battle_encounter(): 检查是否进入战斗。 | #   - match_artifact_by_ocr_full(): 通过OCR匹配藏品。 | #   - get_artifact_by_priority(): 根据优先级选择藏品。 | #   - get_entry_by_priority(): 根据优先级选择入口。 | # - LostVoidDetector: 目标检测器，用于识别游戏画面中的元素。 | # - LostVoidArtifact: 藏品数据类。 | # - LostVoidChallengeConfig: 挑战配置类。 |  | # 重要功能点： | # - 藏品数据加载和管理。 | # - 目标检测，用于识别游戏元素。 | # - 自动战斗指令的初始化和管理。 | # - 战斗状态检测。 | # - 基于优先级的藏品选择和入口选择。 | ```
        │   │   │   │   ├── lost_void_detector.py    這個 Python 文件定義了一個名為 `LostVoidDetector` 的類，它繼承自 `Yolov8Detector`，用於崩壞星穹鐵道的 YOLO 模型目標檢測。 |  | **主要功能：** |  | *   使用 YOLOv8 模型檢測圖像中的特定目標。 | *   提供方法來判斷幀中是否存在特定類別的目標。 | *   提供方法來獲取特定類別目標在幀中的最右側結果。 |  | **核心類和函數：** |  | *   `LostVoidDetector`: 繼承自 `Yolov8Detector`，用於檢測崩壞星穹鐵道中的目標。 |     *   `__init__`: 初始化檢測器，包括模型名稱、備份模型名稱、是否使用 GPU 等。 |     *   `is_frame_with_all`: 判斷幀中是否存在所有指定類別的目標（感嘆號、距離、入口）。 |     *   `is_frame_with`: 判斷幀中是否存在特定類別的目標。 |     *   `get_result_by_x`: 獲取幀中特定類別目標的最右側結果。 |  | **重要功能點：** |  | *   使用 YOLOv8 模型進行目標檢測。 | *   針對崩壞星穹鐵道遊戲中的特定目標類別進行檢測。 | *   提供靈活的方法來查詢檢測結果。 | *   包含一個 `__debug` 函數，用於測試和演示檢測器的功能。
        │   │   │   │   └── lost_void_det_class.py    這個 Python 文件定義了一個名為 `LostVoidDetClass` 的類，用於表示與 Lost Void 檢測相關的類別信息。 |  | *   **核心類:** `LostVoidDetClass` | *   **核心函數:** `__init__` (構造函數) | *   **重要功能點:** |     *   `LostVoidDetClass` 類用於存儲 Lost Void 檢測的類別索引 (`class_idx`) 和類別名稱 (`class_name`)。 |     *   構造函數初始化類別索引和類別名稱。
        │   │   │   └── operation/
        │   │   │       ├── lost_void_move_by_det.py    ```python | # 1. 文件主要功能 | 該文件定義了一個名為 `LostVoidMoveByDet` 的 ZOperation，用於在迷失之地中識別目標並朝其移動。它處理了移動、轉向、脫困、交互等情況，並根據識別結果進行相應的動作。 |  | # 2. 核心類和函數 | -   **`MoveTargetWrapper`**: 封裝了檢測到的目標信息，包括目標名稱、矩形區域，以及合併邏輯，用於處理多個目標的合併。 | -   **`LostVoidMoveByDet`**: 繼承自 `ZOperation`，是主要的移動操作類。 |     -   `__init__`: 初始化操作，設置目標類型、停止條件等。 |     -   `turn_at_first`: 初始轉向，識別目標並轉向。 |     -   `move_towards`: 朝目標移動。 |     -   `turn_to_target`: 根據目標位置轉向。 |     -   `get_move_target`: 獲取移動目標。 |     -   `get_entry_target`: 獲取入口目標，處理合併邏輯。 |     -   `check_stuck`: 判斷是否被困。 |     -   `get_out_of_stuck`: 嘗試脫困。 |     -   `check_interact_stop`: 判斷是否需要停止以進行交互。 |     -   `handle_no_target`: 處理未識別到目標的情況。 |     -   `get_same_as_last_target`: 嘗試選擇與上次目標最接近的目標。 |  | # 3. 重要功能點 | -   **目標識別與移動**: 使用 `LostVoidDetector` 識別目標，並控制角色朝目標移動。 | -   **脫困機制**: 檢測角色是否被困，並提供脫困策略，包括移動和攻擊。 | -   **交互處理**: 判斷是否需要停止移動以進行交互。 | -   **多目標合併**: `MoveTargetWrapper` 類中的合併邏輯，用於處理多個入口的合併。 | -   **狀態管理**: 使用 `STATUS_IN_BATTLE`, `STATUS_ARRIVAL`, `STATUS_NO_FOUND`, `STATUS_CONTINUE`,
        │   │   │       ├── lost_void_run_level.py    ```python | 文件摘要： |  | 该文件定义了 `LostVoidRunLevel` 类，用于处理《崩坏：星穹铁道》游戏中“迷失之地”的层间移动和战斗流程。它集成了目标检测、交互、自动战斗等功能，以完成特定区域类型的挑战。 |  | 核心类和函数： |  | *   **`LostVoidRunLevel`**:  核心类，继承自 `ZOperation`，负责迷失之地的层间移动和战斗。 |     *   `__init__`: 初始化，设置区域类型、检测器、自动战斗操作器等。 |     *   `wait_loading`: 等待加载，识别奖励选择和挑战确认。 |     *   `init_for_region_type`: 根据区域类型初始化流程。 |     *   `non_battle_check`: 非战斗画面识别，检测交互、距离、入口等。 |     *   `try_interact`: 尝试交互。 |     *   `handle_interact`: 处理交互结果，包括选择和对话。 |     *   `after_interact`: 交互后处理，根据交互目标进行移动。 |     *   `in_battle`: 战斗流程，启动自动战斗，并检测战斗状态。 |     *   `handle_challenge_result_confirm`: 处理挑战结果确认。 |     *   `handle_challenge_result_finish`: 处理挑战结果完成。 |     *   `fail_exit_lost_void`: 失败退出空洞。 |     *   `handle_battle_fail`: 处理战斗失败。 |     *   `handle_fail_exit`: 点击失败退出完成。 |     *   `handle_pause`: 暂停时停止自动战斗。 |     *   `after_operation_done`: 操作完成后停止自动战斗。 |     *   `try_talk`: 尝试对话。 |     *   `try_talk_options`: 尝试对话选项。 |     *   `move_after_interact`: 交互后进行移动。 | *   `ZOperation`:  基类，提供操作框架。 | *   `LostVoidDetector`: 用于检测游戏画面中的目标。 | *   `AutoBattleOperator`: 自动战斗操作器。 |  | 重要功能点： |  | *   **区域类型处理**:  根据 `LostVoidRegionType`  处理不同
        │   │   │       └── interact/
        │   │   │           ├── lost_void_bangboo_store.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个名为 `LostVoidBangbooStore` 的类，用于在游戏“迷失之地”中操作邦布商店，实现购买藏品的功能。它通过识别商店类型、藏品信息、价格和购买按钮，并根据优先级选择藏品进行购买。 |  | **核心类和函数:** |  | *   **`StoreItemWrapper`**: 辅助类，用于封装商店中藏品的信息，包括藏品对象、矩形区域、价格和购买按钮矩形。 |     *   `add_price()`: 添加价格信息。 |     *   `add_buy()`: 添加购买按钮信息。 | *   **`LostVoidBangbooStore(ZOperation)`**: 主要操作类，继承自 `ZOperation`。 |     *   `check_store_type()`: 识别商店类型（金币或血量）。 |     *   `buy_artifact_gold()`: 购买藏品，包括识别藏品、筛选优先级、点击购买、处理确认。 |     *   `get_artifact_pos()`: 识别藏品的位置、价格和购买按钮。 |     *   `check_min_blood_valid()`: 检查血量是否满足购买条件。 |     *   `click_confirm()`: 点击购买确认按钮。 |     *   `after_confirm()`: 处理购买后的流程，例如武备升级。 |     *   `finish()`: 结束操作，点击返回按钮。 |  | **重要功能点:** |  | *   **商店类型识别:** 区分金币商店和血量商店。 | *   **藏品识别:** 通过 OCR 技术识别藏品名称、价格和购买按钮。 | *   **优先级选择:** 根据配置和刷新次数，优先购买高优先级藏品。 | *   **血量检查:** 购买血量商店的藏品时，检查当前血量是否满足最低要求。 | *   **流程控制:** 使用 `operation_node` 和 `node_from` 装饰器定义操作流程，包括识别、购买、确认和结束。 | *   **错误处理:** 包含重试机制和失败处理逻辑。
        │   │   │           ├── lost_void_choose_common.py    ## 摘要 |  | **文件功能:** |  | 該 Python 腳本實現了在遊戲 "迷失之地" 中選擇物品的自動化操作。它根據屏幕上的文本和圖像識別，選擇符合優先級的藏品或武備，並處理刷新和確認操作。 |  | **核心類和函數:** |  | *   **`LostVoidChooseCommon(ZContext)`**:  繼承自 `ZOperation`，負責執行選擇操作。 |     *   `__init__(self, ctx: ZContext)`: 初始化，設置操作名稱和選擇數量。 |     *   `choose_artifact(self) -> OperationRoundResult`:  核心函數，執行選擇流程，包括識別屏幕、選擇物品、刷新和確認。 |     *   `get_artifact_pos(self, screen: MatLike) -> Tuple[List[MatchResult], List[MatchResult]]`:  識別屏幕上的藏品或武備位置，並確定已選擇的物品。 |  | **重要功能點:** |  | *   **屏幕識別和 OCR:** 使用 OCR 識別屏幕上的文本，以確定需要選擇的物品數量和類型。 | *   **物品優先級:**  根據配置的優先級選擇物品，並處理刷新操作以獲取更多選擇。 | *   **選擇邏輯:**  根據識別到的物品數量和優先級，執行點擊操作來選擇物品。 | *   **錯誤處理:**  使用 `round_retry` 和 `round_wait` 處理錯誤和等待，確保操作的穩定性。 | *   **調試功能:** 包含 `__debug()` 和 `__get_get_artifact_pos()` 函數，用於測試和調試。
        │   │   │           ├── lost_void_choose_gear.py    ```python | # 摘要 | # 文件功能： | #   该文件定义了在“迷失之地”游戏中选择武备的操作。它负责识别屏幕上的武备，并根据优先级选择和点击它们。 | # 核心类和函数： | #   - LostVoidChooseGear: 继承自 ZOperation，负责武备选择操作。 | #   - choose_gear(self) -> OperationRoundResult:  主函数，选择武备。 | #   - get_gear_pos(self, screen_list: List[MatLike], only_no_level: bool = False) -> List[MatchResult]:  识别武备位置。 | #   - get_level_pos(self, screen: MatLike) -> List[MatchResult]:  获取等级的位置。 | #   - click_equip(self) -> OperationRoundResult: 点击携带按钮。 | #   - click_back(self) -> OperationRoundResult: 点击返回按钮。 | # 重要功能点： | #   - 使用图像识别技术（特征匹配）来识别屏幕上的武备。 | #   - 根据优先级选择武备。 | #   - 包含重试机制，以应对识别失败的情况。 | #   - 提供了点击“携带”和“返回”按钮的功能。 | ```
        │   │   │           ├── lost_void_choose_no_detail.py    此 Python 文件定义了一个名为 `LostVoidChooseNoDetail` 的类，用于处理“迷失之地-无详情选择”场景下的交互操作。 |  | **主要功能:** |  | *   在“迷失之地-无详情选择”界面中选择藏品并点击确定。 | *   处理可能出现的二次选择情况。 |  | **核心类和函数:** |  | *   `LostVoidChooseNoDetail(ZContext)`:  继承自 `ZOperation`，初始化操作，并维护已选择的藏品索引列表 `chosen_idx_list`。 | *   `choose_artifact()`:  作为起始节点，尝试选择藏品。它首先移动鼠标到特定位置，然后截图。接着，它会检查当前屏幕是否为“迷失之地-无详情选择”或“迷失之地-通用选择”。如果识别到“通用选择”，则直接返回成功。否则，它会调用 `get_artifact_pos()` 获取藏品位置，并根据优先级选择一个藏品进行点击。 | *   `get_artifact_pos(screen: MatLike) -> List[MatchResult]`:  从屏幕截图中识别藏品的位置。它会裁剪出藏品名称区域，使用 OCR 识别文本，然后匹配藏品信息。 | *   `click_confirm()`:  点击“确定”按钮。它会检查是否需要处理二次选择，并尝试点击“确定”按钮，直到不再找到该按钮。 |  | **重要功能点:** |  | *   **屏幕识别和导航:** 使用 `screen_loader` 和 `round_by_find_area` 等方法进行屏幕识别和导航。 | *   **OCR 识别:** 使用 OCR 识别藏品名称。 | *   **藏品选择逻辑:**  根据优先级选择藏品，并排除已选择的藏品。 | *   **错误处理和重试:** 使用 `round_retry` 处理可能的错误，并进行重试。 | *   **二次选择处理:**  处理可能出现的二次选择情况。
        │   │   │           ├── lost_void_choose_no_num.py    這個 Python 腳本定義了一個名為 `LostVoidChooseNoNum` 的類，它繼承自 `ZOperation`，用於處理遊戲中“迷失之地”場景中不需要選擇數量的選擇操作。 |  | **主要功能：** |  | *   處理“迷失之地”場景中不需要數量選擇的交互，例如點擊“確定”按鈕。 |  | **核心類和函數：** |  | *   `LostVoidChooseNoNum(ZOperation)`：繼承自 `ZOperation`，處理“迷失之地-無數量選擇”的操作。 |     *   `choose_artifact()`：使用 `@operation_node` 裝飾器標記，是操作的起始節點。它移動鼠標到特定區域，截圖，檢查當前屏幕，並點擊“確定”按鈕。 |  | **重要功能點：** |  | *   使用屏幕截圖和圖像識別來確認當前屏幕狀態。 | *   使用 `round_by_find_and_click_area` 函數來查找並點擊屏幕上的特定區域（例如“確定”按鈕）。 | *   包含重試機制，以處理可能發生的屏幕識別錯誤。 | *   `__debug()` 函數用於測試和調試該操作。
        │   │   │           ├── lost_void_interact_target_const.py    此 Python 文件定义了与“虚空”游戏模式中的交互目标相关的常量和类。 |  | *   **主要功能:** 定义了可交互的 NPC、BOSS 和其他目标的枚举，并提供了一个函数来根据 OCR 结果匹配交互目标。 | *   **核心类和函数:** |     *   `LostVoidInteractNPC`:  一个枚举，定义了可交互的 NPC 的名称。 |     *   `LostVoidBoss`:  一个枚举，定义了最终入口交互的 BOSS 的名称。 |     *   `LostVoidInteractTarget`:  一个类，表示一个交互目标，包含名称、图标、交互类型等属性。 |     *   `match_interact_target(ctx: ZContext, ocr_result: str) -> Optional[LostVoidInteractTarget]`:  核心函数，根据 OCR 结果匹配具体的交互目标，并返回 `LostVoidInteractTarget` 对象。 | *   **重要功能点:** |     *   使用枚举定义了可交互的 NPC 和 BOSS。 |     *   `LostVoidInteractTarget` 类用于封装交互目标的信息。 |     *   `match_interact_target` 函数使用字符串匹配来识别交互目标，并根据匹配结果创建 `LostVoidInteractTarget` 对象。 |     *   函数考虑了不同类型的交互，如与 NPC、代理人、入口和 BOSS 的交互。
        │   │   │           ├── lost_void_lottery.py    這段程式碼定義了一個名為 `LostVoidLottery` 的類，它繼承自 `ZOperation`，用於執行遊戲「迷失之地-抽獎機」的抽獎操作。 |  | **主要功能:** |  | *   執行「迷失之地-抽獎機」的抽獎流程，包括點擊開始按鈕、處理抽獎結果，以及在抽獎次數用盡或出現錯誤時返回大世界。 | *   根據不同的抽獎結果，導航到不同的交互操作，例如 `LostVoidChooseCommon`、`LostVoidChooseNoDetail` 和 `LostVoidChooseNoNum`。 |  | **核心類和函數:** |  | *   `LostVoidLottery(ZOperation)`:  主類，負責抽獎流程的控制。 |     *   `click_start()`: 點擊開始按鈕，並檢查剩餘抽獎次數。 |     *   `confirm_after_click()`: 處理點擊開始後的界面，判斷並執行相應的交互操作，或者點擊獲取確定按鈕。 |     *   `back_to_world()`: 在抽獎次數用盡或失敗時，返回大世界。 |  | **重要功能點:** |  | *   使用 OCR 識別剩餘抽獎次數。 | *   根據不同的界面，調用不同的交互操作。 | *   使用 `operation_node` 和 `node_from` 裝飾器定義操作流程和狀態轉換。 | *   包含一個 `__debug()` 函數，用於測試。
        │   │   │           └── lost_void_route_change.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件定義了一個名為 `LostVoidRouteChange` 的操作，用於處理遊戲中「迷失之地」的路径迭换。 |  | **核心類和函數：** |  | *   `LostVoidRouteChange`：繼承自 `ZOperation`，負責執行迷失之地路径迭换相關的操作。 |     *   `back_to_world()`：嘗試返回到遊戲世界。 |  | **重要功能點：** |  | *   `back_to_world()` 使用截圖判斷是否在遊戲世界中，如果不在，則嘗試通過點擊按鈕返回。 | *   使用了 `@operation_node` 裝飾器來定義操作節點，並指定了重試次數。 | *   使用了 `round_by_find_and_click_area` 函數來查找並點擊屏幕上的區域。 | *   使用了 `round_retry` 和 `round_success` 函數來處理操作的結果。
        │   │   └── withered_domain/
        │   │       ├── hollow_zero_app.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了 `HollowZeroApp` 类，用于自动化处理游戏《崩坏：星穹铁道》中“枯萎之都”的日常任务。它通过模拟用户操作，完成传送、选择副本、出战、自动运行等流程。 |  | **核心类和函数:** |  | *   **`HollowZeroApp(ZApplication)`:**  继承自 `ZApplication`，是核心类，负责整个“枯萎之都”任务的自动化流程。 |     *   `__init__(self, ctx: ZContext)`: 初始化，设置任务名称、类型等。 |     *   `handle_init(self)`: 初始化配置。 |     *   `check_first_screen(self) -> OperationRoundResult`: 检查初始屏幕，判断是否在空洞内。 |     *   `tp(self) -> OperationRoundResult`: 传送至“枯萎之都”。 |     *   `wait_entry_loading(self) -> OperationRoundResult`: 等待入口加载。 |     *   `choose_mission_type(self) -> OperationRoundResult`: 选择副本类型。 |     *   `choose_mission(self) -> OperationRoundResult`: 选择副本。 |     *   `click_next(self) -> OperationRoundResult`: 点击“下一步”等按钮。 |     *   `deploy(self) -> OperationRoundResult`: 部署队伍。 |     *   `auto_run(self) -> OperationRoundResult`: 自动运行副本。 |     *   `wait_back_loading(self) -> OperationRoundResult`: 完成后等待加载。 |     *   `finish(self) -> OperationRoundResult`: 返回正常世界。 | *   **`__debug()`:**  用于调试，创建 `ZContext` 实例并运行 `HollowZeroApp`。 |  | **重要功能点:** |  | *   **流程控制:**  使用 `@operation_node` 和 `@node_from` 装饰器定义操作节点和流程依赖关系，构建任务流程。 | *   **屏幕识别:**  使用 `screenshot()` 截屏，并结合 `round_by_find_area`, `round_by_ocr_and_click` 等方法进行屏幕元素识别和点击操作。 | *   **任务执行:**  调用 `
        │   │       ├── hollow_zero_config.py    這個 Python 文件的主要功能是定義和管理 "空洞零" 遊戲模塊的配置。 |  | 核心類和函數： |  | *   **HollowZeroExtraTask**:  一個枚舉，定義了額外的任務選項，例如 "不进行"、"刷满业绩点" 和 "刷满周期奖励"。 | *   **HollowZeroExtraExitEnum**:  一個枚舉，定義了額外的退出條件，例如 "通关"、"2层业绩后退出" 和 "3层业绩后退出"。 | *   **HollowZeroConfig**:  繼承自 `YamlConfig`，負責加載、保存和管理 "空洞零" 模塊的配置。它包含多個屬性，用於訪問和修改配置項。 |  | 重要功能點： |  | *   使用 `YamlConfig` 處理配置文件的加載和保存。 | *   定義了多個配置屬性，例如 `mission_name`, `challenge_config`, `weekly_plan_times`, `daily_plan_times`, `extra_task` 和 `extra_exit`，每個屬性都有 getter 和 setter 方法。 | *   使用枚舉 `HollowZeroExtraTask` 和 `HollowZeroExtraExitEnum` 來定義額外的任務和退出選項，增強了配置的可讀性和可維護性。 | *   `challenge_config_adapter` 屬性提供了一個 `YamlConfigAdapter` 實例，用於適配 `challenge_config` 配置項。
        │   │       ├── hollow_zero_debug_app.py    這個 Python 文件定義了一個名為 `HollowZeroDebugApp` 的應用程式，用於調試零號空洞相關的功能。 |  | *   **主要功能:** 啟動並運行零號空洞的調試流程。 | *   **核心類:** |     *   `HollowZeroDebugApp`: 繼承自 `ZApplication`，負責初始化應用程式，設置任務名稱和類型，並觸發零號空洞的自動運行。 | *   **核心函數:** |     *   `__init__`: 初始化應用程式，設置應用程式 ID、名稱和運行記錄。 |     *   `handle_init`: 根據配置初始化任務名稱和類型。 |     *   `auto_run`: 使用 `HollowRunner` 執行零號空洞的流程，並返回結果。 | *   **重要功能點:** |     *   初始化任務信息。 |     *   使用 `HollowRunner` 運行零號空洞的邏輯。 |     *   使用 `@operation_node` 裝飾器標記 `auto_run` 函數為起始節點。
        │   │       └── hollow_zero_run_record.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `HollowZeroRunRecord` 类，用于管理和跟踪游戏 "Hollow Zero" 的运行状态，包括每日和每周的运行次数、完成状态以及相关的配置信息。 |  | **核心类和函数:** |  | *   **`HollowZeroRunRecord`**: 继承自 `AppRunRecord`，用于记录和管理 Hollow Zero 的运行状态。 |     *   `__init__`: 初始化函数，设置运行记录的类型、实例索引和游戏刷新时间偏移。 |     *   `run_status_under_now`:  根据当前时间计算并返回当前的运行状态（等待、成功）。 |     *   `check_and_update_status`:  检查并更新运行状态，包括重置记录。 |     *   `reset_for_weekly`: 重置每周的运行次数、每日运行次数和相关状态。 |     *   `weekly_run_times`: 属性，用于获取和设置每周的运行次数。 |     *   `daily_run_times`: 属性，用于获取和设置每日的运行次数。 |     *   `add_times`: 增加通关次数。 |     *   `add_daily_times`: 增加每日进入次数。 |     *   `is_finished_by_times`: 检查是否已完成（基于运行次数）。 |     *   `is_finished_by_weekly_times`: 检查是否已完成（基于每周运行次数）。 |     *   `is_finished_by_day`: 检查是否已完成（基于每日）。 |     *   `is_finished_by_week`: 检查是否已完成（基于每周）。 |     *   `no_eval_point`: 属性，用于获取和设置是否获得评估点。 |     *   `period_reward_complete`: 属性，用于获取和设置周期奖励是否完成。 |  | **重要功能点:** |  | *   跟踪每日和每周的运行次数。 | *   根据配置和运行次数判断是否完成。 | *   根据时间（日、周）重置运行状态。 | *   支持额外的任务类型（评估点、周期奖励）。 | *   提供方法来增加运行次数和每日进入次数。
        │   ├── life_on_line/
        │   │   ├── life_on_line_app.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 脚本定义了一个自动化应用程序 `LifeOnLineApp`，用于在游戏中执行“真拿命验收”任务的自动化流程。它通过一系列操作节点，模拟用户操作，完成任务的循环执行，直到达到设定的次数或遇到特定情况。 |  | **核心类和函数:** |  | *   **`LifeOnLineApp(ZApplication)`:**  核心类，继承自 `ZApplication`，负责整个自动化流程的控制。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用程序，设置运行记录等。 |     *   `tp(self)`: 传送操作。 |     *   `wait_world(self)`: 等待加载。 |     *   `interact(self)`: 交互操作。 |     *   `enter_mission(self)`: 进入副本。 |     *   `wait_battle_screen(self)`: 等待战斗画面加载。 |     *   `run_key_sim(self)`: 模拟按键操作。 |     *   `interact_after_mission(self)`: 通关后的交互。 |     *   `talk_after_mission(self)`: 通关后的对话。 |     *   `click_finished(self)`: 点击完成。 |     *   `check_times(self)`: 检查运行次数。 |     *   `back_to_world(self)`: 返回大世界。 |     *   `fail_to_interact(self)`: 交互失败处理。 |     *   `click_exit_battle(self)`: 点击退出战斗。 |     *   `click_exit_battle_confirm(self)`: 点击退出战斗确认。 | *   **`ZContext`:**  上下文对象，包含游戏环境的各种信息。 | *   **`LifeOnLineRunRecord`:**  运行记录，用于跟踪任务的执行次数和状态。 | *   **`OperationRoundResult`:**  操作结果类，用于表示操作的成功与否及状态。 |  | **重要功能点:** |  | *   **流程控制:**  使用 `@node_from` 和 `@operation_node` 装饰器定义操作节点，构建任务流程图，实现自动化流程。 | *   **图像识别:**  使用 `self.
        │   │   ├── life_on_line_config.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 這個文件定義了 `LifeOnLineConfig` 類，用於管理 "life_on_line" 模塊的配置，這些配置儲存在 YAML 文件中。它提供了訪問和修改配置參數的接口。 |  | **核心類和函數:** |  | *   `LifeOnLineConfig`: 繼承自 `YamlConfig`，負責加載、保存和管理 "life\_on\_line" 模塊的配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化配置，指定模塊名稱和實例索引。 |     *   `daily_plan_times` (property):  獲取和設置每日計劃次數。 |     *   `daily_plan_times_adapter` (property):  提供 `daily_plan_times` 的配置適配器，用於在 UI 中顯示和編輯配置。 |     *   `predefined_team_idx` (property):  獲取和設置預定義隊伍的索引。 |     *   `predefined_team_idx_adapter` (property):  提供 `predefined_team_idx` 的配置適配器。 |  | **重要功能點:** |  | *   使用 `YamlConfig` 處理 YAML 配置文件。 | *   使用 property 實現配置參數的獲取和設置，提供簡潔的 API。 | *   使用 `YamlConfigAdapter` 為配置參數提供 UI 適配器，方便在界面中進行配置。 | *   定義了 `daily_plan_times` 和 `predefined_team_idx` 兩個重要的配置參數。
        │   │   └── life_on_line_run_record.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了 `LifeOnLineRunRecord` 類，用於記錄和管理遊戲 "life_on_line" 的運行記錄，包括每日運行次數。 |  | **核心類和函數:** |  | *   `LifeOnLineRunRecord`: 繼承自 `AppRunRecord`，用於記錄遊戲的運行狀態。 |     *   `__init__`: 初始化 `LifeOnLineRunRecord`，接收 `LifeOnLineConfig` 實例。 |     *   `reset_record`: 重置運行記錄，包括每日運行次數。 |     *   `daily_run_times`: 屬性，用於獲取和設置每日運行次數。 |     *   `add_times`: 增加每日運行次數。 |     *   `is_finished_by_times`: 檢查是否已達到每日運行次數上限。 |  | **重要功能點:** |  | *   記錄和管理遊戲的每日運行次數。 | *   提供方法增加運行次數。 | *   提供方法判斷是否達到每日運行次數上限，依據 `LifeOnLineConfig` 中的配置。
        │   ├── miscellany/
        │   │   ├── miscellany_app.py    這個 Python 文件定義了 `MiscellanyApp` 類，它是一個應用程序，用於管理其他子應用程序。 |  | *   **主要功能:** 管理和執行其他應用程序，例如兌換碼、郵件和在線生命應用程序。它還負責初始化、獲取和更新子應用程序的運行順序。 | *   **核心類和函數:** |     *   `MiscellanyApp`: 繼承自 `OneDragonApp` 和 `ZApplication`，是主要應用程序類。 |     *   `__init__(self, ctx: ZContext)`: 應用程序的構造函數，初始化應用程序 ID 和操作。 |     *   `handle_init(self) -> None`: 初始化應用程序實例。 |     *   `get_app_list(self) -> List[ZApplication]`: 返回子應用程序的列表。 |     *   `get_app_order_list(self) -> List[str]`: 獲取子應用程序的運行順序。 |     *   `update_app_order_list(self, new_app_orders: List[str]) -> None`: 更新子應用程序的運行順序。 | *   **重要功能點:** |     *   管理子應用程序的生命週期和執行順序。 |     *   使用 `ZContext` 獲取配置和上下文信息。 |     *   提供用於獲取和更新應用程序運行順序的方法。 |     *   包含一個 `__debug()` 函數，用於測試和調試應用程序。
        │   │   ├── miscellany_config.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 這個文件定義了 `MiscellanyConfig` 類，用於管理與雜項配置相關的設置，特別是應用程序的運行順序和運行列表。它使用 `YamlConfig` 類來加載和保存配置數據。 |  | **核心類和函數:** |  | *   **`MiscellanyConfig`**:  繼承自 `YamlConfig`，負責處理雜項配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化配置，指定配置文件的名稱。 |     *   `app_order` (property):  獲取和設置應用程序的運行順序 (List[str])。 |     *   `move_up_app(self, app_id: str)`:  將指定應用程序的運行順序往前調一位。 |     *   `app_run_list` (property):  獲取和設置應用程序的運行列表 (List[str])。 |     *   `set_app_run(self, app_id: str, to_run: bool)`:  根據 `to_run` 參數，將應用程序添加到或從運行列表中移除。 |  | **重要功能點:** |  | *   管理應用程序的運行順序，允許調整應用程序的執行順序。 | *   控制哪些應用程序應該運行，通過 `app_run_list` 實現。 | *   使用 `YamlConfig` 類來加載和保存配置，使得配置可以持久化。
        │   │   └── miscellany_run_record.py    這個 Python 文件定義了一個名為 `MiscellanyRunRecord` 的類，用於記錄和管理雜項應用程序的運行狀態。 |  | *   **主要功能:** 記錄雜項應用程序的運行狀態，並提供相關的狀態檢查和更新功能。 | *   **核心類:** `MiscellanyRunRecord` 繼承自 `AppRunRecord`。 | *   **重要功能點:** |     *   `__init__`: 初始化 `MiscellanyRunRecord` 實例，並調用父類 `AppRunRecord` 的初始化方法。 |     *   `check_and_update_status`: 重置運行記錄。 |     *   `run_status_under_now`: 始終返回 `AppRunRecord.STATUS_WAIT`，表示應用程序始終處於等待狀態。
        │   ├── notorious_hunt/
        │   │   ├── notorious_hunt_app.py    這個 Python 文件定義了 `NotoriousHuntApp` 類，它是一個用於處理《原神》遊戲中惡名狩獵活動的應用程式。 |  | **主要功能:** |  | *   自動執行惡名狩獵任務。 | *   領取惡名狩獵的獎勵。 | *   處理任務流程中的各種狀態和錯誤。 |  | **核心類和函數:** |  | *   `NotoriousHuntApp`: 繼承自 `ZApplication`，是惡名狩獵應用程式的主類。 |     *   `__init__(self, ctx: ZContext)`: 初始化應用程式，設置應用程式 ID 和運行記錄。 |     *   `handle_init(self) -> None`: 執行前的初始化。 |     *   `transport(self) -> OperationRoundResult`: 傳送到惡名狩獵地點。 |     *   `notorious_hunt(self) -> OperationRoundResult`: 執行惡名狩獵。 |     *   `check_left_times(self) -> OperationRoundResult`: 檢查剩餘次數。 |     *   `click_reward_entry(self) -> OperationRoundResult`: 點擊獎勵入口。 |     *   `claim_all(self) -> OperationRoundResult`: 領取所有獎勵。 |     *   `back_to_world(self) -> OperationRoundResult`: 返回大世界。 |  | **重要功能點:** |  | *   使用 `operation_node` 裝飾器定義任務流程中的節點。 | *   使用 `node_from` 裝飾器定義節點之間的依賴關係。 | *   根據配置獲取下一個惡名狩獵計劃。 | *   處理惡名狩獵的剩餘次數和獎勵領取。 | *   使用 `TransportByCompendium`, `NotoriousHunt` 和 `BackToNormalWorld` 等操作類來執行具體的操作。
        │   │   ├── notorious_hunt_config.py    此 Python 文件定义了恶名狩猎（Notorious Hunt）的配置类，用于管理和存储游戏中的狩猎计划。 |  | *   **主要功能:** 加载、保存和管理恶名狩猎的计划，包括计划的更新、移动、重置和获取下一个计划。 | *   **核心类和函数:** |     *   `NotoriousHuntLevelEnum`: 定义了恶名狩猎的等级枚举。 |     *   `NotoriousHuntBuffEnum`: 定义了恶名狩猎的 Buff 枚举。 |     *   `NotoriousHuntConfig`: 继承自 `YamlConfig`，用于加载和保存恶名狩猎的配置。 |         *   `__init__`: 初始化配置，加载计划列表，并处理版本兼容性问题。 |         *   `_get_default_plan`: 获取默认的周本计划。 |         *   `save`: 保存配置到 YAML 文件。 |         *   `update_plan`: 更新指定索引的计划。 |         *   `move_up`: 向上移动计划的顺序。 |         *   `reset_plans`: 重置所有计划的运行次数。 |         *   `get_next_plan`: 获取下一个需要执行的计划。 |         *   `add_plan_run_times`: 为匹配的计划增加运行次数。 |         *   `_is_same_plan`: 检查两个计划是否相同。 | *   **重要功能点:** |     *   从 YAML 文件加载和保存狩猎计划。 |     *   支持计划的更新、排序和重置。 |     *   提供获取下一个计划的逻辑。 |     *   处理计划的运行次数。 |     *   包含版本兼容性处理，例如更新 TAB 名称。
        │   │   └── notorious_hunt_run_record.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了 `NotoriousHuntRunRecord` 類，用於記錄和管理「惡名追捕」遊戲的運行記錄。它繼承自 `AppRunRecord`，並擴展了其功能以適應遊戲的特定需求。 |  | **核心類和函數:** |  | *   `NotoriousHuntRunRecord`: 核心類，用於管理惡名追捕的運行記錄。 |     *   `__init__(self, instance_idx: Optional[int] = None, game_refresh_hour_offset: int = 0)`: 構造函數，初始化運行記錄，設置遊戲類型、實例索引、刷新時間偏移和記錄週期。 |     *   `reset_record(self) -> None`: 重置記錄，包括調用父類的重置方法，並將剩餘次數重置為 3。 |     *   `run_status_under_now`: 屬性，根據當前時間和剩餘次數返回遊戲的運行狀態（等待、運行中、成功）。 |     *   `left_times`: 屬性，用於獲取和設置剩餘遊戲次數。 |  | **重要功能點:** |  | *   記錄遊戲的運行狀態，包括是否需要重置和剩餘次數。 | *   提供 `reset_record` 方法，用於重置遊戲記錄。 | *   使用 `AppRunRecordPeriod.WEEKLY` 作為記錄週期。 | *   使用 `left_times` 屬性來跟踪玩家剩餘的遊戲次數。
        │   ├── predefined_team_checker/
        │   │   └── predefined_team_checker.py    這個 Python 腳本 `predefined_team_checker.py` 實現了在遊戲中識別預定義編隊角色的功能。 |  | **主要功能:** |  | *   識別遊戲中的預定義編隊角色，並將其與配置的編隊信息進行匹配。 | *   通過 OCR 識別編隊名稱和角色頭像，然後匹配角色模板。 | *   支持在屏幕上滑動以識別更多角色。 |  | **核心類和函數:** |  | *   **`TeamWrapper`**: 封裝編隊名稱和角色列表。 | *   **`PredefinedTeamChecker`**: 繼承自 `ZApplication`，是主要的功能類。 |     *   `__init__`: 初始化，設置應用 ID 和重試選項。 |     *   `goto_menu`: 前往遊戲菜單畫面。 |     *   `goto_menu_more`: 前往更多功能畫面。 |     *   `click_predefined_team`: 點擊預備編隊按鈕。 |     *   `check_team_members`: 識別編隊角色，包括截圖、更新角色信息和滑動屏幕。 |     *   `update_team_members`: 使用 OCR 識別編隊名稱和角色頭像，並更新編隊成員信息。 | *   `__debug()`: 測試函數，用於初始化上下文並運行 `PredefinedTeamChecker`。 |  | **重要功能點:** |  | *   使用 `operation_node` 裝飾器定義操作流程，例如前往菜單、點擊按鈕等。 | *   使用 OCR 識別編隊名稱和角色頭像。 | *   使用模板匹配來識別角色。 | *   支持屏幕滑動以獲取更多編隊信息。 | *   將識別到的角色信息更新到 `team_config` 中。
        │   ├── random_play/
        │   │   ├── random_play_app.py    ```python | 摘要: |  | 該 Python 腳本定義了一個名為 RandomPlayApp 的 ZApplication 類，用於在遊戲中執行影像店營業的隨機播放功能。 |  | 核心類和函數: |  | *   **RandomPlayApp**: 繼承自 ZApplication，負責隨機播放流程的控制。 |     *   `__init__`: 初始化應用程式，設置應用程式 ID、名稱、運行記錄等。 |     *   `handle_init`: 初始化，設置錄像帶主題列表和需要的主題列表。 |     *   `transport`: 傳送到指定地點。 |     *   `wait_world`: 等待世界加載。 |     *   `move_and_interact`: 移動和交互。 |     *   `wait_run`: 等待經營畫面加載。 |     *   `check_running`: 檢查營業狀態。 |     *   `click_promoter_entry`: 點擊宣傳員入口。 |     *   `choose_promoter`: 選擇宣傳員，支持隨機選擇和名稱/頭像匹配。 |     *   `get_pos_by_avatar`: 根據頭像匹配宣傳員位置。 |     *   `check_video_theme`: 識別錄像帶主題。 |     *   `click_video_entry`: 點擊錄像帶入口。 |     *   `check_recommended`: 檢查推薦上架。 |     *   `click_filter`: 點擊上架篩選。 |     *   `choose_theme`: 選擇主題。 |     *   `choose_onshelf`: 上架。 |     *   `back`: 返回。 |     *   `start`: 開始營業。 |     *   `confirm`: 確認開始營業。 |     *   `back_to_world`: 返回大世界。 |  | 重要功能點: |  | *   流程控制：使用 operation\_node 裝飾器定義了遊戲操作的流程，包括傳送、等待、交互、檢查狀態、選擇宣傳員、選擇主題、上架等。 | *   宣傳員選擇：支持隨機選擇宣傳員，以及通過名稱和頭像匹配宣傳員。 | *   主題識別與篩選：識別錄像帶主題，並根據主題進行篩選和上架。
        │   │   ├── random_play_config.py    這個 Python 文件定義了 `RandomPlayConfig` 類，用於管理隨機遊戲配置。 |  | *   **主要功能:** 讀取和管理隨機遊戲的配置參數，例如 agent 的名稱。 | *   **核心類:** `RandomPlayConfig` 繼承自 `YamlConfig`，用於處理 YAML 配置文件。 | *   **重要功能點:** |     *   `__init__`: 初始化配置，指定模塊名稱和實例索引。 |     *   `random_agent_name()`: 靜態方法，返回默認的 agent 名稱 "随机"。 |     *   `agent_name_1` 和 `agent_name_2`: 屬性，用於獲取和設置 agent 的名稱，從配置文件中讀取，如果不存在則使用默認值。
        │   │   └── random_play_run_record.py    這個 Python 文件定義了 `RandomPlayRunRecord` 類，用於記錄隨機遊戲的運行信息。 |  | *   **核心類:** `RandomPlayRunRecord` 繼承自 `AppRunRecord`。 | *   **主要功能:** 記錄隨機遊戲的運行，並初始化時設定遊戲實例索引和遊戲刷新小時偏移量。 | *   **重要功能點:**  `__init__` 方法初始化 `RandomPlayRunRecord` 實例，並調用父類 `AppRunRecord` 的初始化方法，設定應用名稱為 'random\_play'。
        │   ├── redemption_code/
        │   │   ├── redemption_code_app.py    **摘要:** |  | 该文件定义了一个名为 `RedemptionCodeApp` 的应用程序，用于自动兑换游戏中的兑换码。它继承自 `ZApplication`，并使用一系列操作节点来完成兑换流程。 |  | **核心类和函数:** |  | *   **`RedemptionCodeApp(ZContext)`**:  主应用程序类，负责整个兑换码兑换流程的控制。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用程序，包括设置应用程序 ID、名称和运行记录。 |     *   `check_new_code(self) -> OperationRoundResult`: 检查是否有新的兑换码。 |     *   `open_menu(self) -> OperationRoundResult`: 打开游戏菜单。 |     *   `click_more(self) -> OperationRoundResult`: 点击“更多”按钮。 |     *   `click_code(self) -> OperationRoundResult`: 点击“兑换码”按钮。 |     *   `input_code(self) -> OperationRoundResult`: 输入兑换码。 |     *   `confirm_code(self) -> OperationRoundResult`: 确认兑换码兑换。 |     *   `back(self) -> OperationRoundResult`: 返回到正常游戏世界。 | *   **`ZContext`**:  游戏上下文，包含游戏状态和配置信息。 | *   **`OpenMenu`, `BackToNormalWorld`**:  用于打开菜单和返回正常世界的辅助操作类。 |  | **重要功能点:** |  | *   自动从 `redemption_code_record` 中获取未使用的兑换码列表。 | *   通过模拟点击和 OCR 识别来导航游戏界面，找到兑换码输入框和兑换按钮。 | *   使用键盘输入兑换码。 | *   处理兑换成功和失败的情况，并更新兑换码使用记录。 | *   提供一个调试函数 `__debug()` 用于测试。
        │   │   └── redemption_code_run_record.py    這個 Python 文件的主要功能是管理和追蹤兌換碼的運行記錄。 |  | 核心類和函數： |  | *   **RedemptionCode**:  一個數據類，用於表示兌換碼及其失效日期。 | *   **RedemptionCodeRunRecord**:  繼承自 `AppRunRecord`，用於管理兌換碼的運行狀態。 |     *   `__init__`: 初始化，包含有效的兌換碼列表。 |     *   `run_status_under_now`: 根據當前日期和未使用的兌換碼列表，返回運行狀態。 |     *   `check_and_update_status`: 檢查並更新運行狀態，如果存在未使用的兌換碼，則重置記錄。 |     *   `used_code_list`:  屬性，用於獲取和設置已使用的兌換碼列表。 |     *   `get_unused_code_list(dt: str)`:  根據日期獲取未使用的兌換碼列表。 |     *   `add_used_code(code: str)`:  將兌換碼添加到已使用列表中。 |  | 重要功能點： |  | *   管理有效的兌換碼列表。 | *   根據當前日期和已使用列表，計算未使用的兌換碼。 | *   追蹤和更新兌換碼的運行狀態。 | *   記錄已使用的兌換碼。
        │   ├── ridu_weekly/
        │   │   ├── ridu_weekly_app.py    這個 Python 腳本定義了一個名為 `RiduWeeklyApp` 的應用程序，用於自動化麗都周紀的遊戲任務。 |  | **核心類和函數:** |  | *   `RiduWeeklyApp`: 繼承自 `ZApplication`，是應用程序的主要類。 |     *   `__init__`: 初始化應用程序，設置應用程序 ID、名稱、運行記錄和重試選項。 |     *   `open_compendium`: 打開快捷手册。 |     *   `choose_train`: 選擇日常。 |     *   `click_schedule`: 點擊麗都周紀。 |     *   `claim_score`: 領取積分。 |     *   `confirm_schedule`: 領取獎勵。 |     *   `finish`: 完成任務並返回。 | *   `ZContext`: 遊戲上下文，提供遊戲環境信息。 | *   `OpenCompendium`: 打開快捷手册的操作。 | *   `BackToNormalWorld`: 返回正常世界的操作。 |  | **重要功能點:** |  | *   自動化麗都周紀任務流程，包括打開快捷手册、選擇日常、點擊麗都周紀、領取積分和獎勵，以及完成任務。 | *   使用 `operation_node` 和 `node_from` 裝飾器定義任務流程中的節點和依賴關係。 | *   使用 `round_by_op_result`, `round_by_goto_screen`, `round_by_find_and_click_area`, `round_by_ocr_and_click` 等方法處理遊戲交互和流程控制。 | *   包含重試機制，以處理遊戲中的錯誤或異常情況。 | *   `__debug` 函數用於測試和調試應用程序。
        │   │   └── ridu_weekly_run_record.py    這個 Python 文件定義了 `RiduWeeklyRunRecord` 類，用於記錄和管理 "ridu_weekly" 應用程序的運行記錄。 |  | *   **核心類:** `RiduWeeklyRunRecord` 繼承自 `AppRunRecord`。 | *   **核心函數:** `__init__` 函數用於初始化 `RiduWeeklyRunRecord` 實例，並調用父類 `AppRunRecord` 的初始化函數。 | *   **重要功能點:** 該類主要用於記錄 "ridu\_weekly" 應用程序的運行信息，包括實例索引和遊戲刷新小時偏移量。
        │   ├── scratch_card/
        │   │   ├── scratch_card_app.py    **摘要:** |  | 该文件定义了 `ScratchCardApp` 类，用于实现游戏 "刮刮卡" 功能的自动化流程。它继承自 `ZApplication`，并使用一系列操作节点来完成刮刮卡相关的任务。 |  | **核心类和函数:** |  | *   `ScratchCardApp`:  继承自 `ZApplication`，负责整个刮刮卡流程的控制。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用，设置应用 ID、名称、运行记录等。 |     *   `handle_init(self) -> None`: 初始化函数，目前为空。 |     *   `transport(self) -> OperationRoundResult`: 传送至指定地点。 |     *   `wait_world(self) -> OperationRoundResult`: 等待游戏世界加载。 |     *   `move_and_interact(self) -> OperationRoundResult`: 移动并交互。 |     *   `click_scratch_card(self) -> OperationRoundResult`: 点击刮刮卡。 |     *   `scratch(self) -> OperationRoundResult`: 执行刮刮操作。 |     *   `back_to_world(self) -> OperationRoundResult`: 返回大世界。 | *   `__debug()`: 用于调试的函数，创建 `ZContext` 和 `ScratchCardApp` 实例，并执行刮刮卡流程。 |  | **重要功能点:** |  | *   **流程控制:**  使用 `@operation_node` 和 `@node_from` 装饰器定义了流程的节点和依赖关系，构建了完整的刮刮卡自动化流程。 | *   **图像识别:**  使用 `round_by_find_area`, `round_by_find_and_click_area`, `round_by_ocr_and_click` 等方法进行图像识别和点击操作。 | *   **用户交互:**  使用 `ctx.controller` 控制角色移动和交互。 | *   **重试机制:**  使用 `node_max_retry_times` 和 `round_retry` 实现重试机制，提高流程的稳定性。 | *   **刮刮操作:**  通过模拟拖动操作实现刮刮卡功能。
        │   │   └── scratch_card_run_record.py    這個 Python 文件定義了一個名為 `ScratchCardRunRecord` 的類，用於記錄刮刮卡遊戲的運行記錄。 |  | *   **主要功能**: 記錄刮刮卡遊戲的運行信息。 | *   **核心類**: `ScratchCardRunRecord` 繼承自 `AppRunRecord`。 | *   **重要功能點**: |     *   `__init__` 方法初始化 `ScratchCardRunRecord` 實例，並調用父類 `AppRunRecord` 的初始化方法，設置遊戲類型為 'scratch\_card'，並處理實例索引和遊戲刷新時間偏移量。
        │   └── shiyu_defense/
        │       ├── shiyu_defense_app.py    ## 摘要 |  | 该 Python 文件定义了 `ShiyuDefenseApp` 类，用于自动化式舆防卫战的流程。 |  | **主要功能:** |  | *   自动化式舆防卫战的流程，包括传送、选择节点、识别弱点、选择配队、出战、自动战斗、领取奖励等。 |  | **核心类和函数:** |  | *   `ShiyuDefenseApp`: 继承自 `ZApplication`，负责式舆防卫战的整体流程控制。 |     *   `tp()`: 传送。 |     *   `wait_loading()`: 等待画面加载。 |     *   `choose_node_idx()`: 选择节点。 |     *   `check_weakness()`: 识别弱点并计算配队。 |     *   `choose_team()`: 选择配队。 |     *   `deploy()`: 出战。 |     *   `shiyu_battle()`: 自动战斗。 |     *   `to_next_node()`: 进入下一节点。 |     *   `all_node_finished()`: 所有节点完成。 |     *   `claim_reward()`: 领取奖励。 |     *   `close_reward()`: 关闭奖励。 |     *   `back_after_all()`: 结束后返回。 | *   `ShiyuDefenseBattle`: 封装了战斗逻辑。 | *   `DefensePhaseTeamInfo`: 存储每个阶段的配队信息。 |  | **重要功能点:** |  | *   根据游戏画面识别节点和弱点，并选择合适的配队。 | *   自动进行战斗，并根据战斗结果进行后续操作。 | *   处理战斗失败的情况。 | *   领取奖励。 | *   使用 `operation_node` 装饰器定义流程中的每个步骤。 | *   使用 `node_from` 装饰器定义节点之间的依赖关系。 | *   使用 `ZContext` 管理游戏上下文信息。
        │       ├── shiyu_defense_battle.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 文件定义了 `ShiyuDefenseBattle` 类，用于在游戏“式舆防卫战”中执行自动战斗。它通过加载自动战斗指令、等待战斗画面、移动角色、自动战斗、处理战斗结果（包括胜利、失败和超时）以及退出战斗等步骤来实现自动战斗流程。 |  | **核心类和函数:** |  | *   **`ShiyuDefenseBattle(ZContext, predefined_team_idx)`:**  主类，继承自 `ZOperation`，负责整个式舆防卫战的自动战斗流程。 |     *   `__init__`: 初始化函数，设置上下文、预设队伍信息，并初始化相关变量。 |     *   `load_auto_op`: 加载自动战斗指令。 |     *   `wait_battle_screen`: 等待战斗画面加载。 |     *   `start_move`: 移动角色到战斗位置。 |     *   `auto_battle`: 执行自动战斗，并根据战斗状态进行处理。 |     *   `move_after_battle`: 战斗结束后移动。 |     *   `check_distance`: 检查角色与目标的距离。 |     *   `battle_timeout`: 处理战斗超时情况。 |     *   `voluntary_exit`: 主动退出战斗。 |     *   `click_exit`, `click_exit_confirm`: 点击退出战斗相关的按钮。 |     *   `battle_fail_exit`: 处理战斗失败撤退的情况。 |     *   `wait_exit`: 等待退出战斗。 |     *   `_on_pause`, `_on_resume`: 处理暂停和恢复操作。 |     *   `after_operation_done`: 在操作完成后停止自动战斗。 |  | **重要功能点:** |  | *   **自动战斗流程:**  定义了完整的自动战斗流程，包括加载指令、等待画面、移动、战斗、处理结果和退出。 | *   **状态管理:**  使用 `OperationRoundResult` 和状态字符串（例如 `STATUS_NEED_SPECIAL_MOVE`, `STATUS_FAIL_TO_MOVE`）来管理和控制流程。 | *   **移动控制:**  根据距离信息控制角色的移动。 | *   **战斗结果处理:**  处理战斗胜利、失败、超时等不同情况，并采取相应的操作。 | *
        │       ├── shiyu_defense_config.py    此 Python 文件定义了式舆防卫战的配置类，用于管理和存储游戏中的队伍配置信息。 |  | *   **核心类:** |     *   `ShiyuDefenseTeamConfig`:  表示单个队伍的配置，包含队伍索引、是否参与剧变节点以及弱点列表。 |     *   `ShiyuDefenseConfig`: 继承自 `YamlConfig`，负责加载、保存和管理所有队伍的配置。 |  | *   **重要功能点:** |     *   `init_team_list()`: 从配置文件中初始化队伍配置。 |     *   `save_team_list()`: 将队伍配置保存到配置文件。 |     *   `get_config_by_team_idx()`: 根据队伍索引获取队伍配置。 |     *   `add_weakness()`/`remove_weakness()`:  添加/移除队伍的弱点。 |     *   `change_for_critical()`: 修改队伍是否参与剧变节点。 |     *   `critical_max_node_idx`:  获取和设置剧变节点的最大索引。
        │       ├── shiyu_defense_run_record.py    這個 Python 文件定義了 `ShiyuDefenseRunRecord` 類，用於記錄和管理名為 "shiyu_defense" 的應用程序的運行狀態。 |  | **主要功能：** |  | *   記錄和管理 "shiyu\_defense" 應用程序的運行狀態，包括劇變節點的完成情況。 | *   提供方法來獲取下一個需要挑戰的節點索引，添加已完成的節點，以及重置記錄。 |  | **核心類和函數：** |  | *   `CriticalNode`:  表示劇變節點的數據結構，包含節點數、開始時間和結束時間。 | *   `ShiyuDefenseRunRecord(AppRunRecord)`:  繼承自 `AppRunRecord`，用於記錄 "shiyu\_defense" 應用程序的運行狀態。 |     *   `__init__(self, config: ShiyuDefenseConfig, instance_idx: Optional[int] = None, game_refresh_hour_offset: int = 0)`:  初始化方法，設置配置和實例索引。 |     *   `run_status_under_now`:  根據當前時間獲取運行狀態。 |     *   `next_node_idx()`:  獲取下一個需要挑戰的節點索引。 |     *   `add_node_finished(self, node_idx: int)`:  將節點標記為已完成。 |     *   `critical_history`:  獲取已完成的劇變節點列表。 |     *   `reset_record()`:  重置運行記錄。 |  | **重要功能點：** |  | *   管理劇變節點的完成歷史。 | *   根據配置和當前時間確定應用程序的運行狀態。 | *   提供方法來更新和查詢節點的完成情況。
        │       └── shiyu_defense_team_utils.py    此 Python 文件实现了式舆防卫战的配队逻辑。 |  | **主要功能：** |  | *   根据游戏画面识别弱点和抗性，并为每个阶段选择最佳队伍。 |  | **核心类和函数：** |  | *   `DefensePhaseTeamInfo`: 存储每个阶段的队伍信息，包括弱点、抗性、队伍下标和得分计算。 |     *   `cal_score`: 计算队伍的得分，基于与弱点和抗性的匹配程度。 |     *   `score`: 返回队伍的得分。 | *   `DefenseTeamSearcher`: 负责搜索最佳配队。 |     *   `search`: 执行深度优先搜索 (DFS) 以找到最佳队伍组合。 |     *   `dfs`: 递归搜索，尝试不同的队伍组合，并使用剪枝优化。 |     *   `compare_and_save_best`: 比较当前结果与最佳结果，并更新最佳结果。 |     *   `no_way_better`: 剪枝函数，判断当前搜索分支是否可能找到更优解。 |     *   `is_team_conflict`: 检查两支队伍的代理人是否冲突。 | *   `calc_teams`: 主函数，用于计算配队。 |     *   识别每个阶段的弱点和抗性。 |     *   创建 `DefenseTeamSearcher` 实例并调用 `search` 方法。 | *   `check_type_by_area`: 识别特定区域的属性类型。 |  | **重要功能点：** |  | *   **深度优先搜索 (DFS)**：使用 DFS 算法搜索最佳队伍组合。 | *   **剪枝优化**:  `no_way_better` 函数用于优化搜索过程。 | *   **得分计算**:  `cal_score` 函数根据队伍与弱点和抗性的匹配程度计算得分。 | *   **冲突检测**:  `is_team_conflict` 函数用于避免选择代理人冲突的队伍。 | *   **OCR 识别**:  `check_type_by_area` 函数使用 OCR 技术识别游戏画面中的属性类型。
        ├── auto_battle/
        │   ├── auto_battle_agent_context.py    ```python | """ | 文件摘要： |  | 此文件定义了 `AutoBattleAgentContext` 类，用于在自动战斗中管理和识别角色状态。它使用多线程来并行处理图像识别任务，并维护一个 `TeamInfo` 对象来跟踪队伍中的角色信息。 |  | 核心类和函数： |  | *   `AutoBattleAgentContext`:  管理自动战斗中的角色信息和状态。 |     *   `init_battle_agent_context`: 初始化自动战斗上下文，包括角色列表和需要检测的状态。 |     *   `check_agent_related`:  识别角色相关信息，并更新状态。 |     *   `_check_agent_in_parallel`: 并发识别角色头像。 |     *   `_check_agent_state_in_parallel`: 并发识别角色状态。 |     *   `switch_next_agent`, `switch_prev_agent`: 切换角色。 |     *   `chain_left`, `chain_right`: 连携技切换。 | *   `TeamInfo`:  管理队伍中的角色信息，包括角色列表、能量、特殊技和终结技状态。 |     *   `update_agent_list`: 更新角色列表。 |     *   `is_same_agent_list`:  判断角色列表是否一致。 |     *   `switch_next_agent`, `switch_prev_agent`: 切换角色。 |     *   `get_agent_pos`: 获取角色在队伍中的位置。 | *   `AgentInfo`:  存储单个角色的信息，包括角色对象、能量、特殊技和终结技状态。 | *   `CheckAgentState`:  封装需要检查的角色状态信息。 |  | 重要功能点： |  | *   **角色识别**:  通过图像识别和模板匹配来识别角色。 | *   **状态检测**:  检测角色的能量、特殊技、终结技状态，以及其他自定义状态。 | *   **多线程**: 使用 `ThreadPoolExecutor` 并发执行图像识别和状态检测任务，提高效率。 | *   **角色切换**:  提供切换角色功能，并更新状态。 | *   **连携技支持**:  支持连携技的切换。 | *   **状态更新**:  将识别到的状态更新到 `ConditionalOperator` 中。 | """ | ```
        │   ├── auto_battle_context.py    **1. 主要功能:** |  | *   `AutoBattleContext` 類別負責管理遊戲中的自動戰鬥邏輯，包括控制角色動作、識別戰鬥狀態、處理閃避、切換角色、識別連攜技和快速支援等。 | *   它整合了 `AutoBattleAgentContext`、`AutoBattleDodgeContext` 和 `AutoBattleCustomContext`，以實現更複雜的自動戰鬥行為。 |  | **2. 核心類和函數:** |  | *   **`AutoBattleContext` 類:** |     *   `__init__(self, ctx: ZContext)`: 初始化上下文，包括子上下文、鎖、計時器和狀態變量。 |     *   `dodge()`, `switch_next()`, `switch_prev()`, `normal_attack()`, `special_attack()`, `ultimate()`, `chain_left()`, `chain_right()`, `move_w()`, `move_s()`, `move_a()`, `move_d()`, `lock()`, `chain_cancel()`:  控制角色在戰鬥中的各種動作。 |     *   `quick_assist()`, `switch_by_name()`: 處理快速支援和切換角色。 |     *   `init_battle_context()`: 初始化自動戰鬥的配置，包括子上下文的初始化和識別區域的加載。 |     *   `check_battle_state()`: 核心函數，用於識別戰鬥狀態，包括是否在戰鬥中、戰鬥是否結束、以及其他狀態的識別。 |     *   `check_chain_attack()`, `check_quick_assist()`, `_check_battle_end()`, `check_battle_distance()`:  用於識別特定戰鬥狀態的函數。 |     *   `is_normal_attack_btn_available()`: 快速判斷是否在戰鬥畫面。 |     *   `start_context()`, `stop_context()`: 啟動和停止上下文。 | *   **`AutoBattleAgentContext` 類:** (由 `AutoBattleContext` 實例化) 處理與角色代理相關的邏輯。 | *   **`AutoBattleDodgeContext` 類:** (由 `AutoBattleContext` 實例化) 處理閃避相關的
        │   ├── auto_battle_custom_context.py    這個 Python 文件 `auto_battle_custom_context.py` 實現了一個用於自動戰鬥的自定義上下文。 |  | *   **主要功能:** 提供設置和清除戰鬥狀態的功能，這些狀態用於控制自動戰鬥的行為。 | *   **核心類:** `AutoBattleCustomContext` | *   **核心函數:** |     *   `__init__(self, ctx: ZContext)`: 初始化上下文，接收一個 `ZContext` 對象和一個模擬的 `ConditionalOperator`。 |     *   `init_battle_custom_context(self, auto_op: ConditionalOperator)`: 初始化自動操作，接收一個 `ConditionalOperator`。 |     *   `set_state(self, state_name_list: List[str], time_diff: float, time_diff_add: float, value: int, value_add: int)`: 設置多個狀態，可以指定觸發時間、狀態值和疊加值。 |     *   `clear_state(self, state_name_list: List[str])`: 清除多個狀態。 | *   **重要功能點:** |     *   使用 `ConditionalOperator` 管理狀態。 |     *   支持批量設置和清除狀態，提高效率。 |     *   狀態設置包含時間偏移量，允許在未來觸發狀態變化。
        │   ├── auto_battle_dodge_context.py    ## 代码摘要 |  | **1. 主要功能:** |  | 该文件定义了 `AutoBattleDodgeContext` 类，用于在游戏自动战斗中检测闪避时机。它通过分析屏幕截图中的闪光和录制音频来识别闪避信号，并结合 `ConditionalOperator` 来触发闪避操作。 |  | **2. 核心类和函数:** |  | *   **`AudioRecorder`**:  负责录制和处理音频数据，包括启动录制、停止录制、滤波处理和获取音频数据。 |     *   `start_running_async()`: 异步启动音频录制。 |     *   `_record_loop()`: 音频录制循环，持续录制音频数据。 |     *   `stop_running()`: 停止音频录制。 |     *   `clear_audio()`: 清除当前录音。 | *   **`AutoBattleDodgeContext`**:  管理闪避检测的上下文。 |     *   `init_battle_dodge_context()`: 初始化上下文，包括加载模型和设置识别间隔。 |     *   `check_dodge_flash()`: 识别屏幕截图中的闪光，并触发闪避。 |     *   `check_dodge_audio()`: 识别音频中的闪避提示，并触发闪避。 |     *   `start_context()`: 启动音频录制。 |     *   `stop_context()`: 停止音频录制。 |     *   `get_max_corr()`: 计算两个音频信号的最大相关性。 |     *   `_get_filter_wave()`: 音频滤波。 | *   **`YoloStateEventEnum`**: 定义了用于闪避识别的事件枚举。 |  | **3. 重要功能点:** |  | *   **异步音频录制**: 使用 `ThreadPoolExecutor` 异步录制音频，避免阻塞主线程。 | *   **闪光检测**: 使用 `FlashClassifier` 模型检测屏幕截图中的闪光。 | *   **音频检测**:  通过音频模板匹配和相关性分析来检测闪避提示。 | *   **事件去重**:  通过时间间隔控制音频事件的触发频率。 | *   **滤波处理**: 对音频数据进行高通滤波处理，提高识别准确性。 | *   **条件操作**: 使用 `ConditionalOperator` 来触发
        │   ├── auto_battle_operator.py    ```python | """ | 该文件定义了 `AutoBattleOperator` 类，用于实现游戏的自动战斗功能。 |  | 主要功能： |     *   加载自动战斗配置，根据配置执行一系列操作。 |     *   处理各种游戏事件，如躲避、切换角色、释放技能等。 |     *   周期性地执行锁定敌人和视角调整操作。 |  | 核心类和函数： |     *   `AutoBattleOperator`: 继承自 `ConditionalOperator`，负责自动战斗的逻辑控制。 |         *   `__init__`: 初始化，加载配置，创建 `AutoBattleContext`。 |         *   `init_before_running`: 运行前初始化，加载自动战斗配置。 |         *   `init_before_running_async`: 异步初始化。 |         *   `get_atomic_op`: 根据操作定义获取原子操作。 |         *   `get_state_handler_template`: 获取场景处理器模板。 |         *   `get_operation_template`: 获取操作模板。 |         *   `operate_periodically`: 周期性执行锁定和视角调整。 |         *   `start_running_async`: 启动自动战斗。 |         *   `stop_running`: 停止自动战斗。 |         *   `dispose`: 销毁资源。 |     *   `AutoBattleContext`: 自动战斗上下文，管理游戏状态和操作。 |     *   `AtomicOp`: 原子操作的基类，各种具体操作的父类。 |     *   `StateRecorder`: 状态记录器。 |     *   `get_all_state_event_ids`: 获取所有状态事件ID。 |     *   `is_valid_state`: 验证状态是否合法。 |  | 重要功能点： |     *   异步初始化和启动自动战斗。 |     *   使用 `ConditionalOperator` 框架处理条件操作。 |     *   支持多种原子操作，如移动、攻击、释放技能等。 |     *   周期性地执行锁定和视角调整。 |     *   通过配置文件定义自动战斗逻辑。 | """ | ```
        │   ├── auto_battle_state.py    這個 Python 文件的摘要如下： |  | *   **主要功能：** 定義了一個枚舉 `BattleStateEnum`，用於表示遊戲自動戰鬥中的各種狀態，例如按鍵操作、技能可用狀態等。 | *   **核心類和函數：** |     *   `BattleStateEnum` (Enum):  定義了戰鬥狀態的枚舉，包含各種按鍵操作和狀態標識。 | *   **重要功能點：** |     *   定義了遊戲中常用的按鍵操作，如閃避、切換角色、普通攻擊、特殊攻擊、終結技、連攜技、移動、鎖定敵人等。 |     *   定義了技能可用狀態，如特殊攻擊準備就緒、終結技準備就緒、連攜技準備就緒、快速支援準備就緒等。
        │   ├── auto_battle_utils.py    這個 Python 文件的主要功能是提供自動戰鬥的工具函數。 |  | 核心類和函數： |  | *   `AutoBattleOperator`: 負責自動戰鬥的執行。 | *   `load_auto_op(op, auto_config_sub_dir, auto_config_name)`: 加載自動戰鬥指令，初始化 `AutoBattleOperator`。 | *   `load_auto_op_async(op, auto_config_sub_dir, auto_config_name)`: 异步加载自动战斗指令。 | *   `stop_running(auto_op)`: 停止自動戰鬥。 | *   `resume_running(auto_op)`: 恢復自動戰鬥。 | *   `check_astra_and_switch(auto_op, timeout_seconds)`: 檢查是否需要切換角色，特別是針對耀佳音的情況。 |  | 重要功能點： |  | *   提供同步和異步方式加載自動戰鬥配置。 | *   提供停止和恢復自動戰鬥的功能。 | *   針對特定角色（耀佳音）提供額外的檢查和切換邏輯，以避免卡住。
        │   ├── agent_state/
        │   │   └── agent_state_checker.py    ## 摘要 |  | **文件功能:** |  | 该 Python 文件定义了一系列函数，用于检测游戏中角色状态，主要通过图像处理技术（如颜色范围检测、模板匹配、灰度分析）来判断角色状态的各种属性，如是否存在、长度、数量等。 |  | **核心类和函数:** |  | *   `ZContext`: 上下文对象，用于提供环境信息。 | *   `AgentStateDef`: 角色状态定义类，包含颜色范围、模板 ID 等状态信息。 | *   `get_template(ctx, state_def, total, pos)`:  根据角色状态定义获取对应的模板。 | *   `check_cnt_by_color_range(ctx, screen, state_def, total, pos)`:  在指定区域内，按颜色判断连通块的数量。 | *   `check_exist_by_color_range(ctx, screen, state_def, total, pos)`:  在指定区域内，按颜色判断是否存在。 | *   `check_length_by_background_gray(ctx, screen, state_def, total, pos)`:  通过背景灰度计算横条长度。 | *   `check_length_by_foreground_gray(ctx, screen, state_def, total, pos)`:  通过前景灰度计算横条长度。 | *   `check_length_by_foreground_color(ctx, screen, state_def, total, pos)`:  通过前景色计算横条长度。 | *   `check_template_not_found(ctx, screen, state_def, total, pos)`:  判断模板是否未找到。 | *   `check_template_found(ctx, screen, state_def, total, pos)`:  判断模板是否找到。 | *   `check_cnt_by_color_channel_max_range(ctx, screen, state_def, total, pos)`:  按颜色通道最大值判断连通块数量。 | *   `check_exist_by_color_channel_max_range(ctx, screen, state_def, total, pos)`:  按颜色通道最大值判断是否存在。 | *   `check_cnt_by_color_channel_equal_range(ctx, screen, state_def, total, pos)`:  按颜色
        │   └── atomic_op/
        │       ├── btn_chain_cancel.py    這個 Python 文件定義了一個 `AtomicBtnChainCancel` 類，用於在自動戰鬥中取消按鈕鏈。 |  | *   **主要功能:** 執行取消按鈕鏈的操作，包括按下、釋放或單純取消。 | *   **核心類和函數:** |     *   `AtomicBtnChainCancel`: 繼承自 `AtomicOp`，用於執行取消按鈕鏈的操作。 |     *   `__init__`: 初始化 `AtomicBtnChainCancel` 實例，根據 `press` 和 `release` 參數設置操作名稱。 |     *   `execute`: 執行取消按鈕鏈的操作，調用 `AutoBattleContext` 的 `chain_cancel` 方法。 |     *   `stop`: 在操作停止時，如果按下了按鈕，則釋放按鈕。 | *   **重要功能點:** |     *   根據 `press`、`press_time` 和 `release` 參數，控制按鈕的按下、按住時間和釋放。 |     *   使用 `AutoBattleContext` 來執行實際的取消操作。 |     *   `stop` 方法確保在操作結束時釋放按鈕。
        │       ├── btn_chain_left.py    這個 Python 文件定義了一個用於自動戰鬥的原子操作，用於控制遊戲中的“連鎖左”按鈕。 |  | *   **主要功能:** 模擬按下和釋放“連鎖左”按鈕，用於自動戰鬥。 | *   **核心類:** `AtomicBtnChainLeft` 繼承自 `AtomicOp`，代表一個原子操作。 | *   **重要功能點:** |     *   `__init__`: 初始化操作，根據 `press` 和 `release` 參數設置操作名稱。 |     *   `execute`: 執行按鈕操作，調用 `AutoBattleContext` 的 `chain_left` 方法。 |     *   `stop`: 在操作停止時，如果按鈕被按下，則釋放按鈕。
        │       ├── btn_chain_right.py    這個 Python 文件的主要功能是定義一個原子操作，用於控制自動戰鬥中右側按鈕的鏈式操作。 |  | *   **核心類:** `AtomicBtnChainRight` 繼承自 `AtomicOp`，用於執行右側按鈕的按下、釋放或持續按壓操作。 | *   **核心函數:** |     *   `__init__`: 初始化 `AtomicBtnChainRight` 實例，根據 `press` 和 `release` 參數設置操作名稱和是否為異步操作。 |     *   `execute`: 執行右側按鈕的鏈式操作，調用 `AutoBattleContext` 的 `chain_right` 方法。 |     *   `stop`: 在操作停止時，如果按鈕被按下，則釋放按鈕。 | *   **重要功能點:** |     *   根據 `press`、`press_time` 和 `release` 參數，控制右側按鈕的按下、持續按壓（異步操作）和釋放。 |     *   使用 `AutoBattleContext` 處理實際的按鈕操作。 |     *   `stop` 方法確保在操作結束時釋放按鈕。
        │       ├── btn_common.py    此 Python 文件定义了用于自动战斗的通用按钮操作。 |  | **主要功能：** |  | *   实现对游戏内按钮的模拟操作，包括按下、松开和点击。 | *   支持按钮操作的重复执行、前后延时。 |  | **核心类和函数：** |  | *   `BtnWayEnum`: 定义按钮操作方式的枚举（按下、松开、点击）。 | *   `BtnRunStatus`: 定义按钮运行状态的枚举（等待、运行、停止）。 | *   `AtomicBtnCommon(AtomicOp)`: 继承自 `AtomicOp`，是核心类，负责处理具体的按钮操作。 |     *   `__init__`: 初始化按钮操作的参数，包括按钮名称、操作方式、按压时间、重复次数等，并根据按钮名称设置对应的操作方法。 |     *   `execute`: 执行按钮操作，包括前置延时、调用操作方法、后置延时，并支持重复执行。 |     *   `stop`: 停止正在进行的按钮操作。 |  | **重要功能点：** |  | *   通过 `BtnWayEnum` 定义了按钮操作的类型。 | *   `AtomicBtnCommon` 类根据 `op_def.op_name` 动态选择要执行的按钮操作方法。 | *   `execute` 方法实现了按钮操作的流程控制，包括延时和重复执行。 | *   `stop` 方法用于中断正在进行的按钮操作，并确保释放按钮。 | *   使用 `threading.Lock` 保证线程安全。
        │       ├── btn_dodge.py    這個 Python 文件定義了一個名為 `AtomicBtnDodge` 的類，它是一個用於自動戰鬥的原子操作，用於處理閃避按鈕的按下、釋放或持續按壓。 |  | *   **主要功能:** 模擬在自動戰鬥中按下和釋放閃避按鈕。 | *   **核心類和函數:** |     *   `AtomicBtnDodge`: 繼承自 `AtomicOp`，表示一個原子操作，用於控制閃避按鈕。 |     *   `__init__`: 初始化 `AtomicBtnDodge` 實例，設置操作名稱和相關參數，如是否按下、按壓時間和釋放。 |     *   `execute`: 執行閃避操作，調用 `AutoBattleContext` 的 `dodge` 方法。 |     *   `stop`: 在操作停止時，如果按鈕被按下，則釋放閃避按鈕。 | *   **重要功能點:** |     *   支持按下、釋放或持續按壓閃避按鈕。 |     *   使用 `AutoBattleContext` 進行實際的按鈕操作。 |     *   `stop` 方法確保在操作結束時釋放按鈕。
        │       ├── btn_lock.py    這個 Python 文件定義了一個名為 `AtomicBtnLock` 的類，它是一個用於自動戰鬥的原子操作，用於控制遊戲中的按鈕鎖定狀態。 |  | *   **主要功能:** 模擬按鈕的按下、鎖定和釋放操作。 | *   **核心類:** `AtomicBtnLock` 繼承自 `AtomicOp`。 | *   **重要功能點:** |     *   `__init__`: 根據 `press` 和 `release` 參數初始化操作名稱，並設置是否為異步操作。 |     *   `execute`: 調用 `AutoBattleContext` 的 `lock` 方法來執行按鈕鎖定操作。 |     *   `stop`: 如果按鈕被按下，則在停止時釋放按鈕。
        │       ├── btn_move_a.py    這個 Python 文件定義了一個名為 `AtomicBtnMoveA` 的 `AtomicOp` 類，用於在自動戰鬥中控制 "A" 按鈕的行為。 |  | *   **主要功能:** 模擬按下、按住和釋放 "A" 按鈕的操作。 | *   **核心類和函數:** |     *   `AtomicBtnMoveA`: 繼承自 `AtomicOp`，負責執行 "A" 按鈕的操作。 |     *   `__init__`: 初始化 `AtomicBtnMoveA` 實例，根據 `press` 和 `release` 參數設置操作名稱和異步狀態。 |     *   `execute`: 執行 "A" 按鈕的操作，調用 `AutoBattleContext` 的 `move_a` 方法。 |     *   `stop`: 在操作停止時，如果按下了 "A" 按鈕，則釋放它。 | *   **重要功能點:** |     *   支持按下、按住（帶有時間）和釋放 "A" 按鈕。 |     *   使用 `AutoBattleContext` 來執行實際的按鈕操作。 |     *   `stop` 方法確保在操作結束時釋放按鈕。
        │       ├── btn_move_d.py    這個 Python 文件的摘要如下： |  | *   **主要功能：** 實現自動戰鬥中控制角色向 D 方向移動的原子操作，包括按下、保持和釋放按鈕。 | *   **核心類和函數：** |     *   `AtomicBtnMoveD`: 繼承自 `AtomicOp`，表示一個原子操作，用於控制角色移動。 |     *   `__init__`: 初始化操作，根據 `press` 和 `release` 參數設置操作名稱和是否為異步操作。 |     *   `execute`: 執行移動操作，調用 `AutoBattleContext` 的 `move_d` 方法。 |     *   `stop`: 停止移動操作，如果按下了按鈕，則釋放按鈕。 | *   **重要功能點：** |     *   控制角色向 D 方向移動，支持按下、保持（通過 `press_time`）和釋放操作。 |     *   使用 `AutoBattleContext` 處理實際的移動邏輯。 |     *   `stop` 方法確保在操作結束時釋放按鈕。
        │       ├── btn_move_s.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了一個名為 `AtomicBtnMoveS` 的 `AtomicOp` 類，用於在自動戰鬥中控制 "S" 按鈕的按下、持續和釋放操作。 |  | **核心類和函數:** |  | *   `AtomicBtnMoveS`: 繼承自 `AtomicOp`，負責執行 "S" 按鈕的相關操作。 |     *   `__init__`: 初始化 `AtomicBtnMoveS` 實例，根據 `press` 和 `release` 參數設置操作名稱。 |     *   `execute`: 執行 "S" 按鈕的操作，調用 `AutoBattleContext` 的 `move_s` 方法。 |     *   `stop`:  如果按鈕被按下，則在停止時釋放按鈕。 |  | **重要功能點:** |  | *   根據 `press`、`press_time` 和 `release` 參數，支持按下、持續按下（帶時間）和釋放 "S" 按鈕。 | *   使用 `AutoBattleContext` 執行實際的按鈕操作。 | *   `stop` 方法確保在操作停止時釋放按鈕，防止按鈕狀態的持續。
        │       ├── btn_move_w.py    這個 Python 文件定義了一個名為 `AtomicBtnMoveW` 的 `AtomicOp` 類，用於控制遊戲中 "W" 鍵的按下、持續和釋放操作。 |  | *   **主要功能:** 模擬按下和釋放遊戲中的 "W" 鍵，用於自動戰鬥。 | *   **核心類和函數:** |     *   `AtomicBtnMoveW`: 繼承自 `AtomicOp`，負責執行 "W" 鍵的相關操作。 |     *   `__init__`: 初始化 `AtomicBtnMoveW` 實例，根據 `press` 和 `release` 參數設置操作名稱。 |     *   `execute`: 執行 "W" 鍵的操作，調用 `AutoBattleContext` 的 `move_w` 方法。 |     *   `stop`: 在 `press` 為 True 時，釋放 "W" 鍵。 | *   **重要功能點:** |     *   根據 `press`、`press_time` 和 `release` 參數控制 "W" 鍵的行為。 |     *   使用 `AutoBattleContext` 處理實際的鍵盤操作。 |     *   `stop` 方法確保在需要時釋放 "W" 鍵。
        │       ├── btn_normal_attack.py    這個 Python 文件定義了一個名為 `AtomicBtnNormalAttack` 的類，它是一個用於自動戰鬥的原子操作，用於控制遊戲中的普通攻擊按鈕。 |  | *   **主要功能:** 模擬按下、按住或釋放普通攻擊按鈕的操作。 | *   **核心類和函數:** |     *   `AtomicBtnNormalAttack`: 繼承自 `AtomicOp`，表示一個原子操作，用於控制普通攻擊按鈕。 |     *   `__init__`: 初始化函數，根據 `press`、`press_time` 和 `release` 參數設置操作的名稱和行為。 |     *   `execute`: 執行普通攻擊按鈕操作，調用 `AutoBattleContext` 的 `normal_attack` 方法。 |     *   `stop`: 停止操作，如果按下了按鈕，則釋放按鈕。 | *   **重要功能點:** |     *   支持按下、按住（帶持續時間）和釋放普通攻擊按鈕。 |     *   使用 `AutoBattleContext` 來執行實際的按鈕操作。 |     *   `stop` 方法確保在操作結束時釋放按鈕。
        │       ├── btn_quick_assist.py    這個 Python 文件定義了一個名為 `AtomicBtnQuickAssist` 的類，它是一個用於自動戰鬥的原子操作，用於執行“快速支援”按鈕的功能。 |  | *   **主要功能:** 模擬點擊“快速支援”按鈕，並在執行前後添加延遲。 | *   **核心類和函數:** |     *   `AtomicBtnQuickAssist`: 繼承自 `AtomicOp`，負責執行快速支援操作。 |     *   `execute()`: 執行快速支援操作，包括延遲、調用 `ctx.quick_assist()` 和更新狀態。 |     *   `stop()`: 停止操作。 | *   **重要功能點:** |     *   使用 `threading.Lock` 來保護狀態更新，確保線程安全。 |     *   根據 `pre_delay` 和 `post_delay` 屬性添加延遲。 |     *   調用 `ctx.quick_assist()` 來觸發遊戲中的快速支援功能。 |     *   使用 `BtnRunStatus` 枚舉來管理操作的狀態。
        │       ├── btn_special_attack.py    這個 Python 文件定義了一個名為 `AtomicBtnSpecialAttack` 的類，它是一個用於自動戰鬥系統的原子操作，用於控制遊戲中的特殊攻擊按鈕。 |  | *   **主要功能:** 模擬按下、釋放或單純觸發特殊攻擊按鈕的操作。 | *   **核心類和函數:** |     *   `AtomicBtnSpecialAttack`: 繼承自 `AtomicOp`，負責執行特殊攻擊按鈕的操作。 |     *   `__init__`: 初始化操作，根據 `press` 和 `release` 參數設置操作名稱和是否為異步操作。 |     *   `execute`: 執行特殊攻擊操作，調用 `AutoBattleContext` 的 `special_attack` 方法。 |     *   `stop`: 在操作停止時，如果按下了按鈕，則釋放按鈕。 | *   **重要功能點:** |     *   支持按下、釋放和單純觸發特殊攻擊按鈕。 |     *   使用 `AutoBattleContext` 來執行實際的按鈕操作。 |     *   `stop` 方法確保在操作停止時釋放按鈕，避免按鈕一直處於按下狀態。 |     *   `async_op` 參數用於指示操作是否為異步操作。
        │       ├── btn_switch_agent.py    這個 Python 文件定義了一個名為 `AtomicBtnSwitchAgent` 的類，它是一個用於自動戰鬥的原子操作，用於切換遊戲中的角色。 |  | *   **主要功能:** 執行切換角色的操作，包括延遲和狀態管理。 | *   **核心類和函數:** |     *   `AtomicBtnSwitchAgent`: 繼承自 `AtomicOp`，負責切換角色的邏輯。 |     *   `execute()`: 執行切換角色的操作，包括延遲和調用 `ctx.switch_by_name()`。 |     *   `stop()`: 停止切換操作。 | *   **重要功能點:** |     *   使用 `AutoBattleContext` 獲取上下文信息。 |     *   使用 `OperationDef` 獲取操作定義，包括角色名稱和延遲時間。 |     *   使用 `threading.Lock` 來保護狀態更新。 |     *   使用 `BtnRunStatus` 枚舉來管理操作狀態。 |     *   包含 `pre_delay` 和 `post_delay` 實現切換前后的延遲。
        │       ├── btn_switch_next.py    這個 Python 文件定義了一個名為 `AtomicBtnSwitchNext` 的 `AtomicOp` 類，用於在自動戰鬥中控制“下一場戰鬥”按鈕。 |  | *   **主要功能:** 模擬按下、釋放或單純觸發“下一場戰鬥”按鈕。 | *   **核心類和函數:** |     *   `AtomicBtnSwitchNext`: 繼承自 `AtomicOp`，負責執行按鈕操作。 |     *   `__init__`: 初始化 `AtomicBtnSwitchNext` 實例，根據 `press` 和 `release` 參數設置操作名稱和是否為異步操作。 |     *   `execute`: 執行按鈕操作，調用 `AutoBattleContext` 的 `switch_next` 方法。 |     *   `stop`: 在 `press` 為 `True` 時，模擬釋放按鈕。 | *   **重要功能點:** |     *   支持按下、釋放或單純觸發按鈕。 |     *   使用 `AutoBattleContext` 來執行實際的按鈕操作。 |     *   `press_time` 參數允許模擬按鈕按下的持續時間。 |     *   `stop` 方法用於確保在需要時釋放按鈕。
        │       ├── btn_switch_prev.py    這個 Python 文件定義了一個名為 `AtomicBtnSwitchPrev` 的 `AtomicOp` 類，用於在自動戰鬥中控制“上一個”按鈕的行為。 |  | *   **主要功能:** 模擬按下、釋放或保持按下“上一個”按鈕的操作。 | *   **核心類和函數:** |     *   `AtomicBtnSwitchPrev`: 繼承自 `AtomicOp`，負責執行按鈕操作。 |     *   `__init__`: 初始化操作的名稱，並設置是否為異步操作。 |     *   `execute`: 執行按鈕操作，調用 `AutoBattleContext` 的 `switch_prev` 方法。 |     *   `stop`: 在操作停止時，如果按鈕被按下，則模擬釋放按鈕。 | *   **重要功能點:** |     *   支持按下、釋放或保持按下按鈕。 |     *   使用 `AutoBattleContext` 來執行實際的按鈕操作。 |     *   `stop` 方法確保在操作結束時釋放按鈕。
        │       ├── btn_ultimate.py    這個 Python 文件定義了一個名為 `AtomicBtnUltimate` 的 `AtomicOp` 類，用於在自動戰鬥中控制終極技能按鈕。 |  | *   **主要功能:** 模擬按下、釋放或執行終極技能按鈕的操作。 | *   **核心類和函數:** |     *   `AtomicBtnUltimate`: 繼承自 `AtomicOp`，用於表示終極技能按鈕的操作。 |     *   `__init__`: 初始化 `AtomicBtnUltimate` 實例，根據 `press` 和 `release` 參數設置操作名稱。 |     *   `execute`: 執行終極技能按鈕操作，調用 `AutoBattleContext` 的 `ultimate` 方法。 |     *   `stop`: 在按下按鈕的情況下，模擬釋放按鈕。 | *   **重要功能點:** |     *   支持按下、釋放或單純觸發終極技能按鈕。 |     *   使用 `AutoBattleContext` 處理實際的按鈕操作。 |     *   `async_op` 屬性根據是否需要等待按鈕釋放而設置。
        │       ├── state_clear.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件定義了一個 `AtomicClearState` 類，用於在自動戰鬥中清除狀態。 |  | **核心類和函數：** |  | *   `AtomicClearState`: 繼承自 `AtomicOp`，負責執行清除狀態的操作。 |     *   `__init__(self, ctx: AutoBattleCustomContext, op_def: OperationDef)`: 初始化 `AtomicClearState` 實例，接收上下文和操作定義。 |     *   `execute(self)`: 執行清除狀態的操作，根據 `state_name_list` 或 `state_name` 清除 `AutoBattleCustomContext` 中的狀態。 |  | **重要功能點：** |  | *   `AtomicClearState` 根據 `OperationDef` 中定義的 `state_name` 或 `state_name_list` 來清除狀態。 | *   使用 `AutoBattleCustomContext` 的 `clear_state` 方法來清除狀態。 | *   支持清除單個狀態或多個狀態。
        │       ├── state_set.py    這個 Python 文件定義了一個用於自動戰鬥的原子操作，用於設置遊戲狀態。 |  | *   **主要功能:** 根據定義設置遊戲實體的状态。 | *   **核心類:** `AtomicSetState` 繼承自 `AtomicOp`，代表設置狀態的操作。 | *   **重要功能點:** |     *   `__init__`: 初始化操作，從 `OperationDef` 中獲取狀態名稱、持續時間、值等參數。 |     *   `execute`: 執行設置狀態的操作，調用 `AutoBattleCustomContext` 的 `set_state` 方法，根據配置設置狀態。 |     *   支持設置單個狀態或多個狀態。
        │       └── wait.py    這個 Python 文件定義了一個名為 `AtomicWait` 的類，它繼承自 `AtomicOp`，用於在自動戰鬥中執行等待操作。 |  | *   **主要功能:** 實現自動戰鬥中的等待功能，根據指定的秒數暫停執行。 | *   **核心類:** `AtomicWait` | *   **重要功能點:** |     *   `AtomicWait` 類初始化時，從 `OperationDef` 中獲取等待秒數，並將其儲存在 `self.wait_seconds` 屬性中。 |     *   `execute` 方法使用 `time.sleep()` 函數暫停執行，等待 `self.wait_seconds` 秒。
        ├── config/
        │   ├── agent_outfit_config.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了代理裝備的配置，包括不同角色的皮膚選項。它使用 `YamlConfig` 類來加載和管理配置，並使用 `Enum` 來定義可用的皮膚選項。 |  | **核心類和函數:** |  | *   `AgentOutfitConfig`: 繼承自 `YamlConfig`，用於加載和管理代理裝備的配置。它包含屬性（property）用於獲取和設置不同角色的皮膚，如 `nicole`, `ellen`, 和 `astra_yao`。 | *   `AgentOutfitNicole`, `AgentOutfitEllen`, `AgentOutfitAstraYao`:  使用 `Enum` 定義了每個角色的可用皮膚選項，每個選項都關聯一個 `ConfigItem` 實例，包含皮膚的名稱和標識符。 |  | **重要功能點:** |  | *   使用 `YamlConfig` 管理配置，這表明配置數據可能存儲在 YAML 文件中。 | *   使用 `Enum` 提供了清晰的皮膚選項定義，增強了代碼的可讀性和可維護性。 | *   每個角色的皮膚選項都有一個默認值。 | *   提供了獲取和設置皮膚配置的屬性（property）。
        │   ├── game_config.py    **摘要:** |  | 该文件定义了游戏配置类 `GameConfig`，用于管理游戏中的各种键位设置和手柄类型。它继承自 `BasicGameConfig`，并使用 `Enum` 定义了手柄类型。 |  | **核心类和函数:** |  | *   `GamepadTypeEnum`: 定义了游戏手柄类型的枚举 (NONE, XBOX, DS4)。 | *   `GameConfig`: 继承自 `BasicGameConfig`，用于存储和管理游戏配置。 |     *   `__init__(self, instance_idx: int)`: 初始化函数。 |     *   一系列 `@property` 装饰器修饰的属性，用于获取和设置各种键位配置，包括普通攻击、闪避、切换、特殊攻击、爆发技、交互、移动等，以及 Xbox 和 DS4 手柄的键位设置。 |     *   `gamepad_requirement_time`: 存储依赖文件最后修改时间。 |     *   `original_hdr_value`: 存储原始 HDR 值。 |  | **重要功能点:** |  | *   定义了游戏中的各种键位设置，包括键盘和手柄。 | *   支持 Xbox 和 DS4 手柄的键位配置。 | *   提供了获取和设置键位配置的接口。 | *   存储了依赖文件的最后修改时间。 | *   存储了原始 HDR 值。
        │   ├── team_config.py    這個 Python 腳本定義了用於管理遊戲中預定義隊伍配置的類。 |  | *   **主要功能:** 讀取、儲存和管理遊戲中的隊伍配置，包括隊伍名稱、代理人 ID 列表和自動戰鬥配置。 | *   **核心類和函數:** |     *   `PredefinedTeamInfo`: 表示一個預定義的隊伍，包含隊伍的索引、名稱、代理人 ID 列表和自動戰鬥配置。 |     *   `TeamConfig`: 繼承自 `YamlConfig`，用於加載和保存隊伍配置。 |         *   `team_list`: 屬性，返回一個 `PredefinedTeamInfo` 列表，包含所有隊伍的配置。 |         *   `update_team`: 更新一個隊伍的配置。 |         *   `get_team_by_idx`: 根據索引獲取隊伍配置。 |         *   `update_team_members`: 更新特定隊伍的代理人列表。 | *   **重要功能點:** |     *   從 YAML 配置文件加載隊伍配置。 |     *   允許更新和修改隊伍配置。 |     *   提供獲取特定隊伍信息的功能。 |     *   支持更新隊伍成員。 |     *   確保每個隊伍至少有三個代理人，如果不足則填充 'unknown'。
        │   └── yolo_config.py    此文件定义了 YOLO 模型相关的配置，包括模型选择、GPU 使用等。 |  | *   **核心类**: `YoloConfig` 继承自 `YamlConfig`，用于管理和存储 YOLO 模型的配置。 | *   **核心函数**: |     *   `__init__`: 初始化 `YoloConfig`，加载配置文件。 |     *   `flash_classifier`, `hollow_zero_event`, `lost_void_det`: 属性，用于获取和设置不同类型的 YOLO 模型，并确保使用最新的两个模型。 |     *   `flash_classifier_gpu`, `hollow_zero_event_gpu`, `lost_void_det_gpu`: 属性，用于获取和设置是否使用 GPU。 |     *   `using_old_model`: 判断是否在使用旧模型。 |     *   `get_flash_classifier_opts`, `get_hollow_zero_event_opts`, `get_lost_void_det_opts`:  获取不同类型模型的可用选项。 | *   **重要功能点**: |     *   管理三种 YOLO 模型（闪光、枯萎之都格子、迷失之地识别）的配置。 |     *   提供模型版本控制，只允许使用最新的两个模型。 |     *   控制是否使用 GPU。 |     *   提供获取模型选项的函数。
        ├── const/
        │   └── game_const.py    這個 Python 文件 `game_const.py` 定義了遊戲中使用的常量。 |  | *   **主要功能:** 儲存遊戲中使用的常量，例如顏色。 | *   **核心常量:** |     *   `YOLO_DEFAULT_COLOR`:  默認的 YOLO 檢測框顏色，RGB 值為 (114, 114, 114)。 | *   **重要功能點:**  定義了遊戲中使用的顏色常量。
        ├── context/
        │   ├── hollow_context.py    **摘要:** |  | 该文件定义了 `HollowContext` 类，用于管理和控制游戏《崩坏：星穹铁道》中“虚数之树”活动的上下文逻辑。它负责地图寻路、角色识别、关卡信息管理以及行动决策。 |  | **核心类和函数:** |  | *   **`HollowContext`**:  主类，管理虚数之树的上下文。 |     *   `__init__(self, ctx: ZContext)`: 初始化上下文，包括数据服务、关卡信息、地图服务等。 |     *   `get_next_to_move(self, current_map: HollowZeroMap)`:  根据当前地图信息，计算并返回下一步要移动到的节点。 |     *   `update_context_after_move(self, current_map: HollowZeroMap, node: HollowZeroMapNode, update_current: bool = True)`:  在移动后更新上下文，包括已访问节点和当前节点。 |     *   `check_agent_list(self, screen: MatLike, skip_if_checked: bool = False)`:  识别屏幕上的角色列表。 |     *   `init_before_hollow_start(self, mission_type_name: str, mission_name: str, level: int = 1, phase: int = 1)`:  在进入虚数之树活动时进行初始化。 |     *   `after_app_shutdown(self)`:  在应用程序关闭后进行清理操作。 |     *   `_match_agent_in(self, img: MatLike, possible_agents: Optional[List[Agent]] = None)`: 在图像中匹配角色。 |  | **重要功能点:** |  | *   **地图寻路**:  使用 `hollow_pathfinding` 模块进行寻路，根据不同的优先级（一步可达、途经点、终点等）选择目标节点。 | *   **角色识别**:  通过模板匹配识别屏幕上的角色头像。 | *   **关卡信息管理**:  维护 `HollowLevelInfo` 对象，跟踪关卡类型、层数、阶段等信息。 | *   **行动决策**:  根据当前地图状态和关卡信息，决定下一步的行动，包括移动到哪个节点。 | *   **上下文更新**:  在移动
        │   └── zzz_context.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `ZContext` 类，它继承自 `OneDragonContext`，用于管理游戏 `Zenless Zone Zero (ZZZ)` 的上下文环境。它负责加载和管理各种配置、服务和运行记录，并提供初始化和关闭时的操作。 |  | **核心类和函数:** |  | *   **`ZContext`**:  主类，继承自 `OneDragonContext`，用于管理游戏上下文。 |     *   `__init__(self)`:  初始化函数，加载各种配置和服务。 |     *   `load_instance_config(self)`:  加载实例独有的配置。 |     *   `init_by_config(self)`:  根据配置进行初始化，包括更新语言和初始化控制器。 |     *   `init_hollow_config(self)`:  初始化空洞配置。 |     *   `init_agent_template_id(self)`:  初始化代理人头像模板ID。 |     *   `after_app_shutdown(self)`:  App 关闭后进行的操作。 |  | **重要功能点:** |  | *   **配置管理**: 加载和管理游戏配置，如 `YoloConfig`, `GameConfig`, `TeamConfig` 等。 | *   **服务管理**:  初始化游戏数据服务，如 `MapAreaService`, `CompendiumService`。 | *   **运行记录**:  管理各种运行记录，如 `EmailRunRecord`, `RandomPlayRunRecord`, `ChargePlanRunRecord` 等，并检查和更新状态。 | *   **上下文初始化**:  根据配置初始化游戏环境，包括语言设置和控制器。 | *   **空洞配置和代理人初始化**:  初始化空洞相关配置和代理人头像模板ID。 | *   **App 关闭处理**:  在 App 关闭时执行清理操作。
        ├── controller/
        │   └── zzz_pc_controller.py    **摘要:** |  | 该文件定义了 `ZPcController` 类，用于控制游戏中的 PC 操作，继承自 `PcControllerBase`。它通过模拟键盘和鼠标输入来实现游戏控制，并支持不同的输入设备（键盘、Xbox、DS4）。 |  | **核心类和函数:** |  | *   **`ZPcController`**:  核心类，负责处理游戏控制逻辑。 |     *   `__init__`: 初始化控制器，设置游戏配置和按键绑定。 |     *   `fill_uid_black`: 遮挡 UID 区域。 |     *   `enable_keyboard`, `enable_xbox`, `enable_ds4`: 根据不同的输入设备配置按键。 |     *   `dodge`, `switch_next`, `switch_prev`, `normal_attack`, `special_attack`, `ultimate`, `chain_left`, `chain_right`, `move_w`, `move_s`, `move_a`, `move_d`, `interact`, `lock`, `chain_cancel`:  封装了各种游戏操作的按键事件，包括按下、释放和点击。 |     *   `turn_by_distance`:  通过鼠标事件实现横向转向。 |     *   `start_moving_forward`, `stop_moving_forward`: 控制角色向前移动。 |  | **重要功能点:** |  | *   **按键映射**:  根据游戏配置和输入设备（键盘、Xbox、DS4）动态设置按键。 | *   **游戏操作控制**:  封装了游戏中的各种操作，如移动、攻击、闪避、切换角色等，通过模拟按键实现。 | *   **横向转向**:  通过鼠标事件实现横向转向。 | *   **移动控制**: 提供了开始和停止向前移动的函数。 | *   **UID 遮挡**: 提供遮挡 UID 的功能。
        ├── game_data/
        │   ├── agent.py    **摘要:** |  | 该 Python 文件定义了与游戏角色（Agent）相关的数据结构和枚举。 |  | **核心类和函数:** |  | *   `AgentTypeEnum`, `DmgTypeEnum`, `RareTypeEnum`: 定义了角色的类型、伤害类型和稀有度等枚举。 | *   `AgentStateCheckWay`: 定义了用于检测角色状态的不同方法。 | *   `AgentStateDef`: 定义了角色状态的结构，包括状态名称、检测方式、模板 ID、颜色范围等。 | *   `CommonAgentStateEnum`: 定义了常见的角色状态，基于 `AgentStateDef`。 | *   `Agent`: 定义了角色类，包含角色 ID、名称、稀有度、类型、伤害类型和状态列表等属性。 | *   `AgentEnum`: 定义了游戏中的角色实例，继承自 `Agent` 类。 |  | **重要功能点:** |  | *   定义了角色属性和状态，用于游戏逻辑。 | *   使用枚举来表示不同的角色属性和状态类型，增强代码可读性和可维护性。 | *   `AgentStateDef` 和 `CommonAgentStateEnum` 用于定义和管理角色的各种状态，包括能量、特殊技能、终结技等。 | *   `AgentEnum` 包含了游戏中所有角色的定义，每个角色都关联了其属性和状态。
        │   ├── compendium.py    ## 摘要 |  | 這個 Python 腳本定義了用於管理遊戲內副本和咖啡數據的類和服務。 |  | **主要功能:** |  | *   加載和管理遊戲副本數據，包括 Tab、Category、MissionType 和 Mission。 | *   加載和管理咖啡數據，包括咖啡名稱、關聯的副本信息以及每日咖啡安排。 | *   提供用於獲取和查詢副本數據的 API。 |  | **核心類和函數:** |  | *   **CompendiumTab, CompendiumCategory, CompendiumMissionType, CompendiumMission:**  用於表示副本數據的數據結構。 | *   **CompendiumData:**  包含所有 CompendiumTab 的數據。 | *   **Coffee:**  表示咖啡，關聯到副本數據。 | *   **CompendiumService:**  管理副本和咖啡數據的服務，包括： |     *   `reload()`: 重新加載數據。 |     *   `_load_all_compendium()`: 從 YAML 文件加載副本數據。 |     *   `_load_coffee()`: 從 YAML 文件加載咖啡數據。 |     *   `get_tab_data()`, `get_category_list_data()`, `get_category_data()` 等:  用於獲取副本數據的 API。 |     *   `get_coffee_config_list_by_day()`: 獲取指定日期的咖啡配置列表。 |     *   `get_extra_coffee_list()`: 獲取額外的咖啡列表。 |  | **重要功能點:** |  | *   從 YAML 文件加載副本和咖啡數據。 | *   提供 API 獲取和查詢副本數據，支持按 Tab、Category、MissionType 和 Mission 進行篩選。 | *   管理每日咖啡安排。 | *   支持額外的咖啡，不佔用次數。 | *   提供獲取特定副本任務名稱列表的函數，例如零號空洞和迷失之地。 | *   提供獲取用於收費計劃的數據的函數。
        │   └── map_area.py    這個 Python 文件定義了用於管理遊戲地圖區域的類。 |  | **主要功能:** |  | *   加載地圖區域數據。 | *   根據 OCR 結果匹配地圖區域和傳送點。 | *   計算從一個區域到另一個區域的方向和步數。 |  | **核心類和函數:** |  | *   `MapArea`:  表示一個地圖區域，包含區域名稱和傳送點列表。 |     *   `__init__(self, area_name: str, tp_list: List[str])`: 初始化 MapArea 實例。 | *   `MapAreaService`:  管理地圖區域數據的服務類。 |     *   `__init__(self)`: 初始化 MapAreaService 實例，並加載數據。 |     *   `reload(self) -> None`:  從 YAML 文件重新加載地圖區域數據。 |     *   `get_best_match_area(self, ocr_result: str) -> Optional[MapArea]`:  根據 OCR 結果匹配最接近的地圖區域。 |     *   `get_direction_to_target_area(self, current_area: MapArea, target_area: MapArea) -> int`:  計算從當前區域到目標區域的方向。 |     *   `get_best_match_tp(self, area_name: str, ocr_result: str) -> Optional[str]`:  根據 OCR 結果匹配最接近的傳送點。 |  | **重要功能點:** |  | *   使用 `yaml` 庫從 `map_area.yml` 文件加載地圖區域數據。 | *   使用 `difflib.get_close_matches` 進行模糊匹配，以根據 OCR 結果找到最匹配的區域和傳送點。 | *   計算從一個區域到另一個區域的相對位置，考慮到環形佈局。
        ├── gui/
        │   ├── app.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个基于 PySide6 和 qfluentwidgets 的应用程序，该应用程序是 "一条龙" 项目的 GUI 界面。它负责创建主窗口，管理子界面，处理用户交互，并集成各种功能，如战斗助手、游戏助手、设置等。 |  | **核心类和函数:** |  | *   **`AppWindow`**:  主窗口类，继承自 `AppWindowBase`。 |     *   `__init__`: 初始化窗口，设置标题、图标，启动版本检查线程，并连接实例切换事件。 |     *   `init_window`: 初始化窗口的 UI 元素，设置样式，布局等。 |     *   `create_sub_interface`: 创建并添加各种子界面，如 HomeInterface, BattleAssistantInterface 等。 |     *   `_on_instance_active_event`: 响应实例激活事件，更新窗口标题。 |     *   `_on_instance_active_signal`: 响应实例切换信号，更新窗口标题。 |     *   `_update_version`: 更新版本显示在标题栏。 |     *   `_check_first_run`: 检查是否为首次运行，如果是则显示欢迎对话框。 | *   **`CheckVersionRunner`**:  一个 QThread，用于在后台获取当前版本信息。 |     *   `run`:  获取版本信息并发出信号。 | *   **`QApplication`**:  应用程序的主类，用于创建和运行应用程序。 |  | **重要功能点:** |  | *   **界面布局和子界面管理:**  使用 `AppWindowBase` 作为基类，管理多个子界面，并通过 `create_sub_interface` 方法添加。 | *   **主题设置:**  使用 `qfluentwidgets` 的 `setTheme` 函数设置应用程序主题。 | *   **版本检查:**  使用 `CheckVersionRunner` 线程在后台检查版本，并在标题栏显示。 | *   **实例切换:**  监听实例切换事件，并更新窗口标题。 | *   **首次运行引导:**  在首次运行时显示欢迎对话框。 | *   **错误处理:**  在应用程序启动时捕获异常，并显示错误信息。 | *   **上下文管理:**  使用 `ZContext` 管理应用程序的上下文和配置。 | *   **异步初始化:**
        │   ├── zzz_installer.py    這個 Python 腳本定義了一個安裝程式的 GUI 應用程式，用於安裝和配置軟體。 |  | *   **主要功能:** 創建一個基於 `InstallerWindowBase` 的安裝程式窗口，包含多個界面用於安裝、擴展安裝、程式碼查看和設置。它還處理首次運行時的歡迎對話框。 | *   **核心類和函數:** |     *   `ZInstallerWindow`: 繼承自 `InstallerWindowBase`，是主安裝程式窗口，負責創建和管理子界面，以及處理首次運行邏輯。 |     *   `create_sub_interface`: 添加了 `InstallerInterface`, `ExtendInstallInterface`, `CodeInterface` 和 `InstallerSettingInterface` 到主窗口。 |     *   `_check_first_run`: 檢查是否為首次運行，如果是，則顯示 `WelcomeDialog`。 | *   **重要功能點:** |     *   使用 `PySide6` 和 `qfluentwidgets` 構建 GUI。 |     *   使用 `OneDragonEnvContext` 和 `OneDragonCustomContext` 管理環境和自定義配置。 |     *   包含安裝、擴展安裝、程式碼查看和設置等界面。 |     *   在首次運行時顯示歡迎對話框。 |     *   支持主題設置。 |     *   在應用程式啟動時異步更新免費代理。
        │   └── view/
        │       ├── accounts/
        │       │   └── app_accounts_interface.py    這個 Python 文件定義了一個名為 `AccountsInterface` 的類，它是一個用於管理賬戶的界面，繼承自 `PivotNavigatorInterface`。 |  | *   **主要功能:** 提供賬戶管理功能，並作為一個導航界面。 | *   **核心類和函數:** |     *   `AccountsInterface`:  繼承自 `PivotNavigatorInterface`，用於賬戶管理的界面。 |     *   `__init__(self, ctx: ZContext, parent=None)`:  初始化 `AccountsInterface`，接收 `ZContext` 實例，並設置導航文本和圖標。 |     *   `create_sub_interface(self)`:  創建子界面，目前添加了 `ZSettingInstanceInterface`。 | *   **重要功能點:** |     *   使用 `PivotNavigatorInterface` 實現導航界面。 |     *   通過 `add_sub_interface` 添加子界面。 |     *   使用 `ZContext` 進行上下文管理。
        │       ├── battle_assistant/
        │       │   ├── auto_battle_editor_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AutoBattleEditorInterface` 类，用于在 GUI 中编辑自动战斗配置。它提供了一个界面，允许用户选择、查看和管理自动战斗配置，包括作者、版本、简介和适用的配队信息。 |  | **核心类和函数:** |  | *   **`TeamSettingCard`**:  一个自定义的 `MultiPushSettingCard`，用于配置队伍信息。它包含多个 `ComboBox`，允许用户选择队伍中的角色。 |     *   `init_team(self, character_list: List[str])`: 初始化队伍信息。 |     *   `on_character_chosen(self)`: 当角色选择发生变化时触发的信号。 | *   **`AutoBattleEditorInterface`**:  继承自 `VerticalScrollInterface`，是主界面类，用于显示和编辑自动战斗配置。 |     *   `get_content_widget(self) -> QWidget`: 构建界面的主要内容。 |     *   `init_left_part(self) -> QWidget`: 初始化界面左侧部分，包含配置信息和操作按钮。 |     *   `init_right_part(self) -> QWidget`: 初始化界面右侧部分（目前为空）。 |     *   `on_interface_shown(self) -> None`: 界面显示时更新配置选项和显示。 |     *   `update_auto_battle_config_opts(self) -> None`: 更新可用的自动战斗配置选项。 |     *   `update_display_by_config(self) -> None`: 根据选定的配置更新界面显示。 |     *   `update_team_group_display(self) -> None`: 更新队伍配置组的显示。 |     *   `on_config_chosen(self, idx: int) -> None`: 当选择配置时触发，加载配置并更新界面。 |     *   `on_cancel_clicked(self) -> None`:  取消配置选择，重置界面。 |  | **重要功能点:** |  | *   **配置选择**:  使用 `ComboBox`  选择已有的自动战斗配置。 | *   **信息展示**:  使用 `HyperlinkCard`  展示作者、版本、简介等配置信息。 | *   **配队配置**:  使用 `TeamSettingCard`  配置适用的配队
        │       │   ├── auto_battle_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AutoBattleInterface` 类，该类是用于自动战斗功能的 GUI 界面，继承自 `AppRunInterface`。它提供了用户界面元素，用于配置和控制自动战斗，包括选择战斗配置、调试、GPU 运算、截图间隔、手柄类型等。 |  | **核心类和函数:** |  | *   **`AutoBattleInterface(ctx: ZContext, parent=None)`**:  主界面类，初始化界面元素，处理用户交互，并与 `AutoBattleApp` 和 `AutoBattleDebugApp` 交互。 | *   **`get_widget_at_top() -> QWidget`**:  创建并返回界面顶部的设置区域，包括帮助链接、战斗配置选择、调试按钮、配置共享按钮、删除按钮、GPU 选项、截图间隔设置、手柄类型选择。 | *   **`get_content_widget() -> QWidget`**:  创建并返回界面的主要内容区域，包含左侧的 `AppRunInterface` 内容和右侧的 `TaskDisplay` 和 `BattleStateDisplay`。 | *   **`on_interface_shown() -> None`**:  界面显示时进行初始化，加载配置，设置信号连接。 | *   **`on_interface_hidden() -> None`**:  界面隐藏时进行清理，断开信号连接。 | *   **`_on_start_clicked() -> None`**:  启动自动战斗，创建 `AutoBattleApp` 实例。 | *   **`_on_debug_clicked() -> None`**:  启动调试模式，创建 `AutoBattleDebugApp` 实例。 | *   **`_on_auto_battle_config_changed(self, index, value)`**:  处理战斗配置改变的事件。 | *   **`_on_screenshot_interval_changed(self, value: str) -> None`**:  处理截图间隔改变的事件。 | *   **`_on_gamepad_type_changed(self, idx: int, value: str) -> None`**:  处理手柄类型改变的事件。 | *   **`_on_shared_clicked(self) -> None`**:  处理配置共享按钮点击事件。 | *   **`_on_del_clicked(self) -> None`**:
        │       │   ├── battle_assistant_interface.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了 `BattleAssistantInterface` 類，它是一個用於集成多個與戰鬥相關的子界面的主界面。它使用 `PivotNavigatorInterface` 作為基礎，並提供了一個導航結構，用於在不同的戰鬥助手功能之間切換。 |  | **核心類和函數:** |  | *   **`BattleAssistantInterface`**:  繼承自 `PivotNavigatorInterface`，是戰鬥助手的主界面。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，接收應用程序上下文 `ctx`。 |     *   `create_sub_interface(self)`:  創建並添加子界面，包括 `DodgeAssistantInterface`, `AutoBattleInterface`, `OperationDebugInterface` 和 `AutoBattleEditorInterface`。 |  | **重要功能點:** |  | *   使用 `PivotNavigatorInterface` 實現導航，提供用戶友好的界面。 | *   集成多個子界面，將戰鬥助手的功能模塊化。 | *   通過 `ZContext` 接收應用程序的上下文，以便子界面可以訪問配置和狀態信息。
        │       │   ├── battle_state_display.py    這個 Python 文件定義了兩個用於顯示自動戰鬥狀態和任務信息的 GUI 組件，使用 PySide6 和 qfluentwidgets 庫。 |  | **主要功能:** |  | *   **BattleStateDisplay:** 顯示自動戰鬥中各個狀態的觸發時間和狀態值。 | *   **TaskDisplay:** 顯示當前正在運行的任務的觸發器、條件集和持續時間。 |  | **核心類和函數:** |  | *   **BattleStateDisplay:** |     *   `__init__(self, parent=None)`: 初始化表格，設置列標題和定時器。 |     *   `set_update_display(self, to_update: bool) -> None`: 控制更新定時器的啟動和停止。 |     *   `_update_display(self) -> None`:  從 `AutoBattleOperator` 獲取狀態信息，並在表格中更新顯示。 | *   **TaskDisplay:** |     *   `__init__(self, parent=None)`: 初始化表格，設置列寬，隱藏標題和滾動條，並初始化表格數據。 |     *   `set_update_display(self, to_update: bool) -> None`: 控制更新定時器的啟動和停止。 |     *   `_update_display(self) -> None`: 從 `AutoBattleOperator` 獲取任務信息，並在表格中更新顯示。 |     *   `adjustTableHeight(self)`: 根據行高調整表格高度。 |  | **重要功能點:** |  | *   使用 `QTimer` 定期更新表格數據。 | *   從 `AutoBattleOperator` 獲取戰鬥狀態和任務信息。 | *   使用 `FluentThemeColor.RED` 突出顯示狀態變化。 | *   `TaskDisplay` 根據任務信息動態更新表格內容。 | *   `TaskDisplay` 調整表格高度以適應內容。
        │       │   ├── dodge_assistant_interface.py    代码摘要： |  | 该文件定义了 `DodgeAssistantInterface` 类，用于构建闪避助手的 GUI 界面。 |  | 核心类和函数： |  | *   `DodgeAssistantInterface`: 继承自 `AppRunInterface`，是闪避助手界面的主类，负责界面布局、配置选项的显示和交互，以及与后端逻辑的交互。 |     *   `__init__`: 初始化界面，设置上下文和导航信息。 |     *   `get_widget_at_top`: 创建顶部设置区域的控件，包括使用说明、闪避方式选择、GPU 运算开关、截图间隔设置、手柄类型选择等。 |     *   `get_content_widget`: 创建内容区域的控件，包含一个水平布局，左侧是 `AppRunInterface` 的内容，右侧是 `BattleStateDisplay`，用于显示战斗状态。 |     *   `on_interface_shown`: 界面显示时进行初始化，包括更新闪避方式选项、初始化配置适配器、设置截图间隔和手柄类型，以及监听事件。 |     *   `on_interface_hidden`: 界面隐藏时取消事件监听，停止战斗状态显示。 |     *   `_update_dodge_way_opts`: 更新闪避方式选项。 |     *   `_on_screenshot_interval_changed`: 处理截图间隔变化事件。 |     *   `get_app`: 返回 `DodgeAssistantApp` 实例。 |     *   `_on_del_clicked`: 处理删除配置按钮的点击事件。 |     *   `_on_gamepad_type_changed`: 处理手柄类型选择变化事件。 |     *   `on_context_state_changed`: 根据运行状态更新显示。 |     *   `_on_auto_op_loaded_event`: 自动战斗指令加载后的处理。 |     *   `_on_auto_op_loaded_signal`: 指令加载后更新需要监听的事件。 | *   `BattleStateDisplay`: 用于显示战斗状态的组件。 |  | 重要功能点： |  | *   提供闪避方式、GPU 运算、截图间隔、手柄类型等配置选项。 | *   通过 `HyperlinkCard` 提供使用说明。 | *   显示战斗状态。 | *   支持删除配置。 | *   响应配置更改，并
        │       │   ├── operation_debug_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `OperationDebugInterface` 类，用于在 GUI 中提供一个指令调试界面，允许用户配置和调试战斗助手的操作指令。 |  | **核心类和函数:** |  | *   **`OperationDebugInterface`**: 继承自 `AppRunInterface`，是指令调试界面的主类。 |     *   `__init__`: 初始化界面，设置导航信息。 |     *   `get_widget_at_top`: 构建界面顶部的控件，包括指令配置、循环指令、手柄类型等设置。 |     *   `on_interface_shown`: 界面显示时进行初始化，加载配置。 |     *   `_update_auto_battle_config_opts`: 更新指令配置选项，从文件系统加载模板。 |     *   `_on_config_changed`: 当指令配置改变时，更新上下文中的配置。 |     *   `_on_repeat_changed`: 当循环指令设置改变时，更新上下文中的配置。 |     *   `get_app`: 返回 `OperationDebugApp` 实例。 |     *   `_on_del_clicked`: 删除选定的指令配置。 |     *   `_on_gamepad_type_changed`: 当手柄类型改变时，更新上下文中的配置。 |  | **重要功能点:** |  | *   提供指令配置的下拉选择框，允许用户选择不同的操作指令模板。 | *   提供循环指令的开关，用于控制指令的重复执行。 | *   提供手柄类型选择框，用于配置战斗助手的手柄类型。 | *   支持删除用户自定义的指令配置。 | *   界面初始化时加载并显示当前的配置。 | *   通过上下文 `ZContext` 存储和管理配置信息。
        │       │   └── template_generation_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个用于生成战斗动作模板的界面，该界面允许用户录制游戏操作，然后根据录制的数据生成 YAML 格式的动作模板。 |  | **核心类和函数:** |  | *   **`TemplateGenerationInterface`**:  继承自 `AppRunInterface`，是主界面类，负责 UI 的构建和逻辑控制。 |     *   `__init__`: 初始化界面，设置导航信息和默认设置。 |     *   `get_widget_at_top`:  创建并返回界面顶部的设置卡片，包括生成模板、载入预设模板和添加切换操作的选项。 |     *   `get_content_widget`:  创建并返回界面的主要内容，包括状态显示、开始/停止录制按钮和日志显示卡片。 |     *   `on_interface_shown`:  界面显示时初始化设置。 |     *   `_template_generation`:  根据录制的数据生成动作模板，调用 `PreProcessor` 和 `SelfAdaptiveGenerator`。 |     *   `_on_key_press`:  处理快捷键事件，启动或停止录制。 |     *   `_on_start_clicked`:  开始录制，初始化 `RecordContext`。 |     *   `_on_stop_clicked`:  停止录制，结束相关线程和进程。 |     *   `_use_existing_changed`:  处理“载入预设模板”选项的改变。 |     *   `_add_switch_changed`:  处理“添加切换操作”选项的改变。 | *   **`AppRunner`**: 继承自 `QThread`，用于在单独的线程中运行录制和模板生成逻辑。 |     *   `run`: 执行录制和输出记录。 |  | **重要功能点:** |  | *   **录制功能**:  通过 `RecordContext` 录制游戏操作。 | *   **模板生成**:  使用 `PreProcessor` 和 `SelfAdaptiveGenerator` 从录制数据生成 YAML 格式的动作模板。 | *   **用户界面**:  提供用户友好的界面，用于控制录制、设置选项和查看日志。 | *   **设置选项**:  允许用户选择是否使用预设模板和是否添加切换代理人操作。 | *   **快捷
        │       ├── devtools/
        │       │   ├── app_devtools_interface.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | `AppDevtoolsInterface` 類別定義了一個應用程式的開發工具介面，它是一個 `PivotNavigatorInterface` 的子類，用於在應用程式中提供開發者工具的導航和管理。 |  | **核心類和函數：** |  | *   `AppDevtoolsInterface`:  主介面類別，繼承自 `PivotNavigatorInterface`。 |     *   `__init__(self, ctx: ZContext, parent=None)`:  建構子，初始化介面並接收 `ZContext` 實例。 |     *   `create_sub_interface(self)`:  創建並添加子介面，包括 `DevtoolsScreenshotHelperInterface`, `DevtoolsTemplateHelperInterface`, 和 `DevtoolsScreenManageInterface`。 |  | **重要功能點：** |  | *   使用 `PivotNavigatorInterface` 實現導航介面，方便使用者在不同開發工具之間切換。 | *   整合了截圖、模板輔助和螢幕管理等開發工具子介面。 | *   使用 `ZContext` 進行上下文管理。
        │       │   └── devtools_screenshot_helper_interface.py    這個 Python 文件定義了一個用於截圖助手的 GUI 界面，該助手是開發工具的一部分。 |  | *   **主要功能:** 提供用戶界面，用於配置和控制截圖助手的設置，包括截圖間隔、持續時間、保存截圖的快捷鍵以及閃避檢測功能。 | *   **核心類和函數:** |     *   `DevtoolsScreenshotHelperInterface`: 繼承自 `AppRunInterface`，負責創建和管理截圖助手的 UI。 |     *   `get_widget_at_top()`:  創建並返回包含設置選項的 UI 元素，包括文本框、開關和按鍵設置卡片。 |     *   `on_interface_shown()`:  當界面顯示時，從上下文加載配置並更新 UI。 |     *   `get_app()`:  返回 `ScreenshotHelperApp` 實例，用於與應用程序邏輯交互。 |     *   `_on_frequency_changed()`, `_on_length_changed()`, `_on_key_save_changed()`, `_on_dodge_detect_changed()`:  處理 UI 控件的更改事件，並將設置更新到上下文中的配置。 | *   **重要功能點:** |     *   提供用戶界面，用於配置截圖助手的各項參數。 |     *   使用 `TextSettingCard`, `KeySettingCard`, 和 `SwitchSettingCard` 等自定義 UI 控件來展示和編輯設置。 |     *   在界面顯示時加載配置，並在設置更改時更新配置。 |     *   與 `ScreenshotHelperApp` 交互以執行截圖操作。
        │       ├── game_assistant/
        │       │   ├── commission_assistant_interface.py    這個 Python 文件定義了 `CommissionAssistantRunInterface` 類，它是一個用於遊戲內委托助手功能的 GUI 界面。 |  | **核心類和函數:** |  | *   `CommissionAssistantRunInterface`: 繼承自 `AppRunInterface`，負責創建和管理委托助手界面的 UI 元素，並處理用戶交互。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，接收上下文 `ZContext`。 |     *   `get_widget_at_top(self) -> QWidget`:  創建並返回包含各種設置選項的 UI 元素，例如對話選項、點擊間隔、劇情模式、自動閃避和自動戰鬥的配置。 |     *   `on_interface_shown(self) -> None`:  界面顯示時，初始化各個設置卡片，將配置與上下文中的數據進行綁定。 |     *   `on_interface_hidden(self) -> None`: 界面隱藏時，執行清理操作。 |     *   `get_app(self) -> Application`:  返回 `CommissionAssistantApp` 實例，作為應用程序的後端邏輯。 |  | **重要功能點:** |  | *   提供用戶界面，用於配置委托助手功能的各項參數。 | *   使用 `ComboBoxSettingCard`, `TextSettingCard`, `KeySettingCard` 等自定義控件，方便用戶設置。 | *   通過 `init_with_adapter` 將 UI 控件與配置數據進行綁定，實現配置的讀取和保存。 | *   包含使用說明鏈接，方便用戶了解功能。
        │       │   ├── game_assistant.py    這個 Python 文件的摘要如下： |  | *   **主要功能:** 該文件定義了一個遊戲助手界面，用於整合多個遊戲相關的輔助工具。 | *   **核心類和函數:** |     *   `GameAssistantInterface`: 繼承自 `PivotNavigatorInterface`，是遊戲助手的核心界面，負責管理和展示子界面。 |     *   `create_sub_interface()`: 創建並添加子界面，包括 `CommissionAssistantRunInterface`, `LifeOnLineRunInterface`, 和 `PredefinedTeamCheckerInterface`。 | *   **重要功能點:** |     *   使用 `PivotNavigatorInterface` 實現導航界面。 |     *   整合了多個遊戲輔助工具的子界面。 |     *   使用 `ZContext` 傳遞上下文信息。
        │       │   ├── life_on_line_run_interface.py    這個 Python 文件定義了一個名為 `LifeOnLineRunInterface` 的界面，用於「拿命验收」功能，該功能可能與遊戲助手相關。 |  | *   **主要功能:** 提供一個界面，用於配置和運行與遊戲相關的「拿命验收」功能，包括查看使用說明、設置每日運行次數和選擇預設隊伍。 | *   **核心類和函數:** |     *   `LifeOnLineRunInterface`: 繼承自 `AppRunInterface`，負責構建和管理界面。 |     *   `__init__`: 初始化界面，接收 `ZContext` 實例。 |     *   `get_widget_at_top`: 創建界面頂部的部件，包括超鏈接卡片（用於幫助說明）、文本設置卡片（用於每日次數）和組合框設置卡片（用於預設隊伍）。 |     *   `on_interface_shown`: 在界面顯示時初始化設置卡片，包括從配置中加載數據，並更新每日運行次數的顯示。 |     *   `get_app`: 返回 `LifeOnLineApp` 實例。 | *   **重要功能點:** |     *   使用 `HyperlinkCard` 提供使用說明。 |     *   使用 `TextSettingCard` 顯示和設置每日運行次數。 |     *   使用 `ComboBoxSettingCard` 選擇預設隊伍。 |     *   通過 `ZContext` 訪問配置和記錄數據。 |     *   使用 `LifeOnLineApp` 運行應用程序邏輯。
        │       │   └── predefined_team_checker_interface.py    這個 Python 文件定義了一個名為 `PredefinedTeamCheckerInterface` 的 GUI 界面，用於預備編隊識別。 |  | *   **主要功能:** 提供一個界面，用於根據用戶輸入的編隊名稱識別代理人。 | *   **核心類和函數:** |     *   `PredefinedTeamCheckerInterface`: 繼承自 `AppRunInterface`，負責界面初始化和管理。 |     *   `get_widget_at_top()`:  創建並返回界面頂部的部件，包括一個 `HyperlinkCard` 用於顯示幫助信息。 |     *   `on_interface_shown()`:  界面顯示時的處理函數。 |     *   `get_app()`:  返回 `PredefinedTeamChecker` 實例，作為應用程序的核心邏輯。 | *   **重要功能點:** |     *   使用 `HyperlinkCard` 提供用戶幫助。 |     *   通過 `get_app()` 函數，將 `PredefinedTeamChecker` 實例作為應用程序的核心邏輯。 |     *   繼承自 `AppRunInterface`，表明它是一個應用程序運行界面。
        │       ├── hollow_zero/
        │       │   ├── hollow_zero_challenge_config_interface.py    ```python | # 摘要 | # 1. 文件主要功能： | #    - 提供一个GUI界面，用于配置和管理枯萎之零挑战的配置。用户可以创建、复制、删除和编辑挑战配置，包括目标配队、自动战斗设置、寻路方式、奖励优先级等。 | # 2. 核心类和函数： | #    - HollowZeroChallengeConfigInterface: 继承自VerticalScrollInterface，是主界面类，负责UI的构建和事件处理。 | #    - _init_left_part(): 初始化左侧的配置选项，包括按钮、文本框、下拉框等。 | #    - _init_right_part(): 初始化右侧的奖励优先级输入框。 | #    - on_interface_shown():  界面显示时初始化，更新界面状态。 | #    - _update_whole_display():  根据当前配置状态更新整个界面的显示。 | #    - _on_..._clicked():  处理各种按钮点击事件，如创建、复制、删除、取消等。 | #    - _on_..._changed():  处理各种配置选项改变的事件，如名称、自动战斗、寻路方式等。 | # 3. 重要功能点： | #    - 配置的创建、复制、删除和保存。 | #    - 目标配队的配置，通过EditableComboBox选择角色。 | #    - 自动战斗配置的选择。 | #    - 寻路方式的配置，包括自定义寻路设置。 | #    - 奖励优先级的配置。 | ```
        │       │   ├── hollow_zero_interface.py    這個 Python 文件的摘要如下： |  | *   **主要功能:**  `HollowZeroInterface` 是一個用於管理 "零號空洞" 相關子界面的導航界面。它使用 `PivotNavigatorInterface` 作為基類，並負責創建和組織與 "零號空洞" 相關的配置和運行界面。 | *   **核心類和函數:** |     *   `HollowZeroInterface`:  繼承自 `PivotNavigatorInterface`，是主界面類。 |     *   `__init__(self, ctx: ZContext, parent=None)`:  構造函數，初始化上下文 (`ZContext`) 和父窗口。 |     *   `create_sub_interface(self)`:  創建並添加子界面，包括 `HollowZeroRunInterface`, `HollowZeroChallengeConfigInterface`, `LostVoidRunInterface`, 和 `LostVoidChallengeConfigInterface`。 | *   **重要功能點:** |     *   使用 `PivotNavigatorInterface` 實現導航功能。 |     *   管理與 "零號空洞" 相關的子界面，包括運行和配置界面。 |     *   使用 `ZContext` 傳遞上下文信息。 |     *   使用 `FluentIcon.IOT` 設置導航圖標。
        │       │   ├── hollow_zero_run_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `HollowZeroRunInterface` 类，用于在 GUI 中展示和控制“枯萎之都”的运行界面。它继承自 `AppRunInterface`，提供了用户界面元素，允许用户配置和启动枯萎之都相关的任务。 |  | **核心类和函数:** |  | *   **`HollowZeroRunInterface(ctx: ZContext, parent=None)`**:  构造函数，初始化界面，接收 `ZContext` 上下文。 | *   **`get_widget_at_top() -> QWidget`**:  创建并返回包含左右布局的顶层 widget，用于放置设置选项。 | *   **`_get_left_opts() -> QWidget`**:  创建并返回左侧的设置选项，包括帮助链接、副本选择、每周基础次数、额外刷取选项。 | *   **`_get_right_opts() -> QWidget`**:  创建并返回右侧的设置选项，包括运行记录、挑战配置、每日进入次数、额外刷取方式选项。 | *   **`on_interface_shown() -> None`**:  界面显示时进行初始化，包括更新副本选项、挑战配置选项，以及设置初始值。 | *   **`_update_run_record_display() -> None`**:  更新运行记录的显示内容。 | *   **`_update_mission_options() -> None`**:  更新副本选择的选项。 | *   **`_update_challenge_config_options() -> None`**:  更新挑战配置的选项。 | *   **`_on_mission_changed(self, idx, value) -> None`**:  处理副本选择改变的事件。 | *   **`_on_reset_record_clicked() -> None`**:  处理重置运行记录的点击事件。 | *   **`get_app() -> ZApplication`**:  获取当前运行的应用程序实例。 | *   **`_on_start_clicked() -> None`**:  处理正常运行按钮的点击事件，启动 `HollowZeroApp`。 | *   **`_on_debug_clicked() -> None`**:  处理调试按钮的点击事件，启动 `HollowZeroDebugApp`。 | *   **`_on_weekly_plan_times
        │       │   ├── lost_void_challenge_config_interface.py    **文件摘要** |  | *   **主要功能:**  该文件定义了一个用于配置《迷失虚空挑战》的界面，允许用户创建、编辑、复制和删除挑战配置。界面包含多个设置选项，如自动战斗配置、周期增益、商店购买策略以及藏品和区域类型的优先级设置。 | *   **核心类和函数:** |     *   `LostVoidChallengeConfigInterface`:  继承自 `VerticalScrollInterface`，是配置界面的主类。 |     *   `_init_left_part()`:  初始化界面左侧的控件，包括按钮和各种设置卡片。 |     *   `_init_right_part()`:  初始化界面右侧的控件，主要用于输入藏品和区域类型的优先级。 |     *   `on_interface_shown()`:  界面显示时进行初始化，加载数据并更新显示。 |     *   `_update_whole_display()`:  根据当前配置状态更新整个界面的显示。 |     *   `_on_choose_existed_yml()`:  处理选择现有配置的事件。 |     *   `_on_create_clicked()`:  处理创建新配置的事件。 |     *   `_on_copy_clicked()`:  处理复制配置的事件。 |     *   `_on_delete_clicked()`:  处理删除配置的事件。 |     *   `_on_cancel_clicked()`:  处理取消编辑的事件。 |     *   `_on_name_changed()`:  处理配置名称改变的事件。 |     *   `_on_artifact_priority_changed()`:  处理藏品优先级改变的事件。 |     *   `_on_region_type_priority_changed()`:  处理区域类型优先级改变的事件。 | *   **重要功能点:** |     *   提供创建、复制、删除配置的功能。 |     *   允许用户选择现有的配置。 |     *   提供多种设置选项，包括自动战斗、周期增益、商店购买策略等。 |     *   允许用户自定义藏品和区域类型的优先级。 |     *   提供错误消息提示。 |     *   界面根据配置状态动态更新控件的可用状态。
        │       │   └── lost_void_run_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `LostVoidRunInterface` 类，用于构建“迷失之地”功能的 GUI 界面，允许用户配置和运行与“迷失之地”相关的任务。 |  | **核心类和函数:** |  | *   **`LostVoidRunInterface(ctx: ZContext, parent=None)`:**  主界面类，继承自 `AppRunInterface`，负责界面的初始化和布局。 | *   **`get_widget_at_top() -> QWidget`:**  创建并返回包含左右两侧设置选项的容器 widget。 | *   **`_get_left_opts() -> QWidget`:**  创建并返回左侧的设置选项，包括帮助说明、副本选择、每周基础次数和额外刷取选项。 | *   **`_get_right_opts() -> QWidget`:**  创建并返回右侧的设置选项，包括运行记录、挑战配置和每天进入次数选项。 | *   **`on_interface_shown() -> None`:**  界面显示时进行初始化，更新各种选项。 | *   **`_update_mission_options() -> None`:**  更新副本选择的选项。 | *   **`_update_challenge_config_options() -> None`:**  更新挑战配置的选项。 | *   **`_on_reset_record_clicked() -> None`:**  重置运行记录。 | *   **`_on_start_clicked() -> None`:**  启动 LostVoidApp。 | *   **`_on_context_state_changed() -> None`:**  根据运行状态更新显示。 |  | **重要功能点:** |  | *   提供用户界面，用于配置迷失之地任务的各种参数，如副本、挑战配置、刷取次数等。 | *   使用 `ComboBoxSettingCard` 和 `TextSettingCard` 等自定义控件来展示和编辑配置选项。 | *   通过 `HyperlinkCard` 提供使用说明。 | *   提供重置运行记录的功能。 | *   根据上下文状态更新界面显示。 | *   启动 `LostVoidApp` 来运行迷失之地任务。
        │       ├── home/
        │       │   └── home_interface.py    ```python | # 摘要 |  | # 主要功能: | # 这是一个用于 Zenless Zone Zero (ZZZ) 的主页界面，提供了启动游戏、访问官网、GitHub 仓库、文档和社群的功能，并包含检查更新的机制。 |  | # 核心类和函数: | # - HomeInterface: 主页界面的核心类，继承自 VerticalScrollInterface，负责布局和管理主页的 UI 元素，包括按钮组、公告卡片和启动游戏按钮。 | # - ButtonGroup: 包含一系列 IconButton，用于导航到官网、GitHub、文档、社群等。 | # - CheckRunnerBase, CheckCodeRunner, CheckVenvRunner, CheckModelRunner: 用于检查代码、依赖、模型更新的线程类。 | # - GameStartThread: 启动游戏的线程，负责调用 OpenGame 操作。 | # - LauncherGame: 继承自 Operation，封装了启动游戏的操作。 | # - start_game: HomeInterface 的函数，用于启动游戏，显示启动中对话框，并启动 GameStartThread。 |  | # 重要功能点: | # - 界面布局: 使用 PySide6 的组件构建主页界面，包括 Banner、按钮组、公告卡片和启动按钮。 | # - 导航功能: ButtonGroup 中的按钮链接到官网、GitHub、文档和社群。 | # - 启动游戏: 点击启动游戏按钮后，通过 GameStartThread 启动游戏，并显示启动中对话框。 | # - 更新检查: 启动时自动检查代码、依赖和模型更新，并在有更新时显示提示。 | # - 错误处理: 启动游戏失败时，显示错误信息。 | ```
        │       ├── installer/
        │       │   ├── extend_install_interface.py    這個 Python 文件定義了一個名為 `ExtendInstallInterface` 的界面，用於擴展安裝功能。 |  | **主要功能:** |  | *   提供一個用於擴展安裝的界面，包括進度條、Gamepad 安裝選項和日誌顯示。 |  | **核心類和函數:** |  | *   `ExtendInstallInterface`: 繼承自 `VerticalScrollInterface`，是主界面類。 |     *   `__init__(self, ctx: OneDragonEnvContext, parent=None)`: 初始化界面，設置上下文和導航信息。 |     *   `get_content_widget(self) -> QWidget`: 創建界面內容，包括進度條、Gamepad 安裝卡片和日誌顯示卡片。 |     *   `on_interface_shown(self) -> None`: 界面顯示時的回調，用於檢查和更新組件狀態。 |     *   `on_interface_hidden(self) -> None`: 界面隱藏時的回調，用於停止日誌。 |     *   `update_progress(self, progress: float, message: str) -> None`: 更新進度條的顯示。 |  | **重要功能點:** |  | *   使用 `ProgressBar` 和 `IndeterminateProgressBar` 顯示安裝進度。 | *   包含 `GamepadInstallCard` 用於 Gamepad 相關的安裝選項。 | *   使用 `LogDisplayCard` 顯示安裝日誌。 | *   提供 `on_interface_shown` 和 `on_interface_hidden` 回調函數，用於界面生命週期的管理。 | *   `update_progress` 函數用於更新進度條，支持確定和不確定進度模式。
        │       │   └── gamepad_install_card.py    這個 Python 文件定義了一個名為 `GamepadInstallCard` 的類，它繼承自 `BaseInstallCard`，用於在 GUI 中安裝和管理虛擬手柄的依賴。 |  | **核心類和函數:** |  | *   **`GamepadInstallCard`**: 繼承自 `BaseInstallCard`，負責處理虛擬手柄的安裝和狀態顯示。 |     *   `__init__`: 初始化，設置標題和安裝方法。 |     *   `after_progress_done`: 安裝完成後的回調，更新配置和顯示。 |     *   `get_display_content`: 獲取顯示的狀態信息（圖標和文本）。 |     *   `get_requirement_time`: 獲取 requirements.txt 文件的最後更新時間。 |     *   `install_requirements`: 安裝虛擬手柄的依賴。 |     *   `get_requirement_path`: 獲取 requirements.txt 文件的路徑。 |  | **重要功能點:** |  | *   **依賴安裝:** 使用 `pip` 安裝 requirements.txt 中指定的依賴。 | *   **狀態顯示:** 根據依賴的安裝狀態顯示不同的圖標和文本。 | *   **更新檢測:** 檢查 requirements.txt 的更新時間，提示用戶更新。 | *   **配置管理:** 使用 `OneDragonEnvContext` 獲取環境配置，並在安裝成功後更新配置。 | *   **進度回調:** 在安裝過程中提供進度回調。
        │       ├── one_dragon/
        │       │   ├── charge_plan_interface.py    **摘要:** |  | 该文件定义了用于管理和显示游戏内体力计划的 GUI 界面。 |  | **核心类和函数:** |  | *   **`ChargePlanCard`**:  一个 `MultiLineSettingCard` 的子类，用于显示和编辑单个体力计划的详细信息。 |     *   包含多个 `ComboBox` 和 `LineEdit`，用于设置计划的类别、任务类型、任务、卡牌数量、狩猎buff、预设队伍、自动战斗配置、运行次数和计划次数。 |     *   使用信号连接到上下文对象，以便在计划更改时更新配置。 |     *   `init_with_plan()`:  使用给定的 `ChargePlanItem` 初始化卡片。 |     *   `_on_..._changed()`:  处理各种控件的更改事件，更新 `ChargePlanItem` 并发出 `changed` 信号。 |     *   `_on_..._clicked()`:  处理按钮点击事件，例如删除、上移、置顶。 |     *   `update_by_history()`:  根据历史记录更新计划。 | *   **`ChargePlanInterface`**:  一个 `VerticalScrollInterface` 的子类，用于显示和管理体力计划列表。 |     *   `get_content_widget()`:  创建界面内容，包括循环执行开关和体力计划卡片列表。 |     *   `update_plan_list_display()`:  根据配置更新计划卡片的显示。 |     *   `_on_add_clicked()`:  添加新的体力计划。 |     *   `_on_plan_item_...()`:  处理单个计划卡片发出的信号，例如更改、删除、上移、置顶。 |     *   `_on_loop_changed()`:  处理循环执行开关的更改。 |  | **重要功能点:** |  | *   **体力计划编辑**:  允许用户配置和编辑体力计划的各个方面，包括类别、任务、卡牌数量等。 | *   **计划列表管理**:  支持添加、删除、移动计划，并根据配置动态更新界面。 | *   **循环执行**:  提供一个开关，用于启用或禁用循环执行体力计划。 | *   **历史记录集成**:  根据历史记录更新计划。 | *   **用户界面**:  使用 `qfluentwidgets`
        │       │   ├── coffee_plan_interface.py    **摘要:** |  | 该文件定义了 `CoffeePlanInterface` 类，用于在 GUI 中展示和配置咖啡计划相关的设置。它基于 `VerticalScrollInterface`，并使用各种设置卡片（`ComboBoxSettingCard` 和 `SwitchSettingCard`）来提供用户界面。 |  | **核心类和函数:** |  | *   **`CoffeePlanInterface(VerticalScrollInterface)`**:  主界面类，继承自 `VerticalScrollInterface`。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，设置上下文和导航文本。 |     *   `get_content_widget(self) -> QWidget`:  构建界面内容，包括各种设置卡片，如咖啡选择方式、挑战方式、体力计划外的数量、预备编队、自动战斗和结束后运行体力计划。 |     *   `on_interface_shown(self) -> None`:  界面显示时初始化设置卡片的值，从上下文获取配置适配器，并设置选项。 |     *   `on_predefined_team_changed(self, idx: int, value: str) -> None`:  当预备编队选项改变时，根据选择的编队，控制自动战斗选项的可见性。 |  | **重要功能点:** |  | *   **配置界面**:  提供用户友好的界面，用于配置咖啡计划的各种参数。 | *   **设置卡片**:  使用 `ComboBoxSettingCard` 和 `SwitchSettingCard` 等自定义设置卡片，方便用户进行配置。 | *   **数据绑定**:  通过配置适配器，将设置卡片与应用程序的配置数据绑定。 | *   **动态更新**:  根据用户选择的预备编队，动态控制自动战斗选项的可见性。 | *   **上下文依赖**:  依赖于 `ZContext` 来访问应用程序的配置和数据。
        │       │   ├── miscellany_run_interface.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | *   `MiscellanyRunInterface` 類別定義了一個用於執行雜項任務的用戶界面，它繼承自 `OneDragonRunInterface`。 |  | **核心類和函數：** |  | *   `MiscellanyRunInterface`: 繼承自 `OneDragonRunInterface`，用於創建雜項任務的運行界面。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，設置上下文、導航文本、對象名稱等。 |     *   `get_one_dragon_app(self) -> OneDragonApp`:  返回 `MiscellanyApp` 的實例。 |     *   `get_one_dragon_app_config(self) -> OneDragonAppConfig`: 返回雜項配置。 |  | **重要功能點：** |  | *   界面初始化時，會設置導航文本為“杂项任务”，並指定幫助文檔的 URL。 | *   `get_one_dragon_app` 方法用於獲取 `MiscellanyApp` 實例，用於處理雜項任務的應用邏輯。 | *   `get_one_dragon_app_config` 方法用於獲取雜項配置，用於配置雜項任務的行為。
        │       │   ├── notorious_hunt_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了用于在 GUI 中显示和编辑“恶名狩猎”计划的界面。它允许用户配置和管理狩猎任务的各种参数，例如任务类型、等级、预设队伍、自动战斗配置、buff 和运行次数。 |  | **核心类和函数:** |  | *   **`ChargePlanCard`**: |     *   `__init__`: 初始化一个用于显示和编辑单个“恶名狩猎”计划的卡片。包含多个 `ComboBox` 和 `LineEdit` 用于配置计划的各个属性。 |     *   `init_with_plan`: 使用给定的 `ChargePlanItem` 初始化卡片中的控件。 |     *   `init_mission_type_combo_box`, `init_level_combo_box`, `init_buff_combo_box`, `init_auto_battle_box`, `init_predefined_team_opt`, `init_run_times_input`, `init_plan_times_input`: 用于初始化各个控件，从配置中加载数据。 |     *   `_on_mission_type_changed`, `_on_level_changed`, `on_buff_changed`, `on_predefined_team_changed`, `_on_auto_battle_changed`, `_on_run_times_changed`, `_on_plan_times_changed`: 响应控件值改变的槽函数，更新 `ChargePlanItem` 的属性并发出 `changed` 信号。 |     *   `_emit_value`: 发出 `changed` 信号，通知计划已更改。 | *   **`NotoriousHuntPlanInterface`**: |     *   `__init__`: 初始化“恶名狩猎”计划的界面，继承自 `VerticalScrollInterface`。 |     *   `get_content_widget`: 创建并返回包含 `ChargePlanCard` 实例的 `Column` 布局。 |     *   `update_plan_list_display`: 根据配置中的计划列表动态更新卡片列表。 |     *   `on_interface_shown`: 当界面显示时，调用 `update_plan_list_display`。 |     *   `on_interface_hidden`: 当界面隐藏时，执行清理操作。 |     *   `_on_plan_item_changed`:
        │       │   ├── setting_team_interface.py    這個 Python 文件的主要功能是提供一個用於配置遊戲中預設隊伍的 GUI 介面。它允許使用者設定隊伍名稱、自動戰鬥選項和隊伍成員的代理人。 |  | 核心類和函數： |  | *   **TeamSettingCard**: 繼承自 `MultiPushSettingCard`，用於顯示和編輯單個預設隊伍的設定。 |     *   `__init__`: 初始化 UI 元素，例如下拉選單和輸入框，並連接信號槽。 |     *   `init_setting_card`: 使用給定的隊伍資訊初始化卡片。 |     *   `on_name_changed`, `on_auto_battle_changed`, `on_agent_1_changed`, `on_agent_2_changed`, `on_agent_3_changed`: 處理使用者輸入更改，更新隊伍資訊，並發射 `changed` 信號。 | *   **SettingTeamInterface**: 繼承自 `VerticalScrollInterface`，是整個設定介面的主介面。 |     *   `__init__`: 初始化介面，包括上下文和導航文本。 |     *   `get_content_widget`: 建立介面的內容，包括幫助訊息和多個 `TeamSettingCard` 實例。 |     *   `on_interface_shown`: 在介面顯示時初始化每個 `TeamSettingCard` 的設定。 |     *   `on_team_info_changed`: 處理 `TeamSettingCard` 發射的 `changed` 信號，更新上下文中的隊伍配置。 |  | 重要功能點： |  | *   允許使用者設定預設隊伍的名稱。 | *   允許使用者選擇每個隊伍的自動戰鬥選項。 | *   允許使用者為每個隊伍選擇三個代理人。 | *   使用 `VerticalScrollInterface` 顯示可滾動的介面。 | *   使用 `MultiPushSettingCard` 顯示每個隊伍的設定。 | *   使用 `ComboBox` 和 `EditableComboBox` 實現下拉選單。 | *   使用 `LineEdit` 實現文字輸入。 | *   使用信號和槽來處理使用者輸入更改，並更新隊伍配置。 | *   提供幫助訊息。
        │       │   ├── shiyu_defense_interface.py    **摘要：** |  | 该文件定义了 `ShiyuDefenseInterface` 类，用于在用户界面中展示和管理式舆防卫战相关信息。它基于 `VerticalScrollInterface`，并使用 `QTableWidget` 和 `CheckBox` 等控件来显示队伍信息和设置。 |  | **核心类和函数：** |  | *   `ShiyuDefenseInterface`:  继承自 `VerticalScrollInterface`，是式舆防卫战界面的主类。 |     *   `__init__`: 初始化界面，设置上下文和导航文本。 |     *   `get_content_widget`: 构建界面内容，包括重置按钮和队伍表格。 |     *   `on_interface_shown`:  界面显示时更新表格数据，包括队伍名称、剧变节点状态和属性弱点。 |     *   `on_weakness_check_changed`: 处理属性弱点复选框状态改变的事件。 |     *   `on_critical_changed`: 处理剧变节点复选框状态改变的事件。 |     *   `on_critical_reset_clicked`: 处理重置运行记录按钮点击事件。 |  | **重要功能点：** |  | *   **队伍信息展示:**  使用表格显示队伍名称、是否参与剧变节点以及属性弱点。 | *   **剧变节点设置:**  通过复选框控制队伍是否参与剧变节点。 | *   **属性弱点设置:**  通过复选框设置队伍的属性弱点。 | *   **重置功能:**  提供重置剧变节点运行记录的功能。 | *   **数据绑定:**  将界面控件与上下文中的数据（如队伍配置、弱点信息）进行绑定，并响应用户交互更新数据。
        │       │   ├── zzz_one_dragon_interface.py    這個 Python 文件定義了一個名為 `ZOneDragonInterface` 的類，它是一個用於管理“一條龍”功能的界面，繼承自 `PivotNavigatorInterface`。 |  | *   **主要功能**: 作為一個導航界面，整合了多個子界面，提供對“一條龍”相關功能的訪問。 | *   **核心類**: `ZOneDragonInterface` 繼承自 `PivotNavigatorInterface`。 | *   **重要功能點**: |     *   `__init__`: 初始化界面，設置導航圖標、名稱和父對象。 |     *   `create_sub_interface`: 創建並添加多個子界面，包括 `ZOneDragonRunInterface`, `SettingTeamInterface`, `ChargePlanInterface`, `NotoriousHuntPlanInterface`, `CoffeePlanInterface`, `ShiyuDefenseInterface` 和 `ZOneDragonSettingInterface`。
        │       │   ├── zzz_one_dragon_run_interface.py    這個 Python 文件定義了 `ZOneDragonRunInterface` 類，它繼承自 `OneDragonRunInterface`。 |  | *   **主要功能:**  為 ZZZ 版本的 OneDragon 應用提供運行界面。 | *   **核心類:** |     *   `ZOneDragonRunInterface`:  繼承自 `OneDragonRunInterface`，用於初始化和獲取 ZZZ 版本的 OneDragon 應用。 | *   **重要功能點:** |     *   `__init__`:  初始化 `ZOneDragonRunInterface`，接收 `ZContext` 實例，並設置幫助文檔的 URL。 |     *   `get_one_dragon_app`:  返回 `ZOneDragonApp` 實例，用於獲取 ZZZ 版本的 OneDragon 應用。
        │       │   └── zzz_one_dragon_setting_interface.py    這個 Python 文件定義了一個用於配置遊戲設置的界面，使用 PySide6 和 qfluentwidgets 庫。 |  | **主要功能:** |  | *   提供一個垂直滾動的界面，用於配置遊戲的各種設置，包括代理人皮膚、影像店代理人和驅動盤拆解選項。 |  | **核心類和函數:** |  | *   `ZOneDragonSettingInterface`: 繼承自 `VerticalScrollInterface`，是主要的設置界面類。 |     *   `__init__`: 初始化界面，接收一個 `ZContext` 實例。 |     *   `get_content_widget`: 創建並返回包含所有設置組件的 `QWidget`。 |     *   `get_agent_outfit_group`: 創建代理人皮膚設置組。 |     *   `get_coffee_shop_group`: 創建影像店設置組。 |     *   `get_drive_disc_dismantle_group`: 創建驅動盤拆解設置組。 |     *   `on_interface_shown`: 在界面顯示時初始化設置卡片的值，使用配置適配器。 |     *   `on_agent_outfit_changed`: 當代理人皮膚選項更改時調用，重新初始化代理人模板 ID。 |  | **重要功能點:** |  | *   使用 `SettingCardGroup` 組織設置選項。 | *   使用 `ComboBoxSettingCard` 和 `EditableComboBoxSettingCard` 實現下拉框設置。 | *   使用 `SwitchSettingCard` 實現開關設置。 | *   使用 `ConfigItem` 封裝配置選項。 | *   使用 `ZContext` 訪問遊戲配置和數據。 | *   使用配置適配器來綁定設置卡片的值到配置。 | *   支持多語言，使用 `gt` 函數進行文本翻譯。
        │       └── setting/
        │           ├── app_setting_interface.py    這個 Python 文件的摘要如下： |  | *   **主要功能:**  定義了應用程式的設置界面，它是一個導航界面，用於管理不同類型的設置子界面。 | *   **核心類和函數:** |     *   `AppSettingInterface`:  繼承自 `PivotNavigatorInterface`，是主要的設置界面，負責管理和顯示子設置界面。 |     *   `create_sub_interface()`:  創建並添加了多個子設置界面，包括遊戲設置、YOLO設置、環境設置和自定義設置。 | *   **重要功能點:** |     *   使用 `PivotNavigatorInterface` 實現導航功能，提供了一個設置頁面的入口。 |     *   通過 `add_sub_interface()` 添加了多個子設置界面，實現了模塊化的設置管理。 |     *   依賴於 `ZContext` 類來獲取應用程式的上下文信息。
        │           ├── setting_game_interface.py    ```python | # 摘要 | # 該文件定義了遊戲設置界面，允許用戶配置遊戲內的多個選項。 |  | # 核心類和函數 | # - SettingGameInterface: 繼承自 VerticalScrollInterface，用於創建遊戲設置界面的主窗口。 | #   - get_content_widget: 構建界面內容，包含多個設置組。 | #   - _get_agent_outfit_group: 創建代理人皮膚設置組。 | #   - _get_basic_group: 創建遊戲基礎設置組。 | #   - _get_launch_argument_group: 創建啟動參數設置組。 | #   - _get_key_group: 創建遊戲按鍵設置組。 | #   - _get_gamepad_group: 創建手柄按鍵設置組。 | #   - on_interface_shown: 初始化界面，將設置選項與配置數據綁定。 | #   - _update_gamepad_part: 根據手柄類型更新手柄按鍵設置的可見性。 | #   - _on_gamepad_type_changed: 處理手柄類型更改事件。 | #   - _on_agent_outfit_changed: 處理代理人皮膚更改事件。 | #   - _on_hdr_switch_changed: 處理HDR開關更改事件。 | #   - _on_launch_argument_switch_changed: 處理啟動參數開關更改事件。 |  | # 重要功能點 | # - 代理人皮膚選擇 | # - 遊戲基礎設置 (輸入方式) | # - 啟動參數設置 (窗口尺寸, 全屏, 無邊框窗口, 顯示器) | # - 按鍵綁定 | # - 手柄按鍵綁定 (Xbox, DS4) | # - HDR 開關 | # - 啟動參數開關 | ```
        │           ├── setting_yolo_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `SettingYoloInterface` 类，用于在 GUI 中显示和管理 YOLO 模型相关的设置。它允许用户选择和下载不同的 YOLO 模型，并配置 GPU 运算选项。同时，它还包含一个日志显示区域，用于显示模型下载和配置过程中的日志信息。 |  | **核心类和函数:** |  | *   `SettingYoloInterface`: 继承自 `VerticalScrollInterface`，是主界面，用于展示 YOLO 模型的设置选项。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，接收一个 `ZContext` 对象。 |     *   `get_content_widget(self) -> QWidget`: 构建界面内容，包括模型设置组和日志组。 |     *   `_init_model_group(self) -> SettingCardGroup`: 初始化模型设置组，包含模型下载和 GPU 运算选项。 |     *   `_init_log_group(self) -> SettingCardGroup`: 初始化日志组，包含日志显示卡片。 |     *   `on_interface_shown(self) -> None`: 界面显示时初始化配置和启动日志。 |     *   `on_interface_hidden(self) -> None`: 界面隐藏时停止日志。 |     *   `_init_flash_classifier_opts(self) -> None`: 初始化闪光识别模型选项。 |     *   `_init_hollow_zero_event_opts(self) -> None`: 初始化空洞格子识别模型选项。 |     *   `_init_lost_void_det_opts(self) -> None`: 初始化迷失之地识别模型选项。 |     *   `_on_flash_classifier_changed(self, index: int, value: str) -> None`: 闪光识别模型选项改变时的处理函数。 |     *   `_on_hollow_zero_event_changed(self, index: int, value: str) -> None`: 空洞格子识别模型选项改变时的处理函数。 |     *   `_on_lost_void_det_changed(self, index: int, value: str) -> None`: 迷失之地识别模型选项改变时的处理函数。 | *   `ZContext`: 上下文对象，用于访问配置信息
        │           └── zzz_setting_instance_interface.py    這個 Python 文件的摘要如下： |  | *   **主要功能：** 該文件定義了 `ZSettingInstanceInterface` 類，它繼承自 `SettingInstanceInterface`，用於在 GUI 中處理設置相關的界面。 | *   **核心類和函數：** |     *   `ZSettingInstanceInterface`: 繼承自 `SettingInstanceInterface`，用於處理設置界面的實例。 |     *   `__init__(self, ctx: OneDragonContext, parent=None)`: 構造函數，初始化 `ZSettingInstanceInterface` 實例，接收 `OneDragonContext` 實例和可選的父級部件。 | *   **重要功能點：** |     *   初始化時接收 `OneDragonContext` 實例，並將其保存為 `ctx` 屬性。 |     *   調用父類 `SettingInstanceInterface` 的構造函數進行初始化。
        ├── hollow_zero/
        │   ├── hollow_battle.py    ```python | 文件摘要： |  | 该文件定义了 `HollowBattle` 类，用于处理《崩坏：星穹铁道》游戏中的零号空洞战斗流程自动化。它继承自 `ZOperation`，并使用状态机模式来控制战斗的各个阶段，包括加载自动战斗指令、等待战斗画面加载、识别特殊移动、移动到战斗位置、自动战斗、处理战斗结果（结算、更新楼层信息、撤退等）以及退出战斗。 |  | 核心类和函数： |  | *   `HollowBattle` 类：核心类，负责控制零号空洞战斗的整个流程。 |     *   `__init__(self, ctx: ZContext, is_critical_stage: bool = False)`: 初始化函数，设置战斗状态和相关参数。 |     *   `load_auto_op()`: 加载自动战斗指令。 |     *   `wait_battle_screen()`: 等待战斗画面加载。 |     *   `check_special_move()`: 识别是否需要特殊移动。 |     *   `special_move()`: 执行特殊移动。 |     *   `move_to_battle()`: 移动到战斗位置。 |     *   `auto_battle()`: 执行自动战斗。 |     *   `period_reward_full()`: 处理结算周期上限。 |     *   `after_battle()`: 处理战斗结果，点击确定按钮。 |     *   `mission_complete()`: 处理普通战斗完成。 |     *   `update_level_info()`: 更新楼层信息。 |     *   `battle_fail()`: 处理战斗失败，点击撤退。 |     *   `move_fail()`: 处理移动失败，尝试退出战斗。 |     *   `click_exit()`: 点击退出战斗。 |     *   `click_exit_confirm()`: 确认退出战斗。 |     *   `wait_exit()`: 等待退出战斗完成。 |     *   `check_distance_to_move(self, screen: MatLike)`: 检查移动距离。 |     *   `_on_pause(self, e=None)`: 暂停时停止自动战斗。 |     *   `_on_resume(self, e=None)`: 恢复时恢复自动战斗。 |     *   `after_operation
        │   ├── hollow_exit_by_menu.py    這個 Python 腳本 `hollow_exit_by_menu.py` 實現了在遊戲中通過菜單離開空洞的功能。 |  | *   **主要功能:** 讓角色通過點擊菜單上的按鈕，離開零號空洞。 | *   **核心類:** `HollowExitByMenu` 繼承自 `ZOperation`，負責執行離開空洞的操作。 | *   **重要功能點:** |     *   `click_menu`: 點擊菜單按鈕，如果成功，則等待；否則重試。 |     *   `click_leave`: 點擊「離開」按鈕。 |     *   `confirm_leave`: 確認離開。 |     *   `click_finish`: 點擊「完成」按鈕，直到返回街區。 |     *   使用 `operation_node` 和 `node_from` 裝飾器定義操作流程和節點之間的依賴關係。 |     *   使用 `round_by_find_area` 和 `round_by_click_area` 等方法來進行屏幕截圖、區域查找和點擊操作。
        │   ├── hollow_level_info.py    這個 Python 文件定義了一個名為 `HollowLevelInfo` 的類，用於儲存和管理與遊戲或應用程序中的空心關卡相關的信息。 |  | *   **核心類:** `HollowLevelInfo` | *   **核心函數:** |     *   `__init__`: 初始化 `HollowLevelInfo` 實例，設置任務類型名稱、任務名稱、關卡和階段。 |     *   `is_mission_type`: 檢查給定的任務類型名稱和關卡是否與當前實例匹配。 |     *   `to_next_level`: 將關卡提升到下一級，並將階段重置為 1。 |     *   `to_next_phase`: 將階段提升到下一階段。 | *   **重要功能點:** |     *   儲存關卡相關信息 (任務類型、任務名稱、關卡、階段)。 |     *   提供方法來判斷是否為特定任務類型和關卡。 |     *   提供方法來推進關卡和階段。
        │   ├── hollow_runner.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 脚本 `hollow_runner.py` 实现了在游戏《崩坏：星穹铁道》中自动执行“零号空洞”活动的逻辑。它通过图像识别、事件处理和寻路算法，实现自动探索、战斗、处理事件和退出空洞的功能。 |  | **核心类和函数:** |  | *   **`HollowRunner(ZOperation)`**:  核心类，继承自 `ZOperation`，负责整个空洞活动的流程控制。 |     *   `check_screen()`:  核心函数，用于识别游戏画面，根据识别结果触发相应的事件处理或寻路操作。 |     *   `_handle_event(screen: MatLike, event_name: str)`:  处理识别到的事件，根据事件类型调用相应的处理程序。 |     *   `try_move_by_map(screen: MatLike, screen_time: float, current_map: HollowZeroMap)`:  根据地图信息进行自动寻路和移动。 |     *   `get_map_node_pos_to_click(screen: MatLike, node: HollowZeroMapNode)`:  获取地图上格子的点击位置，并避开可能出现的选项。 |     *   `exit_hollow()`: 离开空洞 |     *   `mission_complete()`: 完成任务 |  | **重要功能点:** |  | *   **图像识别:**  使用 `hollow_event_utils.check_screen()`  识别游戏画面中的事件和状态。 | *   **事件处理:**  根据识别到的事件，调用不同的事件处理程序 (例如 `CallForSupport`, `BambooMerchant`, `HollowBattle` 等)。 | *   **自动寻路:**  通过 `HollowZeroMap` 和相关服务实现自动寻路，并根据地图信息移动到目标位置。 | *   **地图交互:**  通过点击地图上的格子进行移动，并处理格子上的事件。 | *   **退出机制:**  在满足特定条件或完成任务后，通过菜单退出空洞。 | *   **额外任务处理:**  处理额外的任务，例如业绩考察点和周期性奖励。 | *   **调试功能:**  提供保存截图用于调试和优化模型的功能。
        │   ├── hollow_zero_challenge_config.py    ## 代码摘要 |  | 该Python文件定义了用于管理"Hollow Zero Challenge"配置的类和函数，这些配置基于YAML文件。 |  | **主要功能:** |  | *   加载、保存和管理Hollow Zero Challenge的配置。 | *   提供配置文件的创建、复制和更新功能。 | *   定义了配置项的属性，如自动战斗设置、优先购买物品、寻路方式等。 | *   提供获取所有配置实例和生成新配置文件名称的函数。 |  | **核心类和函数:** |  | *   **`HollowZeroChallengePathFinding(Enum)`:** 定义了寻路方式的枚举。 | *   **`HollowZeroChallengeConfig(YamlConfig)`:** 继承自`YamlConfig`，用于处理Hollow Zero Challenge的配置。 |     *   `__init__`: 初始化配置，设置子目录、是否为mock等。 |     *   `copy_new`: 复制配置并生成新的配置文件名。 |     *   `remove_sample`: 将配置文件标记为非sample。 |     *   `update_module_name`: 更新模块名称并保存配置。 |     *   `save`: 保存配置，处理旧文件删除和文件路径更新。 |     *   `auto_battle`, `resonium_priority`, `event_priority`, `target_agents`, `path_finding`, `go_in_1_step`, `waypoint`, `avoid`, `buy_only_priority`:  定义了配置项的getter和setter方法，用于访问和修改配置。 | *   **`get_all_hollow_zero_challenge_config(with_sample: bool = True)`:**  从配置文件目录加载所有HollowZeroChallengeConfig实例。 | *   **`get_hollow_zero_challenge_new_name()`:**  生成新的配置文件名。 |  | **重要功能点:** |  | *   支持多种寻路方式。 | *   可以设置自动战斗模式。 | *   可以设置共鸣优先购买列表。 | *   可以设置事件优先级。 | *   可以设置目标代理。 | *   可以设置途经点和避免点。 | *   支持只购买优先级中的物品。 | *   提供复制、重命名和删除旧配置文件的功能。
        │   ├── hollow_zero_data_service.py    **摘要:** |  | 该 Python 文件定义了一个 `HallowZeroDataService` 类，用于管理和处理空零游戏的数据，包括事件、入口和鸣徽信息。它从 YAML 文件中加载数据，并提供各种方法来检索、匹配和验证这些数据。 |  | **核心类和函数:** |  | *   **`HallowZeroDataService`**:  主要的数据服务类，负责加载和管理游戏数据。 |     *   `reload()`: 重新加载所有数据。 |     *   `_load_normal_events()`: 加载普通事件。 |     *   `get_normal_event_by_name(event_name: str)`: 通过名称获取事件。 |     *   `_load_entry_list()`: 加载入口列表。 |     *   `get_entry_by_name(entry_name: str)`: 通过名称获取入口。 |     *   `_load_resonium()`: 加载鸣徽数据。 |     *   `match_resonium_by_ocr(cate_ocr: str, name_ocr: str)`:  通过 OCR 识别的类别和名称匹配鸣徽。 |     *   `match_resonium_by_ocr_full(name_full_str: str)`: 通过完整的 OCR 文本匹配鸣徽。 |     *   `check_resonium_priority(input_str: str)`: 校验鸣徽优先级输入。 |     *   `check_entry_list_input(input_str: str)`: 校验入口列表输入。 |     *   `get_default_go_in_1_step_entry_list()`: 获取默认的一步可达入口列表。 |     *   `get_only_boss_go_in_1_step_entry_list()`: 获取速通模式的一步可达入口列表。 |     *   `get_default_waypoint_entry_list()`: 获取默认的途径点入口列表。 |     *   `get_only_boss_waypoint_entry_list()`: 获取速通模式的途径点入口列表。 |     *   `get_default_avoid_entry_list()`: 获取默认的避免途经点入口列表。 |     *   `get_no_battle_list()`: 获取不包含战斗的
        │   ├── event/
        │   │   ├── bamboo_merchant.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个名为 `BambooMerchant` 的类，用于在游戏“零号空洞”中与邦布商人交互，主要功能是识别商店界面，并尝试购买鸣徽或进行催化。 |  | **核心类和函数:** |  | *   **`BambooMerchant(ZOperation)`:**  继承自 `ZOperation` 类，是处理邦布商人逻辑的核心类。 |     *   `check_screen()`:  识别当前屏幕状态，判断是否进入商店、是否为鸣徽交易或催化界面，并根据识别结果返回不同的状态。 |     *   `choose_buy()`:  在第一层界面选择“鸣徽交易”或“特价折扣”。 |     *   `choose_item()`:  选择要购买的鸣徽，通过 OCR 识别商品描述和价格，并根据配置的优先级选择。 |     *   `buy()`:  点击购买按钮。 |     *   `confirm()`:  确认购买。 |     *   `upgrade_resonium()`:  处理鸣徽催化逻辑。 |     *   `back()`:  返回上一级界面。 |     *   `_ocr_price_area(screen: MatLike)`:  使用 OCR 识别商品价格区域。 |     *   `_ocr_desc_area(screen: MatLike)`:  使用 OCR 识别商品描述区域。 |  | **重要功能点:** |  | *   **屏幕识别:** 使用 OCR 技术识别屏幕上的文本，判断当前界面状态。 | *   **商品选择:**  根据 OCR 结果，结合配置的鸣徽优先级，选择要购买的商品。 | *   **流程控制:**  通过状态转换和节点连接，控制操作流程。 | *   **错误处理:**  通过 `round_retry` 和 `round_wait` 处理可能的错误和等待。 | *   **OCR 辅助:** 提供了 `_ocr_price_area` 和 `_ocr_desc_area` 函数，用于从屏幕截图中提取商品信息。 | *   **调试:** 包含一个 `__debug_check_screen` 函数，用于调试和测试屏幕识别。
        │   │   ├── call_for_support.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了 `CallForSupport` 类，用于处理游戏《零号空洞》中的“呼叫支援”事件。它通过 OCR 识别屏幕上的文本，判断是否需要支援，并根据当前队伍和目标队伍配置，选择合适的支援角色和位置。 |  | **核心类和函数:** |  | *   **`CallForSupport(ZOperation)`**:  继承自 `ZOperation`，是处理“呼叫支援”事件的核心类。 |     *   `check_screen()`:  识别屏幕，触发事件处理流程。 |     *   `check_team()`:  判断当前队伍，决定是否需要支援。 |     *   `_get_support_agent(screen)`:  从屏幕上识别支援角色。 |     *   `_best_match_agent(ocr_result)`:  根据 OCR 结果匹配支援角色。 |     *   `_should_call_backup(agent_list, new_agent)`:  判断是否应该呼叫支援，并确定位置。 |     *   `accept_backup()`:  接受支援。 |     *   `choose_pos()`:  选择支援角色位置。 |     *   `confirm()`:  确认支援。 |     *   `reject_agent()`:  拒绝支援。 |  | *   **`RejectOption`**:  定义拒绝支援的选项，包含关键词和相似度阈值。 |  | **重要功能点:** |  | *   **事件识别**:  通过 OCR 识别屏幕上的文本，判断是否触发“呼叫支援”事件。 | *   **角色识别**:  从屏幕上识别支援角色的名称。 | *   **队伍配置判断**:  根据当前队伍和目标队伍配置，决定是否需要支援，以及支援角色的位置。 | *   **自动化操作**:  自动接受支援、选择位置、确认支援或拒绝支援。 | *   **调试功能**:  包含多个调试函数 (`__debug`, `__debug_support_agent`, `__debug_current_agent`, `__debug_check_screen`) 用于测试和开发。
        │   │   ├── choose_resonium.py    這段代碼實現了在遊戲中選擇鳴徽的功能。 |  | 主要功能： |  | *   選擇鳴徽：根據優先級選擇鳴徽，並點擊選擇。 | *   兜底選擇：如果選擇失敗，則隨機選擇一個鳴徽。 |  | 核心類和函數： |  | *   `ChooseResonium`：繼承自 `ZOperation`，負責選擇鳴徽的操作。 |     *   `choose_one()`：選擇鳴徽的主要邏輯，包括截圖、獲取可選列表、根據優先級選擇、點擊選擇。 |     *   `choose_default()`：兜底選擇邏輯，如果 `choose_one` 失敗，則隨機選擇一個。 | *   `ZContext`：遊戲上下文，包含遊戲狀態和控制相關的信息。 | *   `resonium_utils.get_to_choose_list()`：獲取可選鳴徽列表。 | *   `resonium_utils.choose_resonium_by_priority()`：根據優先級選擇鳴徽。 |  | 重要功能點： |  | *   優先級選擇：根據配置的優先級選擇鳴徽。 | *   錯誤處理：如果沒有可選的鳴徽或優先級匹配失敗，則重試或兜底選擇。 | *   屏幕截圖和 OCR：用於獲取遊戲畫面信息和識別文字。 | *   點擊操作：用於點擊選擇的鳴徽。
        │   │   ├── confirm_resonium.py    這個 Python 文件的主要功能是處理遊戲中「確認鳴徽」事件的操作。 |  | 核心類和函數： |  | *   **ConfirmResonium**: 繼承自 `ZOperation`，負責處理確認鳴徽事件的邏輯。 |     *   `__init__(self, ctx: ZContext)`: 構造函數，初始化操作名稱。 |     *   `choose_one(self) -> OperationRoundResult`: 核心函數，使用 OCR 和點擊操作來選擇鳴徽。 |  | 重要功能點： |  | *   使用 OCR 識別屏幕上的文本（"確認" 或 "確定"）。 | *   根據 OCR 結果，在指定的區域內進行點擊操作。 | *   根據操作結果返回成功、重試或失敗狀態。
        │   │   ├── critical_stage.py    這個 Python 文件的主要功能是處理《空洞零》遊戲中的關鍵進展事件。它通過識別屏幕上的文本來觸發事件，然後執行自動戰鬥，並在戰鬥完成後增加通關次數。 |  | 核心類和函數： |  | *   **CriticalStage**: 繼承自 `ZOperation`，負責處理關鍵進展事件的邏輯。 |     *   `__init__`: 初始化，設置事件處理器。 |     *   `check_screen`: 識別屏幕上的文本，判斷是否觸發事件。 |     *   `load_auto_op`: 執行自動戰鬥。 |     *   `add_times`: 增加通關次數。 |  | 重要功能點： |  | *   使用 `EventOcrResultHandler` 處理事件文本識別。 | *   觸發自動戰鬥 (`HollowBattle`)。 | *   更新遊戲記錄 (增加通關次數)。 | *   使用裝飾器 `@operation_node` 和 `@node_from` 定義操作流程和節點之間的依賴關係。
        │   │   ├── door_battle.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件定義了處理《空洞零》遊戲中「門扉禁閉-善戰」事件的邏輯。它負責識別遊戲畫面中的事件文本，並根據識別結果執行相應的操作。 |  | **核心類和函數：** |  | *   **`DoorBattle(ZOperation)`:** 繼承自 `ZOperation`，是處理「門扉禁閉-善戰」事件的主要類。 |     *   `__init__(self, ctx: ZContext)`: 初始化函數，設置事件名稱和 OCR 處理器。 |     *   `check_screen(self) -> OperationRoundResult`: 使用截圖和 OCR 處理器來識別屏幕上的事件文本，並執行相應的操作。 |  | *   **`EventOcrResultHandler`:** 處理 OCR 識別結果的類，用於匹配事件文本並執行操作。 |  | **重要功能點：** |  | *   **事件處理流程：** 該文件定義了事件處理的流程，包括截圖、OCR 文本識別和根據識別結果執行操作。 | *   **OCR 處理器：** 使用 `EventOcrResultHandler` 來處理 OCR 識別結果，匹配事件文本並執行操作。 | *   **兼容性：** 包含對「門扉禁閉-侵蝕」事件的兼容處理，以應對識別錯誤的情況。
        │   │   ├── drop_resonium.py    這個 Python 文件定義了在遊戲中丟棄鳴徽的操作。 |  | *   **主要功能:** 模擬玩家在零號空洞事件中丟棄鳴徽的行為，包括選擇和確認丟棄。 | *   **核心類和函數:** |     *   `DropResoniumBase`: 基礎類，包含丟棄鳴徽的邏輯。 |         *   `choose_one()`: 選擇要丟棄的鳴徽。 |         *   `choose_default()`: 兜底選擇，如果選擇失敗則隨機選擇一個。 |     *   `DropResonium`: 繼承自 `DropResoniumBase`，用於丟棄鳴徽。 |     *   `DropResonium2`: 繼承自 `DropResoniumBase`，用於抵押欠款。 | *   **重要功能點:** |     *   使用 OCR 識別屏幕上的選項。 |     *   根據優先級選擇要丟棄的鳴徽。 |     *   處理選擇失敗的情況，提供兜底方案。 |     *   與遊戲控制器交互，執行點擊操作。
        │   │   ├── event_ocr_result_handler.py    這個 Python 文件定義了一個名為 `EventOcrResultHandler` 的類，用於處理 OCR 結果。 |  | *   **主要功能:** 封裝 OCR 結果處理邏輯，包括目標文本、匹配閾值、處理方法、點擊行為等。 | *   **核心類:** `EventOcrResultHandler` | *   **重要功能點:** |     *   `__init__`: 類的構造函數，初始化 OCR 結果處理器的各個屬性，包括目標文本 (`target_cn`)、匹配閾值 (`lcs_percent`)、處理方法 (`method`)、點擊行為 (`click_result`, `click_wait`) 和事件標記 (`is_event_mark`)。 |     *   `target_cn`: 待匹配的中文文本。 |     *   `lcs_percent`: 文本匹配的相似度閾值。 |     *   `method`: 處理 OCR 結果的回調函數。 |     *   `click_result`: 是否點擊 OCR 結果。 |     *   `click_wait`: 點擊後的等待時間。 |     *   `is_event_mark`: 是否為事件標記。 |     *   `status`: 狀態標識。
        │   │   ├── full_in_bag.py    這個 Python 文件的主要功能是處理在遊戲中背包已滿的事件。 |  | 核心類和函數： |  | *   **FullInBag**: 繼承自 `ZOperation`，負責處理背包已滿的事件。 |     *   `__init__`: 初始化操作，設置操作名稱。 |     *   `drop`: 核心功能，嘗試通過 OCR 識別屏幕上的 "丢弃" 按鈕並點擊，以處理背包已滿的情況。 | *   `__debug`: 是一個用於調試的函數，模擬遊戲環境，初始化上下文，並調用 `drop` 方法。 |  | 重要功能點： |  | *   使用 OCR 技術識別屏幕上的 "丢弃" 按鈕。 | *   點擊 "丢弃" 按鈕以處理背包已滿的事件。 | *   包含調試功能，方便開發和測試。
        │   │   ├── hollow_event_utils.py    ## 摘要 |  | 這個 Python 文件定義了用於處理零號空洞事件的工具函數，主要用於識別和響應遊戲中的事件。 |  | **核心類和函數:** |  | *   `check_event_at_right(ctx, screen, ignore_events)`: 識別右側區域的事件名稱。 | *   `check_entry_opt_at_right(ctx, screen, ignore_events)`: 識別右側區域的事件入口選項。 | *   `check_event_text_and_run(op, screen, handlers)`: 識別事件文本並根據處理程序執行相應的操作。 | *   `click_empty(op, bottom_opt_pos)`: 點擊空白區域，用於兜底操作。 | *   `check_screen(ctx, screen, ignore_events)`: 識別當前屏幕的狀態，包括事件、選項、對話框等。 | *   `get_special_event_by_name(event_name)`: 根據事件名稱獲取特殊事件。 | *   `check_battle_screen(ctx, screen)`: 判斷是否在戰鬥畫面 | *   `check_mission_complete(ctx, screen)`: 判斷是否通關 | *   `check_in_hollow(ctx, screen)`: 判斷是否在空洞內 | *   `check_old_capital(ctx, screen)`: 判斷是否在舊都失物 | *   `check_interact(ctx, screen)`: 判斷是否可以交互 |  | **重要功能點:** |  | *   **事件識別:** 使用 OCR 識別事件文本和選項。 | *   **事件處理:** 根據識別結果，執行相應的操作，例如點擊按鈕。 | *   **屏幕狀態檢測:** 檢測遊戲屏幕的各種狀態，例如戰鬥、任務完成、背包已滿等。 | *   **特殊事件處理:** 處理特定的遊戲事件，例如鳴徽選擇、催化等。 | *   **兜底機制:** 在無法匹配到特定事件時，提供兜底的點擊操作。 | *   **使用 `EventOcrResultHandler` 處理事件。**
        │   │   ├── hollow_interact.py    這個 Python 文件的摘要如下： |  | *   **主要功能:** 處理空洞零事件中的交互操作。 | *   **核心類和函數:** |     *   `HollowInteract`: 繼承自 `ZOperation`，負責處理交互邏輯。 |     *   `interact(self) -> OperationRoundResult`:  `HollowInteract` 類中的主要方法，模擬遊戲中的交互操作，例如按壓按鈕。 | *   **重要功能點:** |     *   使用 `operation_node` 裝飾器標記 `interact` 方法，表明其為操作節點，且是起始節點。 |     *   `interact` 方法通過調用 `self.ctx.controller.interact()` 來模擬交互，並設定按壓和釋放的時間。 |     *   `round_success(wait=1)` 表示交互成功，並等待 1 秒。
        │   │   ├── leave_random_zone.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了一個名為 `LeaveRandomZone` 的操作，用於處理在遊戲中離開隨機區域的事件。它通過屏幕識別、交互和重試機制來實現。 |  | **核心類和函數:** |  | *   `LeaveRandomZone`: 繼承自 `ZOperation`，負責處理離開隨機區域的邏輯。 |     *   `check_screen()`: 核心函數，用於檢查屏幕，識別事件，並執行相應的操作，例如交互。 |  | **重要功能點:** |  | *   使用 `operation_node` 裝飾器定義操作流程的節點。 | *   使用屏幕截圖和圖像識別來檢測遊戲畫面。 | *   根據識別結果，執行交互操作（例如點擊）。 | *   處理成功、等待和重試狀態。 | *   使用 `hollow_event_utils.check_screen` 檢查特殊區域事件。
        │   │   ├── normal_event_handler.py    這個 Python 文件定義了 `NormalEventHandler` 類，用於處理空洞零事件。 |  | **主要功能:** |  | *   處理空洞零遊戲中的常規事件，通過屏幕識別和 OCR 來觸發相應的操作。 |  | **核心類和函數:** |  | *   `NormalEventHandler`: 繼承自 `ZOperation`，負責處理事件邏輯。 |     *   `__init__(self, ctx: ZContext, event: HallowZeroEvent)`: 初始化事件處理器，根據事件配置創建 `EventOcrResultHandler` 列表。 |     *   `check_screen(self) -> OperationRoundResult`: 截取屏幕截圖，並使用 `hollow_event_utils.check_event_text_and_run` 進行 OCR 識別和操作。 | *   `EventOcrResultHandler`: 處理 OCR 結果的類，用於匹配屏幕上的文本。 | *   `__debug_opts()`: 是一個用於調試的函數，模擬事件處理流程。 |  | **重要功能點:** |  | *   使用 OCR 識別屏幕上的文本，以觸發事件。 | *   根據事件配置，創建多個 `EventOcrResultHandler` 進行匹配。 | *   `check_screen` 方法是事件處理的核心，它截取屏幕截圖並觸發 OCR 識別。 | *   `__debug_opts` 函數提供了一個調試環境，方便測試和驗證事件處理邏輯。
        │   │   ├── old_capital.py    這個 Python 腳本定義了一個名為 `OldCapital` 的類，它繼承自 `ZOperation`。 |  | *   **主要功能:** 處理遊戲中與舊都失物相關的事件，允許玩家選擇返回。 | *   **核心類和函數:** |     *   `OldCapital`: 繼承自 `ZOperation`，負責處理舊都失物事件。 |     *   `__init__(self, ctx: ZContext)`: 構造函數，初始化事件名稱。 |     *   `choose_one(self) -> OperationRoundResult`: 是一個操作節點，用於截圖、查找並點擊 "旧都失物-返回" 按鈕，以返回到事件畫面。 | *   **重要功能點:** |     *   使用 `operation_node` 裝飾器標記 `choose_one` 作為操作節點，並將其標記為起始節點。 |     *   使用 `round_by_find_and_click_area` 函數來執行查找和點擊操作。
        │   │   ├── remove_corruption.py    這個 Python 文件定義了一個名為 `RemoveCorruption` 的類，它繼承自 `ZOperation`，用於處理遊戲中清除侵蝕症狀的事件。 |  | *   **主要功能:** 執行遊戲中清除侵蝕症狀的操作。 | *   **核心類和函數:** |     *   `RemoveCorruption`: 繼承自 `ZOperation`，負責清除侵蝕症狀。 |     *   `choose_one()`: 使用 OCR 和點擊操作，在屏幕上選擇並清除侵蝕症狀。 | *   **重要功能點:** |     *   使用 `operation_node` 裝飾器標記 `choose_one` 方法為操作節點，並將其設置為起始節點。 |     *   使用 OCR 識別屏幕上的文本，並根據識別結果進行點擊操作。 |     *   使用 `round_by_ocr_and_click` 方法執行 OCR 識別和點擊操作，並處理結果。
        │   │   ├── resonium_utils.py    此 Python 文件 `resonium_utils.py` 提供了用于处理《零号空洞》游戏中鸣徽相关逻辑的工具函数。 |  | *   **主要功能:** 识别屏幕上的鸣徽，并根据优先级选择鸣徽。 | *   **核心函数:** |     *   `get_to_choose_list(ctx: ZContext, screen: MatLike, target_cn: str, target_lcs_percent: float = 1) -> List[MatchResult]`:  识别屏幕上的鸣徽，返回匹配的鸣徽及其位置信息。 |     *   `choose_resonium_by_priority(item_list: List[Resonium], priority_list: List[str], only_priority: bool = False)`: 根据优先级列表从鸣徽列表中选择鸣徽，并返回其索引列表。 | *   **重要功能点:** |     *   使用 OCR 技术识别鸣徽名称。 |     *   基于最长公共子序列 (LCS) 算法进行字符串匹配。 |     *   支持根据优先级列表选择鸣徽，并可选择仅保留优先级匹配的结果。 |     *   `MatchResult` 用于存储匹配结果，包含鸣徽位置和数据。 |     *   依赖于 `ZContext` 上下文，`Resonium` 数据结构，以及其他工具函数如 `cv2_utils` 和 `str_utils`。
        │   │   ├── swift_supply.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件定義了一個名為 `SwiftSupply` 的操作，用於處理遊戲中“及时补给”事件。它主要負責在選擇獎勵的畫面中選擇一個選項。 |  | **核心類和函數：** |  | *   `SwiftSupply`：繼承自 `ZOperation`，代表“及时补给”事件的操作。 |     *   `__init__(self, ctx: ZContext)`：初始化函數，設置操作名稱。 |     *   `choose_one(self) -> OperationRoundResult`：使用 OCR 識別並點擊“降低压力值”選項。 |  | **重要功能點：** |  | *   使用 OCR 技術從屏幕截圖中識別文本。 | *   根據識別結果，在指定區域內進行點擊操作。 | *   包含重試機制，以確保操作成功。
        │   │   ├── switch_resonium.py    這個 Python 腳本 `switch_resonium.py` 實現了在遊戲中交換鳴徽的功能。 |  | **主要功能:** |  | *   選擇並交換鳴徽。 |  | **核心類和函數:** |  | *   `SwitchResonium(ZOperation)`:  繼承自 `ZOperation`，負責執行交換鳴徽的操作。 |     *   `choose_one()`:  選擇鳴徽，基於優先級和屏幕截圖識別。 |     *   `choose_default()`:  兜底選擇，如果 `choose_one()` 失敗，則隨機選擇一個。 | *   `__debug()`:  用於測試和調試，初始化上下文並執行操作。 |  | **重要功能點:** |  | *   使用屏幕截圖和 OCR 識別可選的鳴徽。 | *   根據配置的優先級選擇鳴徽。 | *   提供兜底機制，以防識別失敗。 | *   使用 `operation_node` 和 `node_from` 裝飾器定義操作流程和節點之間的關係。 | *   使用 `round_retry` 和 `round_by_click_area` 處理操作結果和重試邏輯。
        │   │   └── upgrade_resonium.py    這個 Python 腳本 `upgrade_resonium.py` 實現了在遊戲中升級共鳴徽章（Resonium）的自動化操作。 |  | *   **主要功能:** 選擇並升級共鳴徽章。 | *   **核心類和函數:** |     *   `UpgradeResonium`: 繼承自 `ZOperation`，負責整個升級流程。 |     *   `choose_one()`: 選擇一個共鳴徽章。 |     *   `choose_default()`: 兜底選擇，如果 `choose_one()` 失敗則執行。 | *   **重要功能點:** |     *   使用 `resonium_utils` 模塊來獲取可選擇的共鳴徽章列表並根據優先級進行選擇。 |     *   使用屏幕截圖和 OCR 識別來定位和點擊 UI 元素。 |     *   包含重試機制，以處理識別失敗的情況。 |     *   使用 `operation_node` 和 `node_from` 裝飾器來定義操作流程和節點之間的關係。
        │   ├── game_data/
        │   │   ├── hollow_zero_event.py    這個 Python 文件定義了用於空洞零遊戲的事件相關的數據結構。 |  | *   **主要功能:** 定義了遊戲中事件的結構，包括事件的類型、選項和屬性。 | *   **核心類和函數:** |     *   `HollowZeroEntry`: 表示地圖上的入口點，包含入口的名稱、類型、是否可通行等屬性。 |     *   `HallowZeroNormalEventOption`: 表示事件的選項，包含選項的名稱、描述、等待時間和 OCR 關鍵字等。 |     *   `HallowZeroEvent`: 表示遊戲中的事件，包含事件名稱、選項列表、是否在右側顯示等屬性。 |     *   `HollowZeroSpecialEvent (Enum)`:  定義了特定類型的事件，使用 `Enum` 方便管理和引用。 | *   **重要功能點:** |     *   定義了不同類型的事件，例如商店、戰鬥、副本通關等。 |     *   每個事件可以有多個選項，每個選項都有自己的屬性。 |     *   `HollowZeroEntry` 類用於表示地圖上的入口，並包含一些重要的屬性，例如是否為傳送點，是否可通行等。 |     *   `HollowZeroEvent` 類中的 `is_entry_opt` 標記用於標識進入格子的選項。
        │   │   └── hollow_zero_resonium.py    這個 Python 文件定義了一個名為 `Resonium` 的類，用於表示遊戲中的 Resonium 資源。 |  | *   **核心類:** `Resonium` | *   **核心函數:** `__init__` (構造函數，初始化 Resonium 實例的屬性) | *   **重要功能點:** |     *   `Resonium` 類用於儲存 Resonium 資源的資訊，包括 `category` (類別), `name` (名稱), 和 `level` (等級)。
        │   └── hollow_map/
        │       ├── hollow_map_utils.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了用于构建和处理空洞零地图的工具函数。它主要负责从 YOLO 识别结果构建地图，合并地图，判断地图和节点是否相同，以及获取节点在地图中的索引。 |  | **核心类和函数:** |  | *   `construct_map_from_yolo_result(ctx, detect_result, name_2_entry)`:  从 YOLO 识别结果构建地图。 | *   `construct_map_from_nodes(ctx, nodes, check_time)`:  从节点列表构建地图。 | *   `is_same_map(map_1, map_2)`:  判断两个地图是否相同。 | *   `merge_map(ctx, map_list)`:  合并多个地图。 | *   `is_same_node_pos(x, y)`:  判断两个节点的坐标是否一致。 | *   `is_same_node(x, y)`:  判断两个节点是否是同一个节点。 | *   `get_node_index(current_map, node)`: 获取节点在地图上的下标。 | *   `_at_left`, `_at_right`, `_above`, `_under`:  判断节点之间的相对位置关系。 | *   `_is_same_row`, `_is_same_col`:  判断节点是否在同一行或同一列。 | *   `_add_edge`, `_add_directed_edge`:  添加边到地图的邻接表中。 |  | **重要功能点:** |  | *   从 YOLO 检测结果中提取节点信息，并根据节点类型和位置构建地图。 | *   处理节点合并逻辑，包括底座和格子的合并，以及根据置信度和时间戳更新节点信息。 | *   判断地图和节点是否相同，用于地图的比较和去重。 | *   合并多个地图，用于整合不同时间或不同视角下的地图信息。 | *   构建地图的邻接表，用于表示节点之间的连接关系。 | *   处理“当前”节点，确保地图中只有一个“当前”节点，并处理移动失败的情况。
        │       ├── hollow_pathfinding.py    代码摘要： |  | 该 Python 文件实现了空洞零地图的寻路功能，主要用于计算地图上节点之间的最短路径，并提供了一些辅助函数来获取特定类型的路径。 |  | 核心类和函数： |  | *   `search_map(current_map, avoid_entry_list, visited_nodes)`:  对地图进行广度优先搜索，计算从当前节点到其他节点的最短路径，并避开指定节点。 | *   `_bfs_search_map(current_map, start_idx_list, avoid_entry_list, visited_nodes)`:  使用广度优先搜索算法计算最短路径。 | *   `get_route_in_1_step(current_map, visited_nodes, target_entry_list)`:  获取一步可到达的节点路径。 | *   `get_route_by_entry(current_map, entry_name, visited_nodes)`:  获取到达特定类型格子的最短路径。 | *   `get_route_by_direction(current_map, direction)`:  获取符合特定方向的最远路径。 | *   `had_been_visited(current, visited_nodes)`:  判断节点是否已经访问过。 | *   `draw_map(screen, current_map, next_node, to_click)`:  在图像上绘制地图，包括节点、边和路径信息。 |  | 重要功能点： |  | *   使用广度优先搜索算法计算地图上节点之间的最短路径。 | *   支持避开特定节点进行寻路。 | *   提供获取一步可达路径、到达特定类型格子路径、以及特定方向最远路径的函数。 | *   通过 `visited_nodes` 避免重复访问节点。 | *   提供地图可视化功能，用于调试和展示寻路结果。
        │       ├── hollow_zero_map.py    此文件定义了用于处理空零地图的类和相关数据结构。 |  | **主要功能:** |  | *   表示空零地图的节点和地图本身，包含寻路信息。 | *   提供地图有效性检查、节点搜索等功能。 |  | **核心类和函数:** |  | *   **HollowZeroMapNode:** |     *   `__init__`: 初始化节点，包含位置、入口信息、访问次数、寻路相关信息（路径上的第一个节点、需要步数的节点、步数等）。 |     *   `gt_max_visited_times`: 检查访问次数是否超过限制。 |     *   `next_node_to_move`: 获取下一个要移动的节点。 | *   **HollowZeroMap:** |     *   `__init__`: 初始化地图，包含节点列表、当前索引、边信息、识别时间。 |     *   `is_valid_map`: 检查地图是否有效。 |     *   `contains_entry`: 检查地图是否包含特定类型的入口。 |     *   `search_entry`: 搜索地图中是否存在特定入口。 |     *   `init_path_related`: 初始化所有节点的寻路相关信息。 |  | **重要功能点:** |  | *   寻路信息的存储和管理，包括路径上的第一个节点、步数等。 | *   地图有效性检查，用于判断地图是否可用。 | *   节点搜索，用于查找特定类型的入口。
        │       └── hollow_zero_map_service.py    這個 Python 腳本定義了一個 `HollowZeroMapService` 類，用於根據遊戲畫面計算空洞地圖。 |  | **主要功能:** |  | *   從遊戲畫面中識別空洞地圖，並可與過去的地圖結果合併。 | *   使用 YOLO 模型檢測遊戲畫面中的事件。 | *   提供清除地圖識別結果的功能。 |  | **核心類和函數:** |  | *   `HollowZeroMapService`: 負責處理空洞地圖的識別和管理。 |     *   `__init__(self, ctx: ZContext)`: 初始化服務，包括上下文、數據服務和事件模型。 |     *   `init_event_yolo(self) -> None`: 初始化 YOLO 事件檢測器。 |     *   `cal_current_map_by_screen(self, screen: MatLike, screenshot_time: float) -> Optional[HollowZeroMap]`: 根據當前畫面計算空洞地圖。 |     *   `cal_map_by_screen(self, screen: MatLike, screenshot_time: float) -> Optional[HollowZeroMap]`: 計算空洞地圖，並與過去的結果合併。 |     *   `clear_map_result(self) -> None`: 清除所有識別結果。 |  | **重要功能點:** |  | *   使用 YOLO 模型進行事件檢測，用於識別地圖元素。 | *   合併過去的地圖識別結果，以提高準確性。 | *   `cal_map_by_screen` 函數實現了地圖的識別和合併邏輯。 | *   `clear_map_result` 函數用於重置地圖識別狀態。 | *   包含一個 `__debug_cal_current_map_by_screen` 函數，用於調試和測試地圖識別功能。
        ├── operation/
        │   ├── back_to_normal_world.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个名为 `BackToNormalWorld` 的类，其主要功能是尝试将游戏画面导航回大世界。它通过识别游戏画面中的不同元素，如菜单、街区、对话框等，并执行相应的点击操作，以确保在任何情况下都能返回到游戏的大世界。 |  | **核心类和函数:** |  | *   **`BackToNormalWorld(ZContext)`**:  继承自 `ZOperation` 类，是该文件的核心类，负责执行返回大世界的操作。 |     *   `__init__(self, ctx: ZContext)`:  构造函数，初始化操作名称和上下文。 |     *   `check_screen_and_run(self, screen: Optional[MatLike] = None) -> OperationRoundResult`:  核心函数，用于识别游戏画面并执行相应的操作，尝试返回大世界。它包含了多个子函数调用，用于处理不同的游戏状态。 |     *   `_check_agent_dialog(self, screen: MatLike) -> bool`: 检查是否存在代理人好感度对话。 |     *   `_handle_agent_dialog(self, screen: MatLike) -> OperationRoundResult`: 处理代理人好感度对话。 |     *   `check_compendium(self, screen: MatLike) -> OperationRoundResult`: 检查是否在快捷手册中。 |  | **重要功能点:** |  | *   **画面识别和导航:**  使用 `round_by_goto_screen`, `round_by_find_area`, `round_by_find_and_click_area` 等函数，根据屏幕截图识别游戏画面中的元素，并执行点击操作。 | *   **处理各种游戏状态:**  能够处理多种游戏状态，包括： |     *   直接进入大世界 |     *   通过街区返回 |     *   通过菜单返回 |     *   处理对话框（例如空洞继续对话框） |     *   处理好感度对话 |     *   处理战斗画面 |     *   处理空洞内的撤退和完成 |     *   处理快捷手册 | *   **循环重试机制:**  使用 `round_retry` 和 `node_max_retry_times` 实现循环重试机制，以应对操作失败的情况。 | *   **调试功能:**
        │   ├── choose_predefined_team.py    這個 Python 腳本定義了一個名為 `ChoosePredefinedTeam` 的類，它繼承自 `ZOperation`，用於在遊戲中選擇預先定義的團隊。 |  | **主要功能:** |  | *   在遊戲的“出戰”畫面中，根據提供的索引列表選擇預先定義的團隊。 | *   通過圖像識別和點擊操作來導航遊戲界面。 | *   處理選擇失敗的情況，包括重試和滾動屏幕。 |  | **核心類和函數:** |  | *   `ChoosePredefinedTeam(ctx: ZContext, target_team_idx_list: List[int])`: 構造函數，初始化操作，接收 `ZContext` 和目標團隊索引列表。 | *   `check_screen()`: 檢查屏幕上是否出現“實戰模擬室”和“預備編隊”的標誌，作為操作的起點。 | *   `click_team()`: 點擊“預備編隊”按鈕。 | *   `choose_team()`: 選擇目標團隊。它使用 OCR 識別團隊名稱，並點擊相應的團隊。如果 OCR 失敗，則重試。 | *   `choose_team_fail()`: 處理選擇團隊失敗的情況，包括重試和滾動屏幕。 | *   `click_confirm()`: 點擊“預備出戰”按鈕確認選擇。 | *   `__debug()`: 是一個用於調試的函數，用於測試 OCR 功能。 |  | **重要功能點:** |  | *   使用 OCR 識別遊戲界面上的文本。 | *   使用 `difflib.get_close_matches` 找到與目標團隊名稱最匹配的 OCR 結果。 | *   處理選擇團隊失敗的情況，包括重試和滾動屏幕。 | *   使用 `operation_node` 和 `node_from` 裝飾器定義操作流程和節點之間的依賴關係。
        │   ├── deploy.py    這個 Python 腳本定義了一個名為 `Deploy` 的類，它繼承自 `ZOperation`，用於處理遊戲中的出戰操作。 |  | **主要功能：** |  | *   執行遊戲中的出戰流程，包括點擊出戰按鈕，處理可能出現的確認彈窗，並最終標記出戰成功。 |  | **核心類和函數：** |  | *   `Deploy` 類：繼承自 `ZOperation`，負責出戰流程的控制。 |     *   `__init__(self, ctx: ZContext)`：初始化函數，設置操作名稱。 |     *   `deploy(self) -> OperationRoundResult`：點擊出戰按鈕，嘗試出戰。 |     *   `check_level(self) -> OperationRoundResult`：處理出戰確認彈窗，例如隊員數量不足或等級過低的情況。 |     *   `finish(self) -> OperationRoundResult`：標記出戰成功。 | *   `ZContext`：上下文類，提供遊戲環境的相關信息。 | *   `ZOperation`：基類，提供操作相關的基礎功能。 | *   `operation_node`：裝飾器，用於定義操作節點。 | *   `node_from`：裝飾器，用於定義節點之間的依賴關係。 |  | **重要功能點：** |  | *   使用 `operation_node` 和 `node_from` 裝飾器定義了操作流程的節點和依賴關係，構建了流程的狀態機。 | *   使用 `round_by_find_and_click_area` 函數來查找並點擊屏幕上的特定區域。 | *   處理了出戰過程中可能出現的確認彈窗，例如隊員數量不足或等級過低的情況。 | *   `__debug()` 函數用於測試 `Deploy` 類的執行。
        │   ├── eat_noodle.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个名为 `EatNoodle` 的操作，用于在游戏中执行吃拉面的流程。它通过一系列步骤，包括传送、等待、移动交互、选择拉面、点单、确认、跳过和返回，来模拟吃拉面的过程。 |  | **核心类和函数:** |  | *   **`EatNoodle(ZOperation)`:**  继承自 `ZOperation`，是执行吃拉面流程的核心类。 |     *   `__init__(self, ctx: ZContext, noodle_name: str)`:  初始化函数，接收上下文 `ctx` 和拉面名称 `noodle_name`。 |     *   一系列以 `@operation_node` 装饰的函数，定义了吃拉面的各个步骤，如 `transport`, `wait_world`, `move_and_interact` 等。 |  | **重要功能点:** |  | *   **流程控制:** 使用 `@operation_node` 和 `@node_from` 装饰器定义了操作的流程，每个函数代表一个步骤，并指定了前后依赖关系。 | *   **交互操作:**  使用 `self.ctx.controller` 执行游戏中的移动、交互等操作。 | *   **图像识别:**  使用 `self.screenshot()` 和 `self.ctx.screen_loader` 进行屏幕截图和区域识别，用于判断界面状态和点击特定元素。 | *   **OCR:** 使用 `round_by_ocr_and_click` 函数进行 OCR 识别并点击。 | *   **错误处理和重试:** 使用 `round_by_op_result`, `round_success`, `round_retry` 等方法处理操作结果，并进行重试。 | *   **界面元素定位:** 使用 `round_by_find_area` 和 `round_by_find_and_click_area` 函数来定位和点击界面元素。
        │   ├── key_sim_runner.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件定義了一個 `KeySimRunner` 類，用於模擬按鍵操作。它從配置文件中加載按鍵操作，然後執行它們。 |  | **核心類和函數：** |  | *   `KeySimRunner`: 繼承自 `ZOperation`，負責按鍵模擬的流程控制。 |     *   `__init__(self, ctx: ZContext, config_name: str)`: 初始化 `KeySimRunner`，接收上下文和配置名稱。 |     *   `load_config(self) -> OperationRoundResult`: 從 YAML 配置文件中加載按鍵操作，並將其轉換為 `AtomicOp` 列表。 |     *   `run_key_sim(self) -> OperationRoundResult`: 執行加載的按鍵操作。 |  | **重要功能點：** |  | *   使用 `YamlConfig` 加載按鍵模擬的配置。 | *   使用 `utils.get_ops_from_data` 將配置數據轉換為 `AtomicOp` 列表。 | *   使用 `AutoBattleOperator` 獲取 `AtomicOp` 實例。 | *   使用 `@operation_node` 和 `@node_from` 裝飾器定義操作流程。 | *   `run_key_sim` 函數迭代執行 `AtomicOp` 列表中的操作。
        │   ├── open_menu.py    這個 Python 文件定義了一個名為 `OpenMenu` 的操作，用於在遊戲中打開菜單。 |  | **主要功能:** |  | *   識別遊戲畫面，判斷是否已在菜單頁面。 | *   如果不在菜單頁面，則嘗試返回大世界。 | *   在大世界畫面中，點擊菜單按鈕以打開菜單。 |  | **核心類和函數:** |  | *   `OpenMenu`: 繼承自 `ZOperation`，負責打開菜單的操作。 |     *   `__init__(self, ctx: ZContext)`: 初始化操作，設置操作名稱。 |     *   `check_menu(self) -> OperationRoundResult`: 識別畫面，判斷是否在菜單頁面或大世界。 |     *   `back_to_world(self) -> OperationRoundResult`: 如果不在菜單頁面，返回大世界。 |     *   `click_menu(self) -> OperationRoundResult`: 在大世界畫面中點擊菜單按鈕。 |  | **重要功能點:** |  | *   使用 OCR 和圖像匹配來識別畫面。 | *   使用 `node_from` 和 `operation_node` 裝飾器來定義操作流程和節點。 | *   依賴 `ZContext` 獲取上下文信息。 | *   使用 `BackToNormalWorld` 操作返回大世界。
        │   ├── transport.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `Transport` 类，用于在游戏中执行传送操作。它通过一系列步骤，包括返回大世界、打开地图、选择区域、选择传送点和确认传送，最终实现传送功能。 |  | **核心类和函数:** |  | *   **`Transport(ZOperation)`**:  继承自 `ZOperation` 的类，负责执行传送操作。 |     *   `__init__(self, ctx: ZContext, area_name: str, tp_name: str, wait_at_last: bool = True)`:  初始化函数，设置传送的目标区域和传送点。 |     *   `check_screen()`:  检查当前是否在地图页面。 |     *   `back_to_world()`:  如果不在地图页面，则返回大世界。 |     *   `open_map()`:  在大世界画面中打开地图。 |     *   `choose_area()`:  在地图页面选择目标区域。 |     *   `choose_tp()`:  在地图页面选择目标传送点。 |     *   `click_tp()`:  在地图页面点击确认传送。 |     *   `wait_in_world()`:  等待大世界加载完成。 |  | **重要功能点:** |  | *   **流程控制:**  使用 `@operation_node` 和 `@node_from` 装饰器定义操作流程，实现状态机模式。 | *   **画面识别:**  使用 `screenshot()` 和 `round_by_find_area()` 等方法进行画面识别，判断当前状态。 | *   **OCR:** 使用 OCR 技术识别地图上的区域和传送点名称。 | *   **地图服务:**  使用 `ctx.map_service` 获取地图信息，例如区域之间的方向，传送点列表等。 | *   **滑动操作:**  当目标传送点不在当前显示范围内时，通过滑动操作来查找。 | *   **错误处理:**  使用 `round_retry()` 处理操作失败的情况，并进行重试。 | *   **等待机制:**  `wait_in_world()` 函数用于等待大世界加载完成，确保传送成功。
        │   ├── wait_normal_world.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了一個名為 `WaitNormalWorld` 的操作，其主要功能是等待遊戲中的大世界畫面加載完成。它使用畫面識別來判斷大世界是否已加載，並設定了超時機制。 |  | **核心類和函數:** |  | *   `WaitNormalWorld`: 繼承自 `ZOperation`，代表等待大世界加載的操作。 |     *   `__init__(self, ctx: ZContext)`: 構造函數，初始化操作，設置操作名稱。 |     *   `check_screen(self) -> OperationRoundResult`: 使用畫面識別來判斷大世界是否已加載。 該函數使用 `@operation_node` 裝飾器，並設定了重試次數。 |  | **重要功能點:** |  | *   使用 `ZOperation` 作為基類，表明該操作屬於遊戲操作流程的一部分。 | *   `check_screen` 函數使用畫面截圖和圖像識別來判斷大世界是否加載成功。 | *   `@operation_node` 裝飾器用於定義操作節點，並配置了重試次數，增加了操作的穩定性。 | *   `round_by_find_area` 函數用於基於畫面截圖和關鍵字來判斷畫面是否符合預期。
        │   ├── zzz_operation.py    這個 Python 文件定義了一個名為 `ZOperation` 的類，它繼承自 `one_dragon` 框架中的 `Operation` 類。 |  | *   **主要功能:**  `ZOperation` 類是針對 `zzz_od` 遊戲的特定操作的基類，它封裝了遊戲操作的邏輯，包括重試機制、超時設置和回調函數。 | *   **核心類和函數:** |     *   `ZOperation`:  繼承自 `Operation`，是遊戲操作的基類。 |     *   `__init__`:  `ZOperation` 類的構造函數，初始化上下文 `ZContext`，並創建一個 `OpenAndEnterGame` 的實例，然後調用父類 `Operation` 的構造函數進行初始化。 | *   **重要功能點:** |     *   初始化 `ZContext` 上下文。 |     *   創建 `OpenAndEnterGame` 操作實例。 |     *   繼承了 `Operation` 類提供的重試、超時、回調和遊戲勝利檢查等功能。
        │   ├── arcade/
        │   │   ├── arcade_snake_suicide.py    這個 Python 文件的主要功能是自動化在遊戲中進行蛇對蛇自殺操作，以完成每周行程。 |  | 核心類和函數： |  | *   **ArcadeSnakeSuicide**: 繼承自 ZOperation，負責整個自殺流程的控制。 |     *   `__init__`: 初始化，設置所需完成的次數和已完成的次數。 |     *   `handle_init`: 初始化已完成的次數。 |     *   `start_game`: 啟動蛇對蛇遊戲。 |     *   `wait_game_load`: 等待遊戲加載完成。 |     *   `click_empty`: 模擬點擊空白處繼續，並在達到指定次數後返回大世界。 |     *   `back_to_normal_world`: 返回大世界。 |  | 重要功能點： |  | *   自動化蛇對蛇遊戲的啟動和結束流程。 | *   根據配置的總次數，循環進行自殺操作。 | *   使用截圖和圖像識別來判斷遊戲狀態。 | *   在完成指定次數後，自動返回到大世界。
        │   │   └── arcade_start_game.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `ArcadeStartGame` 类，用于在游戏中启动街机游戏。它通过一系列操作，模拟玩家在游戏中的行为，包括传送、等待加载、选择游戏模式和游戏，最终启动游戏。 |  | **核心类和函数:** |  | *   **`ArcadeStartGame(ZOperation)`**:  继承自 `ZOperation`，是启动街机游戏的核心类。 |     *   `__init__(self, ctx: ZContext, game_name: str)`: 初始化函数，接收游戏名称作为参数。 |     *   `transport(self) -> OperationRoundResult`: 传送至电玩店。 |     *   `wait_world(self) -> OperationRoundResult`: 等待大世界加载。 |     *   `move_and_interact(self) -> OperationRoundResult`: 移动并交互。 |     *   `wait_noodle_shop(self) -> OperationRoundResult`: 等待加载。 |     *   `choose_mode(self) -> OperationRoundResult`: 选择游戏模式。 |     *   `choose_game(self) -> OperationRoundResult`: 选择游戏。 |     *   `click_choose(self) -> OperationRoundResult`: 点击选择游戏。 |     *   `click_start(self) -> OperationRoundResult`: 点击开始游戏。 |  | **重要功能点:** |  | *   **游戏流程自动化:**  通过一系列 `operation_node` 装饰的函数，定义了启动街机游戏的完整流程。 | *   **屏幕交互:**  使用 `self.ctx.controller` 进行移动和交互操作，模拟用户行为。 | *   **图像识别:**  使用 `self.screenshot()` 和 `self.round_by_ocr_and_click()` 等函数，通过屏幕截图和 OCR 技术来识别和点击游戏界面上的元素。 | *   **重试机制:**  使用 `node_max_retry_times` 参数，在某些步骤中设置重试机制，提高操作的稳定性。 | *   **国际化支持:** 使用 `gt()` 函数进行国际化文本处理。
        │   ├── challenge_mission/
        │   │   ├── check_next_after_battle.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 這個文件定義了一個操作，用於在戰鬥結束後，根據用戶的選擇（"再來一次" 或 "結束"）來執行相應的動作。 |  | **核心類和函數:** |  | *   `ChooseNextOrFinishAfterBattle(ZOperation)`:  繼承自 `ZOperation`，負責處理戰鬥結束後的選擇邏輯。 |     *   `__init__(self, ctx: ZContext, try_next: bool)`:  構造函數，初始化上下文和是否嘗試 "再來一次" 的標誌。 |     *   `check_next(self) -> OperationRoundResult`:  判斷是否點擊 "再來一次" 按鈕。如果 `try_next` 為 True，則嘗試點擊 "再來一次"；否則，嘗試點擊 "完成"。 |     *   `finish(self) -> OperationRoundResult`:  如果 `check_next` 失敗，則嘗試點擊 "完成" 按鈕。 |  | **重要功能點:** |  | *   根據 `try_next` 標誌，決定是嘗試 "再來一次" 還是 "完成"。 | *   使用 `round_by_find_and_click_area` 函數來查找屏幕上的按鈕並點擊。 | *   包含重試機制，以應對按鈕未立即出現的情況。 | *   使用 `operation_node` 裝飾器定義操作節點，用於流程控制。
        │   │   └── exit_in_battle.py    這個 Python 文件定義了一個名為 `ExitInBattle` 的類，該類繼承自 `ZOperation`，其主要功能是在戰鬥畫面中嘗試退出戰鬥。 |  | 核心類和函數： |  | *   **`ExitInBattle(ZContext, wait_screen_name: str = None, wait_area_name: str = None)`**: 構造函數，初始化操作，接收上下文和退出後等待的畫面信息。 | *   **`check_screen()`**: 識別戰鬥畫面，嘗試點擊菜單按鈕，並尋找退出戰鬥按鈕。 | *   **`click_exit_battle()`**: 點擊退出戰鬥按鈕。 | *   **`click_confirm()`**: 點擊確認退出按鈕。 | *   **`wait_at_last()`**: 退出後等待，直到指定的畫面出現。 |  | 重要功能點： |  | *   使用 `operation_node` 裝飾器定義操作步驟，並使用 `node_from` 裝飾器指定步驟之間的依賴關係。 | *   使用 `round_by_find_area` 和 `round_by_find_and_click_area` 等方法進行畫面識別和點擊操作。 | *   支持重試機制，以應對畫面識別失敗的情況。 | *   支持在退出戰鬥後等待指定的畫面出現。
        │   ├── compendium/
        │   │   ├── combat_simulation.py    ```python | 文件摘要： | 該文件定義了 `CombatSimulation` 類，用於在遊戲中執行實戰模擬室的自動化操作，包括選擇任務、檢查電量、部署隊伍和自動戰鬥。 |  | 核心類和函數： | *   `CombatSimulation(ZOperation)`:  核心類，繼承自 `ZOperation`，負責實戰模擬的流程控制。 |     *   `async_init_auto_op()`: 异步初始化自动战斗。 |     *   `wait_entry_load()`: 等待進入實戰模擬室界面。 |     *   `choose_mission_type()`: 選擇任務類型。 |     *   `choose_mission()`: 選擇任務。 |     *   `click_card()`: 點擊卡片選擇按鈕。 |     *   `choose_card_num()`: 選擇卡片數量。 |     *   `check_charge()`: 檢查電量是否足夠。 |     *   `click_next()`: 點擊下一步按鈕。 |     *   `choose_predefined_team()`: 選擇預設隊伍。 |     *   `deploy()`: 部署隊伍。 |     *   `init_auto_battle()`: 初始化自動戰鬥。 |     *   `wait_battle_screen()`: 等待戰鬥畫面加載。 |     *   `move_to_battle()`: 進入戰鬥。 |     *   `auto_battle()`: 執行自動戰鬥。 |     *   `after_battle()`: 戰鬥結束後的處理。 |     *   `check_next()`: 判斷是否進行下一次模擬。 |     *   `handle_pause()`: 暫停時的處理。 |     *   `handle_resume()`: 恢復時的處理。 |     *   `after_operation_done()`: 操作完成後的清理。 | *   `__debug_coffee()`: 调试函数，用于测试咖啡任务。 | *   `__debug_charge()`: 调试函数，用于测试电量识别。 | *   `__debug()`: 调试函数，用于测试实战模拟。 |  | 重要功能點： | *   任務選擇：根據配置選擇任務類型和具體任務。 | *   電
        │   │   ├── compendium_choose_category.py    這個 Python 腳本定義了一個名為 `CompendiumChooseCategory` 的操作，用於在遊戲的快捷手冊中選擇一個特定的分類。 |  | **主要功能:** |  | *   選擇快捷手冊中的指定分類。 |  | **核心類和函數:** |  | *   `CompendiumChooseCategory`: 繼承自 `ZOperation`，負責執行選擇分類的操作。 |     *   `__init__(self, ctx: ZContext, category_name: str)`: 初始化操作，接收上下文和分類名稱。 |     *   `choose_tab(self) -> OperationRoundResult`: 核心函數，截取屏幕，使用 OCR 識別分類列表，找到目標分類並點擊。 | *   `__debug()`: 用於測試，初始化上下文，創建 `CompendiumChooseCategory` 實例並執行。 |  | **重要功能點:** |  | *   使用 OCR 識別屏幕上的分類列表。 | *   基於最長公共子序列 (LCS) 匹配來查找目標分類。 | *   點擊找到的分類。 | *   包含重試機制，如果找不到分類則重試。
        │   │   ├── compendium_choose_mission_type.py    **摘要:** |  | 该文件定义了一个名为 `CompendiumChooseMissionType` 的类，用于在游戏《明日方舟》的快捷手册中选择特定类型的副本。它通过 OCR 识别副本类型，并模拟点击操作来选择和确认副本。 |  | **核心类和函数:** |  | *   **`CompendiumChooseMissionType(ZOperation)`**:  继承自 `ZOperation`，负责选择副本类型的操作。 |     *   `__init__(self, ctx: ZContext, mission_type: CompendiumMissionType)`: 初始化函数，设置上下文和目标副本类型。 |     *   `choose_tab(self) -> OperationRoundResult`:  核心函数，用于选择副本类型。它使用 OCR 识别副本名称，并根据识别结果进行点击或滑动操作。 |     *   `confirm(self) -> OperationRoundResult`: 确认选择的副本。 |  | **重要功能点:** |  | *   **OCR 识别**: 使用 OCR 技术识别屏幕上的文本，以确定副本类型和“前往”按钮的位置。 | *   **滑动操作**:  如果目标副本不在当前可见范围内，则执行滑动操作。 | *   **点击操作**:  模拟点击操作来选择副本和确认传送。 | *   **错误处理**: 包含重试机制和错误处理，以应对识别失败或操作失败的情况。 | *   **调试函数**: 包含一个 `__debug()` 函数，用于测试和调试。
        │   │   ├── compendium_choose_tab.py    這個 Python 文件的摘要如下： |  | **主要功能:** |  | 該文件定義了一個操作，用於在遊戲的快捷手册中選擇指定的 Tab。 |  | **核心類和函數:** |  | *   `CompendiumChooseTab`: 繼承自 `ZOperation`，負責選擇快捷手册中的 Tab。 |     *   `__init__(self, ctx: ZContext, tab_name: str)`: 初始化操作，接收上下文和 Tab 名稱。 |     *   `choose_tab(self) -> OperationRoundResult`: 核心函數，執行選擇 Tab 的邏輯。 | *   `__debug()`: 是一個用於測試的函數，用於初始化上下文、啟動 OCR 模型，並執行 `CompendiumChooseTab` 操作。 |  | **重要功能點:** |  | *   使用 OCR 識別 Tab 列表中的文本。 | *   根據 Tab 名稱查找目標點。 | *   使用控制器點擊目標點以選擇 Tab。 | *   包含重試機制，如果找不到 Tab 則重試。 | *   包含一個用於測試的 `__debug` 函數。
        │   │   ├── expert_challenge.py    **摘要:** |  | 该 Python 文件定义了 `ExpertChallenge` 类，用于自动化处理游戏中的专业挑战室任务。它通过模拟用户操作，包括识别电量、选择队伍、部署、自动战斗和处理战斗结果等步骤，以实现自动完成挑战的目的。 |  | **核心类和函数:** |  | *   **`ExpertChallenge`**:  核心类，继承自 `ZOperation`，负责执行专业挑战室的自动化流程。 |     *   `__init__`: 初始化函数，设置挑战计划、是否需要检查电量等参数。 |     *   `wait_entry_load`: 等待进入挑战室界面加载完成。 |     *   `check_charge`: 识别并检查剩余电量是否足够进行挑战。 |     *   `click_next`: 点击“下一步”按钮，直到出现“出战”按钮。 |     *   `choose_predefined_team`: 选择预定义的队伍。 |     *   `deploy`: 执行部署操作。 |     *   `init_auto_battle`: 加载自动战斗指令。 |     *   `wait_battle_screen`: 等待战斗画面加载。 |     *   `move_to_battle`: 移动角色进入战斗。 |     *   `auto_battle`: 执行自动战斗，并监控战斗状态。 |     *   `after_battle`: 处理战斗结束后的逻辑，如减少可运行次数。 |     *   `check_next`: 判断是否需要进行下一次挑战。 |     *   `check_charge_fail`: 处理电量识别失败的情况。 |     *   `battle_timeout`: 处理战斗超时的逻辑。 |     *   `click_result_exit`: 点击挑战结果界面上的退出按钮。 |     *   `handle_pause`: 暂停自动战斗。 |     *   `handle_resume`: 恢复自动战斗。 |     *   `after_operation_done`: 清理资源。 |  | **重要功能点:** |  | *   **电量检查**:  根据配置，检查剩余电量是否足够进行挑战，并计算可运行次数。 | *   **自动战斗**:  集成自动战斗功能，通过加载自动战斗指令，实现战斗过程的自动化。 | *   **流程控制**:  通过一系列 `operation_node` 装饰器定义的节点，构建了完整的挑战流程，包括界面识别、
        │   │   ├── notorious_hunt.py    **摘要:** |  | 该 Python 文件定义了 `NotoriousHunt` 类，用于自动化《代号：无限大》游戏中的恶名狩猎活动。它通过 OCR 识别、图像匹配和模拟用户操作来实现自动选择副本、难度、深度追猎模式、编队、战斗、处理战斗结果等功能。 |  | **核心类和函数:** |  | *   **`NotoriousHunt` 类:** 继承自 `ZOperation`，负责恶名狩猎的整体流程控制。 |     *   `__init__`: 初始化操作，包括计划信息、是否使用电量、运行次数等。 |     *   `wait_entry_load`: 等待恶名狩猎入口加载。 |     *   `check_mission`: 检查副本名称是否匹配。 |     *   `choose_mission`: 选择目标副本。 |     *   `choose_by_use_power`: 选择是否开启深度追猎。 |     *   `check_can_run_times`: 检查剩余可运行次数和电量。 |     *   `choose_level`: 选择挑战难度。 |     *   `click_next`: 点击“下一步”按钮。 |     *   `choose_predefined_team`: 选择预设编队。 |     *   `click_start`: 点击“出战”按钮。 |     *   `init_auto_battle`: 加载自动战斗指令。 |     *   `wait_battle_screen`: 等待战斗画面加载。 |     *   `first_move`: 战斗开始前的移动。 |     *   `move_and_interact`: 移动并交互。 |     *   `choose_buff`: 选择增益效果。 |     *   `move_to_battle`: 移动到战斗位置。 |     *   `auto_battle`: 执行自动战斗。 |     *   `battle_fail`: 处理战斗失败情况。 |     *   `battle_fail_exit`: 战斗失败后退出。 |     *   `after_battle`: 战斗结束后处理。 |     *   `check_next`: 检查是否继续挑战。 |     *   `no_left_times`: 处理没有剩余次数的情况。 |     *   `restart_confirm`: 重新开始挑战的确认。 |     *   `wait_back_to_entry`: 等
        │   │   ├── open_compendium.py    這個 Python 文件定義了一個名為 `OpenCompendium` 的類，它繼承自 `ZOperation`，旨在實現打開遊戲中的快捷手册功能。 |  | *   **主要功能:** 打開遊戲中的快捷手册。 | *   **核心類和函數:** |     *   `OpenCompendium`: 繼承自 `ZOperation`，負責整個打開快捷手册的流程。 |     *   `open_menu()`:  打開遊戲菜單，作為流程的起始節點。 |     *   `click_more()`:  在菜單中點擊“快捷手册”按鈕。 | *   **重要功能點:** |     *   使用 `OpenMenu` 類打開菜單。 |     *   使用 OCR 和點擊功能來定位和點擊“快捷手册”按鈕。 |     *   使用 `operation_node` 和 `node_from` 裝飾器來定義操作流程。
        │   │   ├── routine_cleanup.py    ## 代码摘要 |  | **1. 主要功能:** |  | 該 Python 文件定義了 `RoutineCleanup` 類，用於執行《明日方舟》遊戲中的定期清剿任務。它自動化了選擇關卡、檢查電量、部署隊伍、自動戰鬥和處理戰鬥結果的流程。 |  | **2. 核心類和函數:** |  | *   **`RoutineCleanup` 類:** 繼承自 `ZOperation`，負責執行定期清剿任務。 |     *   `__init__`: 初始化，接收 `ZContext`、`ChargePlanItem`、運行次數和是否需要檢查電量等參數。 |     *   `wait_entry_load`: 等待進入清剿入口。 |     *   `check_charge`: 檢查剩餘電量是否足夠。 |     *   `click_next`: 點擊下一步按鈕，進入戰鬥準備。 |     *   `choose_predefined_team`: 選擇預設編隊。 |     *   `deploy`: 部署隊伍。 |     *   `init_auto_battle`: 加載自動戰鬥指令。 |     *   `wait_battle_screen`: 等待戰鬥畫面加載。 |     *   `move_to_battle`: 角色向前移動準備戰鬥。 |     *   `auto_battle`: 執行自動戰鬥。 |     *   `after_battle`: 戰鬥結束後的處理。 |     *   `check_next`: 判斷是否繼續下一次清剿。 |     *   `check_charge_fail`: 電量識別失敗處理。 |     *   `battle_timeout`: 戰鬥超時處理。 |     *   `click_result_exit`: 點擊挑戰結果退出。 |     *   `handle_pause`: 暫停時的處理。 |     *   `handle_resume`: 恢復時的處理。 |     *   `after_operation_done`: 操作完成後的清理。 | *   **`__debug_charge` 函數:** 用於測試電量識別功能。 | *   **`__debug` 函數:** 用於測試整個清剿流程。 |  | **3. 重要功能點:** |  | *   **電量檢查:** 根據配置判斷是否需要檢查電量，並根據剩餘
        │   │   └── tp_by_compendium.py    這個 Python 腳本定義了一個名為 `TransportByCompendium` 的類，它繼承自 `ZOperation`，用於通過遊戲內的快捷手冊進行傳送。 |  | **主要功能:** |  | *   通過遊戲內的快捷手冊，選擇 Tab、分類和任務類型，實現快速傳送。 |  | **核心類和函數:** |  | *   `TransportByCompendium(ZOperation)`:  主類，負責整個傳送流程。 |     *   `__init__`: 初始化操作，設置傳送的目標 Tab、分類和任務類型。 |     *   `check_first_screen`: 檢查初始畫面，判斷是否已在快捷手冊界面。 |     *   `open_compendium`: 打開快捷手冊。 |     *   `choose_tab`: 選擇指定的 Tab。 |     *   `choose_category`: 選擇指定的分類。 |     *   `choose_mission_type`: 選擇指定的任務類型。 | *   `ZContext`: 遊戲上下文，提供遊戲數據和服務。 | *   `OpenCompendium`:  打開快捷手冊的操作。 | *   `CompendiumChooseCategory`: 選擇分類的操作。 | *   `CompendiumChooseMissionType`: 選擇任務類型的操作。 |  | **重要功能點:** |  | *   使用 `operation_node` 和 `node_from` 裝飾器定義操作流程，實現狀態機。 | *   根據提供的 Tab、分類和任務類型，逐步導航到目標界面。 | *   `__debug` 函數用於測試。 | *   `if __name__ == '__main__':` 塊用於運行測試。
        │   ├── enter_game/
        │   │   ├── auto_hdr.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了两个操作类，用于在游戏中禁用和启用自动 HDR (High Dynamic Range) 功能，通过修改 Windows 注册表实现。 |  | **核心类和函数:** |  | *   **`DisableAutoHDR(Operation)`:**  用于禁用自动 HDR。 |     *   `disable_auto_hdr()`:  禁用 HDR 的主函数，首先保存原始 HDR 设置，然后将注册表键值设置为禁用 HDR。 | *   **`EnableAutoHDR(Operation)`:** 用于启用自动 HDR。 |     *   `enable_auto_hdr()`: 启用 HDR 的主函数，恢复原始 HDR 设置，或者删除键值（如果之前没有保存原始设置）。 |  | **重要功能点:** |  | *   使用 `winreg` 模块操作 Windows 注册表。 | *   保存和恢复 HDR 设置，以确保可以还原到原始状态。 | *   处理游戏路径未配置的情况。 | *   使用 `operation_node` 装饰器定义操作节点，并使用 `OperationRoundResult` 返回操作结果。 | *   包含错误处理机制，捕获 `WindowsError` 异常并记录日志。
        │   │   ├── enter_game.py    ## 代码摘要 |  | **1. 主要功能:** |  | 该 Python 文件定义了 `EnterGame` 类，其主要功能是自动化进入游戏。它通过图像识别和模拟用户操作（如点击、输入账号密码）来完成登录过程，并支持国服、B服和国际服的登录流程。 |  | **2. 核心类和函数:** |  | *   **`EnterGame(ZOperation)`**:  核心类，继承自 `ZOperation`，负责游戏登录的整个流程。 |     *   `__init__(self, ctx: ZContext, switch: bool = False)`: 初始化函数，设置登录相关的配置。 |     *   `check_screen(self) -> OperationRoundResult`:  画面识别，根据当前屏幕状态判断下一步操作，是整个登录流程的起始节点。 |     *   `check_screen_intl(self) -> OperationRoundResult`: 国际服的画面识别。 |     *   `input_account_password(self) -> OperationRoundResult`:  国服账号密码输入。 |     *   `input_account_password_new(self) -> OperationRoundResult`:  国服账号密码输入 (新版UI)。 |     *   `input_bilibili_account_password(self) -> OperationRoundResult`:  B服账号密码输入。 |     *   `input_account_password_intl(self) -> OperationRoundResult`:  国际服账号密码输入。 |     *   `check_server(self) -> OperationRoundResult`: 国际服换服操作。 |     *   `wait_game(self) -> OperationRoundResult`: 等待游戏加载完成。 |  | **3. 重要功能点:** |  | *   **多平台支持:**  支持国服、B服和国际服的登录流程，通过不同的 `input_...` 函数实现。 | *   **图像识别:** 使用 `round_by_find_area` 和 `round_by_find_and_click_area` 等函数进行图像识别，判断当前屏幕状态并执行相应操作。 | *   **账号密码输入:**  支持使用剪切板或模拟键盘输入账号密码。 | *   **换服功能:**  针对国际服，支持切换服务器。 | *   **重试机制:**  使用 `operation_node` 装饰器，并设置 `node
        │   │   ├── open_and_enter_game.py    這個 Python 文件定義了一個名為 `OpenAndEnterGame` 的操作，用於打開並進入遊戲。 |  | **主要功能:** |  | *   打開遊戲並進入遊戲。 | *   處理遊戲窗口的初始化和激活。 | *   控制 HDR 設置。 |  | **核心類和函數:** |  | *   `OpenAndEnterGame`: 繼承自 `Operation`，負責整個打開並進入遊戲的流程。 |     *   `__init__`: 初始化操作，包括上下文和操作名稱。 |     *   `handle_init`: 初始化操作，目前為空。 |     *   `add_edges_and_nodes`: 添加操作流程中的節點和邊。 |     *   `open_game`: 打開遊戲，並禁用 HDR。 |     *   `wait_game`: 等待遊戲打開，激活遊戲窗口，並啟用 HDR。 |     *   `enter_game`: 進入遊戲。 | *   `OperationNode`:  用於定義操作流程中的節點。 | *   `OperationRoundResult`: 用於表示操作的結果。 | *   `OpenGame`:  用於打開遊戲的操作。 | *   `EnterGame`:  用於進入遊戲的操作。 | *   `EnableAutoHDR`, `DisableAutoHDR`:  用於控制 HDR 設置的操作。 |  | **重要功能點:** |  | *   使用 `Operation` 框架構建操作流程。 | *   使用節點和邊定義操作的執行順序。 | *   在打開遊戲和等待遊戲打開階段控制 HDR。 | *   包含重試機制，用於等待遊戲窗口準備就緒。
        │   │   ├── open_game.py    這個 Python 文件的主要功能是打開遊戲。 |  | 核心類： |  | *   `OpenGame`: 繼承自 `Operation`，負責啟動遊戲。 |  | 核心函數： |  | *   `open_game`: 啟動遊戲的函數，使用 `subprocess.Popen` 執行遊戲可執行文件。 |  | 重要功能點： |  | *   從 `ZContext` 獲取遊戲路徑和啟動參數。 | *   構建命令行指令，用於啟動遊戲，包括處理屏幕尺寸、全屏模式、彈出窗口和監視器等參數。 | *   使用 `subprocess.Popen` 在後台啟動遊戲。 | *   提供錯誤處理，如果未配置遊戲路徑，則返回失敗。
        │   │   └── switch_account.py    這個 Python 腳本實現了在遊戲中切換帳號的功能。 |  | *   **主要功能:** 執行一系列操作，包括打開菜單、點擊更多、選擇登出、確認登出，並最終重新進入遊戲。 | *   **核心類和函數:** |     *   `SwitchAccount`: 繼承自 `ZOperation`，負責切換帳號的流程控制。 |     *   `open_menu`: 打開遊戲菜單。 |     *   `click_more`: 點擊菜單中的“更多”選項。 |     *   `more_click_logout`: 在“更多”選項中選擇“登出”。 |     *   `more_logout_confirm`: 確認登出操作。 |     *   `wait_switch_can_click`: 等待切換帳號完成，直到可以點擊“進入遊戲”。 |     *   `enter_game`: 重新進入遊戲。 |     *   `__debug`: 測試函數，用於初始化上下文並執行切換帳號操作。 | *   **重要功能點:** |     *   使用 OCR 和圖像識別來定位和點擊屏幕上的元素。 |     *   使用 `operation_node` 和 `node_from` 裝飾器來定義操作流程和節點之間的依賴關係。 |     *   包含重試機制，以應對操作失敗的情況。 |     *   使用 `ZContext` 存儲上下文信息。
        │   ├── goto/
        │   │   └── goto_menu.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | 該文件定義了一個名為 `GotoMenu` 的操作，其主要功能是導航到遊戲的菜單界面。它旨在確保在任何情況下都能成功前往菜單。 |  | **核心類和函數：** |  | *   `GotoMenu`：繼承自 `ZOperation`，是核心類，負責執行前往菜單的操作。 |     *   `__init__(self, ctx: ZContext)`：構造函數，初始化操作，設置操作名稱為“前往菜單”。 |     *   `check_screen_and_run(self, screen: Optional[MatLike] = None) -> OperationRoundResult`：核心函數，負責檢查當前畫面並嘗試導航到菜單。它使用 `round_by_goto_screen` 嘗試直接導航，如果失敗，則嘗試返回大世界，然後再次嘗試導航。 |  | **重要功能點：** |  | *   使用 `operation_node` 裝飾器標記 `check_screen_and_run` 函數，並設置了重試次數。 | *   使用 `round_by_goto_screen` 嘗試直接導航到菜單。 | *   如果直接導航失敗，則使用 `BackToNormalWorld` 操作返回大世界。 | *   處理了無法到達菜單的情況，返回失敗狀態。 | *   包含屏幕截圖功能。
        │   └── hdd/
        │       └── enter_hdd_mission.py    此文件定义了 `EnterHddMission` 类，用于处理进入 HDD（Hard Disk Drive）副本的操作流程。 |  | *   **核心类:** `EnterHddMission` 继承自 `ZOperation`，负责执行进入 HDD 副本的步骤。 | *   **核心函数:** |     *   `__init__`: 初始化操作，设置章节、任务类型、任务名称和预设队伍索引。 |     *   `choose_chapter`: 选择章节。 |     *   `choose_mission_type`: 选择任务类型。 |     *   `choose_mission`: 选择副本。 |     *   `click_next`: 点击“下一步”。 |     *   `choose_predefined_team`: 选择预设队伍。 |     *   `click_deploy`: 点击“出战”。 |     *   `check_level`: 检查并处理低等级提示。 |     *   `finish`: 标记流程完成。 | *   **重要功能点:** |     *   通过 OCR 和图像识别来定位和点击屏幕元素。 |     *   支持选择章节、任务类型和副本。 |     *   可以选择预设队伍。 |     *   处理低等级提示。 |     *   使用 `operation_node` 和 `node_from` 装饰器定义操作流程和依赖关系。 |     *   包含重试机制和等待时间，以处理可能出现的错误。
        ├── screen_area/
        │   └── screen_normal_world.py    這個 Python 文件定義了一個名為 `ScreenNormalWorldEnum` 的枚舉，用於表示遊戲屏幕中特定區域的定義。 |  | *   **主要功能:** 定義遊戲屏幕中不同區域的常量，特別是針對 UID 區域。 | *   **核心類和函數:** |     *   `ScreenNormalWorldEnum`:  一個枚舉類，用於定義屏幕區域的常量。 |     *   `ScreenArea`:  從 `one_dragon.base.screen.screen_area` 導入的類，用於表示屏幕區域。 |     *   `Rect`:  從 `one_dragon.base.geometry.rectangle` 導入的類，用於定義矩形區域。 | *   **重要功能點:** |     *   `UID`:  定義了屏幕中 UID 區域的 `ScreenArea` 實例，使用 `Rect` 定義了其在 PC 屏幕上的坐標。
        ├── win_exe/
        │   ├── full_launcher.py    這個 Python 腳本 `full_launcher.py` 的主要功能是啟動一個特定的 Python 應用程式。 |  | *   **核心函數:** `python_launcher.run_python()` | *   **重要功能點:** |     *   使用 `python_launcher` 模塊來執行另一個 Python 腳本。 |     *   啟動的腳本是 `zzz_od.gui.app.py`。 |     *   `no_windows=True` 參數表示在沒有 Windows 終端視窗的情況下運行。
        │   └── scheduler_launcher.py    這個 Python 腳本 `scheduler_launcher.py` 的主要功能是啟動一個名為 `zzz_one_dragon_app.py` 的應用程式。 |  | *   **核心函數:** `python_launcher.run_python()` | *   **重要功能點:** |     *   使用 `one_dragon.devtools.python_launcher` 模組來執行 Python 程式。 |     *   啟動 `zzz_od.application.zzz_one_dragon_app.py` 應用程式。 |     *   `no_windows=False` 表示啟動時會顯示 Windows 視窗。
        └── yolo/
            ├── flash_classifier.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | `FlashClassifier` 類別實現了一個基於 YOLOv8 的分類器，用於快速分類圖像。它繼承自 `Yolov8Classifier`，並通過下載和加載預訓練模型來執行分類任務。 |  | **核心類和函數：** |  | *   `FlashClassifier`: 繼承自 `Yolov8Classifier`，初始化時會下載並加載 YOLOv8 模型。 | *   `__init__`:  `FlashClassifier` 的構造函數，初始化分類器的各種參數，例如模型名稱、GPU 使用情況和結果保留時間。 |  | **重要功能點：** |  | *   **模型加載和管理：**  從指定的 URL 下載 YOLOv8 模型，並在本地管理模型文件。 | *   **GPU 加速：** 支援使用 GPU 進行加速，以提高分類速度。 | *   **結果保留：**  可以配置結果保留時間，控制分類結果的生命週期。 | *   **代理設置：** 支援通過 GitHub 代理或個人代理下載模型。
            └── hollow_event_detector.py    這個 Python 文件的摘要如下： |  | **主要功能：** |  | *   `HollowEventDetector` 類別實現了一個基於 YOLOv8 的空洞事件檢測器，專為崩鐵遊戲設計。它繼承自 `Yolov8Detector`，並利用 YOLOv8 模型進行物件偵測。 |  | **核心類和函數：** |  | *   `HollowEventDetector`: 繼承自 `Yolov8Detector`，初始化 YOLOv8 模型，並設定模型名稱、GPU 使用情況和結果保留時間等參數。 | *   `__init__`: 類別的建構子，用於初始化檢測器，並設定模型下載路徑、代理設定等。 |  | **重要功能點：** |  | *   初始化 YOLOv8 模型，並從指定 URL 下載模型。 | *   支援 GPU 加速。 | *   設定結果保留時間，用於管理檢測結果的生命週期。 | *   使用 `yolo_config_utils.get_model_category_dir` 獲取模型存放路徑。 | *   使用 `ZZZ_MODEL_DOWNLOAD_URL` 下載模型。
```
