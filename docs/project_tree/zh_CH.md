```
ZENLESSZONEZERO-ONEDRAGON
├── requirements-dev-ext.txt    这个文件 `requirements-dev-ext.txt` 是一个 Python 项目额外的依赖需求文件，主要用于开发或部署环境。 |  | *   **主要功能:** 列出额外的 Python 库依赖，用于开发和部署。 | *   **核心依赖:** |     *   `polib==1.2.0`: 用于处理 `.po` 文件，例如将 `.mo` 文件编译成 `.po` 文件。 |     *   `pyinstaller==6.7.0`: 用于将 Python 项目打包成可执行文件 (`.exe`)。 |     *   `pip-tools==7.4.1`: 用于管理和编译依赖关系，通常与 `pip-compile` 命令一起使用。 |     *   `colorama==0.4.6`: 用于在终端中显示彩色文本。 | *   **重要功能点:** 这些依赖项扩展了基本项目的功能，包括国际化支持、打包成可执行文件、依赖管理和终端美化。
├── requirements-dev.txt    这个文件 `requirements-dev.txt` 是一个 Python 项目开发依赖文件，列出了项目所需的 Python 库及其版本。 |  | *   **主要功能:** 声明项目开发所需的 Python 库及其版本，用于环境构建和依赖管理。 | *   **核心类和函数:**  无，此文件仅为依赖声明。 | *   **重要功能点:** |     *   列出项目所需的 Python 库，例如 `pyside6`, `opencv-python`, `pyautogui` 等。 |     *   指定了每个库的具体版本号，确保依赖的一致性。
├── requirements-gamepad.txt    这个文件 `requirements-gamepad.txt` 是一个 Python 专案的依赖文件，主要功能是声明专案需要安装的第三方库。 |  | *   **主要功能:** 声明专案依赖。 | *   **核心:** 仅包含一个依赖项 `vgamepad==0.1.0`。 | *   **重要功能点:** 指定了 `vgamepad` 库的版本为 0.1.0，用于游戏手柄的输入处理。
├── requirements-prod.txt    这个文件是一个由 `pip-compile` 生成的 Python 依赖项文件，用于生产环境。 |  | *   **主要功能:** 列出并指定了项目所需的 Python 库及其版本，以确保在生产环境中依赖项的一致性。 | *   **核心类和函数:**  没有定义类或函数，它只是一个依赖项列表。 | *   **重要功能点:** |     *   列出了所有依赖项及其版本号。 |     *   包含了依赖项的依赖关系信息 (例如，`via librosa`)。 |     *   使用清华大学的 PyPI 镜像加速下载。 |     *   依赖项列表是从 `requirements-dev.txt` 派生而来，这表明它是一个开发环境的子集或修改版本。
├── .github/
│   ├── README.md    这个 README.md 文件是 ZenlessZoneZero-OneDragon 项目的一个介绍文件，主要功能是为用户提供项目的概述、功能介绍、快速入门指南、免责声明、贡献者信息、社区链接和支持方式。 |  | *   **主要功能:** 该项目是一个基于图像识别和自动化的智能解决方案，专为游戏 Zenless Zone Zero 设计，提供自动战斗、闪避助手、日常清理、空洞作战等功能。 | *   **核心类和函数:**  由于是 README 文件，没有代码，因此没有核心类和函数。 | *   **重要功能点:** |     *   自动战斗，支持自定义逻辑。 |     *   闪避助手，基于声音和图像识别。 |     *   日常清理，包括多个游戏内日常任务。 |     *   空洞作战，基于大模型训练的识别和寻路功能。 |     *   提供快速入门指南和官方网站链接。 |     *   包含免责声明，强调项目仅供学习交流，使用风险自负。 |     *   列出贡献者，并提供社区链接和支持方式。
│   ├── ISSUE_TEMPLATE/
│   │   ├── 01-bug-common.yml    这个 YAML 文件定义了一个用于 GitHub issue 的模板，专门用于用户提交通用问题反馈。 |  | *   **主要功能:** 创建一个结构化的 issue 模板，引导用户提供足够的信息来报告问题。 | *   **核心元素:** |     *   `name`: 模板的名称 "问题反馈-通用"。 |     *   `description`: 模板的描述，说明适用场景。 |     *   `title`: issue 的标题格式。 |     *   `labels`: 预设的 issue 标签。 |     *   `body`: 包含多个部分的 issue 内容，用于收集用户信息。 | *   **重要功能点:** |     *   提供前置须知，包括版本更新、搜索现有 issue、阅读使用说明等。 |     *   使用复选框确认用户已完成必要步骤。 |     *   要求提供代码版本、问题描述、游戏截图、运行日志和建议。 |     *   明确说明截图和日志的获取方式和位置。 |     *   强调使用特定方式截图，以及提供足够信息的重要性。
│   │   ├── 02-bug-battle-assistant.yml    这个文件定义了一个用于在 GitHub 上提交战斗助手问题反馈的 issue 模板。 |  | *   **主要功能:** 引导用户提供详细信息，以便开发者能够诊断和解决战斗助手相关的问题。 | *   **核心结构:** 使用 YAML 格式定义了 issue 模板的各个组成部分，包括标题、标签、正文内容和用户输入字段。 | *   **重要功能点:** |     *   提供关于如何提交问题的详细说明，包括代码版本、配置、问题描述、截图和日志。 |     *   强制用户确认他们已完成某些步骤，例如使用最新版本的代码、搜索现有问题和更新模型。 |     *   要求用户提供详细的问题描述和重现步骤，以便开发者能够复现问题。 |     *   引导用户使用特定的截图方式（脚本F11）和日志文件位置。 |     *   鼓励用户提供建议。
│   │   ├── 03-bug-hollow-zero.yml    这个 YAML 文件定义了一个用于在 GitHub 上提交与游戏 "枯萎之都" 相关的 bug 反馈的 issue 模板。 |  | **主要功能:** |  | *   创建一个结构化的 issue 模板，用于收集关于 "枯萎之都" 游戏问题的详细信息。 |  | **核心类和函数:** |  | *   该文件使用 YAML 格式，没有类或函数。它定义了 issue 模板的结构。 |  | **重要功能点:** |  | *   **信息收集:** 模板要求用户提供详细信息，包括问题描述、重现步骤、副本信息、寻路方式、游戏截图、运行日志和建议。 | *   **预检验:** 模板包含预检验步骤，要求用户确认他们已更新到最新版本、搜索过现有 issue、更新了模型和脚本等。 | *   **截图和日志要求:** 强调使用特定方式截图（F11 键）和提供运行日志。 | *   **版本信息:** 要求提供代码版本。 | *   **标签和标题:** 设置了 issue 的标题和默认标签。
│   │   └── 04-bug-lost-void.yml    这个 YAML 文件定义了一个用于在 GitHub 上提交关于“零号空洞-迷失之地”游戏问题的 issue 模板。 |  | **主要功能:** |  | *   创建一个结构化的 issue 模板，用于收集关于游戏中“迷失之地”区域问题的详细信息。 |  | **核心元素:** |  | *   `name`:  定义 issue 模板的名称 ("问题反馈-零号空洞-迷失之地")。 | *   `description`:  提供模板的描述。 | *   `title`:  设置 issue 的标题前缀 ("\[问题反馈] \[迷失之地] ")。 | *   `labels`:  添加预定义的标签 ("Triage | 待检查")。 | *   `body`:  包含一系列用于收集信息的字段，包括： |     *   Markdown 说明：提供前置须知和提 issue 的方式。 |     *   复选框：要求用户确认他们已完成某些步骤，例如使用最新版本和更新模型。 |     *   输入框：用于收集代码版本。 |     *   文本框：用于收集问题描述、区域类型、游戏截图、运行日志和建议。 |  | **重要功能点:** |  | *   **提供详细的提问指南**:  包括如何重现问题、提供截图和日志，以及如何描述问题。 | *   **强制信息收集**:  通过 `required: true` 属性确保用户提供关键信息。 | *   **明确的截图要求**:  强调使用脚本 F11 截图，并说明截图位置。 | *   **版本信息**:  要求提供代码版本，以便于问题的定位和修复。 | *   **结构化的问题描述**:  引导用户提供清晰的问题描述、区域类型、截图、日志和建议。
│   ├── workflows/
│   │   ├── check_yaml.yml    这个 YAML 文件定义了一个 GitHub Actions 工作流程，用于检查 `config` 目录下 YAML 文件的语法。 |  | *   **主要功能:** 在推送到 `main`, `YAML_Check`, 和 `dev` 分支，或创建拉取请求时，检查 `config` 目录下的 YAML 文件是否符合语法规范。 | *   **核心函数/步骤:** |     *   `actions/checkout@v3`: 检出代码。 |     *   `actions/setup-python@v4`: 设置 Python 环境。 |     *   `pip install yamllint`: 安装 `yamllint` 工具。 |     *   `yamllint config -c config/.yamllint`: 使用 `yamllint` 检查 `config` 目录下的 YAML 文件，并使用指定的配置文件。 | *   **重要功能点:** |     *   触发条件：`push` 和 `pull_request` 事件，且文件路径匹配 `config/**`。 |     *   使用 `yamllint` 进行 YAML 语法检查。 |     *   指定了 Python 版本。
│   │   └── locale-po.yml    这个 YAML 文件定义了一个 GitHub Actions 工作流程，用于将 `.po` 文件编译成 `.mo` 文件。 |  | *   **主要功能:** 自动编译 `.po` 翻译文件并提交更改。 | *   **核心函数/脚本:** `src/one_dragon/devtools/compile_po.py` (用于编译 `.po` 文件)。 | *   **重要功能点:** |     *   触发条件：在 `main` 和 `dev_locale` 分支的推送，以及 `.po` 文件或 `locale-po.yml` 文件更改时触发。 |     *   使用 Python 3.11 环境。 |     *   安装 `polib` 库。 |     *   运行 `compile_po.py` 脚本编译 `.po` 文件。 |     *   如果编译后有更改，则提交 `.mo` 文件到仓库。
│   └── 开发文档/
│       ├── 开发指南.md    这个 Markdown 文件提供了 Python 应用程序的开发和打包指南。 |  | *   **主要功能:** 描述了设置开发环境和打包 Python 应用程序的步骤。 | *   **核心类和函数:**  无特定类或函数，主要涉及命令行指令。 | *   **重要功能点:** |     *   Python 环境设置，推荐 Python 3.11.9。 |     *   使用 `pip` 和 `pip-compile` 管理依赖。 |     *   使用 `pyinstaller` 打包应用程序，包括生成 `.spec` 文件。 |     *   提供了打包安装器、完整运行器和调度器等多个可执行文件的命令。
│       └── 版本更新.md    这个 Markdown 文件描述了游戏更新的内容，主要集中在角色和皮肤的更新。 |  | **主要功能：** |  | *   新增角色和皮肤，并提供相关的配置和测试。 |  | **核心类和函数：** |  | *   `agent.py`：`AgentEnum` (增加角色) | *   `call_for_support.py`：`reject_agent` (增加拒绝选项) | *   `agent_outfit_config.py`：(增加皮肤选项) | *   `zzz_one_dragon_setting_interface.py`：`get_agent_outfit_group`, `on_interface_shown` (皮肤相关) | *   `zzz_context.py`：`init_agent_template_id` (皮肤初始化) | *   `agent_state_checker.check_length_by_background_gray` (状态条识别) |  | **重要功能点：** |  | *   **角色更新：** 增加新角色，包括角色名称、头像截图、状态判断和测试。 | *   **角色状态：** 描述了角色状态的识别原理，基于颜色判断，并提供了测试和模板管理的流程。 | *   **皮肤更新：** 增加新皮肤，包括配置、截图和界面初始化。 | *   **配置文件更新：** 更新了 `.yml` 文件，增加了拒绝选项和空洞事件。
├── assets/
│   ├── game_data/
│   │   ├── coffee_data.yml    ## 代码摘要 |  | **文件:** `.\assets\game_data\coffee_data.yml` |  | **主要功能:**  定义游戏中的咖啡数据，包括咖啡名称、以及与任务相关的配置信息。同时包含一个排班表，指定了每天提供的咖啡。 |  | **核心数据结构:** |  | *   `coffee_list`:  一个列表，包含多个咖啡的配置信息，每个咖啡配置是一个字典，包含 `coffee_name` (咖啡名称) 以及其他可选字段，如 `tab_name`, `category_name`, `mission_type_name`, `mission_name` 和 `extra`。 | *   `schedule`:  一个列表，定义了咖啡的排班表，包含 `days` (星期几) 和 `coffee_list` (当天提供的咖啡列表)。 |  | **重要功能点:** |  | *   定义了各种咖啡的名称。 | *   为咖啡关联了任务信息，包括任务所属的标签、类别、任务类型和任务名称。 | *   `extra` 字段用于标记特殊咖啡。 | *   通过 `schedule` 定义了每天提供的咖啡。
│   │   ├── compendium_data.yml    **摘要:** |  | 该 YAML 文件定义了游戏中的任务数据，主要用于组织和管理不同类型的任务。 |  | **核心结构:** |  | *   `tab_name`: 定义任务标签页的名称，如 "目标"、"日常"、"训练"、"作战"。 | *   `category_list`: 定义任务类别，如 "实战模拟室"、"定期清剿"、"恶名狩猎"、"零号空洞"等。 | *   `mission_type_list`: 定义任务类型，如 "基础材料"、"代理人晋升"、"迷失之地"等。 | *   `mission_list`: 定义具体任务，包含 `mission_name` 和 `mission_name_display`，用于显示任务名称。 |  | **重要功能点:** |  | *   定义了不同类型的任务，包括训练、作战等。 | *   组织任务通过标签页、类别和类型进行分类。 | *   为每个任务定义了名称和显示名称。 | *   用于配置游戏中的任务系统，包括任务的组织结构和名称。
│   │   ├── map_area.yml    这个 YAML 文件的主要功能是定义游戏地图中的区域及其传送点 (tp_list)。 |  | 核心结构： |  | *   文件包含一个 YAML 列表，每个元素代表一个地图区域。 | *   每个区域是一个字典，包含： |     *   `area_name`: 区域的名称 (字符串)。 |     *   `tp_list`: 一个列表，包含该区域的传送点名称 (字符串列表)。 |  | 重要功能点： |  | *   定义了游戏中不同地图区域的名称。 | *   列出了每个区域中可供玩家传送到的地点。 | *   用于游戏中地图的导航和传送功能。
│   │   ├── agent/
│   │   │   ├── anby.yml    这个 YAML 文件定义了一个名为 "安比" 的游戏代理的数据。 |  | *   **主要功能:** 储存游戏中代理角色的配置数据。 | *   **核心数据:** |     *   `agent_name`: 代理名称，设定为 "安比"。 |     *   `agent_type`: 代理类型，设定为 "STUN"。 |     *   `dmg_type`: 伤害类型，设定为 "ELECTRIC"。 |     *   `rare_type`: 稀有度类型，设定为 "A"。 | *   **重要功能点:**  定义了代理的基础属性，包括名称、类型、伤害类型和稀有度。
│   │   │   ├── anton.yml    这个 YAML 文件定义了一个游戏中名为“安东”的 Agent 的数据。 |  | *   **主要功能:** 储存 Agent 的属性数据。 | *   **核心类/函数:**  无 (YAML 文件，没有类或函数)。 | *   **重要功能点:** |     *   `agent_name`:  Agent 的名称 ("安东")。 |     *   `agent_type`: Agent 的类型 ("ATTACK")。 |     *   `dmg_type`: 伤害类型 ("ELECTRIC")。 |     *   `rare_type`: 稀有度 ("A")。
│   │   │   ├── ben.yml    这个 YAML 文件定义了一个游戏中名为 "本" 的 Agent 的数据。 |  | *   **主要功能:** 储存 Agent "本" 的配置数据。 | *   **核心数据:** |     *   `agent_name`: "本" (Agent 的名称) |     *   `agent_type`: "DEFENSE" (Agent 的类型，防御型) |     *   `dmg_type`: "FIRE" (Agent 的伤害类型，火焰) |     *   `rare_type`: "A" (Agent 的稀有度，A级) | *   **重要功能点:** 定义了 Agent 的基本属性，用于游戏逻辑。
│   │   │   ├── billy.yml    这个 YAML 文件定义了一个名为 "比利" 的游戏代理 (agent) 的数据。 |  | *   **主要功能:** 储存游戏中代理 "比利" 的配置数据。 | *   **核心数据:** |     *   `agent_name`: 代理的名称，设定为 "比利"。 |     *   `agent_type`: 代理的类型，设定为 "ATTACK"。 |     *   `dmg_type`: 代理的伤害类型，设定为 "ELECTRIC"。 |     *   `rare_type`: 代理的稀有度类型，设定为 "A"。 | *   **重要功能点:** 定义了代理的名称、类型、伤害类型和稀有度，这些数据将用于游戏中代理的生成、行为和属性设定。
│   │   │   ├── corin.yml    这个 YAML 文件定义了一个游戏中名为“可琳”的 Agent 的数据。 |  | *   **主要功能:** 描述游戏角色“可琳”的属性。 | *   **核心数据:** |     *   `agent_name`: "可琳" - Agent 的名称。 |     *   `agent_type`: "ATTACK" - Agent 的类型，表明其为攻击型角色。 |     *   `dmg_type`: "PHYSICAL" - 伤害类型为物理伤害。 |     *   `rare_type`: "A" - Agent 的稀有度等级。 | *   **重要功能点:**  定义了 Agent 的基本属性，包括名称、类型、伤害类型和稀有度，这些属性将用于游戏逻辑中。
│   │   │   ├── ellen.yml    这个 YAML 文件定义了一个游戏角色「艾莲」的数据。 |  | *   **主要功能:** 储存游戏角色「艾莲」的属性数据。 | *   **核心数据:** |     *   `agent_name`: 角色名称，设定为「艾莲」。 |     *   `agent_type`: 角色类型，设定为「ATTACK」（攻击型）。 |     *   `dmg_type`: 伤害类型，设定为「ICE」（冰属性）。 |     *   `rare_type`: 稀有度，设定为「S」。 | *   **重要功能点:**  定义了角色的基本属性，包括名称、类型、伤害属性和稀有度。
│   │   │   ├── grace.yml    这个 YAML 文件定义了一个名为 "格莉丝" 的游戏角色数据。 |  | *   **主要功能:** 储存游戏角色 "格莉丝" 的属性数据。 | *   **核心元素:** |     *   `agent_name`: 角色名称 ("格莉丝")。 |     *   `agent_type`: 角色类型 ("ATTACK")。 |     *   `dmg_type`: 伤害类型 ("ELECTRIC")。 |     *   `rare_type`: 稀有度 ("S")。 | *   **重要功能点:**  定义了角色的基本属性，包括名称、类型、伤害类型和稀有度，这些数据将用于游戏中的角色生成和属性计算。
│   │   │   ├── koleda.yml    这个 YAML 文件定义了一个名为 "珂蕾妲" 的游戏代理人的数据。 |  | *   **主要功能:** 描述游戏中一个代理人的属性。 | *   **核心数据:** |     *   `agent_name`: 代理人名称 ("珂蕾妲")。 |     *   `agent_type`: 代理人类型 ("STUN")。 |     *   `dmg_type`: 伤害类型 ("FIRE")。 |     *   `rare_type`: 稀有度 ("S")。 | *   **重要功能点:** 描述了代理人的基本属性，包括名称、类型、伤害类型和稀有度。
│   │   │   ├── lucy.yml    这个 YAML 文件定义了一个名为 "露西" 的游戏代理的数据。 |  | *   **主要功能:** 储存游戏中代理角色的配置数据。 | *   **核心数据:** |     *   `agent_name`: 代理名称，设定为 "露西"。 |     *   `agent_type`: 代理类型，设定为 "SUPPORT"。 |     *   `dmg_type`: 伤害类型，设定为 "FIRE"。 |     *   `rare_type`: 稀有度，设定为 "A"。 | *   **重要功能点:**  定义了代理的基本属性，包括名称、类型、伤害类型和稀有度。
│   │   │   ├── lycaon.yml    这个 YAML 文件定义了一个名为 "莱卡恩" 的游戏代理（agent）的数据。 |  | *   **主要功能:** 储存游戏中代理的配置数据。 | *   **核心数据:** |     *   `agent_name`: 代理的名称，为 "莱卡恩"。 |     *   `agent_type`: 代理的类型，为 "STUN"。 |     *   `dmg_type`: 代理的伤害类型，为 "ICE"。 |     *   `rare_type`: 代理的稀有度，为 "S"。 | *   **重要功能点:** 定义了代理的名称、类型、伤害类型和稀有度，这些是游戏中代理的基本属性。
│   │   │   ├── nekomata.yml    这个 YAML 文件定义了一个名为 "猫又" 的游戏代理（agent）的数据。 |  | *   **主要功能:** 描述游戏中一个攻击型代理的属性。 | *   **核心数据:** |     *   `agent_name`: "猫又" (代理的名称) |     *   `agent_type`: "ATTACK" (代理的类型，表示攻击型) |     *   `dmg_type`: "PHYSICAL" (伤害类型，表示物理伤害) |     *   `rare_type`: "S" (稀有度，表示S级) | *   **重要功能点:**  定义了代理的名称、类型、伤害类型和稀有度，这些属性将影响游戏中的代理行为和强度。
│   │   │   ├── nicole.yml    这个 YAML 文件定义了一个游戏中名为 "妮可" 的 Agent 的数据。 |  | *   **主要功能:** 储存 Agent "妮可" 的属性数据。 | *   **核心数据:** |     *   `agent_name`: "妮可" - Agent 的名称。 |     *   `agent_type`: "SUPPORT" - Agent 的类型，为支援型。 |     *   `dmg_type`: "ETHER" - Agent 的伤害类型，为以太。 |     *   `rare_type`: "A" - Agent 的稀有度，为 A 级。 | *   **重要功能点:** 定义了 Agent 的基本属性，用于游戏内的角色设定。
│   │   │   ├── piper.yml    这个 YAML 文件定义了一个名为 "派派" 的游戏代理（Agent）的数据。 |  | *   **主要功能:** 描述游戏中一个攻击型代理的属性。 | *   **核心数据:** |     *   `agent_name`: "派派" - 代理的名称。 |     *   `agent_type`: "ATTACK" - 代理的类型，表明它是一个攻击型代理。 |     *   `dmg_type`: "PHYSICAL" - 代理的伤害类型，为物理伤害。 |     *   `rare_type`: "A" - 代理的稀有度，为 A 级。 | *   **重要功能点:**  定义了代理的名称、类型、伤害类型和稀有度，这些是游戏中代理的基本属性。
│   │   │   ├── rina.yml    这个 YAML 文件定义了一个游戏内的角色 "丽娜" 的数据。 |  | *   **主要功能:** 描述游戏角色 "丽娜" 的属性。 | *   **核心数据:** |     *   `agent_name`: 角色名称 ("丽娜") |     *   `agent_type`: 角色类型 ("SUPPORT") |     *   `dmg_type`: 伤害类型 ("ELECTRIC") |     *   `rare_type`: 稀有度 ("S") | *   **重要功能点:**  定义了角色的基本属性，包括角色类型、伤害类型和稀有度，这些信息将用于游戏的逻辑和角色管理。
│   │   │   ├── soldier_11.yml    这个 YAML 文件定义了一个游戏中名为 "11号" 的士兵的 Agent 数据。 |  | *   **主要功能:** 描述游戏中士兵 Agent 的属性。 | *   **核心数据:** |     *   `agent_name`: "11号" (Agent 的名称) |     *   `agent_type`: "ATTACK" (Agent 的类型，表示攻击型) |     *   `dmg_type`: "FIRE" (Agent 的伤害类型，表示火焰伤害) |     *   `rare_type`: "S" (Agent 的稀有度，表示 S 级) | *   **重要功能点:** 定义了 Agent 的基本属性，包括名称、类型、伤害类型和稀有度，这些属性将用于游戏逻辑中。
│   │   │   ├── soukaku.yml    这个 YAML 文件定义了一个游戏角色 "苍角" 的数据。 |  | *   **主要功能:** 描述游戏角色 "苍角" 的属性。 | *   **核心数据:** |     *   `agent_name`: 角色名称 ("苍角") |     *   `agent_type`: 角色类型 ("SUPPORT") |     *   `dmg_type`: 伤害类型 ("ICE") |     *   `rare_type`: 稀有度 ("A") | *   **重要功能点:**  定义了角色的基本属性，包括角色名称、类型、伤害类型和稀有度。
│   │   │   └── zhu_yuan.yml    这个 YAML 文件定义了一个游戏角色 "朱鸢" 的数据。 |  | *   **主要功能:** 描述游戏角色 "朱鸢" 的属性。 | *   **核心数据:** |     *   `agent_name`: 角色名称 ("朱鸢") |     *   `agent_type`: 角色类型 ("ATTACK") |     *   `dmg_type`: 伤害类型 ("ETHER") |     *   `rare_type`: 稀有度 ("S") | *   **重要功能点:** 定义了角色的基本属性，包括名称、类型、伤害类型和稀有度。
│   │   ├── hollow_zero/
│   │   │   ├── entry_list.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏 "Hollow Zero" 中的一系列入口点（entry points），这些入口点可能是游戏中的场景、地点或事件。 |  | **核心数据结构:** |  | *   **列表 (List):** 文件内容是一个 YAML 列表，每个元素代表一个入口点。 | *   **字典 (Dictionary):** 每个入口点是一个字典，包含以下键值对： |     *   `entry_name`: 入口点的名称 (字符串)。 |     *   `is_benefit`:  一个布尔值，指示该入口点是否为 "收益" 类型。 |     *   `can_visited_times`:  一个整数，表示可以访问该入口点的次数。 |     *   `can_go`:  一个布尔值，指示是否可以进入该入口点。 |     *   `need_step`:  一个整数，表示进入该入口点所需的步数。 |     *   `is_tp`:  一个布尔值，指示该入口点是否为传送点。 |     *   `is_base`:  一个布尔值，指示该入口点是否为基地。 |     *   `move_afterwards`:  一个布尔值，指示进入该入口点后是否移动。 |  | **重要功能点:** |  | *   定义了游戏中的各种入口点，例如 "起点"、"扭蛋机"、"传送点" 等。 | *   使用 `is_benefit` 属性区分收益型入口点。 | *   使用 `can_visited_times` 限制入口点的访问次数。 | *   使用 `can_go` 和 `need_step` 控制入口点的可访问性。 | *   使用 `is_tp` 标记传送点。 | *   使用 `is_base` 标记基地。 | *   使用 `move_afterwards` 标记进入入口点后是否移动。
│   │   │   ├── resonium.yml    ## 摘要 |  | **文件功能:** |  | 该 YAML 文件定义了一系列游戏内的物品，包括名称、分类（category）和稀有度（level）。这些物品涵盖了多个类别，例如“契合”、“邦布”、“通用”、“诡术”、“研究”、“协助”、“空洞”、“闪避”、“护盾”、“决斗”、“能量”、“暴击”、“支援”、“感电”、“冻结”、“强袭”、“引燃”、“以太”和“顽强”。 |  | **核心类和函数:** |  | *   **无核心类或函数:** 该文件主要由数据组成，没有定义任何类或函数。 | *   **数据结构:** 数据以 YAML 格式组织，每个物品由 `category`, `name`, 和 `level` 字段定义。 |  | **重要功能点:** |  | *   **物品定义:** 文件定义了大量游戏物品，为游戏提供了丰富的内容。 | *   **分类:** 物品按不同的类别进行组织，方便游戏设计和管理。 | *   **稀有度:** 每个物品都有一个稀有度等级，可能用于游戏平衡或物品掉落机制。 | *   **数据驱动:** 游戏的物品数据存储在 YAML 文件中，使得修改和更新物品变得容易。
│   │   │   ├── lost_void/
│   │   │   │   ├── lost_void_artifact_data.yml    **摘要:** |  | *   **主要功能:** 该文件定义了游戏《失落虚空》中各种类型的装备数据，包括终结、机敏、异常·击破、绝境、角色专属装备、通用装备、契合装备、卡牌和杰佩托等。 | *   **核心类和函数:**  该文件使用YAML格式存储数据，没有显式的类或函数定义。数据以列表形式组织，每个元素代表一个装备，包含 `category` (类别), `name` (名称), `level` (等级), 和 `template_id` (模板ID)等字段。 | *   **重要功能点:** |     *   定义了大量不同类型的装备，涵盖了多种游戏机制和角色。 |     *   装备按照类别和等级进行组织，方便游戏内的数据管理和调用。 |     *   每个装备都有一个唯一的 `template_id`，用于关联游戏内的具体实现。
│   │   │   │   └── lost_void_det_class.yml    这个 YAML 文件定义了一系列游戏中的类别，用于描述《空洞骑士》游戏中“遗忘虚空”区域的各种事件和元素。 |  | *   **主要功能:** 定义游戏中不同类型的事件和元素的类别。 | *   **核心结构:**  YAML 文件使用列表结构，每个元素是一个字典，包含 `class_idx` (类别索引) 和 `class_name` (类别名称) 两个键值对。 | *   **重要功能点:** |     *   定义了多个类别，涵盖了游戏中的不同方面，如战斗、挑战、偶遇事件、商店等。 |     *   `class_idx` 用于唯一标识每个类别。 |     *   `class_name` 提供了类别的可读名称，方便游戏开发和维护。
│   │   │   └── normal_event/
│   │   │       ├── 以太露滴.yml    这个 YAML 文件定义了一个名为「以太露滴」的游戏事件。 |  | *   **主要功能:** 定义了游戏中一个事件的内容，包括事件名称、选项及其描述。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "以太露滴"。 |     *   `event_name`: 事件的显示名称，为 "以太露滴"。 |     *   `options`:  一个列表，定义了玩家在事件中可以选择的选项。 |         *   `option_name`: 选项的名称，例如 "制作为治疗喷雾"、"将以太露滴收集储存"、"直接离开"。 |         *   `desc`: 选项的描述，说明选择该选项的效果。 | *   **重要功能点:** |     *   定义了玩家可以选择的三个选项：制作治疗喷雾（回复全队生命值）、收集储存以太露滴、直接离开。 |     *   每个选项都配有描述，说明选择后的效果。
│   │   │       ├── 侵蚀扭蛋机.yml    这个 YAML 文件定义了一个游戏事件，名为 "侵蚀扭蛋机"，属于 "古怪装置" 事件。它提供了两个选项：选择一枚 "诡术鸣徽" 或离开。 |  | *   **主要功能:** 定义游戏中的一个事件及其选项。 | *   **核心元素:** |     *   `entry_name`: 事件的入口名称，为 "侵蚀扭蛋机"。 |     *   `event_name`: 事件的名称，为 "古怪装置"。 |     *   `options`: 事件提供的选项列表。 | *   **重要功能点:**  定义了玩家与事件互动的选项，包括选择物品或离开。
│   │   │       ├── 假面研究者.yml    这个 YAML 文件定义了一个名为 "假面研究者" 的游戏事件。 |  | *   **主要功能:** 定义了游戏中与 "假面研究者" 互动时的选项和结果。 | *   **核心元素:**  `entry_name`, `event_name`, `options`。`options` 包含多个选项，每个选项都有 `option_name` 和可选的 `desc` (描述)。 | *   **重要功能点:** |     *   多种选项，提供不同的游戏内奖励或效果，例如：获得物品（鸣徽、炸弹、邦布、齿轮硬币、立体复印）、触发事件、治疗效果（消除侵蚀、恢复生命值）、商店。 |     *   部分选项带有描述，说明选择后的具体效果。
│   │   │       ├── 全自动医疗仓.yml    这个 YAML 文件定义了游戏中的一个事件 "全自动医疗仓" 及其相关选项。 |  | *   **主要功能:** 定义了游戏事件 "全自动医疗仓" 的行为，包括触发条件和玩家可选择的选项。 | *   **核心类/函数:**  `entry_name`, `event_name`, `options`, `option_name`, `desc` (这些是 YAML 文件中的关键字段，用于定义事件的结构和内容)。 | *   **重要功能点:** |     *   事件 "全自动医疗仓" 及其两个实例。 |     *   第一个实例定义了两个选项: "启动医疗仓" (描述为将存活代理人的生命值按比例均分给全队) 和 "暂时离开"。 |     *   第二个实例仅定义了事件名称 "启动医疗仓"。
│   │   │       ├── 同伴.yml    这个 YAML 文件定义了一个游戏事件，名为 "鬼鬼祟祟的学者"。 |  | *   **主要功能:** 定义游戏中的一个事件，用于触发游戏内容。 | *   **核心元素:** |     *   `entry_name`:  事件的入口名称，值为 "同伴"。 |     *   `event_name`:  事件的名称，值为 "鬼鬼祟祟的学者"。 | *   **重要功能点:**  定义了游戏中一个特定事件的元数据，用于游戏逻辑的触发和处理。
│   │   │       ├── 呼叫增援-拒绝.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏中“呼叫增援”事件在不同角色下的响应，以及玩家拒绝增援时获得的奖励。 |  | **核心类和函数:** |  | *   **`entry_name`**:  定义了事件的名称，都为“呼叫增援”。 | *   **`event_name`**:  定义了角色对事件的回复。 | *   **`options`**: 定义了玩家拒绝增援后可以获得的奖励，均为随机获得不同类型的鸣徽。 | *   **`option_name`**: 定义了奖励的描述，即随机获得哪种类型的鸣徽。 |  | **重要功能点:** |  | *   **角色差异化响应**: 针对不同角色，`event_name` 提供了不同的文本回复，增加了游戏的个性化。 | *   **奖励机制**:  玩家拒绝增援后，会随机获得一种特定类型的鸣徽，这是一种游戏内的奖励机制。 | *   **鸣徽类型多样性**:  提供了多种不同类型的鸣徽作为奖励，包括以太、冻结、感电、引燃、强袭、决斗、暴击、能量、支援、护盾、闪避、通用和顽强，增加了游戏策略性。 | *   **数据驱动**:  使用 YAML 文件存储数据，方便修改和扩展游戏内容。
│   │   │       ├── 奇怪的侦探.yml    这个 YAML 文件定义了一个游戏事件，名为 "奇怪的侦探"。 |  | *   **主要功能:** 定义游戏中的一个事件，可能用于触发剧情、提供任务或与玩家互动。 | *   **核心元素:** |     *   `entry_name`:  事件的内部名称，为 "奇怪的侦探"。 |     *   `event_name`:  事件的显示名称，为 "旧都失物奇怪的侦探"。 | *   **重要功能点:**  定义了事件的标题和描述，用于在游戏中识别和呈现该事件。
│   │   │       ├── 奇怪的学生.yml    这个 YAML 文件定义了一个名为 "奇怪的学生" 的游戏事件，属于 "旧都失物奇怪的少女" 事件。 |  | *   **主要功能:** 定义游戏中的一个事件，包含事件名称、选项列表。 | *   **核心元素:** |     *   `entry_name`: 事件的入口名称，为 "奇怪的学生"。 |     *   `event_name`: 事件的名称，为 "旧都失物奇怪的少女"。 |     *   `options`: 一个选项列表，定义了玩家在事件中可以选择的选项。 | *   **重要功能点:**  定义了玩家在事件中可以选择的各种选项，例如离开、攻击、拒绝邀请、询问等，这些选项将影响游戏的进程。
│   │   │       ├── 奇货.yml    这个 YAML 文件定义了一个名为 "奇货" 的游戏事件，描述了一个自动贩卖机。 |  | *   **主要功能:** 定义游戏中的一个事件，玩家可以通过不同的选项与自动贩卖机互动，并获得不同的奖励。 | *   **核心元素:** |     *   `entry_name`: 事件的唯一标识符，为 "奇货"。 |     *   `event_name`: 事件的显示名称，为 "事件人工自动贩卖机"。 |     *   `options`:  一个选项列表，每个选项代表玩家与贩卖机互动的不同方式。 | *   **重要功能点:** |     *   不同的选项允许玩家以不同方式与贩卖机互动，例如 "拆开贩卖机一探究竞"、"大量投币"、"正常投币"、"恐吓贩卖机"、"搜集浓缩医疗"。 |     *   每个选项都有不同的描述 (`desc`)，说明选择该选项后玩家会获得的奖励或产生的影响。 |     *   奖励包括稀有邦布插件、普通邦布插件和浓缩医疗，以及压力值的变化。 |     *   `lcs_percent`:  可能表示事件触发的机率或相关的逻辑。
│   │   │       ├── 对空部特遣队.yml    这个 YAML 文件定义了一个游戏事件 "对空部特遣队"。 |  | *   **主要功能:** 定义了游戏中的一个事件，包含事件名称、选项及其对应的奖励。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "对空部特遣队"。 |     *   `event_name`: 事件的显示名称，为 "事件对空部特遣队"。 |     *   `options`: 一个选项列表，每个选项代表玩家可以选择的操作。 |         *   `option_name`: 选项的名称。 |         *   `desc`: 选项的描述，说明选择该选项后玩家将获得的奖励，例如 "获得2个浓缩医疗" 或 "获得协助类型B级鸣徽"。 | *   **重要功能点:** 定义了玩家在游戏中可以选择的事件选项，以及每个选项对应的奖励。
│   │   │       ├── 怀斯塔学会研究站.yml    这个 YAML 文件定义了一个游戏事件，名为 "怀斯塔学会研究站"。 |  | *   **主要功能:** 定义了游戏中一个名为 "怀斯塔学会研究站" 的事件及其选项。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "怀斯塔学会研究站"。 |     *   `event_name`: 事件的显示名称，为 "事件怀斯塔学会研究站"。 |     *   `options`:  一个列表，定义了玩家可以选择的选项。 | *   **重要功能点:** |     *   定义了三个选项，每个选项都有 `option_name` 和 `desc` 描述。 |     *   选项包括： |         *   "想要点武装物资"： 奖励 2 枚 "[空洞] 鸣徽"。 |         *   "再多要一些"： 增加 70 点压力值。 |         *   "离开"： 退出事件。
│   │   │       ├── 房屋残骸.yml    这个 YAML 文件定义了一个名为 "房屋残骸" 的游戏事件。 |  | *   **主要功能:** 定义游戏中的一个事件，包含事件名称、触发机率（`lcs_percent`）以及多个选项，每个选项都描述了玩家可以采取的行动及其结果。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "房屋残骸"。 |     *   `event_name`: 事件的显示名称，为 "事件坍塌的房屋"。 |     *   `lcs_percent`: 事件触发的机率，为 0.6。 |     *   `options`: 一个列表，包含玩家可以选择的选项，每个选项都有 `option_name` 和 `desc` 描述。 | *   **重要功能点:** |     *   事件包含多个选项，每个选项都提供不同的结果，例如获得齿轮硬币、承受侵蚀症状、损失生命值、资源受损或消耗物品。 |     *   选项提供了多样化的互动，包括探索、资源管理和风险评估。
│   │   │       ├── 投机客.yml    这个 YAML 文件定义了游戏中名为「投机客」的事件及其相关选项。 |  | *   **主要功能:** 描述了游戏事件「投机客」的各种互动选项，包括借款、获取资源、消除负面状态、恢复生命值、以及还款等。 | *   **核心类/函数:**  该文件使用 YAML 格式，没有类或函数的概念，但定义了两个主要的 `entry_name`，分别是 "投机客" 和 "投机客的提醒"，每个 `entry_name` 下包含了 `event_name` 和 `options` 列表。 | *   **重要功能点:** |     *   多种借款选项，提供不同金额的齿轮硬币。 |     *   提供获取稀有资源的选项，例如「超级物资」和「物资大礼包」。 |     *   提供消除负面状态的选项，例如「净化侵蚀」和「清除压力」。 |     *   提供恢复生命值的选项，例如「身体康复训练」和「恢复身体」。 |     *   提供催化鸣徽的选项。 |     *   提供还款选项。 |     *   「投机客的提醒」事件提供还款相关的选项。
│   │   │       ├── 有偿休息站.yml    这个 YAML 文件定义了游戏中名为「有偿休息站」的事件，包含了多个子事件，每个子事件都有不同的选项。 |  | *   **主要功能:** 定义游戏中的事件，提供玩家在「有偿休息站」中的互动选项。 | *   **核心元素:** |     *   `entry_name`: 事件的入口名称，都为 "有偿休息站"。 |     *   `event_name`: 子事件的名称，例如 "热闹的休息站"、"救助伤员"、"互通有无"、"有偿实验"、"事件有偿休息站"。 |     *   `options`: 每个子事件的选项列表，包含 `option_name` 和可选的 `desc` (描述)。 | *   **重要功能点:** |     *   不同的子事件提供了不同的互动方式，例如打听消息、救助伤员、交易、实验等。 |     *   部分选项会消耗资源（例如生命值、齿轮硬币）或影响状态（例如压力值、侵蚀）。 |     *   `desc` 字段提供了选项的详细描述，说明了选择该选项的后果。
│   │   │       ├── 求救信号.yml    这个 YAML 文件定义了一个游戏事件，名为 "求救信号"。 |  | *   **主要功能:** 定义了游戏中名为 "求救信号" 的事件，包含事件名称和玩家可选择的选项。 | *   **核心元素:** |     *   `entry_name`: "求救信号" - 事件的内部标识符。 |     *   `event_name`: "事件求救信号" - 事件的显示名称。 |     *   `options`: 一个列表，定义了玩家在事件中可以选择的选项，例如 "进行信号源分析"、"直接进入"、"无视信号" 等。 | *   **重要功能点:**  定义了玩家在事件中可以选择的各种选项，这些选项将影响游戏的进程。
│   │   │       ├── 治安官小队.yml    这个 YAML 文件定义了一个游戏事件 "治安官小队" (治安官小队)。 |  | *   **主要功能:** 定义游戏中的一个事件，包含事件名称、触发几率 (lcs_percent) 和多个选项。 | *   **核心类/函数:**  无特定类或函数，文件本身即是数据定义。 | *   **重要功能点:** |     *   `entry_name`: 事件的内部识别名称，为 "治安官小队"。 |     *   `event_name`: 事件的显示名称，为 "治安局预备队"。 |     *   `lcs_percent`: 事件触发几率，为 0.5 (50%)。 |     *   `options`:  定义了玩家在事件中可以选择的选项，包含三个选项: "我一定要珍惜地使用", "不要白不要", "冒风险才有收益"。
│   │   │       ├── 活化结晶.yml    这个 YAML 文件定义了一个名为 "活化结晶" 的游戏事件。 |  | *   **主要功能:** 定义了游戏中一个事件的相关数据，包括事件名称、触发概率和玩家可选择的选项。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "活化结晶"。 |     *   `event_name`: 事件的显示名称，为 "活化结晶"。 |     *   `lcs_percent`: 事件触发的概率，为 0.6 (60%)。 |     *   `options`:  一个列表，定义了玩家可以选择的选项。每个选项包含 `option_name` (选项名称) 和 `desc` (选项描述)。 | *   **重要功能点:** |     *   定义了三个不同的选项，每个选项都提供了不同的奖励和负面效果 (侵蚀)。 |     *   选项的描述清楚地说明了每个选项的结果，包括获得的资源、生命值恢复、侵蚀状态的改变以及其他游戏状态的影响。
│   │   │       ├── 盗洞客.yml    这个 YAML 文件定义了游戏中与名为“盗洞客”相关的事件和选项。 |  | *   **主要功能:** 定义了游戏事件的结构，包括事件名称、入口名称和玩家可选择的选项。 | *   **核心结构:**  文件使用 YAML 格式，以列表的形式定义事件。每个事件包含 `entry_name`, `event_name` 和 `options` 字段。 | *   **重要功能点:** |     *   定义了三个不同的事件，都与“盗洞客”相关。 |     *   每个事件都提供了不同的选项，供玩家选择，例如获取物资、拒绝合作或继续前进。 |     *   其中一个事件涉及到“石头剪子布”游戏。
│   │   │       ├── 盗洞客集会.yml    这个 YAML 文件定义了游戏中的两个事件，名为 "盗洞客集会"，它们都属于 "因缘际会" 事件。 每个事件都包含一系列选项，这些选项会影响游戏状态，例如增加或减少资源、改变生命值、压力值，或提供特殊物品。 |  | 核心类和函数： |  | *   **`entry_name`**:  事件的唯一标识符，这里都是 "盗洞客集会"。 | *   **`event_name`**: 事件的名称，这里都是 "因缘际会"。 | *   **`options`**:  包含玩家可选择的选项列表。 | *   **`option_name`**:  选项的名称。 | *   **`desc`**:  选项的描述，说明选项的影响。 |  | 重要功能点： |  | *   定义了多个选项，这些选项提供了不同的游戏内效果，包括资源增减、生命值变化、压力值变化、以及物品的获得或失去。 | *   选项涵盖了正面和负面效果，增加了游戏的策略性和风险。 | *   选项的描述清晰地说明了每个选项的后果，方便玩家做出选择。
│   │   │       ├── 盲盒区域.yml    这个 YAML 文件定义了游戏中与「盲盒区域」相关的事件和选项。 |  | *   **主要功能:** 定义了游戏中与盲盒区域互动的事件流程和选项。 | *   **核心类/函数:**  没有类或函数，只有YAML数据结构。 | *   **重要功能点:** |     *   `entry_name`:  事件的标题，例如 "盲盒区域" 和 "不宜久留"。 |     *   `event_name`:  事件的描述，例如 "特殊区域播报" 和 "特殊区域"。 |     *   `options`:  玩家可以选择的选项，例如 "拉四下", "拉一下", "离开", "确认继续"。
│   │   │       ├── 真相.yml    这个 YAML 文件定义了一个名为 "真相" 的游戏事件，描述了事件的名称、触发概率、以及玩家可选择的选项。 |  | *   **主要功能:** 定义游戏中的一个事件，包含事件名称、触发概率和选项。 | *   **核心元素:** |     *   `entry_name`: 事件的唯一标识符，这里为 "真相"。 |     *   `event_name`: 事件的显示名称，这里为 "事件药剂说明书"。 |     *   `lcs_percent`: 事件触发的概率，这里为 0.6 (60%)。 |     *   `options`: 玩家可选择的选项列表。 |         *   `option_name`: 选项的名称。 |         *   `desc`: 选项的描述，例如 "压力值+100"。 | *   **重要功能点:** |     *   定义了两个选项："不使用" 和 "直接使用一点点"，后者会增加玩家的压力值。
│   │   │       ├── 秘医.yml    这个 YAML 文件定义了一个名为“秘医”的游戏事件，它提供了多个选项供玩家选择，每个选项都会产生不同的结果。 |  | *   **主要功能:** 定义游戏中的一个事件，玩家可以通过选择不同的选项来获得不同的奖励或承受不同的后果。 | *   **核心类/函数:**  该文件是数据文件，没有类或函数。它使用 YAML 格式来定义事件的结构和选项。 | *   **重要功能点:** |     *   提供多种选项，包括： |         *   获取医疗物品（浓缩医疗）。 |         *   获取鸣徽（护盾）。 |         *   恢复生命值。 |         *   获取齿轮硬币。 |         *   探查地图。 |         *   催化鸣徽。 |         *   获取补给品。 |         *   跳过事件。 |     *   选项会影响玩家的资源、生命值、压力值和游戏进度。
│   │   │       ├── 精锐邦布助手.yml    这个 YAML 文件定义了游戏中名为「精锐邦布助手」的事件，包含多个子事件和选项。 |  | *   **主要功能:** 定义游戏内的事件，提供玩家与「精锐邦布助手」互动的选项，这些选项会影响玩家的游戏资源和状态。 | *   **核心结构:** 文件使用 YAML 格式，以 `entry_name` 标识事件，`event_name` 标识子事件，`options` 包含玩家可选择的选项。 | *   **重要功能点:** |     *   「武装升级」事件：允许玩家用不同级别的鸣徽交换。 |     *   「随机交换」事件：允许玩家交换鸣徽。 |     *   「事件精锐邦布助手」事件：包含多个选项，例如增加压力值、复制物品、获得鸣徽或购买礼包。 |     *   `lcs_percent`: 可能是事件触发机率的参数。 |     *   `desc`: 描述选项的效果。
│   │   │       ├── 紧急撤离点.yml    这个 YAML 文件定义了游戏中的两个事件，都与“紧急撤离点”相关。 |  | *   **主要功能:** 定义了游戏中与紧急撤离相关的事件，以及玩家在这些事件中的选项。 | *   **核心结构:** 文件使用 YAML 格式，包含多个事件条目 (entries)。每个条目定义了 `entry_name` (事件入口名称), `event_name` (事件名称) 和 `options` (玩家选项列表)。 | *   **重要功能点:** |     *   定义了不同事件的名称，例如 "紧急撤离点" 和 "事件应急撒离点"。 |     *   每个事件都提供了多个玩家选项，例如 "不需要按下按钮" 和 "让X号队员离队体整"。 |     *   其中一个事件包含特定于角色的选项，例如 "还没到偷懒的时间"。
│   │   │       ├── 裂隙.yml    这个 YAML 文件定义了一个名为「裂隙」的游戏事件，包含事件名称和多个选项。每个选项都描述了不同的结果，例如压力值变化、角色生命值恢复或损失、物品遗失等。 |  | *   **主要功能:** 定义游戏中的一个事件及其选项和结果。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "裂隙"。 |     *   `event_name`: 事件的显示名称，为 "事件裂隙"。 |     *   `options`: 一个列表，包含事件的选项。 |         *   `option_name`: 选项的名称。 |         *   `desc`: 选项的描述，描述了选择该选项后发生的结果。 | *   **重要功能点:** |     *   定义了多种选项，每个选项都对游戏状态产生不同的影响，包括压力值变化、角色生命值变化、物品遗失等。 |     *   选项的多样性增加了游戏的互动性和随机性。
│   │   │       ├── 调查协会补给站.yml    这个 YAML 文件定义了一个游戏事件，名为「调查协会补给站」。 |  | *   **主要功能:** 定义了玩家在游戏中可以选择的选项，这些选项与获取补给品或产生其他游戏效果相关。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "调查协会补给站"。 |     *   `event_name`: 事件的显示名称，为 "事件协会支援站"。 |     *   `options`: 一个列表，包含玩家可以选择的选项。 | *   **重要功能点:** |     *   每个 `option_name` 定义了一个玩家可以选择的选项。 |     *   `desc` 字段描述了每个选项的效果，包括获得补给品、触发事件或影响玩家的状态（例如压力值）。 |     *   选项包括：兑换补给品、获取鸣徽、获取插件、恢复生命值等。
│   │   │       ├── 调查员.yml    这个 YAML 文件定义了一个名为 "调查员" 的游戏事件，该事件提供了多个选项供玩家选择。 |  | *   **主要功能:** 定义游戏中的一个事件，允许玩家与 "调查员" 互动并获得奖励。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "调查员"。 |     *   `event_name`: 事件的显示名称，为 "老练的调查员"。 |     *   `options`: 一个列表，定义了玩家可以选择的选项。 | *   **重要功能点:** |     *   提供多个选项，每个选项都有不同的描述和结果。 |     *   选项包括购买鸣徽、交换鸣徽、用压力值换取高级鸣徽，以及拒绝互动。 |     *   选项的结果包括消耗游戏内货币、交换物品、增加压力值和获得鸣徽。
│   │   │       ├── 资源回收小组.yml    这个 YAML 文件定义了一个名为 "资源回收小组" 的游戏事件。 |  | *   **主要功能:** 定义了游戏中一个事件的数据，包括事件名称、触发概率、以及玩家可以选择的选项。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "资源回收小组"。 |     *   `event_name`: 事件的显示名称，为 "资源回收小组"。 |     *   `lcs_percent`: 事件触发的概率，为 0.6 (60%)。 |     *   `options`: 包含多个选项的列表，每个选项定义了玩家可以采取的行动。 | *   **重要功能点:** |     *   定义了四个选项，每个选项都有不同的描述，包括购买、抢夺、求情和离开。 |     *   每个选项都与不同的游戏内资源消耗或影响相关，例如齿轮币、生命值和压力值。
│   │   │       ├── 通道.yml    这个 YAML 文件定义了游戏中名为“通道”的事件的配置数据。 |  | *   **主要功能**: 定义了游戏中的事件，包括事件名称、选项及其效果。 | *   **核心类和函数**:  此文件是数据文件，没有类或函数。它使用 YAML 格式来定义事件的结构。 | *   **重要功能点**: |     *   `entry_name`:  事件的标识符，都为 "通道"。 |     *   `event_name`:  事件的描述，例如 "前人藏宝，后人生财" 和 "事件安全车厢"。 |     *   `options`:  每个事件的选项列表。 |         *   `option_name`: 选项的名称。 |         *   `desc`: 选项的描述，描述了选择该选项后的效果，例如获得金币、徽章、损失生命值或压力值等。
│   │   │       ├── 邂逅.yml    ## 摘要 |  | **文件功能:**  定义了游戏中“邂逅”事件的各种分支和选项，这些事件与不同的角色和地点相关联。 |  | **核心类/函数:**  该文件主要由数据构成，没有明确的类或函数。核心数据结构是YAML格式的事件描述，包含以下字段： | *   `entry_name`: 事件的入口名称，这里统一为 "邂逅"。 | *   `event_name`: 事件的名称。 | *   `lcs_percent`:  可能影响事件结果的百分比。 | *   `options`:  事件提供的选项列表，每个选项包含 `option_name` 和可选的 `desc` (描述)。 |  | **重要功能点:** |  | *   **事件分支:**  文件定义了大量“邂逅”事件，每个事件都与特定角色相关联，并提供不同的选项。 | *   **选项影响:**  选项的选择可能会影响游戏进程，例如，通过描述中的效果（例如，伤害提升，压力值降低，清除侵蚀症状）。 | *   **角色互动:**  事件涉及多个游戏角色，包括安比、比利、妮可等，以及不同组织（如狡兔屋、刑侦特勤组、维多利亚家政等）的角色。 | *   **条件概率:**  `lcs_percent` 字段暗示了某些事件可能存在概率触发的机制。
│   │   │       ├── 门扉禁闭-侵蚀.yml    这个 YAML 文件定义了一个游戏事件，名为 "门扉禁闭-侵蚀"（门扉禁闭-侵蚀），与 "异化检疫门"（异化检疫门）相关。它描述了玩家在游戏中可能遇到的情境，并提供了三个选项供玩家选择：接受检疫扫描、使用共犯的钥匙扣、强行闯入通道。 |  | *   **主要功能:** 定义游戏中的一个事件及其选项。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "门扉禁闭-侵蚀"。 |     *   `event_name`: 事件的显示名称，为 "异化检疫门"。 |     *   `options`: 包含玩家可选择的选项列表。 | *   **重要功能点:** 定义了玩家在事件中可以采取的行动，包括与游戏内物品或机制互动的选项。
│   │   │       ├── 门扉禁闭-善战.yml    这个 YAML 文件定义了一个游戏事件 "门扉禁闭-善战"。 |  | *   **主要功能:** 定义游戏中的一个事件，描述了事件的名称、触发条件和相关参数。 | *   **核心元素:** |     *   `entry_name`: 事件的内部标识符，为 "门扉禁闭-善战"。 |     *   `event_name`: 事件的显示名称，为 "怀斯塔学会的前线补给据点"。 |     *   `lcs_percent`: 一个数值，可能表示事件的某种概率或影响。 | *   **重要功能点:**  定义了游戏事件的关键属性，包括事件的名称和相关的数值参数。
│   │   │       ├── 门扉禁闭-财富.yml    这个 YAML 文件定义了一个名为“门扉禁闭-财富”的游戏事件，它与“付费道路”相关联。它包含一系列选项，玩家可以选择使用钥匙、支付费用或离开。核心功能是定义了事件的名称、描述和玩家可选择的选项，以及每个选项的描述，例如支付费用或获得奖励。
│   │   │       ├── 防卫军后勤站.yml    这个 YAML 文件定义了一个游戏事件，名为 "防卫军后勤站"。 |  | *   **主要功能**: 定义游戏中的一个事件，包含事件名称和玩家可选择的选项。 | *   **核心元素**: |     *   `entry_name`: 事件的内部名称，为 "防卫军后勤站"。 |     *   `event_name`: 事件的显示名称，为 "防卫军后勤站"。 |     *   `options`: 一个列表，包含玩家可以选择的选项，包括 "公平交易"、"热情夸赞他们空手套物资" 和 "稍作休息"。 | *   **重要功能点**:  定义了游戏事件的选项，这些选项将影响游戏的进程和玩家的互动。
│   │   │       ├── 限时战斗.yml    这个 YAML 文件的摘要如下： |  | 1.  **主要功能:** 定义了游戏中两个限时战斗事件的数据。 | 2.  **核心类和函数:**  文件使用 YAML 格式，没有类或函数，而是使用 `entry_name`, `event_name`, `option_name` 等键来组织数据。 | 3.  **重要功能点:** |     *   定义了两个限时战斗事件，分别名为 "邦布的秘宝" 和 "身份检查"。 |     *   每个事件包含 `entry_name` 和 `event_name` 属性，用于标识事件。 |     *   第一个事件包含一个选项 `option_name` 为 "人为财死邦布也是"。
│   │   │       ├── 零号银行.yml    这个 YAML 文件定义了一个名为“零号银行”的游戏事件。 |  | *   **主要功能:** 定义了游戏中“零号银行”事件的选项和交互。 | *   **核心元素:** |     *   `entry_name`: "零号银行" - 事件的入口名称。 |     *   `event_name`: "零号银行" - 事件的名称。 |     *   `options`: 一个列表，定义了玩家在事件中可以选择的选项，例如“领取存款返利”、“存款”、“离开”、“密开”、“存入齿轮硬币”、“血样”、“接受压力债务”、“不存了”。 | *   **重要功能点:**  定义了玩家在“零号银行”事件中可以进行的各种操作，包括存款、取款、互动等。
│   │   │       └── 馅饼天降.yml    这个 YAML 文件定义了一个名为 "馅饼天降" 的游戏事件，它描述了事件的触发条件、事件名称、以及玩家在事件中可以选择的四个选项。 |  | *   **主要功能:** 定义游戏中的一个随机事件，玩家可以通过选择不同的选项来获得不同的奖励或承受不同的后果。 | *   **核心元素:** |     *   `entry_name`: 事件的内部名称，为 "馅饼天降"。 |     *   `event_name`: 事件的显示名称，为 "事件埋伏"。 |     *   `lcs_percent`: 事件触发的概率，为 0.6。 |     *   `options`:  一个列表，包含了玩家可以选择的选项，每个选项包含： |         *   `option_name`: 选项的名称。 |         *   `desc`: 选项的描述，说明选择该选项会发生的事情。 | *   **重要功能点:** |     *   事件触发概率控制。 |     *   多个选项提供不同的奖励和惩罚，包括： |         *   消耗齿轮硬币换取S级鸣徽。 |         *   角色生命值损失换取S级鸣徽。 |         *   生命值损失换取齿轮硬币。 |         *   损失生命值。
│   │   └── screen_info/
│   │       ├── arcade.yml    这个 YAML 文件定义了游戏 "arcade" 的屏幕信息，用于界面元素定位和识别。 |  | *   **主要功能:** 描述了 "arcade" 屏幕的各个区域，包括其名称、坐标、文本和其他相关属性。 | *   **核心结构:**  YAML 文件使用 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 结构来组织数据。 `area_list` 包含多个区域的定义。 | *   **重要功能点:** |     *   定义了屏幕上不同区域的坐标 (`pc_rect`)，用于定位 UI 元素。 |     *   每个区域都包含 `area_name` (区域名称) 和 `text` (文本内容)。 |     *   `lcs_percent`, `template_sub_dir`, `template_id`, `template_match_threshold` 属性用于模板匹配和识别。 |     *   定义了如 "游戏名称", "玩家数量", "下一个游戏", "选择", "模式列表", "开始游戏", "蛇对蛇-点击空白处继续", "蛇对蛇-加载完成" 等区域。
│   │       ├── battle.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏战斗界面的屏幕信息，包括屏幕 ID、名称以及界面上各个区域的详细信息，用于游戏 UI 自动化或图像识别。 |  | **核心数据结构:** |  | *   `screen_id`: 屏幕的唯一标识符，此处为 "battle"。 | *   `screen_name`: 屏幕的显示名称，此处为 "战斗画面"。 | *   `area_list`: 包含多个区域信息的列表，每个区域定义了屏幕上一个特定区域的属性。 |  | **重要功能点:** |  | *   **区域定义:**  `area_list` 中每个元素代表一个屏幕区域，包含以下关键信息： |     *   `area_name`: 区域的名称，例如 "头像-3-1", "按键-普通攻击" 等。 |     *   `pc_rect`: 区域的像素坐标 (左上角 x, y, 右下角 x, y)。 |     *   `text`: 区域内显示的文本。 |     *   `lcs_percent`: 用于图像匹配的相似度百分比。 |     *   `template_sub_dir`: 模板图像的子目录。 |     *   `template_id`: 模板图像的 ID。 |     *   `template_match_threshold`: 模板匹配的阈值。 |     *   `goto_list`:  (未使用)  可能用于定义点击区域后的跳转行为。 | *   **界面元素定位:**  通过 `pc_rect` 定义了游戏中各种按钮、头像、文本框等元素的位置。 | *   **图像识别辅助:**  `template_sub_dir`, `template_id`, `template_match_threshold` 和 `lcs_percent`  用于图像识别，辅助定位和识别屏幕元素。 | *   **战斗结果和操作按钮:** 定义了 "完成", "再来一次", "撤退", "倒带", "退出" 等战斗结果和操作按钮的区域。
│   │       ├── battle_menu.yml    这个 YAML 文件定义了游戏中战斗菜单的屏幕信息。 |  | *   **主要功能:**  描述了战斗菜单的界面元素，包括按钮和菜单项的坐标、文本、以及其他相关属性。 | *   **核心结构:**  文件使用 YAML 格式，以 `screen_id` 和 `screen_name` 标识屏幕，`area_list` 包含了屏幕上各个区域的详细信息。 | *   **重要功能点:** |     *   定义了屏幕的 ID 和名称。 |     *   列出了屏幕上的按钮和菜单项，例如 "退出战斗"、"设置" 和 "返回"。 |     *   每个区域都包含了坐标 (`pc_rect`)、文本 (`text`)、以及用于图像识别的相关参数 (`template_sub_dir`, `template_id`, `template_match_threshold`)。 |     *   `goto_list` 属性 (虽然在此文件中为空) 预计用于定义点击按钮后的操作。
│   │       ├── battle_result_fail.yml    这个 YAML 文件定义了游戏中“战斗结果 - 失败”界面的屏幕信息。 |  | *   **主要功能:** 描述了游戏中战斗失败结果界面的布局和元素。 | *   **核心结构:**  YAML 文件使用键值对的形式，定义了屏幕的 `screen_id`、`screen_name` 和 `area_list`。 `area_list` 包含了屏幕上各个区域的详细信息，例如标题和按钮。 | *   **重要功能点:** |     *   定义了屏幕的 `screen_id` 为 `battle_result_fail`。 |     *   定义了屏幕的 `screen_name` 为 "战斗-挑战结果-失败"。 |     *   `area_list` 中包含了标题和“退出”按钮的区域信息，包括位置 (`pc_rect`)、文本 (`text`)、匹配阈值等。 |     *   `goto_list` 属性为空，表示这些区域没有直接的导航目标。
│   │       ├── city_fund.yml    这个 YAML 文件定义了游戏中 "丽都城募" 屏幕的界面元素信息。 |  | *   **主要功能:** 描述了 "丽都城募" 屏幕的 UI 元素，包括按钮、文本区域及其位置。 | *   **核心元素:**  `area_list` 包含了屏幕上所有可交互区域的定义。 | *   **重要功能点:** |     *   定义了屏幕上各个区域的名称 ( `area_name` )，例如 "成长任务"、"等级回馈"、"全部领取" 等。 |     *   每个区域都定义了其在 PC 屏幕上的矩形坐标 (`pc_rect`)，用于定位 UI 元素。 |     *   `text` 字段定义了每个区域显示的文本。 |     *   `goto_list` 字段 (目前为空) 预留了跳转到其他界面的功能。 |     *   `template_id` 和 `template_match_threshold` 字段用于模板匹配，可能用于 UI 元素的识别。
│   │       ├── coffee_shop.yml    这个 YAML 文件定义了游戏中咖啡店屏幕的界面元素信息。 |  | *   **主要功能:** 描述了咖啡店屏幕的各个交互区域，包括按钮和显示区域。 | *   **核心结构:** 使用 YAML 格式，定义了 `screen_id`, `screen_name` 和 `area_list`。`area_list` 包含了多个区域的详细信息。 | *   **重要功能点:** |     *   `area_name`: 每个区域的名称，例如 "点单" (点单), "咖啡列表" (咖啡列表) 等。 |     *   `pc_rect`: 屏幕上每个区域的矩形坐标，用于定位。 |     *   `text`: 区域显示的文本。 |     *   `lcs_percent`: 相似度匹配百分比。 |     *   `template_sub_dir`, `template_id`, `template_match_threshold`: 模板匹配相关的配置。
│   │       ├── combat_simulation.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏界面中“实战模拟室”的屏幕信息，包括屏幕 ID、名称以及各个区域的详细信息。这些信息用于游戏 UI 元素的定位和交互。 |  | **核心类和函数:** |  | *   无核心类和函数，该文件主要由数据结构组成。 |  | **重要功能点:** |  | *   `screen_id`:  `combat_simulation`，标识屏幕的唯一 ID。 | *   `screen_name`:  `实战模拟室`，屏幕的显示名称。 | *   `area_list`:  一个列表，定义了屏幕上各个区域的详细信息，每个区域包含： |     *   `area_name`: 区域的名称，例如“挑战奖励”、“副本名称列表”等。 |     *   `pc_rect`: 区域的矩形坐标，用于定位 UI 元素。 |     *   `text`:  区域显示的文本。 |     *   `lcs_percent`:  用于模板匹配的相似度百分比。 |     *   `template_sub_dir`, `template_id`:  模板相关信息。 |     *   `template_match_threshold`:  模板匹配阈值。 |     *   `color_range`:  颜色范围。 |     *   `goto_list`:  跳转列表。 | *   定义了多个 UI 元素，包括按钮（例如“下一步”、“出战”、“保存方案”、“确定并出战”），文本显示区域（例如“挑战等级”、“剩余电量”、“需要电量”）以及列表和卡片区域。
│   │       ├── commission_assistant.yml    ## 代码摘要 |  | **文件功能:** |  | 此 YAML 文件定义了游戏界面中“委托助手”界面的布局信息，包括各个区域的坐标、文本、模板匹配等信息，用于界面元素的定位和交互。 |  | **核心结构:** |  | *   YAML 文件结构：使用 YAML 格式定义界面元素，包含 `screen_id`, `screen_name`, `area_list` 等字段。 | *   `area_list`:  一个列表，包含多个区域的定义，每个区域定义了其在屏幕上的位置（`pc_rect`），文本（`text`），模板信息（`template_sub_dir`, `template_id`），以及其他属性。 |  | **重要功能点:** |  | *   界面区域定义：定义了对话框标题、右侧选项区域、中间选项区域、左上角街区、对话框确认、左上角返回、文本-剧情右上角、标题-短信、按钮-短信-关闭、区域-短信-文本框、按钮-自动等区域。 | *   坐标和尺寸信息：使用 `pc_rect` 字段定义了每个区域在 PC 屏幕上的坐标和尺寸。 | *   文本信息：使用 `text` 字段定义了区域内的文本内容。 | *   模板匹配：使用 `template_sub_dir`, `template_id` 和 `template_match_threshold` 定义了基于模板匹配的区域定位方式。 | *   界面元素：定义了界面中的各种元素，如按钮、文本框等。
│   │       ├── common_deploy.yml    这个 YAML 文件定义了游戏中一个名为 "通用-出战" 的屏幕的界面元素布局信息。 |  | *   **主要功能:** 描述了游戏界面中 "出战" 屏幕的按钮和其他交互区域的配置信息。 | *   **核心结构:**  使用 `screen_id`, `screen_name` 和 `area_list` 结构来组织数据。 `area_list` 包含多个字典，每个字典描述一个屏幕上的交互区域（例如按钮）。 | *   **重要功能点:** |     *   定义了屏幕的名称和 ID。 |     *   列出了屏幕上各个按钮的详细信息，包括： |         *   `area_name`: 区域的描述性名称。 |         *   `pc_rect`: 区域的矩形坐标，用于定位。 |         *   `text`: 按钮上的文本。 |         *   `lcs_percent`: 匹配百分比。 |         *   `template_id`, `template_sub_dir`, `template_match_threshold`: 模板匹配相关信息。 |         *   `color_range`: 颜色范围。 |         *   `goto_list`: 导航列表。
│   │       ├── common_screen.yml    这个 YAML 文件定义了一个游戏屏幕的通用信息，主要用于界面元素定位和识别。 |  | *   **主要功能:** 描述游戏屏幕的通用信息，包括屏幕 ID、名称和界面区域定义。 | *   **核心类/函数:**  没有类或函数，主要由 YAML 数据结构构成。 | *   **重要功能点:** |     *   `screen_id`:  屏幕的唯一标识符 (`common_screen`)。 |     *   `screen_name`: 屏幕的显示名称 (`画面-通用`)。 |     *   `area_list`:  定义屏幕上的界面区域列表。 |         *   `area_name`: 区域名称 (`左上角-街区`)。 |         *   `pc_rect`:  区域的矩形坐标 (左上角 x, y, 宽, 高)。 |         *   `text`:  区域的文本标签 (`街区`)。 |         *   `lcs_percent`:  用于匹配的相似度百分比。 |         *   `template_sub_dir`, `template_id`, `template_match_threshold`:  与模板匹配相关的配置，用于图像识别。
│   │       ├── compendium.yml    这个 YAML 文件定义了游戏中“快捷手册”界面的屏幕信息。 |  | *   **主要功能:** 定义了“快捷手册”界面的各个区域的布局和属性，用于游戏的 UI 呈现和交互。 | *   **核心结构:** 使用 `screen_id` 和 `screen_name` 标识屏幕，`area_list` 包含多个区域的定义。 | *   **重要功能点:** |     *   `area_name`: 定义了屏幕上各个区域的名称，例如 "TAB列表", "分类列表", "传送确认" 等。 |     *   `pc_rect`: 定义了每个区域在 PC 屏幕上的矩形坐标，用于定位 UI 元素。 |     *   `text`: 区域内显示的文本。 |     *   `lcs_percent`, `template_sub_dir`, `template_id`, `template_match_threshold`: 这些属性可能与图像识别或模板匹配相关，用于 UI 元素的识别和交互。
│   │       ├── compendium_combat.yml    这个 YAML 文件定义了游戏中“快捷手册-作战”界面的屏幕信息。 |  | *   **主要功能**: 定义了屏幕的布局和交互元素，包括标签页和按钮。 | *   **核心结构**: 使用 `screen_id`, `screen_name`, `area_list` 等字段来描述屏幕的各个组成部分。`area_list` 包含了屏幕上各个区域的详细信息，例如按钮和标签页。 | *   **重要功能点**: |     *   定义了多个标签页，包括“训练”，“目标”，“日常”，“作战”，“战术”，以及一个“关闭”按钮。 |     *   `id_mark` 字段标记了当前激活的标签页（“作战”）。 |     *   `goto_list` 字段定义了点击每个区域后的操作，例如跳转到其他界面。 |     *   `color_range` 字段定义了“作战”标签页的颜色范围。
│   │       ├── compendium_errands.yml    这个 YAML 文件定义了游戏中一个名为 "快捷手册-日常" 的屏幕的 UI 元素和交互信息。 |  | *   **主要功能:** 定义了 "快捷手册-日常" 屏幕的各个区域，包括选项卡和按钮，以及它们的交互行为，例如跳转到其他屏幕。 | *   **核心结构:** 文件使用 YAML 格式，包含 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 字段。 `area_list` 包含了屏幕上各个区域的详细信息。 | *   **重要功能点:** |     *   定义了屏幕上各个选项卡 (TAB-训练, TAB-目标, TAB-日常, TAB-作战, TAB-战术) 和按钮 (按钮-关闭) 的位置、文本、颜色范围、以及跳转目标 (goto_list)。 |     *   `id_mark` 字段可能用于标记特定区域。 |     *   `color_range` 字段用于定义颜色范围，可能用于 UI 元素的视觉效果。 |     *   `goto_list` 字段定义了点击区域后要跳转到的屏幕。
│   │       ├── compendium_primer.yml    这个 YAML 文件定义了游戏中一个名为 "快捷手册-目标" 的屏幕的界面元素和交互行为。 |  | *   **主要功能:** 定义了屏幕的布局和导航，包括屏幕名称、区域列表和每个区域的属性。 | *   **核心结构:** 数据以 YAML 格式组织，使用 `screen_id` 和 `screen_name` 标识屏幕，`area_list` 定义了屏幕上的可交互区域。 | *   **重要功能点:** |     *   `area_name`: 定义了屏幕上的可交互区域的名称，例如 "TAB-训练"、"TAB-目标" 等。 |     *   `pc_rect`: 定义了区域的坐标和尺寸。 |     *   `text`: 区域的文本标签。 |     *   `goto_list`: 定义了点击区域后导航到的屏幕。 |     *   `id_mark`: 标记了 "TAB-目标" 区域，可能用于识别或高亮显示。 |     *   `color_range`: 定义了 "TAB-目标" 区域的颜色范围，用于视觉提示。
│   │       ├── compendium_tactics.yml    这个 YAML 文件定义了游戏中“快捷手册-战术”界面的屏幕信息。 |  | *   **主要功能:** 描述了“快捷手册-战术”界面的各个区域，包括标签页和按钮的坐标、文本、跳转目标等信息。 | *   **核心数据结构:**  使用 `area_list` 列表定义了界面中的各个区域，每个区域是一个字典，包含区域名称、坐标 (`pc_rect`)、文本 (`text`)、跳转目标 (`goto_list`) 等信息。 | *   **重要功能点:** |     *   定义了多个标签页，包括“训练”、“目标”、“日常”、“作战”和“战术”。 |     *   定义了一个“关闭”按钮，用于导航到其他界面。 |     *   `pc_rect` 属性定义了每个区域在屏幕上的位置和大小。 |     *   `goto_list` 属性定义了点击区域后要跳转到的目标界面。 |     *   `id_mark` 属性标识了当前激活的标签页。 |     *   `color_range` 属性定义了高亮标签页的颜色范围。
│   │       ├── compendium_training.yml    **摘要:** |  | 该 YAML 文件定义了游戏界面中“快捷手册-训练”界面的布局和交互信息。 |  | **核心信息:** |  | *   `screen_id`: `compendium_training` (界面 ID) | *   `screen_name`: 快捷手册-训练 (界面名称) | *   `area_list`: 定义了界面中各个区域的详细信息，包括： |     *   TAB 标签页 (训练、目标、日常、作战、战术) |     *   按钮 (关闭、奖励) |     *   文本 (电量) |     *   每个区域的 `pc_rect` (位置和大小), `text` (文本), `goto_list` (跳转目标) 等属性。 |  | **重要功能点:** |  | *   定义了界面中各个可交互区域的位置、文本内容和跳转目标。 | *   通过 `goto_list` 定义了点击不同区域后的跳转行为，例如切换标签页或关闭界面。 | *   `color_range` 属性可能用于图像识别或颜色匹配。 | *   `template_id` 和 `template_match_threshold` 属性可能用于模板匹配，以识别界面元素。
│   │       ├── drive_disc_dismantle.yml    这个 YAML 文件定义了游戏中“驱动盘拆解”界面的屏幕信息。 |  | *   **主要功能:** 定义了游戏界面中“驱动盘拆解”屏幕的元素和布局。 | *   **核心元素:** |     *   `screen_id`: 屏幕的唯一标识符，为 `drive_disc_dismantle`。 |     *   `screen_name`: 屏幕的显示名称，为“仓库-驱动仓库-驱动盘拆解”。 |     *   `area_list`: 一个列表，定义了屏幕上各个区域的详细信息，包括： |         *   `area_name`: 区域的名称，例如“标题-驱动盘拆解”、“按钮-快速选择”等。 |         *   `id_mark`: 标识该区域是否用于标识。 |         *   `pc_rect`: 区域在 PC 屏幕上的坐标和尺寸。 |         *   `text`: 区域显示的文本。 |         *   `lcs_percent`: 文本匹配的相似度。 |         *   `template_sub_dir`, `template_id`, `template_match_threshold`: 模板匹配相关的配置。 |         *   `goto_list`: 导航列表。 | *   **重要功能点:** |     *   定义了屏幕上各个按钮的区域，包括“快速选择”、“全选已弃置”、“A及以下”、“S及以下”、“确认”、“拆解”等。 |     *   定义了屏幕上标题区域的文本和位置。 |     *   通过 `pc_rect` 属性定义了每个按钮和文本区域在屏幕上的位置和大小。
│   │       ├── email.yml    这个 YAML 文件定义了游戏中“邮件”界面的屏幕信息。 |  | *   **主要功能:** 描述了游戏邮件界面的各个交互区域，包括按钮和文本。 | *   **核心结构:**  YAML 文件使用 `screen_id`, `screen_name` 和 `area_list` 结构来组织数据。 `area_list` 包含多个区域的定义。 | *   **重要功能点:** |     *   定义了屏幕的 ID 和名称。 |     *   `area_list` 中定义了界面上各个区域的属性，包括： |         *   `area_name`: 区域的名称 (例如 "全部领取", "确认", "标题-邮件", "按钮-返回")。 |         *   `pc_rect`: 区域在 PC 屏幕上的坐标和尺寸。 |         *   `text`: 区域的文本内容。 |         *   `template_id` 和 `template_sub_dir`: 用于识别界面的模板信息。 |         *   `goto_list`:  定义了点击该区域后，游戏将跳转到的界面。 |         *   `id_mark`: 标记是否是标识区域。
│   │       ├── enter_game.yml    ## 代码摘要 |  | **1. 主要功能:** |  | 该 YAML 文件定义了游戏启动界面（"enter_game" 屏幕）的各个可交互区域，用于自动化测试或游戏辅助。它描述了不同服务器（国服、B服、国际服）的登录流程，包括账号密码输入、登录按钮、切换账号等操作。此外，还包含了退出登录和服务器选择等功能。 |  | **2. 核心类和函数:** |  | *   **无核心类和函数**: 这是一个数据配置文件，使用 YAML 格式定义屏幕元素信息。 |  | **3. 重要功能点:** |  | *   **屏幕区域定义:**  定义了屏幕上各个区域的名称 (area\_name)、坐标 (pc\_rect)、文本 (text) 和匹配阈值 (lcs\_percent, template\_match\_threshold)。 | *   **多服务器支持:** 包含了国服、B服和国际服的登录流程，以及国际服的服务器选择功能。 | *   **登录流程:**  定义了账号密码输入框、登录按钮、同意按钮等元素的位置和文本。 | *   **切换账号:**  定义了切换账号的区域和确定按钮。 | *   **退出登录:**  定义了退出登录的区域和确认按钮。 | *   **服务器选择:** 国际服的服务器选择区域，包括欧洲、美国、亚洲和港澳台。 | *   **重试:** 定义了重试按钮。
│   │       ├── expert_challenge.yml    这个 YAML 文件定义了游戏中「专业挑战室」屏幕的界面信息。 |  | *   **主要功能:** 描述了游戏屏幕的布局和元素，包括屏幕 ID、名称以及屏幕上各个区域的定义。 | *   **核心数据结构:** 使用 YAML 格式，定义了 `screen_id`, `screen_name`, `area_list` 等关键字段。`area_list` 包含了屏幕上各个区域的详细信息，例如 `area_name`, `pc_rect`, `text`, `lcs_percent` 等。 | *   **重要功能点:** |     *   定义了屏幕的 ID 和名称。 |     *   通过 `area_list` 定义了屏幕上两个区域：「剩余电量」和「需要电量」，并包含了它们的位置和相关属性。 |     *   `pc_rect` 属性定义了每个区域在 PC 屏幕上的坐标。 |     *   `lcs_percent` 属性可能与图像识别或匹配有关。
│   │       ├── fishing.yml    **摘要:** |  | 该文件 `fishing.yml` 定义了游戏内钓鱼界面的屏幕信息，包括各个区域的坐标、文本、模板匹配信息等。 |  | **核心功能:** |  | *   定义钓鱼界面的各个交互区域，包括按钮、文本区域等。 | *   使用 `pc_rect` 定义每个区域在 PC 屏幕上的坐标。 | *   使用 `template_id` 和 `template_sub_dir` 指定用于识别区域的模板。 |  | **重要功能点:** |  | *   定义了多个按钮，例如 "时机上鱼"、"左"、"右"、"返回"、"确定"、"强力-左"、"强力-右" 等。 | *   定义了 "挑战结果" 标题区域。 | *   定义了 "点击空白处关闭" 按钮。 | *   使用 `template_match_threshold` 定义模板匹配的阈值。
│   │       ├── hdd.yml    这个 YAML 文件定义了游戏中名为 "HDD" 的屏幕的界面元素信息。 |  | *   **主要功能:** 描述了 "HDD" 屏幕的各个区域及其在 PC 上的位置和属性。 | *   **核心结构:**  YAML 文件使用 `screen_id`, `screen_name` 和 `area_list` 来组织数据。`area_list` 包含多个字典，每个字典描述屏幕上的一个区域。 | *   **重要功能点:** |     *   定义了屏幕的名称 ("HDD")。 |     *   `area_list` 中定义了屏幕上多个区域，包括 "章节显示", "章节列表", "委托区域", "下一步", "副本区域", "出战", "街区", "空白", "确定并出战" 等。 |     *   每个区域都包含 `pc_rect` (定义区域的坐标), `text`, `lcs_percent`, `template_sub_dir`, `template_id` 和 `template_match_threshold` 等属性。
│   │       ├── hollow_zero_battle.yml    这个 YAML 文件定义了游戏中「零号空洞-战斗」场景的屏幕信息。 |  | *   **主要功能:** 描述了战斗场景中不同区域的 UI 元素，包括按钮和文本框，用于游戏的交互和界面显示。 | *   **核心元素:**  `screen_id`, `screen_name` 定义了屏幕的 ID 和名称。 `area_list` 包含了多个区域的定义。 | *   **重要功能点:** |     *   `area_name`: 定义了屏幕上各个区域的名称，例如 "鸣徽-确定", "退出战斗" 等。 |     *   `pc_rect`:  定义了每个区域的坐标和尺寸，用于定位 UI 元素。 |     *   `text`:  定义了区域中显示的文本。 |     *   `lcs_percent`:  用于模板匹配的相似度百分比。 |     *   `template_sub_dir`, `template_id`, `template_match_threshold`:  用于模板匹配，识别 UI 元素。
│   │       ├── hollow_zero_entry.yml    这个 YAML 文件定义了游戏中名为「零号空洞-入口」的屏幕的界面元素信息。 |  | *   **主要功能**: 描述了屏幕的布局，包括不同区域的名称、坐标（`pc_rect`）、文本、相似度百分比（`lcs_percent`）以及模板匹配相关的信息。 | *   **核心元素**:  `area_list` 包含了一系列定义屏幕上可交互区域的字典。每个字典代表一个区域，包含以下字段： |     *   `area_name`: 区域的名称，例如 "街区"、"副本列表"、"下一步" 等。 |     *   `pc_rect`: 区域的矩形坐标，用于定位。 |     *   `text`: 区域的文本标签。 |     *   `lcs_percent`: 相似度百分比，用于模板匹配。 |     *   `template_sub_dir`, `template_id`, `template_match_threshold`: 模板匹配相关的配置。 | *   **重要功能点**: |     *   定义了屏幕上多个可交互区域，包括按钮和文本区域。 |     *   使用矩形坐标来定位屏幕上的元素。 |     *   使用文本和模板匹配来识别屏幕元素。 |     *   `pc_alt` 字段指示是否使用替代的 PC 布局。
│   │       ├── hollow_zero_event.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏内名为 "零号空洞-事件" 的屏幕的 UI 元素布局和交互信息。它描述了屏幕上各个区域的名称、位置、文本、模板匹配信息以及跳转目标。 |  | **核心元素:** |  | *   `screen_id`: 屏幕的唯一标识符 ("hollow\_zero\_event")。 | *   `area_list`:  一个列表，包含屏幕上所有可交互区域的定义。 |     *   `area_name`: 区域的名称 (例如 "事件文本", "角色-1", "背包" 等)。 |     *   `pc_rect`: 区域的矩形坐标 (左上角和右下角坐标)。 |     *   `text`: 区域内显示的文本。 |     *   `template_id`, `template_sub_dir`, `template_match_threshold`: 用于模板匹配的配置，用于识别 UI 元素。 |     *   `goto_list`:  定义点击该区域后跳转到的目标。 |  | **重要功能点:** |  | *   **UI 布局定义:**  通过 `area_list` 精确定义了屏幕上各个 UI 元素的位置和大小。 | *   **文本和交互:**  定义了每个区域显示的文本，以及可能的交互行为（例如点击按钮）。 | *   **模板匹配:**  使用模板匹配来识别 UI 元素，用于更灵活的 UI 识别和处理。 | *   **屏幕导航:**  `goto_list`  定义了点击某些区域后，游戏应该跳转到的目标屏幕或状态。 | *   **事件处理:**  该文件描述了与 "零号空洞-事件" 相关的各种 UI 元素，包括角色、文本框、按钮等，暗示了该屏幕用于处理游戏事件和交互。
│   │       ├── hollow_zero_merchant.yml    这个 YAML 文件定义了游戏中「零号空洞-商店」萤幕的 UI 元素区域。 |  | *   **主要功能:** 定义萤幕上各个 UI 元素的坐标、文本和模板匹配信息，用于游戏的 UI 识别和交互。 | *   **核心类/函数:**  此文件是数据文件，没有类或函数。它使用 YAML 格式来描述萤幕的 UI 元素。 | *   **重要功能点:** |     *   `screen_id`:  `hollow_zero_merchant` - 萤幕的唯一标识符。 |     *   `screen_name`:  `零号空洞-商店` - 萤幕的显示名称。 |     *   `area_list`:  包含多个 UI 元素区域的定义，例如： |         *   返回按钮 (`right_top_back`) |         *   确定按钮 |         *   二级标题 |         *   商品价格区域 |         *   商品描述区域 |         *   商品购买区域 (`merchant_add`) |         *   多个商品价格区域 (例如: 商品价格-3-1, 商品价格-3-2 等) |     *   每个 `area_name` 都有 `pc_rect` (坐标), `text`, `lcs_percent`, `template_sub_dir`, `template_id`, `template_match_threshold` 等属性，用于定位和识别 UI 元素。
│   │       ├── life_on_line.yml    这个 YAML 文件定义了游戏中名为 "life_on_line" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了游戏屏幕的布局，包括屏幕 ID、名称、以及一系列可交互区域的定义。 | *   **核心结构:**  YAML 文件，使用 `screen_id` 和 `area_list` 组织数据。`area_list` 包含多个 `area_name` 及其对应的矩形区域 (`pc_rect`) 和文本信息 (`text`)。 | *   **重要功能点:** |     *   定义了屏幕的名称 ("真拿命验收")。 |     *   定义了多个可交互区域，例如 "第二章间章"、"对话选项"、"对话人" 和 "确定并出战"，每个区域都有其位置信息 (pc_rect) 和文本内容。 |     *   使用 `lcs_percent` 和 `template_match_threshold` 描述了区域的匹配阈值。
│   │       ├── lost_void_bangboo_store.yml    **摘要:** |  | 该文件定义了游戏界面“迷失之地-邦布商店”的屏幕信息，使用 YAML 格式。 |  | **核心功能:** |  | *   定义屏幕的各个区域，包括文本、按钮、标识等。 | *   描述每个区域的属性，如名称、坐标、文本、模板信息等。 |  | **重要功能点:** |  | *   `screen_id`: 屏幕的唯一标识符。 | *   `area_list`: 定义屏幕上所有区域的列表。 | *   `area_name`: 区域的名称。 | *   `pc_rect`: 区域在 PC 屏幕上的矩形坐标。 | *   `text`: 区域显示的文本。 | *   `template_id` 和 `template_sub_dir`: 用于图像识别的模板信息。 | *   `goto_list`: 定义区域的跳转目标。 | *   定义了“详情”、“刷新”、“藏品名称”、“价格”、“购买按钮”、“购买-确认”、“返回”、“刷新-可用”、“刷新-确认”、“血量”、“金币”、“角色头像”等区域。
│   │       ├── lost_void_battle_fail.yml    这个 YAML 文件定义了游戏中「迷失之地-战斗失败」界面的屏幕信息。 |  | *   **主要功能:** 定义了战斗失败界面，包括界面 ID、名称和按钮区域的配置。 | *   **核心元素:** |     *   `screen_id`: 屏幕的唯一标识符，为 `lost_void_battle_fail`。 |     *   `screen_name`: 屏幕的显示名称，为「迷失之地-战斗失败」。 |     *   `area_list`:  一个列表，定义了屏幕上的交互区域（按钮）。 | *   **重要功能点:** |     *   定义了三个按钮区域：撤退、重播和分析。 |     *   每个按钮区域都包含其名称、标识符、位置（`pc_rect`）、文本、匹配阈值等信息。 |     *   `id_mark: true` 表明这些区域用于标识。 |     *   `goto_list` 属性为空，表示这些按钮不直接导航到其他界面，可能触发其他游戏逻辑。
│   │       ├── lost_void_battle_result.yml    这个 YAML 文件定义了游戏中“迷失之地-挑战结果”界面的屏幕信息。 |  | *   **主要功能:** 描述了游戏界面中各个区域的布局和元素，包括标题、按钮和奖励。 | *   **核心元素:** |     *   `screen_id`: 屏幕的唯一标识符 ("lost\_void\_battle\_result")。 |     *   `screen_name`: 屏幕的显示名称 ("迷失之地-挑战结果")。 |     *   `area_list`:  一个列表，包含屏幕上各个区域的详细信息，如位置 (pc\_rect), 文本 (text), 和模板信息 (template\_id, template\_sub\_dir)。 | *   **重要功能点:** |     *   定义了屏幕上各个区域的坐标和尺寸，用于界面元素定位。 |     *   定义了“确定”和“完成”按钮。 |     *   定义了奖励区域，并使用 `template_id` 和 `template_sub_dir` 引用了用于显示奖励的模板。
│   │       ├── lost_void_choose_common.yml    **摘要:** |  | 该 YAML 文件定义了游戏界面 "迷失之地-通用选择" 的屏幕布局和元素信息。 |  | **核心元素:** |  | *   `screen_id`: `lost_void_choose_common` - 屏幕的唯一标识符。 | *   `screen_name`: 迷失之地-通用选择 - 屏幕的显示名称。 | *   `area_list`: 包含屏幕上各个区域的定义，每个区域包含名称、矩形坐标、文本、模板匹配信息等。 |  | **重要功能点:** |  | *   定义了屏幕上各种UI元素的位置和属性，包括： |     *   文本区域（详情、藏品名称、武备名称、标题等） |     *   按钮（确定、刷新） |     *   TAB 标签 |     *   武备标识区域 | *   使用 `id_mark` 字段标识是否需要进行 ID 标记。 | *   使用 `template_id` 和 `template_match_threshold` 进行模板匹配。 | *   `goto_list` 字段定义了跳转目标。
│   │       ├── lost_void_choose_no_detail.yml    这个 YAML 文件定义了游戏中一个名为 "迷失之地-无详情选择" 的屏幕的界面元素信息。 |  | *   **主要功能:** 描述了游戏屏幕的布局和交互元素，用于在迷失之地场景中进行选择。 | *   **核心类/函数:**  该文件是数据文件，没有类或函数。 | *   **重要功能点:** |     *   `screen_id`:  `lost_void_choose_no_detail`，屏幕的唯一标识符。 |     *   `area_list`:  定义了屏幕上的各个区域，包括按钮、文本框等，每个区域包含其名称、位置 ( `pc_rect` )、文本、以及用于识别的标记 (`id_mark`) 和模板匹配信息。 |     *   `pc_rect`:  定义了每个区域在 PC 屏幕上的坐标和尺寸。 |     *   `template_id` 和 `template_sub_dir`:  用于模板匹配，辅助识别屏幕元素。 |     *   `goto_list`:  定义了点击区域后的操作，这里为空。
│   │       ├── lost_void_choose_no_num.yml    这个 YAML 文件定义了游戏中一个名为 "迷失之地-无数量选择" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了游戏屏幕的布局和交互元素，包括文本、按钮和区域。 | *   **核心元素:** |     *   `screen_id`: 屏幕的唯一标识符。 |     *   `screen_name`: 屏幕的显示名称。 |     *   `area_list`:  一个列表，定义了屏幕上各个区域的详细信息，包括： |         *   `area_name`: 区域的名称。 |         *   `pc_rect`: 区域在 PC 屏幕上的坐标和尺寸。 |         *   `text`: 区域的文本内容。 |         *   `template_id`, `template_sub_dir`: 模板相关信息，用于图像匹配。 | *   **重要功能点:** |     *   定义了屏幕上 "详情" 文本区域、"确定" 按钮、"藏品名称" 区域和 "迷失之地-TAB" 区域的位置和属性。 |     *   使用 `template_id` 和 `template_sub_dir` 进行图像匹配，用于界面元素识别。 |     *   `goto_list` 属性（虽然为空）暗示了可能存在的屏幕导航功能。
│   │       ├── lost_void_entry.yml    这个 YAML 文件定义了游戏中一个名为 "迷失之地-入口" 的屏幕的界面信息。 |  | *   **主要功能**: 描述了 "迷失之地-入口" 屏幕的 UI 元素，包括按钮的布局、文本、坐标和导航目标。 | *   **核心元素**: |     *   `screen_id`:  `lost_void_entry`，屏幕的唯一标识符。 |     *   `screen_name`:  `迷失之地-入口`，屏幕的显示名称。 |     *   `area_list`:  一个列表，定义了屏幕上各个交互区域（按钮）。 | *   **重要功能点**: |     *   定义了多个按钮，例如 "街区"、"悬赏委托"、"战线肃清" 和 "全部领取" 等。 |     *   每个按钮都包含 `pc_rect` (坐标和尺寸), `text` (按钮文本), `goto_list` (导航目标) 等信息。 |     *   `goto_list` 描述了点击按钮后，游戏将导航到的其他屏幕。 |     *   `id_mark` 标记了是否需要进行 ID 标记。
│   │       ├── lost_void_gear.yml    这个 YAML 文件定义了游戏中“迷失之地-武备选择”屏幕的界面元素和交互信息。 |  | *   **主要功能:** 描述游戏屏幕的布局和交互元素，包括按钮、文本区域和列表。 | *   **核心结构:**  YAML 文件使用 `screen_id` 和 `screen_name` 标识屏幕，`area_list` 包含屏幕上各个区域的定义。 | *   **重要功能点:** |     *   定义了屏幕上各个区域的名称、位置 ( `pc_rect` )、文本 ( `text` ) 和模板信息 ( `template_sub_dir`, `template_id` )。 |     *   `id_mark` 标识是否需要进行 ID 标记。 |     *   `goto_list` (空列表) 预计用于定义导航目标。 |     *   包含“携带”、“详情”和“返回”按钮的定义，以及“武备列表”和“等级列表”区域的定义。
│   │       ├── lost_void_lottery.yml    这个 YAML 文件定义了游戏中“迷失之地-抽奖机”界面的屏幕信息。 |  | *   **主要功能:** 描述了游戏界面中各个区域的属性，包括按钮和文本框的位置、文本内容、模板信息等。 | *   **核心结构:**  文件使用 YAML 格式，以 `screen_id` 和 `screen_name` 标识屏幕，`area_list` 包含了屏幕中各个区域的详细信息。 | *   **重要功能点:** |     *   定义了屏幕的 ID 和名称。 |     *   定义了多个区域，包括“返回”、“奖励预览”、“开始”、“剩余次数”和“确定”按钮。 |     *   每个区域都包含了位置信息 ( `pc_rect` )、文本 ( `text` )、模板信息 ( `template_sub_dir`, `template_id` ) 和其他属性。 |     *   `id_mark` 标识了是否需要进行 ID 标记。 |     *   `goto_list` 属性用于定义点击区域后的跳转行为，但在此文件中为空。
│   │       ├── lost_void_normal_world.yml    这个 YAML 文件定义了游戏中 "迷失之地-大世界" 屏幕的 UI 元素信息。 |  | *   **主要功能**: 描述游戏屏幕上各个 UI 元素的位置、尺寸、文本、模板匹配信息等，用于游戏的 UI 识别和交互。 | *   **核心类和函数**:  无特定类或函数，主要由数据结构组成，以 `screen_id` 和 `area_list` 为主。 | *   **重要功能点**: |     *   `screen_id`: 屏幕的唯一标识符。 |     *   `area_list`:  包含屏幕上所有 UI 元素的列表，每个元素包含: |         *   `area_name`: 元素的名称。 |         *   `pc_rect`: 元素在 PC 屏幕上的矩形区域 (x1, y1, x2, y2)。 |         *   `text`: 元素的文本内容。 |         *   `template_sub_dir` 和 `template_id`:  用于模板匹配的子目录和 ID。 |         *   `template_match_threshold`: 模板匹配的阈值。 |         *   `goto_list`:  定义了 UI 元素触发后的操作，这里为空。 |         *   `id_mark`: 标记是否为 ID 标记。
│   │       ├── lost_void_purge.yml    **摘要:** |  | 该 YAML 文件定义了游戏中名为 "迷失之地-战线肃清" 的屏幕的 UI 元素信息。 |  | *   **主要功能:** 描述游戏屏幕的 UI 元素，包括按钮、文本和区域，以及它们的位置、文本内容和可能的导航目标。 | *   **核心结构:** 文件使用 `screen_id` 和 `screen_name` 标识屏幕，`area_list` 包含屏幕上各个 UI 元素的详细信息。 | *   **重要功能点:** |     *   定义了屏幕上各个区域的名称、矩形坐标、文本内容和标识符。 |     *   `goto_list` 属性定义了 UI 元素可能的导航目标，例如跳转到其他屏幕。 |     *   `lcs_percent`、`template_sub_dir`、`template_id`、`template_match_threshold` 和 `color_range` 属性用于图像识别和匹配。 |     *   `id_mark` 标记了重要的 UI 元素。
│   │       ├── lost_void_route_change.yml    这个 YAML 文件定义了游戏中一个名为 "迷失之地-路径迭换" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了游戏屏幕的布局和交互元素。 | *   **核心元素:** |     *   `screen_id`:  `lost_void_route_change` (屏幕的唯一标识符) |     *   `screen_name`: `迷失之地-路径迭换` (屏幕的显示名称) |     *   `area_list`:  定义屏幕上各个交互区域的列表，例如按钮。 | *   **重要功能点:** |     *   定义了两个按钮区域: "按钮-返回" 和 "按钮-图例详情"。 |     *   每个按钮都包含其在屏幕上的位置 (`pc_rect`)、文本 (`text`)、模板信息 (`template_sub_dir`, `template_id`) 和其他相关配置。 |     *   `goto_list`:  按钮点击后可能触发的导航列表，但在此文件中为空。
│   │       ├── map.yml    这是一个 YAML 配置文件，用于定义游戏地图屏幕的界面元素和交互区域。 |  | *   **主要功能:** 定义游戏地图屏幕的 UI 元素，包括区域名称、矩形坐标、文本、模板匹配信息和跳转列表。 | *   **核心结构:**  `area_list` 包含多个区域定义，每个区域定义包含： |     *   `area_name`: 区域的名称。 |     *   `pc_rect`: 区域的矩形坐标 (左上角 x, 左上角 y, 右下角 x, 右下角 y)。 |     *   `text`: 区域内显示的文本。 |     *   `lcs_percent`:  可能与文本匹配相关的百分比。 |     *   `template_sub_dir`, `template_id`, `template_match_threshold`: 模板匹配相关信息。 |     *   `goto_list`:  定义区域的跳转目标。 | *   **重要功能点:** |     *   定义了地图屏幕上不同区域的坐标和交互信息，例如“区域名称”、“上一个区域”、“下一个区域”、“传送点名称”和“街区详情”。 |     *   使用矩形坐标定义了每个区域的可点击范围。 |     *   包含了文本和模板匹配相关的配置，用于识别和交互。 |     *   `goto_list` 字段表明了区域可能具有的跳转功能。
│   │       ├── menu.yml    ## 摘要 |  | 该文件 (`menu.yml`) 定义了游戏菜单界面的布局信息，使用 YAML 格式存储。 |  | **核心功能:** |  | *   定义菜单界面的各个区域 (areas) 的位置、文本、模板信息和跳转目标。 |  | **核心数据结构:** |  | *   `screen_id`: 屏幕 ID，值为 "menu"。 | *   `screen_name`: 屏幕名称，值为 "菜单"。 | *   `area_list`:  一个列表，包含菜单界面中所有区域的详细信息，每个区域是一个字典，包含以下键: |     *   `area_name`: 区域名称，例如 "返回", "邮件", "底部列表" 等。 |     *   `pc_rect`:  PC 平台上的矩形区域坐标，定义了区域的位置和大小。 |     *   `text`: 区域内的文本内容。 |     *   `lcs_percent`:  匹配相似文本的百分比。 |     *   `template_sub_dir`: 模板子目录。 |     *   `template_id`: 模板 ID。 |     *   `template_match_threshold`: 模板匹配阈值。 |     *   `color_range`: 颜色范围 (未使用)。 |     *   `goto_list`:  点击该区域后跳转的目标界面列表。 |  | **重要功能点:** |  | *   定义了菜单界面中各种按钮、文本框和区域的位置和交互行为。 | *   通过 `goto_list` 定义了界面跳转逻辑，例如点击 "返回" 按钮后跳转到 "大世界-普通" 界面。 | *   使用 `template_sub_dir` 和 `template_id` 定义了界面元素的模板信息，用于界面元素的识别和匹配。 | *   包含 "返回", "邮件", "底部列表", "兑换码", "朋友", "仓库", "更多" 等多个功能区域的定义。
│   │       ├── menu_more.yml    这个 YAML 文件定义了游戏中“更多功能”菜单的屏幕信息。 |  | *   **主要功能:** 描述了“更多功能”菜单的 UI 元素，包括标题、关闭按钮和“预备编队”按钮。 | *   **核心结构:**  文件使用 YAML 格式，定义了 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 等关键字段。`area_list` 包含了屏幕上各个 UI 元素的详细信息。 | *   **重要功能点:** |     *   定义了屏幕的标题和按钮的文本、位置 (`pc_rect`) 和模板信息 (`template_id`, `template_sub_dir`)。 |     *   使用 `id_mark` 标记重要的 UI 元素。 |     *   `goto_list` 字段目前为空，可能用于定义按钮的导航目标。 |     *   `template_match_threshold` 和 `color_range` 用于图像识别和匹配。
│   │       ├── news_stand.yml    这个 YAML 文件定义了游戏中名为“报刊亭”的屏幕的界面元素和交互区域。 |  | *   **主要功能:** 定义了报刊亭屏幕的 UI 元素，包括按钮、文本区域和交互区域的坐标、文本描述和模板匹配参数。 | *   **核心元素:**  `area_list` 包含了屏幕上所有可交互区域的定义，每个区域由 `area_name`, `pc_rect`, `text`, `lcs_percent`, `template_sub_dir`, `template_id`, 和 `template_match_threshold` 属性描述。 | *   **重要功能点:** |     *   定义了“刮刮卡”区域及其相关的交互。 |     *   定义了与“嗷呜”角色互动的区域，包括“叫醒他”和“嗷呜对话”等。 |     *   定义了多个刮层的区域，可能用于刮刮卡效果。 |     *   定义了“对话选项”区域，可能用于与角色的对话。 |     *   `pc_rect` 属性定义了每个区域在屏幕上的位置和大小。 |     *   `text` 属性提供了每个区域的文本描述。 |     *   `lcs_percent`, `template_sub_dir`, `template_id`, 和 `template_match_threshold` 属性用于模板匹配，可能用于 UI 元素的识别和交互。
│   │       ├── noodle_shop.yml    这个 YAML 文件定义了游戏中拉面店屏幕的界面信息。 |  | *   **主要功能:** 描述了拉面店屏幕的布局和交互区域。 | *   **核心结构:** 使用 YAML 格式，包含 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 等键。`area_list` 包含屏幕上各个交互区域的详细信息。 | *   **重要功能点:** |     *   定义了屏幕的 ID 和名称。 |     *   `area_list` 描述了屏幕上各个区域的属性，包括 `area_name`, `pc_rect` (屏幕坐标), `text`, `lcs_percent`, `template_sub_dir`, `template_id` 和 `template_match_threshold`。 |     *   定义了 "点单", "拉面列表", "点单确认" 和 "效果确认" 等区域，并指定了它们在屏幕上的位置和相关文本。
│   │       ├── normal_world.yml    这个 YAML 文件定义了游戏中 "大世界" 屏幕的界面元素信息。 |  | *   **主要功能:** 描述了游戏屏幕的布局，包括不同区域的名称、坐标、文本、模板信息等。 | *   **核心结构:**  YAML 文件使用键值对的形式，定义了屏幕的 `screen_id`, `screen_name` 和 `area_list`。`area_list` 是一个列表，包含屏幕上各个区域的详细信息。 | *   **重要功能点:** |     *   `area_name`:  定义屏幕上的区域，如 "信息", "菜单", "地图" 等。 |     *   `pc_rect`:  定义区域的坐标和尺寸 (左上角和右下角的 x, y 坐标)。 |     *   `text`:  区域内显示的文本。 |     *   `lcs_percent`:  用于模板匹配的相似度百分比。 |     *   `template_sub_dir` 和 `template_id`:  用于指定与该区域相关的模板文件。 |     *   `template_match_threshold`:  模板匹配的阈值。
│   │       ├── normal_world_basic.yml    这个 YAML 文件定义了游戏中一个名为 "大世界-普通" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了游戏屏幕的布局，包括屏幕 ID、名称以及屏幕上的交互区域。 | *   **核心类/函数:**  无特定类或函数，文件使用 YAML 格式定义数据结构。 | *   **重要功能点:** |     *   `screen_id`: 屏幕的唯一标识符 "normal_world_basic"。 |     *   `screen_name`: 屏幕的显示名称 "大世界-普通"。 |     *   `area_list`:  定义了屏幕上多个交互区域，每个区域包含： |         *   `area_name`: 区域的名称，例如 "按钮-信息" 和 "按钮-菜单"。 |         *   `pc_rect`: 区域在 PC 屏幕上的矩形坐标。 |         *   `template_sub_dir` 和 `template_id`:  用于模板匹配的相关信息。 |         *   `goto_list`:  定义了区域触发后导航到的目标，例如 "菜单"。
│   │       ├── notorious_hunt.yml    ## 代码摘要 |  | **主要功能:** |  | 该 YAML 文件定义了游戏界面 "恶名狩猎" 的屏幕信息，用于识别和定位屏幕上的各种元素。 |  | **核心类和函数:** |  | *   无显式类或函数定义，该文件使用 YAML 格式定义屏幕元素。 |  | **重要功能点:** |  | *   `screen_id`: 屏幕的唯一标识符 "notorious\_hunt"。 | *   `screen_name`: 屏幕的显示名称 "恶名狩猎"。 | *   `area_list`: 定义了屏幕上各个区域的详细信息，包括： |     *   `area_name`: 区域的名称，例如 "副本名称列表", "剩余次数" 等。 |     *   `pc_rect`: 区域的像素坐标 (x1, y1, x2, y2)。 |     *   `text`: 区域内显示的文本。 |     *   `lcs_percent`: 相似度匹配的百分比。 |     *   `template_sub_dir`, `template_id`: 模板相关信息，用于图像识别。 |     *   `template_match_threshold`: 模板匹配的阈值。 |     *   `color_range`: 颜色范围，用于颜色识别。 |     *   `goto_list`: 跳转目标列表。 | *   定义了诸如 "选择", "重新开始", "奖励入口", "难度选择入口" 等关键按钮和区域的位置和属性。 | *   包含了用于 "深度追猎" 和 "无报酬模式" 的按钮定义。 | *   定义了 "街区" 按钮和 "副本名称" 标题区域。
│   │       ├── random_play.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏界面 "影像店营业" 的屏幕信息，包括屏幕 ID、名称以及各个区域的坐标、文本和相关配置。 |  | **核心元素:** |  | *   **`screen_id`**:  `random_play` - 屏幕的唯一标识符。 | *   **`screen_name`**:  `影像店营业` - 屏幕的显示名称。 | *   **`area_list`**:  一个列表，定义了屏幕上所有可交互区域的详细信息。 |  | **重要功能点:** |  | *   定义了屏幕上各个区域的坐标 (`pc_rect`)，用于界面元素定位。 | *   每个区域都包含 `area_name` (区域名称) 和 `text` (文本内容)。 | *   `lcs_percent` 和 `template_match_threshold` 用于模板匹配，可能用于图像识别或 UI 自动化测试。 | *   定义了多个区域，包括 "昨日账本"、"返回"、"宣传员入口"、"录像带入口"、"经营状况"、"确认"、"上架筛选"、"主题筛选"、"上架"、"下架"、"选择宣传员"、"开始营业" 等，这些区域代表了游戏中的各种交互元素。
│   │       ├── ridu_weekly.yml    **摘要:** |  | 该 YAML 文件定义了游戏界面 "丽都周纪" 的屏幕信息，主要用于界面元素定位和交互。 |  | **核心数据结构:** |  | *   `screen_id`: 屏幕 ID，值为 "ridu_weekly"。 | *   `screen_name`: 屏幕名称，值为 "丽都周纪"。 | *   `area_list`: 包含多个区域信息的列表，每个区域定义了屏幕上的一个可交互或可识别的元素。 |  | **重要功能点:** |  | *   定义了屏幕上多个区域的坐标 (`pc_rect`)、文本 (`text`)、匹配阈值 (`template_match_threshold`) 等信息。 | *   `area_list` 中定义了如 "丽都周纪"、"代办列表"、"确认代办"、"领取"、"任务区域" 等区域，用于识别和定位屏幕上的关键元素。 | *   `goto_list` 字段为空，表示没有直接的跳转目标。 | *   `lcs_percent` 用于模板匹配的相似度。
│   │       ├── routine_cleanup.yml    这个 YAML 文件定义了游戏中名为 "定期清剿" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了游戏屏幕的布局，包括屏幕名称、以及屏幕上各个区域的定义。 | *   **核心数据结构:** 使用 YAML 格式定义了 `screen_id`, `screen_name`, `pc_alt` 和 `area_list`。`area_list` 包含了屏幕上各个区域的详细信息，例如区域名称、坐标、文本、匹配阈值等。 | *   **重要功能点:** |     *   定义了屏幕的名称和 ID。 |     *   定义了屏幕上多个区域的坐标和属性，用于界面元素识别和交互。 |     *   `area_list` 中的每个元素代表屏幕上的一个可识别区域，例如副本名称列表、剩余电量和需要电量。 |     *   `pc_rect` 属性定义了每个区域的坐标。 |     *   `template_match_threshold` 属性定义了模板匹配的阈值，用于图像识别。
│   │       ├── shiyu_defense.yml    ## 代码摘要 |  | **文件功能:** |  | 该 YAML 文件定义了游戏界面 "式舆防卫战" 的屏幕信息，用于定位屏幕上的各个区域。 |  | **核心元素:** |  | *   `screen_id`: 屏幕的唯一标识符，这里是 "shiyu\_defense"。 | *   `screen_name`: 屏幕的显示名称，这里是 "式舆防卫战"。 | *   `area_list`:  一个列表，包含了屏幕上所有区域的定义。每个区域定义包含以下信息： |     *   `area_name`: 区域的名称 (例如 "节点-01", "下一步" 等)。 |     *   `pc_rect`: 区域的像素坐标 (左上角 x, y 和右下角 x, y)。 |     *   `text`:  区域内显示的文本。 |     *   `lcs_percent`:  用于相似度匹配的参数。 |     *   `template_sub_dir`:  模板子目录。 |     *   `template_id`:  模板 ID。 |     *   `template_match_threshold`:  模板匹配的阈值。 |  | **重要功能点:** |  | *   定义了多个区域，包括游戏中的节点、弱点、抗性、按钮 (例如 "下一步", "退出战斗")、奖励相关区域、以及 "前次行动最佳记录" 相关的区域。 | *   部分区域定义了 `template_sub_dir` 和 `template_id`，用于基于模板的图像识别。 | *   通过 `pc_rect` 定义了每个区域的像素坐标，用于定位。 | *   `template_match_threshold` 用于控制模板匹配的严格程度。
│   │       ├── storage_drive_disc.yml    这个 YAML 文件定义了游戏中一个名为 "仓库-驱动仓库" 的屏幕的界面信息。 |  | *   **主要功能:** 描述了游戏界面中 "仓库-驱动仓库" 屏幕的 UI 元素及其交互。 | *   **核心类和函数:**  该文件使用 YAML 格式，没有类或函数。它定义了屏幕的属性，以及屏幕上各个区域的配置。 | *   **重要功能点:** |     *   `screen_id`:  `storage_drive_disc`，屏幕的唯一标识符。 |     *   `screen_name`:  "仓库-驱动仓库"，屏幕的显示名称。 |     *   `area_list`:  定义了屏幕上各个 UI 元素的区域，包括： |         *   标题 "驱动仓库" |         *   按钮 "拆解"，点击后跳转到 "仓库-驱动仓库-驱动盘拆解" 屏幕。 |         *   左上角的 "街区" 区域，点击后跳转到 "大世界-普通" 屏幕。 |     *   每个 `area_name` 包含 UI 元素的文本、位置 ( `pc_rect` )、以及跳转目标 ( `goto_list` )。
│   │       └── storage_wengine.yml    这个 YAML 文件定义了游戏中一个名为“仓库-音擎仓库”的屏幕的界面信息。 |  | *   **主要功能:** 描述了游戏界面中“音擎仓库”屏幕的 UI 元素及其位置、文本和交互行为。 | *   **核心结构:** 文件使用 YAML 格式，包含 `screen_id`, `screen_name`, `pc_alt` 和 `area_list` 等字段。`area_list` 是一个列表，其中每个元素定义了屏幕上的一个 UI 区域。 | *   **重要功能点:** |     *   定义了屏幕的标题、按钮（例如“回收”）和导航区域（例如“街区”和“驱动盘”）。 |     *   每个 UI 区域都包含其在屏幕上的坐标 (`pc_rect`)、文本 (`text`)、标识符 (`id_mark`) 和导航目标 (`goto_list`)。 |     *   `goto_list` 字段指定了点击该区域后将导航到的其他屏幕。
│   ├── models/
│   │   └── onnx_ocr/
│   │       └── ppocr_keys_v1.txt    ## 摘要 |  | **1. 文件主要功能:** |  | 这个文件是一个文本文件，包含了一系列字符，很可能是用于 OCR (光学字符识别) 模型的词汇表或字典。这些字符可能代表了 OCR 模型的识别范围，例如用于 PPOCR 模型的关键字。 |  | **2. 核心类和函数:** |  | *   **核心类:** 无 (纯文本文件) | *   **核心函数:** 无 (纯文本文件) |  | **3. 重要功能点:** |  | *   **字符列表:** 文件包含大量字符，涵盖了数字、标点符号、汉字、字母和其他特殊符号。 | *   **OCR 词汇表:** 这些字符很可能被用于 OCR 模型的训练或推理过程中，用于识别文本。 | *   **PPOCR 关键字:** 文件名暗示了它可能与 PPOCR (PaddlePaddle OCR) 模型有关，并包含了该模型可能使用的关键字。
│   └── template/
│       ├── agent_state/
│       │   ├── burnice_white_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程式的代理状态模板。 |  | *   **主要功能:** 定义一个名为 "burnice\_white\_2\_2" 的角色状态模板，用于视觉呈现。 | *   **核心元素:** |     *   `template_id`: "burnice\_white\_2\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-柏妮思-22" - 模板的显示名称。 |     *   `template_shape`: "rectangle" - 模板的形状。 |     *   `auto_mask`: `true` - 指示是否自动应用遮罩。 |     *   `point_list`:  `[614, 96], [667, 97]` -  定义用于模板定位或形状的关键点。 | *   **重要功能点:**  定义了模板的形状、遮罩设置和关键点，这些对于模板的视觉呈现和互动至关重要。
│       │   ├── burnice_white_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏或应用程序中角色的视觉状态。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状（例如，矩形）。 |     *   `auto_mask`:  是否启用自动遮罩。 |     *   `point_list`:  关键点坐标列表，用于定位或标记角色状态。 | *   **重要功能点:**  定义了角色状态的视觉表现和定位信息，用于在游戏或其他应用程序中渲染和处理角色状态。
│       │   ├── burnice_white_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏或应用程序中角色的视觉状态。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里定义为矩形。 |     *   `auto_mask`: 布尔值，指示是否启用自动遮罩。 |     *   `point_list`: 一个坐标列表，可能用于定义角色状态的关键点。 | *   **重要功能点:** |     *   定义了角色状态的视觉呈现方式。 |     *   包含了用于定位和处理角色状态的关键信息。 |     *   `auto_mask` 属性暗示了图像处理或渲染方面的功能。
│       │   ├── burnice_white_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于游戏或应用程序中。 |  | *   **主要功能:** 定义角色状态模板的配置信息，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心配置项:** |     *   `template_id`:  模板的唯一标识符 (burnice\_white\_3\_3)。 |     *   `template_name`:  模板的描述性名称 (角色状态-柏妮思-33)。 |     *   `template_shape`:  模板的形状 (rectangle)。 |     *   `auto_mask`:  是否启用自动遮罩 (true)。 |     *   `point_list`:  关键点坐标列表，用于定位或处理角色状态元素。 | *   **重要功能点:**  定义了模板的视觉外观、自动遮罩设置以及关键点，这些信息对于角色状态的渲染和交互至关重要。
│       │   ├── ellen_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个代理状态模板，用于描述游戏角色艾莲的状态。 |  | *   **主要功能:** 定义代理状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 `ellen_2_2`。 |     *   `template_name`: 模板的描述性名称，为 `角色状态-艾莲-22`。 |     *   `template_shape`: 模板的形状，为 `rectangle`。 |     *   `auto_mask`:  是否启用自动遮罩，为 `true`。 |     *   `point_list`:  定义关键点坐标列表，用于定位或识别角色状态。 | *   **重要功能点:** |     *   定义了艾莲角色状态的模板，用于游戏或其他应用场景。 |     *   `auto_mask: true` 表明系统会自动处理遮罩，可能用于图像处理或显示优化。 |     *   `point_list` 提供了关键点坐标，可用于精确定位角色状态。
│       │   ├── ellen_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，名为 "角色状态-艾莲-31"，用于描述游戏或应用程式中角色的视觉状态。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 "ellen\_3\_1"。 |     *   `template_name`: 模板的显示名称，为 "角色状态-艾莲-31"。 |     *   `template_shape`: 模板的形状，为 "rectangle"。 |     *   `auto_mask`:  是否自动遮罩，设为 `true`。 |     *   `point_list`:  包含两个坐标点的列表，可能用于定义角色状态的边界或关键点。 | *   **重要功能点:** |     *   定义角色状态的视觉呈现方式 (形状)。 |     *   启用自动遮罩功能，可能用于图像处理或遮罩效果。 |     *   定义关键点，用于定位或标记角色状态的特定区域。
│       │   ├── ellen_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个代理状态模板，用于描述游戏中角色艾莲的状态。 |  | *   **主要功能:** 定义代理状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 `ellen_3_2`。 |     *   `template_name`: 模板的描述性名称，为 `角色状态-艾莲-32`。 |     *   `template_shape`: 模板的形状，为 `rectangle`。 |     *   `auto_mask`:  是否启用自动遮罩，为 `true`。 |     *   `point_list`: 定义关键点坐标列表。 | *   **重要功能点:**  定义了模板的形状、遮罩行为和关键点，这些信息用于在游戏中渲染和处理角色状态。
│       │   ├── ellen_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-艾莲-33"。 |  | *   **主要功能:** 定义角色状态的模板配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，值为 "ellen\_3\_3"。 |     *   `template_name`: 模板的名称，值为 "角色状态-艾莲-33"。 |     *   `template_shape`: 模板的形状，值为 "rectangle"。 |     *   `auto_mask`: 是否自动遮罩，值为 `true`。 |     *   `point_list`: 一个包含关键点坐标的列表。 | *   **重要功能点:** |     *   定义了模板的形状为矩形。 |     *   启用了自动遮罩功能。 |     *   指定了两个关键点的坐标。
│       │   ├── energy_2_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序的角色状态模板。 |  | *   **主要功能:** 定义一个名为 "角色状态-能量-21" 的角色状态模板，用于视觉呈现和可能的自动遮罩。 | *   **核心元素:** |     *   `template_id`: "energy\_2\_1" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-能量-21" - 模板的描述性名称。 |     *   `template_shape`: "rectangle" - 模板的形状，定义为矩形。 |     *   `auto_mask`: `true` - 启用自动遮罩功能。 |     *   `point_list`:  定义矩形两个顶点的坐标，用于绘制或定位模板。 | *   **重要功能点:**  定义了模板的形状、名称、自动遮罩设置以及用于定位或绘制的关键点。
│       │   ├── energy_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序的代理状态模板。 |  | *   **主要功能:** 定义一个名为 "角色状态-能量-22" 的代理状态模板，用于视觉化表示。 | *   **核心元素:** |     *   `template_id`: "energy\_2\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-能量-22" - 模板的显示名称。 |     *   `template_shape`: "rectangle" - 模板的形状。 |     *   `auto_mask`: `true` -  指示是否自动应用遮罩。 |     *   `point_list`:  定义矩形模板的两个顶点坐标 (722, 74) 和 (780, 75)。 | *   **重要功能点:**  定义了模板的视觉属性，包括形状、遮罩和位置，用于在游戏或应用程序中呈现代理的状态。
│       │   ├── energy_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序的代理状态模板。 |  | *   **主要功能:** 定义一个名为 "energy\_3\_1" 的代理状态模板，用于视觉呈现。 | *   **核心元素:** |     *   `template_id`: "energy\_3\_1" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-能量-31" - 模板的显示名称。 |     *   `template_shape`: "rectangle" - 模板的形状。 |     *   `auto_mask`: `true` -  指示是否自动应用遮罩。 |     *   `point_list`:  定义了矩形的两个顶点坐标 (379, 74) 和 (564, 75)，用于定义模板的边界。 | *   **重要功能点:**  通过定义形状、遮罩和坐标点，该文件配置了代理状态的可视化表示。
│       │   ├── energy_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序中代理状态的模板。 |  | *   **主要功能:** 定义一个名为 "角色状态-能量-32" 的代理状态模板，用于视觉化表示。 | *   **核心配置:** |     *   `template_id`: `energy_3_2`，模板的唯一标识符。 |     *   `template_name`: "角色状态-能量-32"，模板的显示名称。 |     *   `template_shape`: `rectangle`，模板的形状。 |     *   `auto_mask`: `true`，是否自动生成遮罩。 |     *   `point_list`:  `688, 74` 和 `745, 75`，定义了模板的关键点，用于定位和绘制。 | *   **重要功能点:**  定义了模板的视觉属性，包括形状、遮罩和关键点，这些信息用于在游戏或应用程序中呈现代理的能量状态。
│       │   ├── energy_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序的代理状态模板。 |  | *   **主要功能:** 定义一个名为 "energy\_3\_3" 的代理状态模板，用于视觉呈现。 | *   **核心元素:** |     *   `template_id`: "energy\_3\_3"，模板的唯一标识符。 |     *   `template_name`: "角色状态-能量-33"，模板的描述性名称。 |     *   `template_shape`: "rectangle"，模板的形状。 |     *   `auto_mask`: "true"，指示是否自动应用遮罩。 |     *   `point_list`:  定义矩形模板的两个顶点坐标 (869, 74) 和 (927, 75)。 | *   **重要功能点:**  定义了模板的形状、遮罩行为和用于绘制模板的关键点。
│       │   ├── evelyn_chevalier_1_2_2/
│       │   │   └── config.yml    这个 YAML 文件的摘要如下： |  | 1.  **主要功能:** 定义了一个用于角色状态的模板配置，描述了角色伊芙琳的状态信息。 | 2.  **核心元素:** |     *   `template_id`:  `evelyn_chevalier_1_2_2` - 模板的唯一标识符。 |     *   `template_name`: `角色状态-伊芙琳-燎火-22` - 模板的描述性名称。 |     *   `template_shape`: `rectangle` - 模板的形状。 |     *   `auto_mask`: `true` -  指示是否自动应用遮罩。 |     *   `point_list`:  `[609, 99], [645, 100]` -  定义了矩形区域的关键点坐标。 | 3.  **重要功能点:**  该文件配置了角色状态模板的属性，包括模板 ID、名称、形状、自动遮罩设置以及用于定义模板边界的关键点坐标。 这些信息用于在游戏或其他应用程序中呈现和处理角色状态。
│       │   ├── evelyn_chevalier_1_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个 Agent 状态模板。 |  | *   **主要功能:** 定义 Agent 状态的模板配置，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里设定为 "rectangle"。 |     *   `auto_mask`:  是否启用自动遮罩，这里设定为 `true`。 |     *   `point_list`:  关键点坐标列表，用于定义模板的关键位置。 | *   **重要功能点:** |     *   定义 Agent 状态模板的基础信息。 |     *   配置自动遮罩功能。 |     *   定义模板的关键点，用于后续处理。
│       │   ├── evelyn_chevalier_1_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个代理状态模板，用于游戏或应用程序中的角色状态显示。 |  | *   **主要功能:**  配置代理状态模板的属性，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心元素:** |     *   `template_id`:  模板的唯一标识符。 |     *   `template_name`:  模板的描述性名称。 |     *   `template_shape`:  模板的形状（例如，矩形）。 |     *   `auto_mask`:  是否启用自动遮罩。 |     *   `point_list`:  关键点坐标列表，用于定位或处理图像元素。 | *   **重要功能点:**  定义了模板的视觉外观和行为，例如形状、遮罩和关键点，这些信息用于在游戏或应用程序中渲染和处理角色状态。
│       │   ├── evelyn_chevalier_1_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于游戏或其他应用程序。 |  | *   **主要功能:** 描述角色状态的模板配置，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里设定为 "rectangle"。 |     *   `auto_mask`:  是否启用自动遮罩。 |     *   `point_list`:  定义了关键点坐标列表，用于定位或标记。 | *   **重要功能点:** |     *   定义了角色状态模板的基础属性。 |     *   `auto_mask` 启用自动遮罩功能，可能用于图像处理或 UI 渲染。 |     *   `point_list` 提供了关键点坐标，用于定位或标记角色状态元素。
│       │   ├── evelyn_chevalier_2_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板。 |  | *   **主要功能:** 配置一个角色状态模板，用于标记和识别游戏中的角色状态。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里设定为 `multi_rect`，表示多个矩形。 |     *   `auto_mask`:  是否自动生成遮罩。 |     *   `point_list`:  定义了多个点的坐标，用于定义模板的形状。 | *   **重要功能点:** 配置文件定义了模板的属性，包括 ID、名称、形状、是否自动遮罩以及用于定义形状的点坐标。
│       │   ├── evelyn_chevalier_2_3_1/
│       │   │   └── config.yml    这个 YAML 文件的摘要如下： |  | 1.  **主要功能:** 定义了一个角色状态模板的配置，用于描述游戏中角色的视觉状态。 | 2.  **核心元素:** |     *   `template_id`: 模板的唯一标识符，例如 `evelyn_chevalier_2_3_1`。 |     *   `template_name`: 模板的描述性名称，例如 `角色状态-伊芙琳-燎索点-31`。 |     *   `template_shape`: 模板的形状，例如 `multi_rect`。 |     *   `auto_mask`:  是否自动生成遮罩，`true` 表示启用。 |     *   `point_list`:  定义了一组坐标点，可能用于绘制角色状态的边界或区域。 | 3.  **重要功能点:**  定义了角色状态模板的关键属性，包括标识、名称、形状、自动遮罩设置以及用于定义视觉元素的坐标点。
│       │   ├── evelyn_chevalier_2_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于游戏或其他应用程序。 |  | *   **主要功能:** 配置角色状态模板的属性，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里指定为 `multi_rect`。 |     *   `auto_mask`:  是否启用自动遮罩。 |     *   `point_list`:  定义多个关键点的坐标列表，用于定位或识别角色状态的特定区域。 | *   **重要功能点:**  定义了角色状态模板的关键属性，包括外观、遮罩和关键点，这些信息用于在游戏或其他应用程序中呈现和处理角色状态。
│       │   ├── evelyn_chevalier_2_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-伊芙琳-燎索点-33"。 |  | *   **主要功能:** 配置角色状态模板，用于定义游戏中角色的视觉表现。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符 "evelyn\_chevalier\_2\_3\_3"。 |     *   `template_name`: 模板的描述性名称 "角色状态-伊芙琳-燎索点-33"。 |     *   `template_shape`: 模板的形状，设定为 "multi\_rect"。 |     *   `auto_mask`:  是否启用自动遮罩，设定为 `true`。 |     *   `point_list`:  定义了一组坐标点，用于描述模板的形状。 | *   **重要功能点:**  定义了模板的 ID、名称、形状、自动遮罩设置和用于定义形状的点列表。
│       │   ├── guard_break/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏中角色状态的模板，名为 "角色状态-格挡破碎" (Guard Break)。 |  | *   **主要功能:** 定义角色格挡破碎状态的视觉模板，用于游戏资源管理。 | *   **核心配置:** |     *   `template_id`: `guard_break`，模板的唯一标识符。 |     *   `template_name`: `角色状态-格挡破碎`，模板的显示名称。 |     *   `template_shape`: `rectangle`，模板的形状。 |     *   `auto_mask`: `true`，是否自动生成遮罩。 |     *   `point_list`: 一个包含两个坐标点的列表，用于定义模板的形状或位置。
│       │   ├── hoshimi_miyabi_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏或应用程序中角色的视觉状态。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状类型，这里设定为 `multi_rect`。 |     *   `auto_mask`:  是否启用自动遮罩功能。 |     *   `point_list`:  定义了一系列关键点的坐标，用于定位和识别角色状态。 | *   **重要功能点:** |     *   定义了角色状态的视觉表现，通过形状和关键点来实现。 |     *   `auto_mask` 启用，表明系统可能需要自动处理遮罩，以更好地显示角色状态。 |     *   `point_list` 提供了用于定位和识别角色状态的关键点坐标。
│       │   ├── hoshimi_miyabi_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏或应用程序中角色的视觉状态。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 `hoshimi_miyabi_3_1`。 |     *   `template_name`: 模板的描述性名称，为 "角色状态-雅-31"。 |     *   `template_shape`: 模板的形状，为 `multi_rect`。 |     *   `auto_mask`: 是否启用自动遮罩，为 `true`。 |     *   `point_list`: 一个坐标列表，定义了角色状态的关键点。 | *   **重要功能点:** |     *   配置了角色状态模板的名称和形状。 |     *   启用自动遮罩功能，用于图像处理。 |     *   定义了一组关键点坐标，可能用于角色状态的视觉效果或动画。
│       │   ├── hoshimi_miyabi_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个代理状态模板，用于描述游戏中角色的状态。 |  | *   **主要功能:** 定义一个名为「角色状态-雅-32」的代理状态模板，用于多边形区域的状态检测。 | *   **核心元素:** |     *   `template_id`: `hoshimi_miyabi_3_2`，模板的唯一标识符。 |     *   `template_name`: `角色状态-雅-32`，模板的名称。 |     *   `template_shape`: `multi_rect`，模板的形状，表示多边形。 |     *   `auto_mask`: `true`，启用自动遮罩。 |     *   `point_list`: 一个包含多个坐标点的列表，定义了多边形的顶点，用于界定状态检测的区域。 | *   **重要功能点:**  定义了代理状态模板的形状和位置，以及是否启用自动遮罩。
│       │   ├── hoshimi_miyabi_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板。 |  | *   **主要功能:** 配置一个角色状态模板，用于识别和处理游戏中的角色状态。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的名称。 |     *   `template_shape`: 模板的形状，这里定义为 `multi_rect` (多矩形)。 |     *   `auto_mask`:  是否自动生成遮罩，设为 `true`。 |     *   `point_list`:  定义了多个点的坐标，用于描述角色状态的区域。 | *   **重要功能点:**  定义了模板的形状和位置，以及是否自动生成遮罩，用于图像识别或游戏状态分析。
│       │   ├── jane_attack_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于游戏或其他应用程序。 |  | *   **主要功能:** 定义角色 "简" 在 "萨霍夫跳" 状态下的视觉表现和行为。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符 (jane\_attack\_2\_2)。 |     *   `template_name`: 模板的描述性名称 ("角色状态-简-萨霍夫跳-22")。 |     *   `template_shape`: 模板的形状 ("circle")。 |     *   `auto_mask`: 是否自动应用遮罩 (true)。 |     *   `point_list`: 定义形状的点坐标列表。 | *   **重要功能点:**  定义了模板的形状、遮罩设置和关键点坐标，这些信息用于渲染和处理角色状态的视觉效果。
│       │   ├── jane_attack_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于游戏或其他应用程序。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心数据结构:** YAML 文件本身，使用键值对存储配置信息。 | *   **重要功能点:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里设置为 "circle"。 |     *   `auto_mask`:  是否启用自动遮罩，设置为 `true`。 |     *   `point_list`:  定义关键点坐标列表，用于角色动画或碰撞检测。
│       │   ├── jane_attack_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于游戏或其他应用程序。 |  | *   **主要功能:** 定义角色 "Jane" 在 "萨霍夫跳" 状态下的视觉表现和行为。 | *   **核心元素:** |     *   `template_id`: "jane\_attack\_3\_2" 模板的唯一标识符。 |     *   `template_name`: "角色状态-简-萨霍夫跳-32" 模板的描述性名称。 |     *   `template_shape`: "circle" 模板的形状。 |     *   `auto_mask`: `true` 表示自动遮罩。 |     *   `point_list`:  定义了两个点的坐标 (626, 98) 和 (626, 95)，可能用于定义形状或碰撞区域。 | *   **重要功能点:**  定义了模板的形状、遮罩设置和关键点，这些信息用于角色在特定状态下的视觉呈现和交互。
│       │   ├── jane_attack_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于游戏或动画中的角色。 |  | *   **主要功能:** 定义角色状态的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心类和函数:**  无，因为这是一个数据配置文件，而不是代码文件。 | *   **重要功能点:** |     *   `template_id`:  `jane_attack_3_3`，模板的唯一标识符。 |     *   `template_name`: `角色状态-简-萨霍夫跳-33`，模板的描述性名称。 |     *   `template_shape`: `circle`，定义了模板的形状。 |     *   `auto_mask`: `true`，表示启用自动遮罩。 |     *   `point_list`:  定义了两个关键点的坐标，用于角色动画或特效。
│       │   ├── jane_red_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个 Agent 状态模板，名为 "角色状态-简-狂热心流-22"。 |  | *   **主要功能:** 描述 Agent 的状态模板，包含模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，值为 "jane_red_2_2"。 |     *   `template_name`: 模板的描述性名称，值为 "角色状态-简-狂热心流-22"。 |     *   `template_shape`: 模板的形状，值为 "rectangle"。 |     *   `auto_mask`:  是否启用自动遮罩，值为 "true"。 |     *   `point_list`:  定义关键点坐标的列表。 | *   **重要功能点:** |     *   定义 Agent 状态模板的基础信息。 |     *   指定模板的形状和是否自动遮罩。 |     *   通过 `point_list` 定义关键点，可能用于定位或识别 Agent 状态。
│       │   ├── jane_red_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个 Agent 状态模板。 |  | *   **主要功能:** 配置 Agent 状态模板的属性，用于在游戏或其他应用程序中呈现 Agent 的状态。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状 (例如 "rectangle")。 |     *   `auto_mask`:  指示是否自动应用遮罩。 |     *   `point_list`:  定义模板的关键点坐标。 | *   **重要功能点:**  定义了模板的 ID、名称、形状、遮罩设置以及关键点坐标，这些信息共同构成了 Agent 状态的可视化表现。
│       │   ├── jane_red_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个 Agent 状态模板。 |  | *   **主要功能:** 配置 Agent 状态模板的属性，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状（例如 "rectangle"）。 |     *   `auto_mask`:  指示是否启用自动遮罩。 |     *   `point_list`:  定义关键点坐标的列表。 | *   **重要功能点:**  定义了 Agent 状态模板的视觉和行为属性，用于在游戏或其他应用程序中呈现 Agent 的状态。
│       │   ├── jane_red_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个代理状态模板，用于描述游戏中角色的状态。 |  | *   **主要功能:** 定义代理状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 `jane_red_3_3`。 |     *   `template_name`: 模板的描述性名称，为 `角色状态-简-狂热心流-33`。 |     *   `template_shape`: 模板的形状，为 `rectangle`。 |     *   `auto_mask`:  是否启用自动遮罩，为 `true`。 |     *   `point_list`:  定义矩形区域的关键点坐标列表。 | *   **重要功能点:** |     *   定义了代理状态模板的基本属性，用于在游戏中视觉化和管理角色状态。 |     *   `auto_mask` 启用自动遮罩，可能用于优化渲染或处理。 |     *   `point_list` 定义了模板的形状，用于定位和绘制状态元素。
│       │   ├── life_deduction_2_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序中角色状态的模板，特别是关于血量扣减的视觉表现。 |  | *   **主要功能**: 定义了角色血量扣减状态的视觉模板。 | *   **核心配置**: |     *   `template_id`: `life_deduction_2_1`，模板的唯一标识符。 |     *   `template_name`: `角色状态-血量扣减-21`，模板的名称。 |     *   `template_shape`: `rectangle`，定义了模板的形状为矩形。 |     *   `auto_mask`: `true`，表示自动应用遮罩。 |     *   `point_list`:  `[275, 51], [605, 52]`，定义了矩形的两个顶点，用于定位和绘制矩形。 | *   **重要功能点**:  定义了模板的形状、位置和遮罩设置，用于在界面上视觉化地呈现血量扣减的效果。
│       │   ├── life_deduction_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-血量扣减-31"，用于表示血量扣减的视觉效果。 |  | *   **主要功能:** 定义角色状态模板的配置，用于血量扣减的可视化。 | *   **核心配置项:** |     *   `template_id`: `life_deduction_3_1`，模板的唯一标识符。 |     *   `template_name`: `角色状态-血量扣减-31`，模板的描述性名称。 |     *   `template_shape`: `rectangle`，模板的形状。 |     *   `auto_mask`: `true`，是否自动遮罩。 |     *   `point_list`:  `[274, 51], [572, 52]`，定义模板的关键点，用于定位和绘制。 | *   **重要功能点:**  定义了模板的形状、名称、遮罩设置和关键点，这些配置共同决定了血量扣减效果的视觉呈现。
│       │   ├── lighter_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-莱特-22"，模板形状为矩形。它包含以下关键信息： |  | 1.  **主要功能:** 定义角色状态的模板配置。 | 2.  **核心元素:** |     *   `template_id`: "lighter\_2\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-莱特-22" - 模板的名称。 |     *   `template_shape`: "rectangle" - 模板的形状。 |     *   `auto_mask`: `true` -  指示是否自动生成遮罩。 |     *   `point_list`:  包含两个点的列表，用于定义模板的几何形状或位置。 | 3.  **重要功能点:**  定义了模板的 ID、名称、形状、是否自动遮罩以及用于定位的点列表。
│       │   ├── lighter_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-莱特-31"。 |  | *   **主要功能:** 描述角色状态的视觉模板，用于在游戏或其他应用中呈现角色状态。 | *   **核心配置:** |     *   `template_id`: "lighter\_3\_1" (模板 ID) |     *   `template_name`: "角色状态-莱特-31" (模板名称) |     *   `template_shape`: "rectangle" (模板形状) |     *   `auto_mask`: `true` (是否自动遮罩) |     *   `point_list`:  定义矩形模板的两个顶点坐标 (135, 119) 和 (219, 120)。 | *   **重要功能点:** 定义模板的形状、名称、ID，以及是否自动遮罩和用于定位的关键点。
│       │   ├── lighter_3_2/
│       │   │   └── config.yml    这个 YAML 文件的摘要如下： |  | 1.  **主要功能：** 定义了用于角色状态的模板配置，特别是针对名为 "lighter\_3\_2" 的角色。 | 2.  **核心元素：** |     *   `template_id`: "lighter\_3\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-莱特-32" - 模板的描述性名称。 |     *   `template_shape`: "rectangle" - 模板的形状。 |     *   `auto_mask`: `true` - 指示是否自动应用遮罩。 |     *   `point_list`:  定义了一组坐标点，可能用于定位或定义模板的边界。 | 3.  **重要功能点：** 该文件配置了模板的 ID、名称、形状、自动遮罩设置以及关键点坐标，这些信息共同定义了角色状态的可视化或处理方式。
│       │   ├── lighter_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序的角色状态模板。 |  | *   **主要功能:** 定义了名为 "lighter\_3\_3" 的角色状态模板的配置信息，包括模板的 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符 ("lighter\_3\_3")。 |     *   `template_name`: 模板的显示名称 ("角色状态-莱特-33")。 |     *   `template_shape`: 模板的形状 ("rectangle")。 |     *   `auto_mask`: 是否启用自动遮罩 ("true")。 |     *   `point_list`: 一个包含两个坐标点的列表，用于定义模板的关键点。 | *   **重要功能点:** |     *   定义了角色状态模板的基本属性。 |     *   启用自动遮罩功能，可能用于图像处理或游戏渲染。 |     *   通过 `point_list` 定义了模板的关键点，这些点可能用于定位、动画或交互。
│       │   ├── pulchra_hunter_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-波可娜-22"。 |  | *   **主要功能:** 配置角色状态模板，用于图像处理。 | *   **核心元素:** |     *   `template_id`: "pulchra\_hunter\_2\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-波可娜-22" - 模板的名称。 |     *   `template_shape`: "multi\_rect" - 模板的形状类型。 |     *   `auto_mask`: `true` - 指示是否自动应用遮罩。 |     *   `point_list`: 一个包含多个坐标点的列表，用于定义模板的形状。 | *   **重要功能点:** 定义了模板的形状和位置，以及是否自动应用遮罩，这些信息对于图像处理和角色状态的识别至关重要。
│       │   ├── pulchra_hunter_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态检测的模板。 |  | *   **主要功能:** 定义了角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里定义为 `multi_rect`。 |     *   `auto_mask`: 是否启用自动遮罩。 |     *   `point_list`: 一个包含关键点坐标的列表，用于定位角色状态。 | *   **重要功能点:**  定义了角色状态检测的关键点，以及是否启用自动遮罩。
│       │   ├── pulchra_hunter_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏中角色「波可娜」的状态。 |  | *   **主要功能:** 配置角色状态模板，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符 (pulchra\_hunter\_3\_2)。 |     *   `template_name`: 模板的描述性名称 (角色状态-波可娜-32)。 |     *   `template_shape`: 模板的形状 (multi\_rect)。 |     *   `auto_mask`: 是否启用自动遮罩 (true)。 |     *   `point_list`: 定义多个关键点的坐标，用于定位角色状态。 | *   **重要功能点:** 配置文件定义了角色状态的视觉表现和定位方式，通过 `point_list` 提供了用于绘制或识别角色状态的关键点。
│       │   ├── pulchra_hunter_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏中角色「波可娜」的状态。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状和关键点。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 `pulchra_hunter_3_3`。 |     *   `template_name`: 模板的描述性名称，为「角色状态-波可娜-33」。 |     *   `template_shape`: 模板的形状，为 `multi_rect`。 |     *   `auto_mask`:  是否自动生成遮罩，设为 `true`。 |     *   `point_list`:  定义了一组关键点的坐标，用于标识角色状态的区域。 | *   **重要功能点:**  定义了角色状态的视觉区域，以及是否自动生成遮罩。
│       │   ├── qingyi_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个 agent 状态模板，用于描述游戏中角色的状态。 |  | *   **主要功能:** 定义 agent 状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心配置项:** |     *   `template_id`: 模板的唯一标识符，为 `qingyi_2_2`。 |     *   `template_name`: 模板的描述性名称，为 `角色状态-青衣-22`。 |     *   `template_shape`: 模板的形状，为 `rectangle`。 |     *   `auto_mask`: 是否自动遮罩，为 `true`。 |     *   `point_list`: 一个包含两个坐标点的列表，用于定义模板的关键点。 | *   **重要功能点:**  定义了 agent 状态模板的基本属性，包括外观和关键点，用于在游戏中视觉化和定位 agent 状态。
│       │   ├── qingyi_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏中角色的视觉状态。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心元素:** |     *   `sub_dir`: 指定模板所属的子目录。 |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里设定为矩形。 |     *   `auto_mask`:  是否启用自动遮罩。 |     *   `point_list`:  关键点坐标列表，用于定位角色状态的视觉元素。 | *   **重要功能点:**  定义了模板的形状、自动遮罩设置和关键点，这些配置共同决定了角色状态在游戏中的视觉呈现方式。
│       │   ├── qingyi_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-青衣-32"。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心配置:** |     *   `template_id`: `qingyi_3_2` (模板 ID) |     *   `template_name`: `角色状态-青衣-32` (模板名称) |     *   `template_shape`: `rectangle` (模板形状) |     *   `auto_mask`: `true` (是否自动遮罩) |     *   `point_list`:  `578, 96` 和 `631, 97` (关键点坐标) | *   **重要功能点:**  定义了模板的形状、是否自动遮罩以及关键点，这些信息用于在图像或其他视觉元素中定位和呈现角色状态。
│       │   ├── qingyi_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-青衣-33"。 |  | *   **主要功能:** 定义角色状态的模板配置，用于视觉化呈现。 | *   **核心元素:** |     *   `template_id`: "qingyi\_3\_3" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-青衣-33" - 模板的名称。 |     *   `template_shape`: "rectangle" - 模板的形状。 |     *   `auto_mask`: `true` -  是否自动进行遮罩。 |     *   `point_list`:  `[760, 96], [813, 97]` - 定义模板的关键点坐标。 | *   **重要功能点:**  定义模板的形状、遮罩设置和关键点，用于在视觉化中定位和呈现角色状态。
│       │   ├── seth_lowell_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板。 |  | *   **主要功能:** 定义一个名为 "角色状态-赛斯-22" 的角色状态模板，用于在应用程序中呈现或处理角色状态信息。 | *   **核心元素:** |     *   `template_id`: "seth\_lowell\_2\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-赛斯-22" - 模板的显示名称。 |     *   `template_shape`: "rectangle" - 模板的形状。 |     *   `auto_mask`: `true` -  指示是否启用自动遮罩。 |     *   `point_list`:  定义矩形模板的两个顶点坐标 (613, 98) 和 (666, 99)。 | *   **重要功能点:**  定义了模板的形状、名称、自动遮罩设置以及用于定位模板的关键点。
│       │   ├── seth_lowell_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个 agent 状态模板。 |  | *   **主要功能:**  配置一个 agent 状态模板，用于描述 agent 的视觉呈现和行为。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里设定为 "rectangle"。 |     *   `auto_mask`:  是否自动应用遮罩。 |     *   `point_list`:  定义形状的点坐标列表。 | *   **重要功能点:**  定义了模板的形状、名称、遮罩设置和关键点坐标，这些信息用于在界面上呈现 agent 的状态。
│       │   ├── seth_lowell_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板。 |  | *   **主要功能:** 定义角色状态的模板配置，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心配置项:** |     *   `sub_dir`: 模板所属的子目录 (agent\_state)。 |     *   `template_id`: 模板的唯一标识 (seth\_lowell\_3\_2)。 |     *   `template_name`: 模板的描述性名称 (角色状态-赛斯-32)。 |     *   `template_shape`: 模板的形状 (rectangle)。 |     *   `auto_mask`: 是否启用自动遮罩 (true)。 |     *   `point_list`: 关键点坐标列表，用于定位角色状态元素。 | *   **重要功能点:**  定义模板的形状和关键点，以及是否启用自动遮罩。
│       │   ├── seth_lowell_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个代理状态模板。 |  | *   **主要功能:** 定义一个代理状态模板的配置，用于描述游戏中角色的状态。 | *   **核心配置项:** |     *   `sub_dir`: 模板所属的子目录，值为 `agent_state`。 |     *   `template_id`: 模板的唯一标识符，值为 `seth_lowell_3_3`。 |     *   `template_name`: 模板的名称，值为 `角色状态-赛斯-33`。 |     *   `template_shape`: 模板的形状，值为 `rectangle`。 |     *   `auto_mask`: 是否自动生成遮罩，值为 `true`。 |     *   `point_list`: 一个包含两个坐标点的列表，用于定义模板的边界或关键点。 | *   **重要功能点:**  定义了模板的形状、名称、自动遮罩设置以及关键点坐标。
│       │   ├── soukaku_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-苍角-22"。 |  | *   **主要功能:** 定义角色状态的视觉模板，包括形状和坐标。 | *   **核心元素:** |     *   `template_id`: "soukaku\_2\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-苍角-22" - 模板的名称。 |     *   `template_shape`: "polygon" - 模板的形状类型。 |     *   `auto_mask`: true - 指示是否自动创建遮罩。 |     *   `point_list`:  定义多边形顶点坐标的列表。 | *   **重要功能点:**  定义了模板的形状和位置，用于在界面上呈现角色状态。
│       │   ├── soukaku_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏或应用程序中的角色状态。 |  | *   **主要功能:** 定义角色状态的模板，包括模板 ID、名称、形状和用于遮罩的点列表。 | *   **核心元素:** |     *   `template_id`: `soukaku_3_1`，模板的唯一标识符。 |     *   `template_name`: `角色状态-苍角-31`，模板的描述性名称。 |     *   `template_shape`: `polygon`，模板的形状类型。 |     *   `auto_mask`: `true`，指示是否自动应用遮罩。 |     *   `point_list`: 一个包含多个坐标点的列表，用于定义多边形的形状，可能用于遮罩。 | *   **重要功能点:** |     *   定义了角色状态的几何形状 (多边形)。 |     *   包含了用于遮罩的点列表，这可能用于视觉效果或碰撞检测。 |     *   `auto_mask` 标志表明遮罩功能已启用。
│       │   ├── soukaku_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个名为 "角色状态-苍角-32" 的代理状态模板。 |  | *   **主要功能:** 定义代理状态的模板配置，包括模板 ID、名称、形状、自动遮罩设置和点列表。 | *   **核心元素:** |     *   `template_id`: "soukaku\_3\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-苍角-32" - 模板的描述性名称。 |     *   `template_shape`: "polygon" - 模板的形状类型。 |     *   `auto_mask`: `true` - 指示是否启用自动遮罩。 |     *   `point_list`:  定义多边形形状的坐标点列表。 | *   **重要功能点:**  定义了代理状态的几何形状，用于视觉呈现或碰撞检测。
│       │   ├── soukaku_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板。 |  | *   **主要功能:** 定义角色状态的视觉模板，包括形状和坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的名称。 |     *   `template_shape`: 模板的形状，这里为 "polygon"。 |     *   `auto_mask`: 是否自动生成遮罩。 |     *   `point_list`: 定义多边形形状的顶点坐标列表。 | *   **重要功能点:**  定义了角色状态的形状和位置，用于在游戏或其他应用程序中视觉化地表示角色状态。
│       │   ├── special_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于游戏或其他应用程序。 |  | *   **主要功能:** 定义一个名为 "角色状态-特殊技-31" 的角色状态模板，包含模板 ID、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`:  "special\_3\_1" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-特殊技-31" - 模板的名称。 |     *   `template_shape`: "circle" - 模板的形状。 |     *   `auto_mask`: `true` -  指示是否启用自动遮罩。 |     *   `point_list`:  包含两个坐标点的列表，用于定义模板的关键点。 | *   **重要功能点:**  定义了角色状态的外观和行为，包括形状、遮罩和关键点，这些信息用于游戏或其他应用程序中角色的视觉表现和交互。
│       │   ├── trigger_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程式的模板，用于描述一个触发器（trigger）的状态。 |  | *   **主要功能:** 定义一个名为 "角色状态-扳机-22" 的矩形触发器模板，用于处理游戏中的状态变化。 | *   **核心元素:** |     *   `template_id`: "trigger\_2\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-扳机-22" - 模板的描述性名称。 |     *   `template_shape`: "rectangle" - 触发器的形状。 |     *   `auto_mask`: `true` - 指示是否自动应用遮罩。 |     *   `point_list`:  定义矩形触发器两个顶点的坐标 (619, 98) 和 (662, 99)。 | *   **重要功能点:**  定义了触发器的形状、位置和自动遮罩的设置，这些设置用于在游戏中检测和响应玩家或其他实体进入触发区域。
│       │   ├── trigger_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序的模板，用于描述一个矩形区域的角色状态触发器。 |  | *   **主要功能:** 定义一个角色状态触发器的配置，包括其形状、位置和自动遮罩设置。 | *   **核心元素:** |     *   `template_id`: 触发器的唯一标识符。 |     *   `template_name`: 触发器的名称。 |     *   `template_shape`: 触发器的形状，这里为 "rectangle"。 |     *   `auto_mask`:  是否自动应用遮罩。 |     *   `point_list`:  定义矩形区域的两个顶点坐标。 | *   **重要功能点:**  定义了触发器的形状和位置，以及是否自动遮罩，这些信息用于在游戏或应用程序中检测角色是否进入特定区域。
│       │   ├── trigger_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-扳机-32"。 |  | *   **主要功能:** 定义一个矩形形状的模板，用于角色状态的触发。 | *   **核心元素:** |     *   `template_id`: "trigger\_3\_2" (模板 ID) |     *   `template_name`: "角色状态-扳机-32" (模板名称) |     *   `template_shape`: "rectangle" (模板形状) |     *   `auto_mask`: `true` (是否自动遮罩) |     *   `point_list`:  定义矩形两个顶点的坐标 (585, 98) 和 (628, 99)。 | *   **重要功能点:**  定义了模板的形状、名称、ID，以及是否自动遮罩，并提供了用于定位矩形的两个关键点坐标。
│       │   ├── trigger_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序的模板，用于描述一个名为 "角色状态-扳机-33" 的矩形区域的代理状态触发器。 |  | *   **主要功能:** 定义一个代理状态触发器的配置，包括其形状、位置和自动遮罩设置。 | *   **核心元素:** |     *   `template_id`: "trigger\_3\_3" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-扳机-33" - 模板的描述性名称。 |     *   `template_shape`: "rectangle" - 模板的形状。 |     *   `auto_mask`: `true` -  指示是否自动应用遮罩。 |     *   `point_list`:  定义矩形区域的两个顶点坐标 (767, 98) 和 (809, 99)。 | *   **重要功能点:**  定义了触发器的形状、位置和遮罩行为，这些信息将用于在游戏或应用程序中触发代理状态的变化。
│       │   ├── ultimate_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个 Agent 状态模板，用于描述游戏中角色的状态。 |  | *   **主要功能:** 定义一个角色状态模板，包含模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的名称。 |     *   `template_shape`: 模板的形状 (例如 "rectangle")。 |     *   `auto_mask`:  是否启用自动遮罩。 |     *   `point_list`:  定义关键点坐标的列表。 | *   **重要功能点:**  定义了模板的基础属性，包括用于视觉呈现和交互的形状和关键点。 `auto_mask` 参数暗示了可能用于图像处理或视觉效果的功能。
│       │   ├── ultimate_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于游戏或其他应用程序。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心配置项:** |     *   `sub_dir`: 模板所属的子目录。 |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的名称。 |     *   `template_shape`: 模板的形状，这里定义为 "circle" (圆形)。 |     *   `auto_mask`: 是否启用自动遮罩，设置为 `true`。 |     *   `point_list`: 一个包含两个坐标点的列表，用于定义模板的关键点。 | *   **重要功能点:**  定义了角色状态的视觉表现和行为，包括形状、遮罩和关键点，这些信息将被用于渲染或处理角色状态。
│       │   ├── ultimate_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏中角色的终结技状态。 |  | *   **主要功能:** 定义角色状态模板的配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心配置项:** |     *   `sub_dir`: 模板所属的子目录，为 `agent_state`。 |     *   `template_id`: 模板的唯一标识符，为 `ultimate_3_2`。 |     *   `template_name`: 模板的描述性名称，为 `角色状态-终结技-32`。 |     *   `template_shape`: 模板的形状，为 `rectangle`。 |     *   `auto_mask`: 是否自动遮罩，为 `true`。 |     *   `point_list`: 定义关键点坐标列表，用于定位和识别角色状态。 | *   **重要功能点:**  定义了模板的形状和关键点，以及是否启用自动遮罩，这些配置共同决定了角色状态的视觉表现和识别方式。
│       │   ├── ultimate_3_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序的角色状态模板。 |  | *   **主要功能:** 定义了名为 "角色状态-终结技-33" 的角色状态模板，用于视觉化呈现。 | *   **核心元素:** |     *   `template_id`: "ultimate\_3\_3" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-终结技-33" - 模板的名称。 |     *   `template_shape`: "rectangle" - 模板的形状。 |     *   `auto_mask`: `true` -  指示是否自动应用遮罩。 |     *   `point_list`:  定义了矩形模板的两个顶点坐标 (831, 74) 和 (863, 75)。 | *   **重要功能点:**  定义了模板的形状、名称、遮罩设置和关键点坐标，这些信息用于在游戏或应用程序中渲染和处理角色状态。
│       │   ├── yanagi_blue_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个代理状态模板。 |  | *   **主要功能:** 配置代理状态模板，描述其外观和形状。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的描述性名称。 |     *   `template_shape`: 模板的形状，这里设定为 `polygon` (多边形)。 |     *   `auto_mask`:  是否自动生成遮罩，设定为 `true`。 |     *   `point_list`:  定义多边形形状的顶点坐标列表。 | *   **重要功能点:**  定义了代理状态的视觉呈现，包括形状和遮罩。
│       │   ├── zhu_yuan_2_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-朱鸢-22"。 |  | *   **主要功能:** 定义角色状态的视觉模板，用于图像处理或游戏开发。 | *   **核心配置:** |     *   `template_id`: "zhu\_yuan\_2\_2" - 模板的唯一标识符。 |     *   `template_name`: "角色状态-朱鸢-22" - 模板的描述性名称。 |     *   `template_shape`: "quadrilateral" - 模板的形状，定义为四边形。 |     *   `auto_mask`: `true` - 启用自动遮罩功能。 |     *   `point_list`:  定义四边形的四个顶点坐标，用于定位模板在图像中的位置。
│       │   ├── zhu_yuan_3_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于角色状态的模板，名为 "角色状态-朱鸢-31"。 |  | *   **主要功能:** 定义角色状态的模板配置，包括模板 ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 "zhu\_yuan\_3\_1"。 |     *   `template_name`: 模板的名称，为 "角色状态-朱鸢-31"。 |     *   `template_shape`: 模板的形状，为 "quadrilateral" (四边形)。 |     *   `auto_mask`:  是否自动遮罩，设为 `true`。 |     *   `point_list`:  定义四边形四个顶点的坐标列表。 | *   **重要功能点:**  定义了模板的几何形状和关键点，用于在图像或场景中定位和识别角色状态。 启用自动遮罩功能。
│       │   ├── zhu_yuan_3_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个角色状态模板，用于描述游戏中角色“朱鸢”的状态。 |  | *   **主要功能:** 定义角色状态模板的配置信息。 | *   **核心配置:** |     *   `sub_dir`: 模板所属的子目录。 |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的名称。 |     *   `template_shape`: 模板的形状，这里定义为四边形。 |     *   `auto_mask`: 是否自动生成遮罩，设为 true。 |     *   `point_list`: 定义四边形的顶点坐标。 | *   **重要功能点:** 描述角色状态模板的形状和位置，以及是否自动生成遮罩。
│       │   └── zhu_yuan_3_3/
│       │       └── config.yml    这个 YAML 文件的摘要如下： |  | 1.  **主要功能：** 定义了一个角色状态模板的配置，用于描述游戏中朱鸢角色的状态。 | 2.  **核心元素：** |     *   `template_id`:  `zhu_yuan_3_3`，模板的唯一标识符。 |     *   `template_name`: `角色状态-朱鸢-33`，模板的名称。 |     *   `template_shape`: `quadrilateral`，定义了模板的形状为四边形。 |     *   `auto_mask`: `true`，表示启用自动遮罩。 |     *   `point_list`:  定义了四边形的四个顶点坐标，用于描述角色状态的区域。 | 3.  **重要功能点：**  定义了角色状态模板的形状、自动遮罩设置以及用于定位状态区域的关键点坐标。
│       ├── battle/
│       │   ├── avatar_1_rina/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于战斗场景中角色头像的模板。 |  | *   **主要功能:** 描述了角色头像的形状和位置，用于在战斗场景中渲染角色头像。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符 (`avatar_1_rina`)。 |     *   `template_name`: 模板的名称 (`战斗-头像-3-1`)。 |     *   `template_shape`: 模板的形状 (`polygon`)。 |     *   `auto_mask`: 是否自动生成遮罩 (`true`)。 |     *   `point_list`: 定义多边形形状的顶点坐标列表。 | *   **重要功能点:**  定义了头像的形状和位置，用于渲染。
│       │   ├── avatar_2_anby/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个战斗场景中头像的模板配置。 |  | *   **主要功能:** 定义战斗中头像的视觉模板，包括形状、自动遮罩设置和关键点坐标。 | *   **核心配置项:** |     *   `template_id`: 模板 ID，`avatar_2_anby`。 |     *   `template_name`: 模板名称，`战斗-头像-3-2`。 |     *   `template_shape`: 模板形状，`quadrilateral` (四边形)。 |     *   `auto_mask`: 是否启用自动遮罩，`true`。 |     *   `point_list`: 定义四边形四个顶点的坐标列表。 | *   **重要功能点:**  定义了头像的形状和位置，以及是否启用自动遮罩，这些配置用于在战斗场景中渲染头像。
│       │   ├── avatar_2_anton/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于战斗场景的头像模板。 |  | *   **主要功能:** 定义战斗场景中头像的配置，包括模板 ID、名称、形状和关键点。 | *   **核心元素:** |     *   `template_id`:  `avatar_2_anton`，模板的唯一标识符。 |     *   `template_name`:  `战斗-头像-3-3`，模板的名称。 |     *   `template_shape`:  `quadrilateral`，头像的形状。 |     *   `auto_mask`:  `true`，是否自动应用遮罩。 |     *   `point_list`:  定义头像边界的四个点的坐标。 | *   **重要功能点:**  定义了头像的形状和位置，以及是否自动应用遮罩，用于在战斗场景中渲染头像。
│       │   ├── avatar_2_piper/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个战斗场景中，名为 "avatar_2_piper" 的模板配置。 |  | *   **主要功能:**  配置战斗场景中头像的模板，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心元素:** |     *   `template_id`:  "avatar_2_piper" - 模板的唯一标识符。 |     *   `template_name`: "战斗-头像-2-2" - 模板的名称。 |     *   `template_shape`: "quadrilateral" - 模板的形状（四边形）。 |     *   `auto_mask`: true -  是否启用自动遮罩。 |     *   `point_list`:  定义四边形四个顶点的坐标列表。 | *   **重要功能点:**  定义了战斗场景中头像的视觉呈现，包括形状和位置，以及是否启用自动遮罩。
│       │   ├── avatar_chain_anby/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于战斗场景的连携技模板。 |  | *   **主要功能:** 定义一个名为 "连携技-2" 的连携技模板，用于战斗场景。 | *   **核心配置:** |     *   `template_id`: `chain_attack_anby` (模板 ID) |     *   `template_name`: `连携技-2` (模板名称) |     *   `template_shape`: `circle` (模板形状) |     *   `auto_mask`: `true` (是否自动遮罩) |     *   `point_list`:  定义了两个点的坐标，用于定位模板。 | *   **重要功能点:**  定义了连携技的形状、名称、遮罩设置和关键点坐标，这些信息用于在战斗场景中视觉化和控制连携技的行为。
│       │   ├── avatar_chain_nicole/
│       │   │   └── config.yml    这个 YAML 配置文件定义了游戏中一个名为 "连携技-1" 的角色连携技能的视觉效果和触发点。 |  | *   **主要功能:** 配置角色连携技能的视觉效果和触发点。 | *   **核心配置:** |     *   `template_id`: "avatar\_chain\_nicole" - 模板 ID。 |     *   `template_name`: "连携技-1" - 模板名称。 |     *   `template_shape`: "circle" - 视觉形状为圆形。 |     *   `auto_mask`: `true` - 启用自动遮罩。 |     *   `point_list`:  定义了两个触发点的坐标 (538, 887) 和 (489, 887)。 | *   **重要功能点:** 定义了视觉模板的形状、自动遮罩设置以及触发点坐标，这些信息用于在游戏中呈现和触发该连携技能。
│       │   ├── avatar_chain_trigger/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于战斗场景中的视觉效果模板，特别是关于角色连携技能的触发。 |  | *   **主要功能:** 定义一个连携技能触发的视觉效果模板。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 `avatar_chain_trigger`。 |     *   `template_name`: 模板的名称，为 `连携技-1`。 |     *   `template_shape`: 模板的形状，为 `circle`。 |     *   `auto_mask`: 是否自动应用遮罩，为 `true`。 |     *   `point_list`: 一个包含两个坐标点的列表，用于定义视觉效果的位置。 | *   **重要功能点:**  定义了连携技能视觉效果的基础属性，包括形状、遮罩和位置。
│       │   ├── avatar_quick_trigger/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于战斗场景的快速支援触发器模板。 |  | *   **主要功能:** 定义战斗中快速支援的触发区域和相关属性。 | *   **核心属性:** |     *   `template_id`: `avatar_quick_trigger`，模板 ID。 |     *   `template_name`: `战斗-快速支援`，模板名称。 |     *   `template_shape`: `circle`，触发区域形状为圆形。 |     *   `auto_mask`: `true`，启用自动遮罩。 |     *   `point_list`:  定义了两个点的坐标，用于定义触发区域的位置。 | *   **重要功能点:**  定义了触发器的基本属性，包括形状、自动遮罩以及触发点的坐标。
│       │   ├── avatar_quick_zhu_yuan/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个战斗模板，用于快速支援。 |  | *   **主要功能:** 定义战斗场景的模板，用于快速支援。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的名称。 |     *   `template_shape`: 模板的形状，这里设定为 `circle`。 |     *   `auto_mask`: 是否自动遮罩，设定为 `true`。 |     *   `point_list`: 一个坐标点列表，定义了模板的关键点。 | *   **重要功能点:**  定义了战斗模板的形状、遮罩设置和关键点坐标。
│       │   ├── btn_assist_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个战斗场景中支援按钮的模板配置。 |  | *   **主要功能:**  配置战斗场景中支援按钮的外观和行为。 | *   **核心元素:** |     *   `template_id`:  模板的唯一标识符，为 `assist_1`。 |     *   `template_name`:  模板的显示名称，为 `战斗-支援-1`。 |     *   `template_shape`:  按钮的形状，为 `circle`。 |     *   `auto_mask`:  是否自动应用遮罩，为 `true`。 |     *   `point_list`:  定义按钮的坐标点列表。 | *   **重要功能点:**  定义了按钮的 ID、名称、形状、是否自动遮罩以及坐标点，这些信息共同构成了按钮的视觉和交互属性。
│       │   ├── btn_assist_2/
│       │   │   └── config.yml    这个 YAML 配置文件定义了游戏战斗场景中一个名为 "战斗-支援-2" 的辅助按钮的配置。 |  | *   **主要功能:** 配置战斗场景中的辅助按钮，包括外观、形状和位置。 | *   **核心配置项:** |     *   `template_id`:  `assist_2`，按钮的唯一标识符。 |     *   `template_name`:  "战斗-支援-2"，按钮的显示名称。 |     *   `template_shape`:  `circle`，按钮的形状为圆形。 |     *   `auto_mask`: `true`，表示自动遮罩。 |     *   `point_list`:  按钮的两个坐标点，定义了按钮的位置。 | *   **重要功能点:**  定义了辅助按钮的视觉样式和位置，用于在战斗场景中呈现和交互。
│       │   ├── btn_dodge/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于战斗场景中闪避按钮的模板。 |  | *   **主要功能:** 定义闪避按钮的视觉模板，包括其形状、位置和遮罩配置。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 "dodge"。 |     *   `template_name`: 模板的显示名称，为 "战斗-闪避"。 |     *   `template_shape`: 模板的形状，为 "circle"。 |     *   `auto_mask`: 是否自动应用遮罩，为 `true`。 |     *   `point_list`: 定义按钮位置的坐标点列表。 | *   **重要功能点:**  定义了闪避按钮的视觉外观和位置，用于游戏中的战斗界面。
│       │   ├── btn_interact/
│       │   │   └── config.yml    这个 YAML 配置文件定义了战斗场景中一个交互按钮的模板。 |  | *   **主要功能:** 定义战斗场景中交互按钮的视觉和行为属性。 | *   **核心元素:** |     *   `template_id`:  `btn_interact` (模板 ID) |     *   `template_name`: `战斗-交互` (模板名称) |     *   `template_shape`: `circle` (按钮形状) |     *   `auto_mask`: `true` (是否自动遮罩) |     *   `point_list`:  `1454, 967` 和 `1413, 967` (按钮的坐标点列表，可能用于定义按钮的边界或位置) | *   **重要功能点:** |     *   定义了按钮的形状、名称和位置。 |     *   `auto_mask` 属性指示是否需要自动遮罩，这可能与按钮的视觉效果有关。
│       │   ├── btn_menu/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于战斗场景中菜单按钮的模板。 |  | *   **主要功能:** 定义战斗场景中菜单按钮的视觉外观和形状。 | *   **核心元素:** |     *   `template_id`: `btn_menu`，模板的唯一标识符。 |     *   `template_name`: `战斗-菜单`，模板的显示名称。 |     *   `template_shape`: `polygon`，定义按钮的形状为多边形。 |     *   `auto_mask`: `true`，表示自动生成遮罩。 |     *   `point_list`: 定义多边形按钮的顶点坐标。 | *   **重要功能点:**  定义了按钮的形状 (多边形) 和顶点，以及是否自动生成遮罩。
│       │   ├── btn_normal_attack/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏战斗场景中普通攻击按钮的模板。 |  | *   **主要功能:** 配置普通攻击按钮的视觉和行为。 | *   **核心配置项:** |     *   `template_id`:  `normal_attack`，按钮的唯一标识符。 |     *   `template_name`: `战斗-普通攻击`，按钮的显示名称。 |     *   `template_shape`: `circle`，按钮的形状。 |     *   `auto_mask`: `true`，指示是否自动应用遮罩。 |     *   `point_list`:  定义按钮的坐标点列表，用于定位和绘制按钮。 | *   **重要功能点:**  定义了按钮的形状、名称、遮罩设置和坐标，这些信息共同构成了游戏中普通攻击按钮的视觉表现和交互。
│       │   ├── btn_special_attack_1/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于战斗场景中特殊攻击按钮的模板。 |  | *   **主要功能:** 定义特殊攻击按钮的视觉和行为属性。 | *   **核心元素:** |     *   `template_id`:  `special_attack_1`，按钮的唯一标识符。 |     *   `template_name`: `战斗-特殊攻击-1`，按钮的显示名称。 |     *   `template_shape`: `circle`，按钮的形状。 |     *   `auto_mask`: `true`，是否自动应用遮罩。 |     *   `point_list`:  包含两个坐标点，可能用于定义按钮的边界或锚点。 | *   **重要功能点:**  定义了按钮的视觉形状、遮罩设置和位置。
│       │   └── btn_ultimate_1/
│       │       └── config.yml    这个 YAML 配置文件定义了一个用于游戏战斗场景中终结技按钮的模板。 |  | *   **主要功能:** 定义终结技按钮的视觉和行为属性。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符 ("ultimate\_1")。 |     *   `template_name`: 模板的显示名称 ("战斗-终结技-1")。 |     *   `template_shape`: 按钮的形状 ("circle")。 |     *   `auto_mask`: 是否自动应用遮罩 (true)。 |     *   `point_list`:  定义按钮位置的坐标点列表。 | *   **重要功能点:**  定义了按钮的形状、名称、遮罩设置以及位置。
│       ├── fishing/
│       │   ├── btn_left/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于钓鱼游戏的左侧按钮模板。 |  | *   **主要功能:** 定义钓鱼游戏中左侧按钮的视觉和行为属性。 | *   **核心元素:** |     *   `template_id`:  `btn_left` (按钮的唯一标识符) |     *   `template_name`: `钓鱼-按键-左` (按钮的显示名称) |     *   `template_shape`: `circle` (按钮的形状为圆形) |     *   `auto_mask`: `true` (启用自动遮罩) |     *   `point_list`:  `[320, 883], [263, 883]` (按钮的关键点坐标，用于定位和交互) | *   **重要功能点:**  定义了按钮的形状、名称、遮罩行为和关键点坐标，这些信息用于在游戏中渲染和交互左侧按钮。
│       │   ├── btn_right/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于钓鱼游戏中右侧按钮的模板。 |  | *   **主要功能:** 定义钓鱼游戏中右侧按钮的视觉模板，包括形状、位置和自动遮罩设置。 | *   **核心配置:** |     *   `template_id`:  `btn_right`，模板的唯一标识符。 |     *   `template_name`: `钓鱼-按键-右`，模板的中文名称。 |     *   `template_shape`: `circle`，按钮的形状为圆形。 |     *   `auto_mask`: `true`，启用自动遮罩。 |     *   `point_list`: 包含两个坐标点，定义了按钮的位置。 | *   **重要功能点:**  定义了按钮的形状、位置和是否启用自动遮罩，这些配置共同决定了游戏中右侧按钮的视觉呈现和交互行为。
│       │   └── interact_timing/
│       │       └── config.yml    这个 YAML 配置文件定义了一个名为 "钓鱼-时机上鱼" 的钓鱼互动模板。 |  | *   **主要功能:** 定义钓鱼游戏中，玩家需要根据时机互动的模板配置。 | *   **核心元素:** |     *   `template_id`:  `interact_timing`，模板的唯一标识。 |     *   `template_name`:  `钓鱼-时机上鱼`，模板的名称。 |     *   `template_shape`:  `circle`，模板的形状。 |     *   `auto_mask`:  `true`，表示自动启用遮罩。 |     *   `point_list`:  `[1600, 882], [1526, 880]`，定义了模板的关键点坐标。 | *   **重要功能点:**  定义了模板的类型、名称、形状、遮罩设置以及关键点坐标，这些信息用于在游戏中呈现互动提示。
│       ├── hollow/
│       │   ├── avatar_anby/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于生成图像的模板配置。 |  | *   **主要功能:** 描述了用于生成图像的模板配置，包括模板的子目录、ID、名称、形状、自动遮罩设置和关键点坐标。 | *   **核心元素:** |     *   `sub_dir`: 模板所在的子目录。 |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的名称。 |     *   `template_shape`: 模板的形状。 |     *   `auto_mask`: 是否启用自动遮罩。 |     *   `point_list`: 一个包含关键点坐标的列表，用于定义图像的形状或区域。 | *   **重要功能点:**  定义了模板的形状和关键点，以及是否启用自动遮罩。这些配置用于图像生成过程，例如裁剪、变形或添加效果。
│       │   ├── avatar_nicole/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于生成图像的模板配置，特别是针对一个名为 "avatar_nicole" 的角色头像。 |  | *   **主要功能:** 配置图像模板的参数，用于生成特定形状的图像。 | *   **核心配置:** |     *   `template_id`: 模板的唯一标识符 ("avatar_nicole")。 |     *   `template_name`: 模板的描述性名称 ("零号空洞-角色头像-3")。 |     *   `template_shape`: 模板的形状 ("quadrilateral"，即四边形)。 |     *   `auto_mask`:  是否自动应用遮罩 (设为 `true`)。 |     *   `point_list`:  定义四边形四个顶点的坐标列表。 | *   **重要功能点:**  定义了图像的形状和位置，以及是否自动应用遮罩。
│       │   ├── avatar_zhu_yuan/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于生成角色头像的模板。 |  | *   **主要功能:** 配置角色头像模板的属性。 | *   **核心配置项:** |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的名称。 |     *   `template_shape`: 模板的形状，这里定义为四边形。 |     *   `auto_mask`: 是否自动生成遮罩。 |     *   `point_list`: 定义四边形的四个顶点坐标。 | *   **重要功能点:** 定义了模板的形状和用于遮罩的顶点坐标，以及是否自动生成遮罩。
│       │   ├── right_top_back/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个模板的配置，用于在右上角创建一个带有返回按钮的空心矩形。 |  | *   **主要功能:** 配置一个用于右上角返回按钮的模板。 | *   **核心配置:** |     *   `template_id`: `right_top_back`，模板的唯一标识符。 |     *   `template_name`: `右上角-返回`，模板的名称。 |     *   `template_shape`: `rectangle`，模板的形状为矩形。 |     *   `auto_mask`: `true`，启用自动遮罩。 |     *   `point_list`:  定义矩形右上角两个点的坐标，用于定位返回按钮。 | *   **重要功能点:**  定义了模板的形状、名称、自动遮罩设置以及用于定位的关键点坐标。
│       │   └── speed_up/
│       │       └── config.yml    这个 YAML 配置文件定义了一个用于「零号空洞-快进」模板的配置。 |  | *   **主要功能:** 配置模板的属性，包括模板 ID、名称、形状、自动遮罩设置以及关键点坐标。 | *   **核心配置项:** |     *   `template_id`: 模板的唯一标识符，值为 "speed_up"。 |     *   `template_name`: 模板的显示名称，值为 "零号空洞-快进"。 |     *   `template_shape`: 模板的形状，值为 "rectangle"。 |     *   `auto_mask`:  是否启用自动遮罩，值为 `true`。 |     *   `point_list`:  定义关键点坐标的列表，用于模板的定位或变换。 | *   **重要功能点:**  定义了模板的基本属性，以及是否启用自动遮罩和关键点坐标。
│       ├── lost_void/
│       │   ├── gear_hoshimi_miyabi_3/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个游戏模板，用于描述一个名为“迷失之地武备”的装备。 |  | *   **主要功能:** 定义游戏中装备的外观和行为。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 `agent_gear_hoshimi_miyabi_3`。 |     *   `template_name`: 模板的名称，为“迷失之地武备”。 |     *   `template_shape`: 模板的形状，为 `circle`。 |     *   `auto_mask`:  是否自动应用遮罩，设为 `true`。 |     *   `point_list`:  定义了两个坐标点 (1112, 982) 和 (1176, 978)，可能用于定义装备的某些视觉效果或碰撞区域。 | *   **重要功能点:**  定义了装备的视觉形状、遮罩设置和关键点坐标。
│       │   └── normal_world_tab/
│       │       └── config.yml    这个 YAML 配置文件定义了一个用于游戏中的 UI 模板，主要功能是描述一个名为 "迷失之地-TAB" 的多边形 UI 元素。 |  | *   **主要功能:** 定义一个 UI 模板的配置，用于在游戏中呈现 "迷失之地-TAB" 元素。 | *   **核心配置项:** |     *   `sub_dir`: 模板所属的子目录 ("lost\_void")。 |     *   `template_id`: 模板的 ID ("normal\_world\_tab")。 |     *   `template_name`: 模板的名称 ("迷失之地-TAB")。 |     *   `template_shape`: 模板的形状 ("polygon")。 |     *   `auto_mask`: 是否自动应用遮罩 (true)。 |     *   `point_list`: 定义多边形 UI 元素的顶点坐标列表。 | *   **重要功能点:**  定义了 UI 元素的形状和位置，以及是否自动遮罩。
│       ├── menu/
│       │   ├── back/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个名为 "菜单-返回" 的模板，用于在 "menu" 子目录下创建一个矩形形状的模板。它指定了模板的 ID、名称、形状，以及是否自动进行遮罩处理。 配置文件还定义了两个关键点坐标。 |  | *   **主要功能:** 定义菜单返回按钮的模板配置。 | *   **核心元素:** |     *   `template_id`: "back" (模板 ID) |     *   `template_name`: "菜单-返回" (模板名称) |     *   `template_shape`: "rectangle" (模板形状) |     *   `auto_mask`: `true` (是否自动遮罩) |     *   `point_list`: 包含两个点坐标的列表，用于定义模板的关键点。 | *   **重要功能点:**  定义模板的形状、名称、ID，以及是否自动遮罩和关键点坐标。
│       │   └── friends/
│       │       └── config.yml    这个 YAML 配置文件定义了一个菜单模板，用于在应用程序中显示朋友相关的菜单。 |  | *   **主要功能:** 定义朋友菜单的配置，包括菜单的形状、自动遮罩设置和关键点坐标。 | *   **核心配置项:** |     *   `template_id`: 模板 ID，为 "friends"。 |     *   `template_name`: 模板名称，为 "菜单-朋友"。 |     *   `template_shape`: 菜单形状，为 "circle"。 |     *   `auto_mask`: 是否自动遮罩，为 `true`。 |     *   `point_list`: 关键点坐标列表，用于定位菜单元素。 | *   **重要功能点:**  配置了菜单的外观和行为，包括形状、遮罩和关键点，这些信息将被用于渲染和定位菜单。
│       ├── normal_world/
│       │   ├── interact/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于大世界交互的模板。 |  | *   **主要功能:** 配置大世界交互模板的属性。 | *   **核心元素:** |     *   `template_id`: 模板的唯一标识符，为 "interact"。 |     *   `template_name`: 模板的名称，为 "大世界-交互"。 |     *   `template_shape`: 模板的形状，为 "circle"。 |     *   `auto_mask`:  是否自动遮罩，为 `true`。 |     *   `point_list`:  定义了模板的点列表，用于定义交互区域的边界。 | *   **重要功能点:**  定义了交互模板的形状、名称、遮罩设置和关键点坐标，用于在游戏世界中创建交互区域。
│       │   ├── inter_knot/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个名为 "大世界-绳网" 的模板，用于在 "normal_world" 子目录下创建一个 "inter_knot" 模板。 |  | *   **主要功能:** 配置一个用于生成绳网的模板。 | *   **核心配置:** |     *   `template_id`: "inter_knot" (模板 ID) |     *   `template_name`: "大世界-绳网" (模板名称) |     *   `template_shape`: "circle" (模板形状) |     *   `auto_mask`: true (是否自动遮罩) |     *   `point_list`:  定义了两个点的坐标，用于模板的定位或生成。 | *   **重要功能点:**  定义了模板的形状、名称、遮罩行为以及用于定位或生成的关键点。
│       │   ├── map/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个地图模板的配置。 |  | *   **主要功能:**  配置一个名为 "大世界-地图" 的地图模板，用于 "normal\_world" 子目录。 | *   **核心配置项:** |     *   `template_id`:  `map`，模板的唯一标识符。 |     *   `template_name`:  `大世界-地图`，模板的显示名称。 |     *   `template_shape`:  `circle`，模板的形状。 |     *   `auto_mask`:  `true`，是否自动进行遮罩处理。 |     *   `point_list`:  `[1777, 827], [1738, 827]`，定义了地图上的一些关键点坐标。 | *   **重要功能点:**  定义了地图模板的基本属性，包括形状、遮罩设置和关键点坐标。
│       │   ├── message/
│       │   │   └── config.yml    这个 YAML 配置文件定义了一个用于游戏或应用程序的模板，主要用于在 "normal_world" 子目录下显示信息。 |  | *   **主要功能:**  配置一个名为 "message" 的模板，用于在大世界中显示信息，并定义了其外观和位置。 | *   **核心配置项:** |     *   `sub_dir`:  "normal_world" - 模板所属的子目录。 |     *   `template_id`: "message" - 模板的唯一标识符。 |     *   `template_name`: "大世界-信息" - 模板的显示名称。 |     *   `template_shape`: "circle" - 模板的形状。 |     *   `auto_mask`: `true` -  是否自动应用遮罩。 |     *   `point_list`:  `[1777, 967], [1738, 967]` -  模板的坐标点列表，定义了模板在屏幕上的位置。 | *   **重要功能点:**  定义了模板的形状、名称、自动遮罩设置以及在屏幕上的位置，这些配置共同决定了信息在游戏中的视觉呈现方式。
│       │   └── run/
│       │       └── config.yml    这个 YAML 配置文件定义了一个名为 "大世界-疾跑" 的模板，用于在 "normal_world" 子目录下生成。 |  | *   **主要功能:** 配置一个用于 "大世界-疾跑" 游戏功能的模板。 | *   **核心配置:** |     *   `sub_dir`:  "normal_world" (子目录) |     *   `template_id`: "run" |     *   `template_name`: "大世界-疾跑" |     *   `template_shape`: "circle" (模板形状) |     *   `auto_mask`: `true` (是否自动遮罩) |     *   `point_list`:  定义了两个坐标点 (1563, 967) 和 (1522, 967)，可能用于定义模板的关键点或边界。 | *   **重要功能点:**  定义了模板的名称、形状、自动遮罩设置以及关键点坐标，这些信息共同构成了游戏中 "疾跑" 功能的视觉和行为基础。
│       ├── predefined_team/
│       │   └── avatar_anby/
│       │       └── config.yml    这个 YAML 配置文件定义了一个预定义团队模板的配置，名为 "avatar_anby"。 |  | *   **主要功能:** 定义了用于创建团队头像的模板配置。 | *   **核心配置项:** |     *   `sub_dir`: 模板所属的子目录 ("predefined_team")。 |     *   `template_id`: 模板的唯一标识 ("avatar_anby")。 |     *   `template_name`: 模板的显示名称 ("预备编队-头像")。 |     *   `template_shape`: 模板的形状 ("rectangle")。 |     *   `auto_mask`: 是否自动生成遮罩 (true)。 |     *   `point_list`: 一个包含两个点的列表，可能用于定义模板的边界或关键点。 | *   **重要功能点:** 定义了模板的形状、遮罩设置和关键点，用于生成团队头像。
│       └── shiyu_defense/
│           ├── node_01/
│           │   └── config.yml    这个 YAML 配置文件定义了名为 "式舆防卫战-节点01" 的游戏模板的配置。 |  | *   **主要功能:** 配置游戏模板，包括模板 ID、名称、形状、自动遮罩设置和节点坐标。 | *   **核心元素:** |     *   `sub_dir`: 模板所属的子目录。 |     *   `template_id`: 模板的唯一标识符。 |     *   `template_name`: 模板的名称。 |     *   `template_shape`: 模板的形状，这里设定为 "circle"。 |     *   `auto_mask`:  是否启用自动遮罩，设定为 `true`。 |     *   `point_list`:  定义节点坐标的列表。 | *   **重要功能点:**  配置了模板的形状、自动遮罩启用状态，以及节点的位置坐标，这些都是游戏场景的重要组成部分。
│           └── node_02/
│               └── config.yml    这个 YAML 配置文件定义了一个名为 "式舆防卫战-节点02" 的模板，用于游戏或应用程式中。 |  | *   **主要功能:** 配置游戏模板的相关属性。 | *   **核心元素:** |     *   `sub_dir`: 模板所属的子目录 (shiyu\_defense)。 |     *   `template_id`: 模板的唯一标识符 (node\_02)。 |     *   `template_name`: 模板的显示名称 ("式舆防卫战-节点02")。 |     *   `template_shape`: 模板的形状 (circle)。 |     *   `auto_mask`:  是否自动应用遮罩 (true)。 |     *   `point_list`:  定义模板中关键点的坐标列表。 | *   **重要功能点:** |     *   定义了模板的形状和名称，用于游戏场景的视觉呈现。 |     *   `auto_mask` 属性暗示了自动遮罩功能，可能用于隐藏或显示某些游戏元素。 |     *   `point_list` 提供了模板中关键点的坐标，可能用于碰撞检测、路径规划或其他游戏逻辑。
├── config/
│   ├── format.py    **摘要:** |  | 该 Python 脚本用于格式化 YAML 文件，主要功能包括查找 YAML 文件、调整缩进、裁剪尾随空格、确保文件末尾有换行符，以及修复注释和标点符号的空格问题。 |  | **核心类和函数:** |  | *   `find_yml_files(directory)`: 递归查找指定目录及其子目录下的所有 .yml 和 .yaml 文件。 | *   `convert_indent_to_spaces(content, spaces=2)`: 将缩进转换为指定数量的空格。 | *   `trim_trailing_whitespace(content)`: 裁剪每行的尾随空格。 | *   `ensure_newline_at_end(content)`: 确保文件末尾以新行结束。 | *   `ensure_document_start(content)`: 确保文件以 "---" 开头 (已注释)。 | *   `fix_comment_spacing(content)`: 修复注释中 `#` 后面缺少空格的问题。 | *   `fix_comment_spacing_before(content)`: 修复注释中 `#` 前面缺少空格的问题。 | *   `fix_comma_spacing(content)`: 修复逗号后面缺少空格的问题。 | *   `fix_bracket_spacing(content)`: 修复括号内多余空格的问题。 | *   `process_file(file_path)`: 处理单个 YAML 文件，应用上述格式化操作。 | *   `main(directory)`: 主函数，查找 YAML 文件并调用 `process_file` 进行处理。 |  | **重要功能点:** |  | *   递归查找 YAML 文件。 | *   将缩进转换为空格。 | *   删除尾随空格。 | *   确保文件末尾有换行符。 | *   修复注释空格问题。 | *   修复逗号空格问题。 | *   修复括号内空格问题。 | *   使用正则表达式进行文本替换。
│   ├── project.yml    这个 YAML 配置文件 `project.yml` 储存了关于名为 "ZenlessZoneZero-OneDragon" 专案的配置资讯。 |  | *   **主要功能:**  定义专案的配置，包括专案名称、Python 版本、GitHub 和 Gitee 仓库连结、Git 分支、依赖档案、萤幕解析度、pip 来源以及 QQ 连结。 | *   **核心元素:**  配置文件本身，使用 YAML 格式。 | *   **重要功能点:** |     *   储存专案的基本资讯，如名称和版本。 |     *   提供 GitHub 和 Gitee 仓库的 HTTPS 和 SSH 连结。 |     *   指定 Git 分支。 |     *   定义依赖档案路径。 |     *   设定萤幕解析度。 |     *   指定 pip 来源。 |     *   提供 QQ 连结。
│   ├── yaml_fixer.py    这个 Python 脚本用于修复 YAML 文件的格式问题。 |  | *   **主要功能:** 修正 YAML 文件中的换行符和行内注释的格式。 | *   **核心函数:** |     *   `fix_yaml_file(file_path)`: 读取 YAML 文件，统一换行符为 LF，修复行内注释前的空格，然后将修改后的内容写回文件。 |     *   `process_directory(directory)`: 递归遍历指定目录下所有 .yml 文件，并调用 `fix_yaml_file` 进行处理。 | *   **重要功能点:** |     *   统一换行符为 LF。 |     *   确保行内注释前至少有一个空格。 |     *   递归处理指定目录下的所有 .yml 文件。 |     *   包含错误处理，打印处理失败的文件路径和错误信息。 |     *   脚本的入口点，指定要处理的根目录。
│   └── key_sim/
│       └── 真拿命验收.sample.yml    这个 YAML 配置文件定义了一系列游戏操作，用于模拟游戏中的角色动作。 |  | *   **主要功能:** 定义了游戏操作的顺序，包括按键按下和松开，以及延迟时间。 | *   **核心元素:** `operations` 列表包含一系列操作。每个操作是一个字典，包含 `op_name` (操作名称), `way` (按下或松开), `post_delay` (操作后的延迟时间), 和 `press` (按住时长，可选)。 | *   **重要功能点:** |     *   模拟了妮可的滑行和平A连招。 |     *   切换角色到下一个角色，并模拟了比利的移动。 |     *   模拟了角色移动、闪避和普通攻击。 |     *   包含了按键的按下、松开和延迟时间，用于模拟游戏中的时序。
├── service/
│   ├── zzz_base_scheduler.py    这个 Python 脚本文件 `zzz_base_scheduler.py` 实现了一个基于 `apscheduler` 的后台任务调度器。 |  | *   **主要功能:** 定期执行 `SynBattle` 类中的 `fetch_data` 方法。 | *   **核心类和函数:** |     *   `AsyncIOScheduler`:  `apscheduler` 提供的异步任务调度器。 |     *   `SynBattle`: 假设的类，其 `fetch_data` 方法是需要定期执行的任务。 |     *   `scheduler.add_job()`:  添加一个定时任务。 |     *   `scheduler.start()`:  启动调度器。 |     *   `asyncio.get_event_loop().run_forever()`:  运行事件循环，使调度器能够持续执行。 | *   **重要功能点:** |     *   使用 `apscheduler` 实现了定时任务调度。 |     *   每 60 秒调用 `SynBattle` 实例的 `fetch_data` 方法。 |     *   在接收到 `KeyboardInterrupt` 或 `SystemExit` 信号时，关闭调度器。
│   ├── zzz_data_model.py    这个 Python 文件 `zzz_data_model.py` 定义了使用 SQLAlchemy 的数据模型，用于与 MySQL 数据库交互。 |  | **主要功能:** |  | *   定义数据库连接和会话管理。 | *   定义 `BattleInfo` 数据模型，用于存储战斗信息。 | *   提供用于查询和操作 `BattleInfo` 表的函数。 |  | **核心类和函数:** |  | *   `Base`:  `declarative_base()` 创建的基类，用于声明数据模型。 | *   `BattleInfo`:  继承自 `Base` 的数据模型类，定义了 `battle_info` 表的结构，包含 `id`, `battle_name`, `battle_url`, `creation_name`, `creation_date` 等字段。 | *   `get_db_session()`:  获取当前线程的数据库会话。 | *   `get_battle_info()`:  获取所有战斗信息，按创建日期降序排列。 | *   `get_battle_url(bid)`:  根据 ID 获取战斗信息。 | *   `get_battle_by_name(battle_name)`: 根据战斗名称获取战斗信息。 | *   `clear_battle_info_table()`: 清空 `battle_info` 表。 |  | **重要功能点:** |  | *   使用 `scoped_session` 确保线程安全。 | *   包含数据库连接配置 (`DATABASE_URI`)。 | *   提供 CRUD (Create, Read, Update, Delete) 操作的函数，用于管理 `BattleInfo` 数据。 | *   包含错误处理，在查询失败时回滚事务。
│   ├── zzz_save_battle_class.py    这个 Python 脚本 `zzz_save_battle_class.py` 提供了保存战斗资讯的功能，包括从 URL 或上传档案储存 YAML 格式的战斗资料，并将其储存到资料库中。 |  | *   **主要功能:** 储存战斗资料，支援从 URL 下载或上传 YAML 档案，并将档案路径和相关资讯储存到资料库。 | *   **核心函数:** |     *   `save_battle(battle_name: str, file, creation_name: str, creation_date: datetime)`: 核心函数，处理档案下载、储存、YAML 格式验证，以及资料库的更新或插入操作。 | *   **重要功能点:** |     *   支援从 URL 下载档案。 |     *   验证上传档案的格式是否为 YAML。 |     *   在储存档案前检查并删除旧档案（如果存在）。 |     *   使用 `yaml.safe_load` 验证 YAML 档案的有效性。 |     *   使用 `BattleInfo` 资料模型与资料库交互，更新或插入战斗资讯。 |     *   使用 `get_db_session()` 获取资料库 session。 |     *   使用 `requests` 库下载档案。 |     *   使用 `fastapi.HTTPException` 处理错误并返回 HTTP 错误码。 |     *   使用 `session.commit()` 和 `session.rollback()` 进行资料库事务管理。
│   ├── zzz_shared_battle_service.py    这个 Python 文件定义了一个 FastAPI 应用程序，用于处理与战斗相关的数据。 |  | *   **主要功能:** 提供 API 接口，用于查询战斗信息、上传战斗配置和下载战斗文件。 | *   **核心类和函数:** |     *   `FastAPI()`: 初始化 FastAPI 应用程序。 |     *   `read_battle_info()`: 处理 `/getBattleInfo` 路由的 POST 请求，返回所有战斗信息。 |     *   `upload_battle_info()`: 处理 `/uploadBattleInfo` 路由的 POST 请求，用于上传战斗配置文件，并调用 `save_battle` 函数保存文件。 |     *   `download_battle_info()`: 处理 `/downloadBattleInfo/{bid}` 路由的 GET 请求，根据 ID 下载战斗配置文件。 |     *   `get_battle_info()`: 从 `zzz_data_model` 模块导入，用于获取战斗信息。 |     *   `get_battle_url()`: 从 `zzz_data_model` 模块导入，用于获取战斗文件的 URL。 |     *   `save_battle()`: 从 `zzz_save_battle_class` 模块导入，用于保存上传的战斗文件。 | *   **重要功能点:** |     *   提供 API 接口，用于获取、上传和下载战斗相关的数据。 |     *   使用 FastAPI 框架构建，支持文件上传和下载。 |     *   使用 `zzz_data_model` 和 `zzz_save_battle_class` 模块来处理数据和文件保存。 |     *   包含错误处理，例如文件不存在时返回 HTTP 错误。 |     *   使用 `uvicorn` 运行 FastAPI 应用程序。
│   └── zzz_syn_battle_service.py    这个 Python 文件 `zzz_syn_battle_service.py` 实现了从远程服务同步战斗数据的功能。 |  | *   **主要功能:** 定期检查远程服务上的群文件，如果文件有更新或不存在，则下载文件并保存战斗数据。 | *   **核心类:** |     *   `SynBattle`: 负责与远程服务交互，获取文件列表和文件 URL，并触发数据保存。 | *   **核心函数:** |     *   `file_name_tool(file_name)`: 移除文件名中的文件扩展名。 |     *   `fetch_data(self)`: 从远程服务获取群文件列表，检查文件是否需要更新，并调用 `getFileUrl` 获取文件 URL。 |     *   `getFileUrl(self, file_id, busid, file_name, uploader_name, creation_date)`: 根据文件 ID 和 busid 从远程服务获取文件 URL，并调用 `save_battle` 保存战斗数据。 | *   **重要功能点:** |     *   使用 `requests` 库与远程服务进行 HTTP 通信。 |     *   使用 `datetime` 处理文件修改时间。 |     *   使用 `save_battle` 保存战斗数据 (来自 `zzz_save_battle_class`)。 |     *   使用 `get_battle_by_name` 检查战斗数据是否存在 (来自 `zzz_data_model`)。 |     *   使用 `clear_battle_info_table` 清空战斗信息表 (来自 `zzz_data_model`)。 |     *   包含错误处理和日志记录。
└── src/
    ├── one_dragon/
    │   ├── README.md    这个文件的摘要如下： |  | *   **主要功能:** 描述了 `.\src\one_dragon\README.md` 文件的主要功能，即为一条龙项目共用的代码，并计划将其转化为框架。 | *   **核心类和函数:**  由于文件是 README.md，所以没有代码，因此没有核心类和函数。 | *   **重要功能点:**  代码共享和框架化。
    │   ├── base/
    │   │   ├── conditional_operation/
    │   │   │   ├── atomic_op.py    这个 Python 文件定义了一个名为 `AtomicOp` 的类，它表示一个原子操作。 |  | *   **主要功能:**  定义一个基础的原子操作，执行后会触发事件。 | *   **核心类:** `AtomicOp` | *   **重要功能点:** |     *   `__init__`: 初始化原子操作，包含操作名称和是否为异步操作的标志。 |     *   `execute`: 执行原子操作。 |     *   `dispose`: 销毁操作，解除事件监听。 |     *   `stop`: 停止操作。
    │   │   │   ├── conditional_operator.py    ## 代码摘要 |  | **主要功能:** |  | 该文件定义了 `ConditionalOperator` 类，用于管理和执行基于状态变化的条件操作。它通过监听状态变化，触发相应的场景处理逻辑，并支持并发执行。该类从 YAML 配置文件加载场景和操作定义，并提供初始化、运行、停止和状态更新等功能。 |  | **核心类和函数:** |  | *   **`ConditionalOperator`**:  核心类，负责条件操作的整体管理。 |     *   `__init__`: 初始化，加载配置。 |     *   `init`: 初始化，设置场景处理逻辑。 |     *   `dispose`: 销毁，停止运行并释放资源。 |     *   `start_running_async`: 异步启动运行。 |     *   `stop_running`: 停止运行。 |     *   `update_state`: 更新单个状态并触发场景。 |     *   `batch_update_states`: 批量更新状态并触发场景。 |     *   `_trigger_scene`: 触发特定场景的处理逻辑。 |     *   `_normal_scene_loop`: 处理无状态触发的场景循环。 |     *   `_on_task_done`:  处理任务完成后的回调。 |     *   `get_state_recorder`: 获取状态记录器。 |     *   `_update_state_recorder`: 更新状态记录。 |  | **重要功能点:** |  | *   **场景触发:**  根据状态变化触发不同的场景处理逻辑，支持基于状态的触发和周期性触发。 | *   **并发执行:** 使用 `ThreadPoolExecutor` 并发执行操作任务。 | *   **优先级管理:**  支持任务优先级，可以中断低优先级的任务。 | *   **状态管理:**  通过 `StateRecorder` 管理状态，并提供更新和清除状态的功能。 | *   **配置加载:**  从 YAML 文件加载场景和操作定义。 | *   **线程安全:** 使用 `Lock` 和 `AtomicInt` 来保证线程安全。 | *   **打断机制:**  支持在满足特定条件时打断正在运行的任务。 | *   **批量更新:** 支持批量更新状态，并根据优先级触发场景。
    │   │   │   ├── operation_def.py    这个 Python 文件定义了一个名为 `OperationDef` 的类，用于表示条件操作的定义。 |  | *   **主要功能:** 储存条件操作的配置信息，包括操作名称、数据、模板、延迟、按键属性、等待时间、状态信息和代理人。 | *   **核心类:** `OperationDef` | *   **重要功能点:** |     *   `__init__`: 构造函数，初始化 `OperationDef` 实例的各个属性，包括操作名称、数据、模板、延迟、按键方式、按键时间、重复次数、等待秒数、状态名称、状态列表、状态触发时间、状态触发偏移量、状态值、状态值偏移量和代理人名称。 |     *   定义了多个属性，用于配置不同类型的条件操作，例如按键操作、等待操作和状态设置操作。
    │   │   │   ├── operation_task.py    这个 Python 文件定义了 `OperationTask` 类，用于管理和执行一系列 `AtomicOp` 对象。 |  | **核心类和函数:** |  | *   `OperationTask`: 包含一个 `op_list` (AtomicOp 列表)，用于定义要执行的操作。 |     *   `__init__(self, op_list: List[AtomicOp])`: 初始化 OperationTask。 |     *   `run_async(self) -> Future`: 异步执行操作。 |     *   `_run(self) -> bool`: 执行 `op_list` 中的操作。 |     *   `stop(self) -> bool`: 停止正在运行的操作。 |     *   `add_expr(self, expr: str, debug_name: Optional[str] = None) -> None`: 添加表达式及其调试名称。 |     *   `set_priority(self, priority: Optional[int]) -> None`: 设置任务的优先级。 |     *   `set_trigger(self, trigger: Optional[str]) -> None`: 设置触发器。 |     *   `add_interrupt_states(self, interrupt_states: Set[str]) -> None`: 添加可中断的状态。 |     *   `expr_display`: 显示表达式。 |     *   `priority_display`: 显示优先级。 |     *   `trigger_display`: 显示触发器。 |     *   `debug_name_display`: 显示调试名称。 |  | **重要功能点:** |  | *   **异步执行:** 使用 `ThreadPoolExecutor` 异步执行 `AtomicOp`。 | *   **停止机制:** 提供了 `stop()` 方法来停止正在运行的操作，并处理中断。 | *   **优先级和中断:** 支援设置任务的优先级和可中断状态。 | *   **触发器:** 支援设置触发器，用于触发特定场景。 | *   **表达式和调试名称:** 提供了添加表达式和调试名称的功能，用于界面显示和调试。
    │   │   │   ├── operation_template.py    这个 Python 文件定义了一个名为 `OperationTemplate` 的类，它继承自 `YamlConfig`。 |  | *   **主要功能:**  `OperationTemplate` 类用于从 YAML 配置文件中加载配置，并初始化配置。 | *   **核心类:** `OperationTemplate` | *   **重要功能点:** |     *   `__init__` 方法：初始化 `OperationTemplate` 实例，它使用 `YamlConfig` 类来加载 YAML 配置文件。它接受子目录 (`sub_dir`)、模板名称 (`template_name`) 和实例索引 (`instance_idx`) 作为参数。它还设置了 `sample=True` 和 `copy_from_sample=False` 参数。
    │   │   │   ├── scene_handler.py    这个 Python 文件 `scene_handler.py` 实现了 `SceneHandler` 类，用于处理基于条件的场景操作。 |  | *   **主要功能:**  根据触发时间和状态处理程序，获取符合条件的场景操作指令，管理状态处理程序，并提供销毁方法。 | *   **核心类和函数:** |     *   `SceneHandler`:  主类，管理场景操作。 |         *   `__init__(self, interval_seconds: float, state_handlers: List[StateHandler], priority: Optional[int] = None)`: 初始化 `SceneHandler`，包含间隔时间、状态处理程序列表和优先级。 |         *   `get_operations(self, trigger_time: float) -> Optional[OperationTask]`: 根据触发时间和优先级，获取符合条件的操作任务。 |         *   `get_usage_states(self) -> set[str]`:  获取所有使用的状态。 |         *   `dispose(self) -> None`:  销毁所有状态处理程序。 | *   **重要功能点:** |     *   使用 `StateHandler` 列表来处理不同的状态条件。 |     *   支持操作任务的优先级，用于控制任务的执行顺序和中断。 |     *   提供获取使用状态和销毁资源的方法。
    │   │   │   ├── state_cal_tree.py    **摘要:** |  | 该 Python 文件定义了一个状态计算树，用于根据状态记录器和时间/值范围来评估复杂的条件表达式。 |  | **核心类和函数:** |  | *   **`StateCalNodeType` 和 `StateCalOpType` (Enum):** 定义了节点类型（操作符、状态、真）和操作符类型（AND、OR、NOT）。 | *   **`StateCalNode`:**  表示状态计算树中的一个节点，包含节点类型、操作符类型、子节点、状态记录器、时间/值范围等属性。 |     *   `in_time_range(now: float) -> bool`:  根据当前时间判断节点是否满足条件。 |     *   `get_usage_states() -> set[str]`: 获取树中使用的所有状态名称。 |     *   `dispose() -> None`: 销毁节点及其子节点。 | *   **`construct_state_cal_tree(expr_str: str, state_getter: Callable[[str], StateRecorder], debugname: Optional[str] = None) -> StateCalNode`:**  核心函数，根据给定的表达式字符串构建状态计算树。 |  | **重要功能点:** |  | *   **状态计算树的构建:**  `construct_state_cal_tree` 函数将字符串表达式解析成树状结构，支持 AND, OR, NOT 逻辑运算，以及时间/值范围的判断。 | *   **条件评估:** `in_time_range` 方法递归地评估树中的节点，根据状态记录器、时间范围和值范围来判断条件是否为真。 | *   **状态依赖分析:** `get_usage_states` 方法用于获取表达式中使用的所有状态记录器的名称。 | *   **资源释放:** `dispose` 方法用于释放节点及其子节点所占用的资源。 | *   **支持时间范围和值范围的判断:**  状态节点可以配置时间范围和值范围，用于更精确的条件判断。
    │   │   │   ├── state_event.py    这个 Python 文件定义了一个名为 `StateEvent` 的类，用于表示状态事件。 |  | *   **主要功能:** 储存和表示在特定时间发生的事件，这些事件可能与数值相关。 | *   **核心类:** `StateEvent` | *   **重要功能点:** |     *   `__init__`: 初始化 `StateEvent` 实例，包含触发时间 (`trigger_time`) 以及可选的数值 (`value`) 和数值增加量 (`value_add`)。 |     *   `__str__`:  提供 `StateEvent` 实例的字符串表示，方便调试和显示。
    │   │   │   ├── state_handler.py    这个 Python 文件定义了一个 `StateHandler` 类，用于处理基于状态的条件操作。 |  | *   **主要功能:** 根据时间和状态判断，触发相应的操作。它使用状态计算树来评估状态，并执行相关的原子操作。 | *   **核心类和函数:** |     *   `StateHandler`: 核心类，用于管理状态判断和操作。 |         *   `__init__`: 初始化 `StateHandler`，包含状态表达式、状态计算树、子处理器、操作列表、中断状态和调试名称。 |         *   `get_operations`: 根据触发时间获取符合条件的操作任务。 |         *   `get_usage_states`: 获取 `StateHandler` 使用的所有状态。 |         *   `dispose`: 释放资源。 | *   **重要功能点:** |     *   使用 `StateCalNode` 进行状态判断。 |     *   支持嵌套的 `StateHandler` (通过 `sub_handlers`)。 |     *   `OperationTask` 用于封装要执行的操作。 |     *   `interrupt_states` 允许中断其他状态。 |     *   包含调试名称 (`debug_name`)，用于更好地追踪。
    │   │   │   ├── state_handler_template.py    这个 Python 文件定义了一个名为 `StateHandlerTemplate` 的类，它继承自 `YamlConfig`。 |  | *   **主要功能:**  用于处理基于 YAML 配置的状态，并从 YAML 文件加载配置。 | *   **核心类:** `StateHandlerTemplate` | *   **重要功能点:** |     *   `__init__`: 类的构造函数，初始化 `YamlConfig`，并设置模块名称、子目录和实例索引。它使用 `sample=True` 和 `copy_from_sample=False` 参数来配置 `YamlConfig` 的行为。
    │   │   │   ├── state_recorder.py    这个 Python 文件定义了用于记录和管理状态的类。 |  | *   **主要功能:** 记录状态的触发时间和值，并支持状态的清除和更新。 | *   **核心类和函数:** |     *   `StateRecord`:  表示单个状态记录，包含状态名称、触发时间、值、是否清除等信息。 |     *   `StateRecorder`:  用于记录和管理特定状态的类。 |         *   `update_state_record(self, record: StateRecord)`:  更新状态记录，包括触发时间和值的更新。 |         *   `clear_state_record(self)`:  清空状态记录。 |         *   `dispose(self)`:  销毁状态记录器，释放资源。 | *   **重要功能点:** |     *   支持状态的触发时间和值的记录。 |     *   支持状态的清除，用于处理互斥状态。 |     *   `trigger_time_add` 属性允许修改触发时间。 |     *   `mutex_list` 属性用于定义互斥状态。
    │   │   │   └── utils.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于构建和管理条件操作的工具函数，主要用于处理场景、状态和操作的定义、加载和执行。它支持基于模板的配置，允许嵌套和复用配置。 |  | **核心类和函数:** |  | *   `construct_scene_handler(...)`:  构建一个 `SceneHandler` 实例，用于管理场景的执行。 | *   `construct_state_handler(...)`: 构建一个 `StateHandler` 实例，用于处理特定状态下的条件和操作。 | *   `_get_state_handlers(...)`: 递归地获取 `StateHandler` 列表，支持模板嵌套。 | *   `_get_state_handlers_by_template(...)`:  根据模板名称获取 `StateHandler` 列表。 | *   `get_ops_from_data(...)`:  从配置数据中获取 `AtomicOp` 列表，支持模板嵌套。 | *   `get_ops_by_template(...)`:  根据模板名称获取 `AtomicOp` 列表。 |  | **重要功能点:** |  | *   **场景和状态处理:**  构建 `SceneHandler` 和 `StateHandler` 用于管理场景和状态逻辑。 | *   **模板支持:**  通过 `_get_state_handlers_by_template` 和 `get_ops_by_template` 支持状态和操作的模板化配置，实现配置的复用和嵌套。 | *   **循环引用检测:**  通过 `usage_states_handler_templates` 和 `usage_operation_templates` 集合，防止模板的循环引用。 | *   **状态表达式解析:** 使用 `construct_state_cal_tree` 解析状态表达式。 | *   **操作获取:**  使用 `op_getter` 和 `operation_template_getter` 获取 `AtomicOp` 实例。 | *   **中断状态:** 支持 `interrupt_states` 用于中断状态。 | *   **Debug Name:** 支持在状态处理器中添加 `debug_name` 用于调试。
    │   │   ├── config/
    │   │   │   ├── basic_game_config.py    **摘要:** |  | 该文件定义了游戏的基础配置类 `BasicGameConfig`，用于管理和存储游戏相关的配置信息，如输入方式、屏幕尺寸、全屏模式、HDR、启动参数等。它使用 `YamlConfig` 类来处理配置文件的读写，并定义了多个枚举类型来表示配置选项。 |  | **核心类和函数:** |  | *   **`BasicGameConfig(YamlConfig)`**: 继承自 `YamlConfig`，负责游戏的配置管理。 |     *   `__init__(self, instance_idx: int)`: 初始化函数，调用父类的初始化方法。 |     *   多个 `@property` 装饰的 getter 和 setter 方法: 用于获取和设置各种游戏配置项，如 `type_input_way`, `screen_size`, `full_screen` 等。 | *   **`TypeInputWay(Enum)`**: 定义了输入方式的枚举，包括 `INPUT` 和 `CLIPBOARD`。 | *   **`ScreenSizeEnum(Enum)`**: 定义了屏幕尺寸的枚举，包括多种分辨率。 | *   **`FullScreenEnum(Enum)`**: 定义了全屏模式的枚举，包括 `WINDOWED` 和 `FULL_SCREEN`。 | *   **`MonitorEnum(Enum)`**: 定义了显示器选择的枚举。 | *   **`YamlConfigAdapter`**: 用于适配 `YamlConfig` 的配置项。 |  | **重要功能点:** |  | *   通过枚举定义了游戏配置的选项，增强了代码的可读性和可维护性。 | *   使用 `YamlConfig` 类来持久化存储配置信息。 | *   提供了对各种游戏配置项的获取和设置接口。 | *   `type_input_way_adapter` 属性提供了配置项的适配器。
    │   │   │   ├── config_item.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件定义了用于配置选项的 `ConfigItem` 类，以及用于从枚举中获取配置项的辅助函数。 |  | **核心类和函数：** |  | *   `ConfigItem`:  表示一个配置选项，包含显示文本 (label)、真实值 (value) 和描述 (desc)。 | *   `get_config_item_from_enum(enum: Iterable[Enum], value: Any) -> Optional[ConfigItem]`:  从给定的枚举中查找具有特定值的 `ConfigItem`。 |  | **重要功能点：** |  | *   `ConfigItem` 类使用 `gt` 函数 (来自 `one_dragon.utils.i18_utils`) 实现了文本的国际化 (i18n)。 | *   `get_config_item_from_enum` 函数用于从枚举中高效地检索配置项，这在处理配置选项时非常有用。
    │   │   │   ├── custom_config.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | *   定义了自定义配置，用于存储和管理应用程序的用户偏好设置，例如主题和主页背景。 |  | **核心类和函数：** |  | *   `ThemeEnum`：一个枚举类，定义了可用的主题选项（浅色、深色、自动）。 | *   `CustomConfig`：继承自 `YamlConfig`，负责加载、保存和管理自定义配置。 |     *   `__init__(self)`：初始化 `CustomConfig`，指定配置模块名称为 'custom'。 |     *   `theme` (property)：获取和设置应用程序的主题。 |     *   `banner` (property)：获取和设置是否启用自定义主页背景。 |  | **重要功能点：** |  | *   使用 `YamlConfig` 读取和写入 YAML 格式的配置文件。 | *   使用枚举 `ThemeEnum` 定义了主题选项，提供了类型安全和可读性。 | *   提供了 `theme` 和 `banner` 属性，方便访问和修改配置项。 | *   `theme` 属性默认值为 `ThemeEnum.AUTO`。 | *   `banner` 属性默认值为 `False`。
    │   │   │   ├── game_account_config.py    这个 Python 文件定义了游戏帐户配置，使用 YAML 格式储存和管理游戏帐户相关的设定。 |  | *   **核心类和函数:** |     *   `GamePlatformEnum`, `GameLanguageEnum`, `GameRegionEnum`: 使用 `Enum` 定义游戏平台、语言和地区的枚举。 |     *   `GameAccountConfig`: 继承自 `YamlConfig`，用于管理游戏帐户配置，包括平台、地区、路径、帐户、密码和语言等属性，并提供了 getter 和 setter 方法。 |     *   `__init__`: 初始化 `GameAccountConfig`，设定预设值。 |     *   `platform`, `game_region`, `game_path`, `game_language`, `account`, `password`: 属性，提供读取和更新配置的能力。 |     *   `game_refresh_hour_offset`: 根据游戏地区返回游戏刷新时间的小时偏移量。 |  | *   **重要功能点:** |     *   使用 YAML 储存配置，方便管理和修改。 |     *   使用枚举定义游戏平台、语言和地区，提高程式码可读性和可维护性。 |     *   提供 getter 和 setter 方法，方便读取和更新配置。 |     *   根据游戏地区计算刷新时间偏移量。
    │   │   │   ├── json_config.py    这个 Python 文件 `json_config.py` 定义了一个 `JsonConfig` 类，用于管理基于 JSON 的配置文件。 |  | **主要功能:** |  | *   加载、保存和管理 JSON 配置文件。 | *   支持多个实例配置，每个实例都有自己的配置。 | *   支持使用 sample 文件作为模板，如果配置文件不存在则复制 sample 文件。 | *   支持 mock 模式，在测试时不读取或保存文件。 |  | **核心类和函数:** |  | *   `JsonConfig`: 继承自 `JsonOperator`，负责配置文件的管理。 |     *   `__init__(self, module_name, instance_idx, sub_dir, sample, mock)`: 初始化 `JsonConfig` 实例，设置模块名称、实例索引、子目录、是否使用 sample 文件和是否为 mock 模式。 |     *   `_get_json_file_path(self, sample)`: 根据配置生成 JSON 文件的路径，如果 sample 文件存在且配置文件不存在，则复制 sample 文件。 |  | **重要功能点:** |  | *   支持实例配置，通过 `instance_idx` 区分不同的配置。 | *   使用 `sample` 文件作为模板，方便配置文件的初始化。 | *   `mock` 模式允许在不实际读写文件的情况下进行测试。 | *   使用 `os_utils.get_path_under_work_dir` 获取配置文件路径，确保路径的正确性。
    │   │   │   ├── json_operator.py    这个 Python 文件 `json_operator.py` 实现了一个用于读取、写入和操作 JSON 配置文件的工具类。 |  | **主要功能:** |  | *   读取 JSON 文件 | *   将数据保存到 JSON 文件 | *   获取和更新 JSON 文件中的数据 | *   删除 JSON 配置文件 |  | **核心类和函数:** |  | *   `JsonOperator`:  主类，用于操作 JSON 文件。 |     *   `__init__(self, file_path: Optional[str] = None)`: 初始化，读取文件内容。 |     *   `__read_from_file(self) -> None`:  从 JSON 文件中读取数据。 |     *   `save(self)`:  将 `self.data` 写入 JSON 文件。 |     *   `save_diy(self, text: str)`: 以自定义文本格式保存数据。 |     *   `get(self, prop: str, value=None)`:  获取指定属性的值。 |     *   `update(self, key: str, value, save: bool = True)`:  更新指定键的值，并可选择是否保存。 |     *   `delete(self)`: 删除配置文件。 |  | **重要功能点:** |  | *   支持读取和写入 JSON 格式的配置文件。 | *   提供 `get` 和 `update` 方法方便访问和修改配置数据。 | *   `save_diy` 方法允许以自定义文本格式保存数据。 | *   包含错误处理，例如文件不存在或读取失败时的处理。 | *   `file_path` 为 `None` 时，模拟操作，用于测试。
    │   │   │   ├── one_dragon_app_config.py    这个 Python 文件的主要功能是管理 OneDragon 应用程序的配置，这些配置存储在 YAML 文件中。 |  | 核心类： |  | *   `OneDragonAppConfig`：继承自 `YamlConfig`，用于加载和管理 OneDragon 应用程序的配置。 |  | 重要功能点： |  | *   `app_order` 属性：获取和设置应用程序的运行顺序（列表）。 | *   `move_up_app` 方法：将指定应用程序的运行顺序提前一位。 | *   `app_run_list` 属性：获取和设置应用程序的运行列表。 | *   `set_app_run` 方法：根据 `to_run` 标志，将应用程序 ID 添加或移除到运行列表中。
    │   │   │   ├── one_dragon_config.py    这个 Python 文件定义了 `OneDragonConfig` 类，用于管理与 "一条龙" 应用相关的配置，特别是游戏实例的设置。 |  | **核心类和函数:** |  | *   `OneDragonConfig`: 继承自 `YamlConfig`，负责加载、保存和管理配置数据。 |     *   `__init__`: 初始化配置，加载实例列表。 |     *   `_init_instance_list`: 从配置中初始化 `instance_list` 属性。 |     *   `create_new_instance`: 创建新的游戏实例。 |     *   `update_instance`: 更新现有游戏实例的配置。 |     *   `active_instance`: 激活指定的游戏实例。 |     *   `delete_instance`: 删除游戏实例。 |     *   `dict_instance_list`: 属性，用于获取和设置实例列表的字典表示。 |     *   `current_active_instance`: 属性，获取当前激活的游戏实例。 |     *   `instance_list_in_od`: 属性，获取需要在 "一条龙" 中运行的实例列表。 |     *   `instance_run`: 属性，获取和设置实例运行模式 (全部或当前)。 |     *   `after_done`: 属性，获取和设置完成操作 (无，关闭游戏，关机)。 | *   `OneDragonInstance`: 表示一个游戏实例的数据结构，包含索引、名称、激活状态等。 | *   `RunInOneDragonApp`, `AfterDoneOpEnum`, `InstanceRun`: 枚举类型，定义了配置中的选项。 |  | **重要功能点:** |  | *   管理游戏实例的创建、更新、激活和删除。 | *   从 YAML 文件加载和保存配置。 | *   确定哪些实例需要在 "一条龙" 应用中运行。 | *   配置完成操作 (例如，游戏结束后的操作)。 | *   支持多个游戏实例的管理。
    │   │   │   ├── yaml_config.py    这个 Python 文件定义了一个 `YamlConfig` 类，用于管理和读取 YAML 配置文件。 |  | **核心类和函数：** |  | *   **`YamlConfig`**: 继承自 `YamlOperator`，负责加载、保存和管理 YAML 配置文件。 |     *   `__init__`: 初始化 `YamlConfig` 实例，包括模块名称、实例索引、子目录、是否为 sample 文件、是否从 sample 复制等。 |     *   `_get_yaml_file_path`: 根据配置参数生成 YAML 文件的路径，如果配置文件不存在且存在 sample 文件，则复制 sample 文件。 |     *   `is_sample`: 判断当前文件是否为 sample 文件。 |     *   `get_prop_adapter`: 获取一个配置适配器，用于读写 YAML 配置文件的特定属性。 |  | **重要功能点：** |  | *   支持多个实例的配置，通过 `instance_idx` 区分。 | *   支持子目录配置，通过 `sub_dir` 指定。 | *   支持 mock 模式，用于测试，不读取和保存文件。 | *   如果配置文件不存在，可以从 sample 文件复制。 | *   提供 `get_prop_adapter` 方法，用于方便地读写配置项。
    │   │   │   └── yaml_operator.py    这个 Python 文件 `yaml_operator.py` 提供了用于读取、写入和管理 YAML 配置文件的功能。 |  | **主要功能:** |  | *   读取 YAML 文件并将其缓存以提高性能。 | *   提供读取、更新、保存和删除 YAML 配置文件的接口。 |  | **核心类和函数:** |  | *   `read_cache_or_load(file_path: str)`: 读取 YAML 文件，使用缓存机制避免重复读取，并在文件修改时更新缓存。 | *   `YamlOperator`: 核心类，用于操作 YAML 文件。 |     *   `__init__(self, file_path: Optional[str] = None)`: 初始化，接收 YAML 文件路径。 |     *   `__read_from_file(self) -> None`: 从 YAML 文件中读取数据。 |     *   `save(self)`: 将数据保存到 YAML 文件。 |     *   `save_diy(self, text: str)`: 以自定义文本格式保存数据。 |     *   `get(self, prop: str, value=None)`: 获取 YAML 文件中指定属性的值。 |     *   `update(self, key: str, value, save: bool = True)`: 更新 YAML 文件中的属性。 |     *   `delete(self)`: 删除 YAML 配置文件。 |     *   `is_file_exists(self) -> bool`: 检查配置文件是否存在。 |  | **重要功能点:** |  | *   缓存机制 (`cached_yaml_data`) 提高读取效率。 | *   提供 `save_diy` 函数，允许以自定义文本格式保存 YAML 文件。 | *   提供 `update` 函数，更新配置并可选择是否立即保存。 | *   包含错误处理，例如文件读取失败时使用默认值。 | *   提供 `delete` 函数，用于删除配置文件。
    │   │   ├── controller/
    │   │   │   ├── controller_base.py    **摘要:** |  | 该文件定义了 `ControllerBase` 类，作为游戏控制器的基类，提供了截图、点击、滚动、拖拽、输入文本等基本操作的接口，并管理截图的历史记录。 |  | **核心类和函数:** |  | *   `ScreenshotWithTime`: 用于存储截图及其创建时间。 | *   `ControllerBase`: |     *   `__init__`: 初始化控制器，设置截图的存活时间和最大截图数量。 |     *   `screenshot`: 截图并保存到历史记录，同时处理历史记录的清理。 |     *   `click`: 点击指定位置。 |     *   `scroll`: 滚动操作。 |     *   `drag_to`: 拖拽操作。 |     *   `input_str`: 输入文本。 |     *   `close_game`: 关闭游戏。 |     *   `get_screenshot`: 获取截图，由子类实现。 |     *   `fill_uid_black`: 遮挡UID，由子类实现。 |     *   `before_screenshot`: 截图前的操作，由子类实现。 |     *   `init_before_context_run`: 运行前初始化。 |     *   `is_game_window_ready`: 游戏窗口是否准备好。 |     *   `delete_all_input`: 删除所有输入文本。 |  | **重要功能点:** |  | *   截图管理：维护截图历史记录，并根据存活时间和最大数量进行清理。 | *   基本游戏操作：提供点击、滚动、拖拽、输入文本等基本操作的接口。 | *   扩展性：通过虚方法 `get_screenshot`, `fill_uid_black`, `before_screenshot` 允许子类实现特定平台的截图和处理逻辑。
    │   │   │   ├── pc_clipboard.py    这个 Python 脚本 `pc_clipboard.py` 提供了与 Windows 剪贴板交互的功能。 |  | *   **主要功能:** 提供了复制文本到剪贴板、从剪贴板粘贴文本以及清空剪贴板的功能。 | *   **核心类和函数:** |     *   `PcClipboard` 类: 封装了剪贴板操作的静态方法。 |         *   `copy_and_paste(text: str)`: 将文本复制到剪贴板，然后粘贴出来。 |         *   `empty_clipboard()`: 清空剪贴板。 |         *   `copy_string(text: str)`: 将文本复制到剪贴板。 |         *   `paste_text()`: 从剪贴板粘贴文本，并使用 `pynput` 模拟 Ctrl+V 组合键。 | *   **重要功能点:** |     *   使用 `win32clipboard` 库与 Windows 剪贴板交互。 |     *   使用 `pynput` 库模拟 Ctrl+V 键盘输入进行粘贴操作。 |     *   包含日志记录，用于记录剪贴板操作和文本的脱敏处理。 |     *   在剪贴板操作中使用了 `try...finally` 块来确保剪贴板被正确关闭。
    │   │   │   ├── pc_controller_base.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 文件定义了一个 `PcControllerBase` 类，用于控制 PC 游戏，包括窗口管理、鼠标键盘操作、截图、手柄支持等。它提供了基础的 PC 游戏控制功能，如点击、截图、滚动、拖拽、输入文本等。 |  | **核心类和函数:** |  | *   **`PcControllerBase`**:  核心类，继承自 `ControllerBase`，负责 PC 游戏控制。 |     *   `__init__`: 初始化，设置游戏窗口信息、键盘鼠标控制器、手柄控制器等。 |     *   `init_before_context_run`: 初始化，禁用 Fail-Safe，初始化 mss 截图库，激活游戏窗口。 |     *   `active_window`: 激活游戏窗口。 |     *   `enable_xbox`, `enable_ds4`, `enable_keyboard`: 启用不同的控制器（Xbox, DS4, 键盘鼠标）。 |     *   `is_game_window_ready`: 检查游戏窗口是否准备就绪。 |     *   `click`:  模拟鼠标点击。 |     *   `get_screenshot`:  获取游戏截图，支持缩放。 |     *   `scroll`:  模拟鼠标滚轮滚动。 |     *   `drag_to`:  模拟鼠标拖拽。 |     *   `close_game`: 关闭游戏窗口。 |     *   `input_str`:  输入文本。 |     *   `mouse_move`:  移动鼠标到指定位置。 | *   **`win_click`**:  模拟鼠标点击。 | *   **`win_scroll`**:  模拟鼠标滚轮滚动。 | *   **`get_mouse_sensitivity`**:  获取鼠标灵敏度。 | *   **`drag_mouse`**:  模拟鼠标拖拽。 | *   **`get_current_mouse_pos`**:  获取当前鼠标位置。 |  | **重要功能点:** |  | *   **游戏窗口管理:**  使用 `PcGameWindow` 类管理游戏窗口，包括激活窗口、获取窗口信息等。 | *   **多种控制器支持:** 支持键盘鼠标、Xbox 手柄和 DS4 手柄，通过切换 `btn_controller` 实现。 | *   **截图:**  使用 `mss` 库进行截图，并支持根据游戏窗口
    │   │   │   ├── pc_game_window.py    **文件摘要** |  | *   **主要功能:**  该文件定义了一个 `PcGameWindow` 类，用于管理和操作 PC 游戏窗口，包括获取窗口信息、激活窗口、获取窗口位置和缩放比例，以及坐标转换。 | *   **核心类和函数:** |     *   `PcGameWindow`:  主类，用于封装游戏窗口的操作。 |         *   `__init__(self, win_title: str, standard_width: int = 1920, standard_height: int = 1080)`: 初始化窗口，获取窗口标题、标准分辨率等信息。 |         *   `init_win(self) -> None`: 初始化窗口，通过窗口标题查找窗口句柄。 |         *   `get_win(self) -> Optional[Win32Window]`: 获取窗口对象。 |         *   `get_hwnd(self) -> int`: 获取窗口句柄。 |         *   `is_win_valid(self) -> bool`: 检查窗口是否有效。 |         *   `is_win_active(self) -> bool`: 检查窗口是否处于激活状态。 |         *   `is_win_scale(self) -> bool`: 检查窗口是否被缩放。 |         *   `active(self) -> bool`: 激活游戏窗口。 |         *   `win_rect(self) -> Optional[Rect]`: 获取游戏窗口在屏幕上的位置和大小。 |         *   `get_scaled_game_pos(self, game_pos: Point) -> Optional[Point]`: 将标准分辨率下的游戏坐标转换为当前窗口的坐标。 |         *   `is_valid_game_pos(self, s_pos: Point, rect: Rect = None) -> bool`: 检查游戏坐标是否在游戏窗口内。 |         *   `game2win_pos(self, game_pos: Point) -> Optional[Point]`: 将游戏坐标转换为屏幕坐标。 | *   **重要功能点:** |     *   窗口初始化和获取。 |     *   窗口激活和状态检查（是否有效、是否激活、是否缩放）。 |     *   坐标转换，包括缩放和屏幕坐标转换，用于处理不同分辨率下的游戏。
    │   │   │   └── pc_button/
    │   │   │       ├── backend_keyboard_mouse_contoller.py    该文件实现了通过 Windows API 模拟键盘输入的功能，主要用于控制 PC 上的应用程序。 |  | *   **主要功能:** 模拟键盘按键和文本输入，查找目标窗口，并将其线程附加到当前线程。 | *   **核心函数:** |     *   `send_key(hwnd, key)`: 模拟按下和释放指定键。 |     *   `send_text(hwnd, text)`: 模拟输入文本。 |     *   `find_window(class_name, window_name)`: 查找指定窗口。 |     *   `attach_to_window_thread(hwnd)`: 将当前线程附加到目标窗口的线程。 |     *   `detach_from_window_thread(current_id, target_id)`: 解除线程附加。 | *   **重要功能点:** |     *   使用 `ctypes` 库调用 Windows API 函数。 |     *   定义了键盘映射 `VK_CODE`，将字符映射到虚拟键码。 |     *   `main()` 函数演示了如何查找窗口、附加线程、模拟按键输入和解除线程附加。 |     *   通过 `WM_KEYDOWN` 和 `WM_KEYUP` 消息模拟键盘事件。
    │   │   │       ├── ds4_button_controller.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个用于模拟 DualShock 4 (DS4) 手柄按键操作的控制器类。它使用 `vgamepad` 库来模拟手柄输入，并提供按键触发、按键按下、按键释放等功能。 |  | **核心类和函数:** |  | *   **`Ds4ButtonEnum(Enum)`:**  定义了 DS4 手柄的按键枚举，将按键名称映射到配置项。 | *   **`Ds4ButtonController(PcButtonController)`:**  继承自 `PcButtonController`，是 DS4 手柄控制器的核心类。 |     *   `__init__()`: 初始化控制器，创建 `vgamepad` 实例，并定义按键处理函数列表。 |     *   `tap(self, key: str)`: 触发单个按键。 |     *   `tap_a`, `tap_b`, `tap_x`, `tap_y`, `tap_lt`, `tap_rt`, `tap_lb`, `tap_rb`, `tap_l_stick_w`, `tap_l_stick_s`, `tap_l_stick_a`, `tap_l_stick_d`, `tap_l_thumb`, `tap_r_thumb`:  分别对应触发不同的 DS4 手柄按键。 |     *   `press(self, key: str, press_time: Optional[float] = None)`:  模拟按键按下并保持一段时间。 |     *   `release(self, key: str)`: 释放按键。 |     *   `release_a`, `release_b`, `release_x`, `release_y`, `release_lt`, `release_rt`, `release_lb`, `release_rb`, `release_l_stick`, `release_l_thumb`, `release_r_thumb`: 分别对应释放不同的 DS4 手柄按键。 |     *   `_press_button(self, btn, press: bool = False, press_time: Optional[float] = None)`: 模拟按下或释放一个按钮。 |     *   `_release_btn(self, btn)`: 释放一个按钮。 |     *   `reset(self)`: 重置手柄状态。
    │   │   │       ├── keyboard_mouse_controller.py    这个 Python 文件定义了一个 `KeyboardMouseController` 类，它继承自 `PcButtonController`，用于模拟键盘和鼠标操作。 |  | *   **主要功能:** 模拟键盘按键和鼠标按钮的点击、按下和释放操作。 | *   **核心类和函数:** |     *   `KeyboardMouseController`: 负责控制键盘和鼠标操作的类。 |         *   `__init__`: 初始化键盘和鼠标控制器。 |         *   `tap(self, key: str)`: 模拟单次按键或鼠标点击。 |         *   `press(self, key: str, press_time: Optional[float] = None)`: 模拟按下按键或鼠标按钮，可选择持续时间。 |         *   `release(self, key: str)`: 模拟释放按键或鼠标按钮。 | *   **重要功能点:** |     *   使用 `pynput` 库来控制键盘和鼠标。 |     *   使用 `pc_button_utils` 模块来处理按键和鼠标按钮的转换。 |     *   `press` 方法支持按键持续时间。 |     *   包含一个 `if __name__ == '__main__':` 块，用于测试 `press` 和 `release` 方法。
    │   │   │       ├── pc_button_controller.py    这个 Python 文件定义了一个名为 `PcButtonController` 的类，用于模拟 PC 上的按键操作。 |  | *   **主要功能:** 提供按键模拟功能，包括单击、按下、释放按键，以及设置按键持续时间。 | *   **核心类:** `PcButtonController` | *   **重要功能点:** |     *   `tap(key: str)`: 模拟单击按键。 |     *   `press(key: str, press_time: Optional[float] = None)`: 模拟按下按键，可指定按键持续时间。 |     *   `release(key: str)`: 模拟释放按键。 |     *   `reset()`: 重置控制器状态。 |     *   `set_key_press_time(key_press_time: float)`: 设置按键的预设持续时间。 |     *   `key_press_time`: 属性，表示按键的预设持续时间，默认值为 0.02。
    │   │   │       ├── pc_button_listener.py    这个 Python 文件定义了一个 `PcButtonListener` 类，用于监听 PC 上的键盘、鼠标和游戏手柄按钮事件，并在按钮被 "点击" 时触发回调函数。 |  | *   **主要功能:** 监听键盘、鼠标和游戏手柄按钮事件，并在按钮被按下时调用指定的回调函数。 | *   **核心类:** `PcButtonListener` | *   **重要功能点:** |     *   `__init__`: 初始化监听器，接收一个 `on_button_tap` 回调函数，以及标志位用于控制是否监听键盘、鼠标和游戏手柄。 |     *   `_on_keyboard_press`: 处理键盘按键按下事件，提取按键名称，并调用回调函数。 |     *   `_on_mouse_click`: 处理鼠标点击事件，提取鼠标按钮名称，并调用回调函数。 |     *   `_call_button_tap_callback`: 使用线程池提交回调函数，并处理回调结果。 |     *   `start`: 启动键盘和鼠标监听器。 |     *   `stop`: 停止键盘和鼠标监听器。 |     *   使用 `pynput` 库来监听键盘和鼠标事件。 |     *   使用线程池来执行回调函数，避免阻塞主线程。
    │   │   │       ├── pc_button_utils.py    这个 Python 文件 `pc_button_utils.py` 提供了用于处理 PC 按钮（包括鼠标和键盘）的工具函数。 |  | **主要功能:** |  | *   判断按键类型（鼠标、Xbox、DS4）。 | *   获取按键对象，将字符串按键名称转换为 `pynput` 库中的按键对象。 | *   检查是否安装了虚拟手柄库 `vgamepad`。 |  | **核心类和函数:** |  | *   `is_mouse_button(key: str)`: 判断是否为鼠标按键。 | *   `is_xbox_button(key: str)`: 判断是否为 Xbox 按键。 | *   `is_ds4_button(key: str)`: 判断是否为 DS4 按键。 | *   `get_button(key: str)`: 获取按键对象，根据按键类型调用 `get_mouse_button` 或 `get_keyboard_button`。 | *   `get_mouse_button(key: str)`: 获取鼠标按键对象。 | *   `get_keyboard_button(key: str)`: 获取键盘按键对象。 | *   `is_vgamepad_installed()`: 判断是否安装了 `vgamepad` 库。 |  | **重要功能点:** |  | *   使用 `lru_cache` 进行缓存，提高函数的执行效率。 | *   使用 `pynput` 库来表示鼠标和键盘按键。 | *   提供了将字符串按键名称转换为 `pynput` 按键对象的功能。 | *   检查 `vgamepad` 库的安装状态，用于支持虚拟手柄功能。
    │   │   │       └── xbox_button_controller.py    **摘要:** |  | 该文件定义了一个用于模拟 Xbox 游戏手柄按键操作的控制器。 |  | **核心类和函数:** |  | *   **XboxButtonEnum**:  定义了 Xbox 游戏手柄的按键枚举，将按键名称映射到配置项。 | *   **XboxButtonController**: 继承自 `PcButtonController`，负责模拟 Xbox 游戏手柄的按键操作。 |     *   `__init__()`: 初始化控制器，创建 vgamepad 实例（如果已安装），并设置按键处理程序。 |     *   `tap(key: str)`: 模拟按下并释放一个按键。 |     *   `press(key: str, press_time: Optional[float] = None)`: 模拟按下按键，可以选择按住一段时间。 |     *   `release(key: str)`: 模拟释放按键。 |     *   `tap_*()`:  针对每个按键的 `tap` 操作的具体实现，包括摇杆和扳机。 |     *   `release_*()`:  针对每个按键的 `release` 操作的具体实现。 |     *   `_press_button(btn, press: bool = False, press_time: Optional[float] = None)`:  用于按下和释放按钮的内部函数。 |     *   `_release_btn(btn)`:  用于释放按钮的内部函数。 |     *   `reset()`: 重置游戏手柄状态。 |  | **重要功能点:** |  | *   使用 `vgamepad` 库模拟 Xbox 游戏手柄。 | *   支持按下、释放以及按住按键操作。 | *   通过 `tap`、`press` 和 `release` 方法提供统一的按键操作接口。 | *   针对不同按键类型（按钮、摇杆、扳机）有不同的处理逻辑。 | *   可以设置按键的按住时间。
    │   │   ├── geometry/
    │   │   │   ├── point.py    这个 Python 文件定义了一个 `Point` 类，用于表示二维空间中的点。 |  | *   **主要功能:**  提供一个表示二维点的类，支持坐标初始化、坐标转换为元组、字符串表示，以及点的加减运算。 | *   **核心类:** `Point` | *   **重要功能点:** |     *   `__init__(self, x, y)`: 初始化点的 x 和 y 坐标，并将其转换为整数。 |     *   `tuple(self)`:  返回点的坐标作为一个元组 (x, y)。 |     *   `__repr__(self)`:  返回点的字符串表示，例如 "(x, y)"。 |     *   `__add__(self, other)`:  定义点的加法运算。 |     *   `__sub__(self, other)`:  定义点的减法运算。
    │   │   │   └── rectangle.py    这个 Python 文件定义了一个 `Rect` 类，用于表示二维空间中的矩形。 |  | *   **核心类:** `Rect` | *   **核心函数:** |     *   `__init__(self, x1, y1, x2, y2)`: 矩形的构造函数，接受左上角和右下角的坐标，并将其转换为整数。 |     *   `center`: 属性，返回矩形的中心点 `Point`。 |     *   `__repr__(self)`:  返回矩形的字符串表示。 |     *   `left_top`: 属性，返回矩形的左上角点 `Point`。 |     *   `right_bottom`: 属性，返回矩形的右下角点 `Point`。 |     *   `width`: 属性，返回矩形的宽度。 |     *   `height`: 属性，返回矩形的高度。 |     *   `add_offset(self, p)`:  将矩形移动一个偏移量。 | *   **重要功能点:**  提供矩形的坐标、中心点、宽度、高度等属性的访问，以及移动矩形的功能。
    │   │   ├── matcher/
    │   │   │   ├── match_result.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于存储和处理图像匹配结果的类，包括单个匹配结果 (`MatchResult`) 和匹配结果列表 (`MatchResultList`)。主要用于计算机视觉 (cv2) 和 OCR 结果的处理。 |  | **核心类和函数:** |  | *   **`MatchResult`**: |     *   `__init__(self, c, x, y, w, h, template_scale: float = 1, data: Any = None)`: 初始化匹配结果，包含置信度、坐标、宽高、模板缩放比例和附加数据。 |     *   `__repr__(self)`:  返回匹配结果的字符串表示。 |     *   `left_top`, `center`, `right_bottom`, `rect`:  属性，用于获取匹配结果的几何信息 (Point, Rect)。 |     *   `add_offset(self, p: Point)`:  对匹配结果的坐标进行偏移。 | *   **`MatchResultList`**: |     *   `__init__(self, only_best: bool = True)`: 初始化匹配结果列表，可以选择只保留最佳结果。 |     *   `__repr__(self)`:  返回匹配结果列表的字符串表示。 |     *   `__iter__(self)`, `__next__(self)`, `__len__(self)`:  实现迭代器协议，方便遍历结果列表。 |     *   `append(self, a: MatchResult, auto_merge: bool = True, merge_distance: float = 10)`:  添加匹配结果，支持自动合并功能，合并相同位置的匹配结果，保留置信度更高的结果。 |     *   `__getitem__(self, item)`:  通过索引访问匹配结果。 |     *   `add_offset(self, lt: Point)`:  对列表中所有匹配结果进行坐标偏移。 |  | **重要功能点:** |  | *   存储和表示单个匹配结果的几何信息和置信度。 | *   管理多个匹配结果，支持只保留最佳结果。 | *   提供结果合并功能，避免重复检测。 | *   支持对结果进行坐标偏移，方便处理图像裁剪等操作。 | *   提供迭代器接口，方便遍历结果列表。
    │   │   │   ├── template_matcher.py    这个 Python 脚本定义了一个 `TemplateMatcher` 类，用于在图像中匹配模板。 |  | *   **主要功能:** 该脚本提供了两种匹配模板的方法： |     *   `match_template`: 使用 OpenCV 的模板匹配功能，支持掩码和阈值。 |     *   `match_one_by_feature`: 使用特征匹配，通过检测和匹配图像特征来找到模板位置。 | *   **核心类和函数:** |     *   `TemplateMatcher`: 核心类，负责模板匹配。 |         *   `__init__(self, template_loader: TemplateLoader)`: 初始化，接收一个 `TemplateLoader` 实例。 |         *   `match_template(...) -> MatchResultList`: 执行模板匹配，返回匹配结果列表。 |         *   `match_one_by_feature(...) -> Optional[MatchResult]`: 执行基于特征的匹配，返回最佳匹配结果。 |     *   `TemplateLoader`: 外部依赖，用于加载模板信息。 |     *   `MatchResultList`, `MatchResult`: 数据结构，用于存储匹配结果。 | *   **重要功能点:** |     *   支持使用掩码进行模板匹配，可以与模板自身的掩码和额外的掩码结合使用。 |     *   可以设置匹配阈值，控制匹配的严格程度。 |     *   提供基于特征的匹配方法，使用特征检测和匹配来定位模板。 |     *   `ignore_inf` 参数用于忽略无限大的匹配结果。 |     *   `only_best` 参数用于只返回最佳匹配结果。
    │   │   │   └── ocr/
    │   │   │       ├── ocr_matcher.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了一个 `OcrMatcher` 类，用于执行 OCR (光学字符识别) 任务，从图像中提取文本。 |  | **核心类和函数:** |  | *   `OcrMatcher`:  OCR 匹配器的主要类。 |     *   `__init__(self)`:  构造函数。 |     *   `init_model(self) -> bool`:  初始化 OCR 模型。 |     *   `run_ocr_single_line(self, image: MatLike, threshold: float = None, strict_one_line: bool = True) -> str`:  对单行文本进行 OCR 识别。 |     *   `run_ocr(self, image: MatLike, threshold: float = None, merge_line_distance: float = -1) -> dict[str, MatchResultList]`:  对图像进行 OCR，返回所有匹配结果。 |  | **重要功能点:** |  | *   提供单行和多行文本的 OCR 识别功能。 | *   支持设置匹配阈值。 | *   `run_ocr` 函数支持合并多行文本结果，以处理多行文本的情况。 | *   `init_model` 函数用于初始化 OCR 模型。
    │   │   │       ├── ocr_utils.py    这个 Python 文件 `ocr_utils.py` 提供了用于处理 OCR 结果的工具函数，主要用于将 OCR 文本结果合并成单行或多行。 |  | *   **主要功能:**  处理 OCR 文本结果，将其合并成单行或多行，以处理换行和文本排列问题。 | *   **核心函数:** |     *   `merge_ocr_result_to_single_line(ocr_map, join_space: bool = True) -> str`:  将 OCR 结果合并成单行字符串。 |     *   `merge_ocr_result_to_multiple_line(ocr_map, join_space: bool = True, merge_line_distance: float = 40) -> dict[str, MatchResultList]`: 将 OCR 结果合并成多行，并返回一个字典，其中键是合并后的文本，值是 `MatchResultList`。 | *   **重要功能点:** |     *   `merge_ocr_result_to_single_line`:  根据 y 坐标判断是否在同一行，并根据 x 坐标排序，最后合并成单行文本。 |     *   `merge_ocr_result_to_multiple_line`:  根据 y 坐标的距离判断是否在同一行，然后合并成多行文本。包含合并结果的边界框计算。 |     *   `join_space`:  控制合并文本时是否加入空格。 |     *   `merge_line_distance`:  控制合并行的最大 y 轴距离。
    │   │   │       ├── onnx_ocr_matcher.py    **摘要:** |  | 该文件定义了 `OnnxOcrMatcher` 类，它使用 ONNX 版本的 PaddleOCR 模型进行 OCR 文本识别。 |  | **核心类和函数:** |  | *   **`OnnxOcrMatcher`**:  继承自 `OcrMatcher`，负责使用 ONNX 模型进行 OCR 识别。 |     *   `init_model()`:  初始化并加载 ONNX OCR 模型。 |     *   `run_ocr_single_line()`:  对单行文本进行 OCR 识别。 |     *   `run_ocr()`:  对图像进行 OCR 识别，返回所有匹配结果。 |     *   `_run_ocr_without_det()`:  不使用检测模型进行 OCR 识别。 |     *   `match_words()`:  在图像中查找关键词，返回匹配结果。 |  | **重要功能点:** |  | *   使用 ONNX 加速 OCR 识别。 | *   支持单行和多行文本识别。 | *   提供关键词匹配功能，支持忽略大小写、完全匹配和最长公共子序列匹配。 | *   可以设置匹配阈值和行距合并参数。
    │   │   │       └── paddle_ocr_matcher.py    **摘要:** |  | 该文件定义了 `PaddleOcrMatcher` 类，它继承自 `OcrMatcher`，使用 PaddleOCR 库进行 OCR 文本识别。 |  | **核心类和函数:** |  | *   **`PaddleOcrMatcher`**:  核心类，负责初始化 PaddleOCR 模型并执行 OCR 识别。 |     *   **`__init__(self)`**: 初始化函数，调用父类初始化。 |     *   **`init_model(self) -> bool`**:  初始化 PaddleOCR 模型，从指定目录加载模型文件。 |     *   **`run_ocr_single_line(self, image: MatLike, threshold: float = None, strict_one_line: bool = True) -> str`**:  对单行文本进行 OCR 识别。 |     *   **`run_ocr(self, image: MatLike, threshold: float = None, merge_line_distance: float = -1) -> dict[str, MatchResultList]`**:  对图片进行 OCR 识别，返回匹配结果。 |     *   **`_run_ocr_without_det(self, image: MatLike, threshold: float = None) -> str`**:  不使用检测模型进行 OCR 识别。 |  | **重要功能点:** |  | *   使用 PaddleOCR 进行文本识别。 | *   支持单行和多行文本识别。 | *   可以设置置信度阈值。 | *   可以合并多行识别结果。 | *   提供了两种 OCR 模式：使用检测模型和不使用检测模型。 | *   包含模型加载和错误处理。
    │   │   ├── operation/
    │   │   │   ├── application_base.py    这个 Python 文件定义了一个 `Application` 类，该类继承自 `Operation`，用于表示一个应用程序在一个更大的操作流程中的执行。 |  | **核心类和函数:** |  | *   **`Application` 类:**  代表一个应用程序，继承自 `Operation`，负责应用程序的启动、停止和生命周期管理。 |     *   `__init__`: 初始化应用程序，包括应用程序 ID、运行记录、上下文初始化和停止标志等。 |     *   `_init_before_execute`: 在执行前初始化，更新运行记录，初始化应用程序，启动上下文，并分发应用程序启动事件。 |     *   `handle_resume`: 恢复运行后的处理，由子类实现。 |     *   `after_operation_done`: 在操作完成后处理，更新运行记录，停止上下文，并分发应用程序停止事件。 |     *   `_update_record_after_stop`: 根据运行结果更新运行记录。 |     *   `current_execution_desc`:  返回当前运行的描述。 |     *   `next_execution_desc`:  返回下一步运行的描述。 |     *   `get_preheat_executor`: 获取用于预热的线程池执行器。 |     *   `init_for_application`: 初始化应用程序，包括 OCR 模型的初始化。 | *   **`ApplicationEventId` 枚举:**  定义了应用程序启动和停止的事件 ID。 | *   **`get_preheat_executor` 函数:**  返回一个用于预热的线程池执行器。 |  | **重要功能点:** |  | *   应用程序的启动和停止流程管理。 | *   上下文的初始化和停止控制。 | *   运行记录的更新。 | *   事件的分发，用于通知应用程序的状态变化。 | *   OCR 模型的初始化。 | *   使用线程池进行预热。
    │   │   │   ├── application_desc.py    这个 Python 文件的摘要如下： |  | *   **主要功能:**  定义 `ApplicationDesc` 类，用于描述和管理应用程序的相关信息。 | *   **核心类:** |     *   `ApplicationDesc`:  用于封装应用程序的 ID、名称、`Application` 实例和运行记录 `AppRunRecord`。 | *   **重要功能点:** |     *   `ApplicationDesc` 类的初始化方法 `__init__`，接收应用程序的 ID、名称、`Application` 实例和运行记录作为参数，并将它们保存为实例变量。
    │   │   │   ├── application_run_record.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AppRunRecord` 类，用于记录应用程序的运行状态和相关信息，例如运行时间、状态等，并提供方法来更新和重置这些记录。它还定义了 `AppRunRecordPeriod` 枚举，用于指定记录的周期（每日或每周）。 |  | **核心类和函数:** |  | *   **`AppRunRecordPeriod` (Enum):** 定义了记录周期，包括 `DAILY` 和 `WEEKLY`。 | *   **`AppRunRecord` (Class):** |     *   `__init__(self, app_id: str, instance_idx: Optional[int] = None, game_refresh_hour_offset: int = 0, record_period: AppRunRecordPeriod = AppRunRecordPeriod.DAILY)`: 构造函数，初始化应用程序 ID、实例索引、游戏刷新小时偏移和记录周期。 |     *   `_init_after_read_file(self)`: 从配置文件中读取并初始化记录信息。 |     *   `check_and_update_status(self)`: 检查并更新运行状态，如果需要则重置记录。 |     *   `update_status(self, new_status: int, only_status: bool = False)`: 更新运行状态，并可以选择是否更新时间信息。 |     *   `reset_record(self)`: 重置运行记录，将状态设置为 `STATUS_WAIT`。 |     *   `run_status_under_now(self)`: 根据当前时间返回运行状态。 |     *   `_should_reset_by_dt(self) -> bool`: 根据时间判断是否应该重置状态。 |     *   `get_current_dt(self) -> str`: 获取当前时间的日期字符串。 |     *   `app_record_now_time_str() -> str`: 获取当前时间的字符串表示。 |  | **重要功能点:** |  | *   记录应用程序的运行状态（WAIT, SUCCESS, FAIL, RUNNING）。 | *   支持每日或每周的记录周期。 | *   根据时间自动重置运行状态。 | *   提供更新状态、重置记录等方法。 | *   使用 `YamlConfig` 存储和加载运行记录。 | *   `game_refresh_hour_offset` 属性
    │   │   │   ├── context_event_bus.py    这个 Python 文件的主要功能是实现一个基于事件的上下文事件总线。 |  | 核心类和函数： |  | *   **ContextEventItem**: 封装事件 ID 和事件数据的类。 | *   **ContextEventBus**: 负责事件的发布、监听和取消监听。 |     *   `dispatch_event(event_id, event_obj)`: 发布事件，将事件分发给已注册的回调函数，使用线程池执行回调。 |     *   `listen_event(event_id, callback)`: 注册事件监听器。 |     *   `unlisten_event(event_id, callback)`: 取消单个事件监听器。 |     *   `unlisten_all_event(obj)`: 取消特定对象的所有事件监听器。 |     *   `after_app_shutdown()`: 在应用程序关闭时关闭线程池。 |  | 重要功能点： |  | *   使用线程池 (`ThreadPoolExecutor`) 异步执行事件回调，避免阻塞。 | *   支持事件的注册、取消注册和发布。 | *   提供取消特定对象所有监听器的功能。 | *   在应用程序关闭时关闭线程池，释放资源。
    │   │   │   ├── one_dragon_app.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `OneDragonApp` 类，它是一个用于管理和运行多个应用程序的类，这些应用程序按照特定的顺序执行，并支持实例切换和重试失败的任务。 |  | **核心类和函数:** |  | *   **`OneDragonApp`**: 继承自 `Application`，是核心类，负责协调和执行其他应用程序。 |     *   `__init__`: 初始化 `OneDragonApp` 实例，设置上下文、应用程序 ID、操作名称等。 |     *   `get_app_list`: 获取应用程序列表（由子类实现）。 |     *   `get_app_order_list`: 获取应用程序的运行顺序。 |     *   `update_app_order_list`: 更新应用程序的运行顺序。 |     *   `handle_init`: 初始化，根据配置设置需要运行的实例。 |     *   `get_one_dragon_apps_in_order`:  根据配置获取按顺序排列的应用程序列表。 |     *   `check_app`: 检查需要运行的应用程序，并筛选出未完成的应用程序。 |     *   `run_app`: 运行选定的应用程序。 |     *   `run_retry_app`: 重试失败的应用程序。 |     *   `switch_instance`: 切换到下一个实例。 |     *   `switch_account`: 切换账号。 |     *   `after_switch_account`: 切换账号后的处理。 |     *   `after_operation_done`:  在操作完成后执行，用于恢复应用程序的上下文设置。 |  | **重要功能点:** |  | *   **应用程序排序和运行:**  根据配置的顺序运行应用程序，并支持动态更新运行顺序。 | *   **实例切换:**  支持在不同的游戏实例之间切换，以实现多账号操作。 | *   **失败重试:**  能够重试运行失败的应用程序。 | *   **状态管理:**  跟踪应用程序的运行状态，并根据状态进行相应的处理。 | *   **上下文控制:**  控制应用程序在运行前后的上下文初始化和停止。
    │   │   │   ├── one_dragon_context.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `OneDragonContext` 类，作为整个 OneDragon 应用程序的核心上下文，负责管理应用程序的运行状态、配置、事件处理、控制器、屏幕截图、OCR 等功能。它还集成了键盘和鼠标监听器，并提供了启动、停止、暂停和恢复运行的方法。 |  | **核心类和函数:** |  | *   **`OneDragonContext`**:  核心类，继承自 `ContextEventBus` 和 `OneDragonEnvContext`。 |     *   `__init__(self, controller: Optional = None)`:  初始化上下文，包括配置加载、控制器初始化、键盘和鼠标监听器启动。 |     *   `start_running(self) -> bool`:  启动应用程序运行。 |     *   `stop_running(self)`:  停止应用程序运行。 |     *   `switch_context_pause_and_run(self)`:  切换暂停和运行状态。 |     *   `_on_key_press(self, key: str)`:  处理键盘按键事件，触发相关操作。 |     *   `screenshot_and_save_debug(self) -> None`:  截取屏幕截图并保存到调试目录。 |     *   `switch_instance(self, instance_idx: int) -> None`: 切换实例 |     *   `async_init_ocr(self) -> None`: 异步初始化OCR |     *   `after_app_shutdown(self) -> None`: App关闭后进行的操作 |  | *   **`ContextRunStateEnum`**:  定义了应用程序运行状态的枚举（STOP, RUN, PAUSE）。 | *   **`ContextRunningStateEventEnum`**: 定义了运行状态相关的事件。 | *   **`ContextKeyboardEventEnum`**: 定义了键盘事件。 | *   **`ContextInstanceEventEnum`**: 定义了实例相关的事件。 |  | **重要功能点:** |  | *   **状态管理**:  管理应用程序的运行状态（启动、停止、暂停、恢复）。 | *   **事件处理**:  通过 `ContextEventBus` 处理和分发事件。 | *   **配置管理**:  加载和管理各种配置，例如 `OneDragonConfig`, `CustomConfig`, `OneDragonAppConfig`, `GameAccountConfig`。 | *   **控制器集成**:  与 `
    │   │   │   ├── one_dragon_env_context.py    这个 Python 文件定义了 `OneDragonEnvContext` 类，用于管理 OneDragon 专案的环境和配置资讯。 |  | *   **主要功能:** 储存和管理专案配置、环境配置以及与 Git、Python 和 GitHub Proxy 相关的服务。 提供非同步更新 GitHub Proxy 的功能，并在应用程式关闭时释放资源。 | *   **核心类和函数:** |     *   `OneDragonEnvContext`:  主要类，负责初始化和管理环境上下文。 |     *   `__init__(self)`: 初始化 `OneDragonEnvContext`，建立 `ProjectConfig`, `EnvConfig`, `GitService`, `PythonService`, 和 `GhProxyService` 实例。 |     *   `async_update_gh_proxy(self)`: 非同步更新 GitHub Proxy URL。 |     *   `after_app_shutdown(self)`: 在应用程式关闭后关闭执行绪池。 | *   **重要功能点:** |     *   使用 `ThreadPoolExecutor` 进行非同步操作，提高效率。 |     *   整合了多个环境服务，如 Git, Python 和 GitHub Proxy。 |     *   提供在应用程式关闭时清理资源的机制。
    │   │   │   ├── operation.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `Operation` 类，它是所有游戏操作的基类。它负责管理操作的执行流程、节点网络、错误处理、超时控制、屏幕截图以及与游戏上下文的交互。 |  | **核心类和函数:** |  | *   **`Operation` 类:**  所有游戏操作的基类，包含操作的执行流程控制、节点管理、错误处理等。 |     *   `__init__`: 初始化操作的上下文、超时时间、回调函数等。 |     *   `execute`:  执行操作的主循环，处理节点执行、重试、超时等。 |     *   `_execute_one_round`:  执行操作的单轮，调用当前节点的函数或指令。 |     *   `_get_next_node`:  根据当前轮的结果获取下一个节点。 |     *   `round_success`, `round_wait`, `round_retry`, `round_fail`:  用于设置单轮操作的结果。 |     *   `round_by_find_and_click_area`, `round_by_find_area`, `round_by_click_area`, `round_by_ocr_and_click`, `round_by_ocr`, `round_by_goto_screen`:  提供各种游戏操作的封装，例如查找并点击区域、OCR识别等。 |     *   `check_game_window`, `open_and_enter_game`:  用于检测游戏窗口和打开游戏。 |     *   `add_edges_and_nodes`, `_add_edges_and_nodes_by_annotation`, `add_edge`, `_init_network`:  用于构建操作的节点网络。 |     *   `handle_init`, `handle_pause`, `handle_resume`:  用于子类实现初始化、暂停和恢复逻辑。 |     *   `screenshot`, `save_screenshot`:  用于截图和保存截图。 |     *   `check_and_update_current_screen`, `check_screen_with_can_go`, `check_current_can_go`:  用于识别和判断当前游戏画面。 |  | **重要功能点:** |  | *   **操作流程控制:**  通过节点网络定义操作的执行流程，支持重试、超时和暂停。 | *   **节点网络
    │   │   │   ├── operation_base.py    这个 Python 文件定义了一个基础指令框架，用于执行操作并返回结果。 |  | *   **主要功能:** 提供一个基类 `OperationBase`，用于定义指令的执行流程，以及 `OperationResult` 类，用于封装指令的执行结果。 | *   **核心类和函数:** |     *   `OperationResult`: 封装指令的执行结果，包含 `success` (是否成功), `status` (状态), 和 `data` (返回数据)。 |     *   `OperationBase`: 基础指令类，包含 `execute` 方法 (由子类实现) 和 `op_success`, `op_fail` 静态方法，用于创建成功和失败的执行结果。 | *   **重要功能点:** |     *   `execute` 方法是指令执行的入口，由子类覆写实现具体的操作逻辑。 |     *   `op_success` 和 `op_fail` 方法用于方便地创建成功和失败的 `OperationResult` 实例。
    │   │   │   ├── operation_edge.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了 `OperationEdge` 和 `OperationEdgeDesc` 类，用于表示操作流程中的边，并提供了一个装饰器 `node_from`，用于将边的描述信息附加到函数上。 |  | **核心类和函数:** |  | *   **`OperationEdge`:**  表示操作流程中的一条边，包含起始节点、结束节点、成功标志、状态和是否忽略状态等属性。 | *   **`OperationEdgeDesc`:**  用于描述 `OperationEdge`，包含节点名称、成功标志、状态和是否忽略状态等属性。 | *   **`node_from`:**  一个装饰器，用于将 `OperationEdgeDesc` 附加到函数上，描述函数的输入边。 |  | **重要功能点:** |  | *   `OperationEdge` 类定义了操作流程中边的关键属性，用于控制流程的执行。 | *   `OperationEdgeDesc` 类用于描述边，方便在流程定义中使用。 | *   `node_from` 装饰器允许将边的描述信息与函数关联起来，方便构建和管理操作流程。 | *   `ignore_status` 属性允许忽略状态，提供灵活性，但通常用于兜底情况。
    │   │   │   ├── operation_node.py    这个 Python 文件定义了 `OperationNode` 类，用于表示带有状态的指令节点，以及一个用于装饰函数的 `operation_node` 装饰器。 |  | *   **主要功能:** 创建和管理操作节点，这些节点封装了用于执行操作的函数或指令。 | *   **核心类和函数:** |     *   `OperationNode`:  表示一个操作节点，包含节点名称、处理函数、操作指令、重试策略、等待时间和超时时间等属性。 |     *   `operation_node`:  一个装饰器，用于将函数标记为操作节点，并将 `OperationNode` 实例附加到函数的注释中。 | *   **重要功能点:** |     *   `OperationNode` 类允许配置节点的行为，例如重试失败的操作、在操作后等待一段时间以及设置超时。 |     *   `operation_node` 装饰器简化了创建操作节点的过程，允许通过装饰函数来定义节点的属性。 |     *   `mute` 属性控制是否显示过程结果日志。 |     *   `is_start_node` 属性标记起始节点。 |     *   `node_max_retry_times` 属性定义节点重试次数。
    │   │   │   └── operation_round_result.py    这个 Python 文件定义了 `OperationRoundResult` 类，用于表示指令单轮执行的结果。 |  | *   **主要功能:** 封装指令执行结果，包含成功、失败、重试和等待等状态。 | *   **核心类和函数:** |     *   `OperationRoundResultEnum`:  一个枚举，定义了指令执行结果的可能状态 (RETRY, SUCCESS, WAIT, FAIL)。 |     *   `OperationRoundResult`:  类，用于储存单轮执行结果，包含 `result` (OperationRoundResultEnum 类型), `status` (状态讯息), 和 `data` (返回数据)。 |     *   `is_success`:  属性，判断结果是否为成功。 |     *   `is_fail`:  属性，判断结果是否为失败。 |     *   `status_display`:  属性，返回结果的中文描述。 | *   **重要功能点:** |     *   使用枚举定义了结果状态，增加了代码的可读性和可维护性。 |     *   `OperationRoundResult` 类封装了结果、状态和数据，方便在框架中传递和处理指令执行结果。 |     *   提供了便捷的属性 `is_success`, `is_fail` 和 `status_display`，方便判断和显示结果。
    │   │   └── screen/
    │   │       ├── screen_area.py    **文件摘要** |  | *   **主要功能:** 定义 `ScreenArea` 类，用于表示屏幕上的一个区域，包含区域的名称、矩形位置、文本、模板信息、颜色范围等属性，以及用于访问这些属性的便捷方法。 | *   **核心类和函数:** |     *   `ScreenArea`:  表示屏幕区域的类，包含区域的各种属性。 |     *   `__init__`:  `ScreenArea` 类的构造函数，初始化屏幕区域的各种属性。 |     *   `rect`, `center`, `left_top`, `x1`, `x2`, `y1`, `y2`, `width`, `height`:  属性，用于访问 `ScreenArea` 的矩形相关信息。 |     *   `template_id_display_text`, `goto_list_display_text`, `color_range_display_text`:  属性，用于生成属性的显示文本。 |     *   `is_text_area`, `is_template_area`:  属性，用于判断区域是否为文本或模板区域。 |     *   `color_range_lower`, `color_range_upper`:  属性，用于获取颜色范围的上下限。 |     *   `to_order_dict`:  将 `ScreenArea` 对象的属性转换为有序字典。 | *   **重要功能点:** |     *   定义屏幕区域的各种属性，包括名称、矩形、文本、模板、颜色范围等。 |     *   提供便捷的属性访问方法，例如获取矩形、中心点、宽高等等。 |     *   提供判断区域类型的属性，例如是否为文本区域或模板区域。 |     *   提供将 `ScreenArea` 对象转换为有序字典的方法，方便数据存储和展示。 |     *   支持模板匹配和颜色范围识别。 |     *   包含跳转画面列表和PC端ALT点击标识。
    │   │       ├── screen_info.py    这个 Python 文件定义了 `ScreenInfo` 类，用于管理游戏屏幕的资讯，包括屏幕图像、区域定义和相关配置。 |  | **核心类和函数:** |  | *   **`ScreenInfo` 类:** |     *   `__init__`: 初始化 ScreenInfo 实例，从 YAML 文件加载数据或创建新实例。 |     *   `get_dir_path`: 获取存储 screen_info 文件的目录路径。 |     *   `get_yml_file_path`: 获取 YAML 配置文件的路径。 |     *   `get_image_file_path`: 获取屏幕图像文件的路径。 |     *   `_init_from_data`: 从 YAML 文件中加载数据，初始化 screen_name, screen_image, pc_alt 和 area_list。 |     *   `get_image_to_show`: 获取带有高亮区域的屏幕图像，用于显示。 |     *   `remove_area_by_idx`: 根据索引删除 area_list 中的 ScreenArea。 |     *   `save`: 保存 ScreenInfo 数据到 YAML 文件，并处理 screen_id 更改时的文件删除。 |     *   `delete`: 删除 ScreenInfo 相关的 YAML 文件。 |  | **重要功能点:** |  | *   从 YAML 文件加载和保存屏幕信息，包括屏幕名称、图像、PC 端 ALT 键状态和区域列表。 | *   管理屏幕上的区域，每个区域由 `ScreenArea` 类定义。 | *   提供高亮显示区域的屏幕图像，用于视觉化。 | *   支持删除和修改屏幕区域。 | *   处理 screen_id 更改时的旧文件删除。
    │   │       ├── screen_loader.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于加载和管理游戏屏幕信息和导航路径的类。它负责加载屏幕定义文件，构建屏幕之间的跳转路径，并提供获取屏幕信息和导航路径的接口。 |  | **核心类和函数:** |  | *   **`ScreenRouteNode`**:  表示一个画面跳转的节点，记录了从哪个画面，点击哪个区域，可以跳转到哪个目标画面。 | *   **`ScreenRoute`**:  表示两个画面之间的跳转路径，包含一系列 `ScreenRouteNode`。 |     *   `can_go`:  判断是否可以到达目标画面。 | *   **`ScreenContext`**:  管理所有屏幕信息和导航路径的上下文。 |     *   `load_all()`:  加载所有屏幕信息，包括屏幕定义和区域信息，并初始化屏幕跳转路径。 |     *   `get_screen(screen_name)`:  根据名称获取屏幕信息。 |     *   `get_area(screen_name, area_name)`:  根据屏幕名称和区域名称获取区域信息。 |     *   `init_screen_route()`:  初始化屏幕之间的跳转路径，包括直接跳转和通过Floyd算法计算间接跳转。 |     *   `get_screen_route(from_screen, to_screen)`:  获取两个画面之间的跳转路径。 |     *   `update_current_screen_name(screen_name)`:  更新当前屏幕名称。 |  | **重要功能点:** |  | *   **屏幕信息加载**: 从YAML文件加载屏幕信息，包括屏幕名称、区域等。 | *   **屏幕跳转路径构建**:  根据屏幕区域的 `goto_list` 构建屏幕之间的跳转路径。 | *   **Floyd算法**: 使用Floyd算法计算任意两个屏幕之间的最短路径，支持多步跳转。 | *   **路径查询**:  提供获取两个屏幕之间跳转路径的接口。 | *   **当前屏幕管理**:  记录当前和上一个屏幕的名称。
    │   │       ├── screen_utils.py    ## 代码摘要 |  | **主要功能:** |  | 该文件定义了一系列用于屏幕截图分析和交互的工具函数，主要用于在游戏中查找特定区域、识别文本、匹配模板，并进行点击操作。 |  | **核心类和函数:** |  | *   **`OcrClickResultEnum`**:  定义了OCR点击操作的结果枚举。 | *   **`FindAreaResultEnum`**: 定义了查找区域的结果枚举。 | *   **`find_area(ctx, screen, screen_name, area_name)`**:  在屏幕上查找指定区域。 | *   **`find_area_in_screen(ctx, screen, area)`**:  在屏幕上查找指定区域，基于`ScreenArea`对象。 | *   **`find_and_click_area(ctx, screen, screen_name, area_name)`**:  查找区域并进行点击操作。 | *   **`get_match_screen_name(ctx, screen, screen_name_list)`**:  根据截图匹配最合适的画面名称。 | *   **`get_match_screen_name_from_last(ctx, screen)`**:  从上次记录的画面开始匹配最合适的画面名称。 | *   **`is_target_screen(ctx, screen, screen_name, screen_info)`**:  判断截图是否是目标画面。 | *   **`find_by_ocr(ctx, screen, target_cn, area, lcs_percent, color_range)`**:  使用OCR查找文本。 |  | **重要功能点:** |  | *   **区域查找:**  支持基于文本OCR和模板匹配的区域查找。 | *   **点击操作:**  在找到区域后，进行点击操作，包括OCR结果的点击和模板匹配结果的点击。 | *   **画面匹配:**  根据截图内容，自动匹配当前游戏画面，支持从上次记录的画面开始匹配。 | *   **OCR文本识别:**  使用OCR技术识别屏幕上的文本，并支持基于最长公共子序列(LCS)的文本匹配。 | *   **颜色过滤:**  支持通过颜色范围过滤图像，用于更精确的OCR识别。 | *   **上下文依赖:**  依赖于`OneDragonContext`对象，用于访问OCR、模板匹配等功能。
    │   │       ├── template_info.py    **摘要:** |  | 该 Python 文件定义了 `TemplateInfo` 类，用于管理和操作游戏模板的图像、配置和特征。它提供了创建、加载、保存和修改模板信息的功能，包括模板图像、掩码、形状、关键点和配置。 |  | **核心类和函数:** |  | *   **`TemplateInfo`**:  核心类，用于处理模板信息。 |     *   `__init__`: 初始化模板信息，包括从配置文件加载数据和图像。 |     *   `get_yml_file_path`: 获取模板配置文件的路径。 |     *   `remove_point_by_idx`, `add_point`: 管理模板的坐标点。 |     *   `get_image`: 获取模板图像（原图、灰度图、掩码）。 |     *   `gray`: 灰度图的属性。 |     *   `features`: 特征点和描述符的属性。 |     *   `make_template_dir`: 创建模板目录，并处理旧目录的移动。 |     *   `save_config`, `save_raw`, `save_mask`: 保存模板配置、原图和掩码。 |     *   `get_template_rect_by_point`: 根据坐标点获取模板矩形区域。 |     *   `get_template_raw_by_screen_point`, `get_template_mask_by_screen_point`: 根据坐标点从屏幕图像中提取模板原图和掩码。 |     *   `get_template_raw_to_display`, `get_template_mask_to_display`, `get_template_merge_to_display`, `get_template_reversed_merge_to_display`, `get_screen_image_to_display`: 获取用于显示的图像。 |     *   `update_template_shape`: 更新模板形状，并进行坐标转换。 |     *   `get_template_features`: 获取模板的特征。 |     *   `copy_new`: 复制模板。 |     *   `update_all_points`: 移动所有坐标点。 | *   **`get_template_xxx_path` 系列函数**:  用于获取模板文件路径的辅助函数。 | *   **`is_template_existed`, `is_template_config_existed`**:  用于
    │   │       └── template_loader.py    这个 Python 文件的主要功能是从硬碟加载和管理模板图像。 |  | 核心类： |  | *   `TemplateLoader`: 负责加载、储存和获取模板信息。 |  | 核心函数： |  | *   `get_all_template_info_from_disk()`: 从硬碟中加载所有模板信息。 | *   `load_template()`: 加载特定模板到内存。 | *   `get_template()`: 从内存中获取模板，如果不存在则加载。 | *   `get_template_mask()`: 获取特定模板的掩码。 |  | 重要功能点： |  | *   从 `assets/template` 目录下的子目录中加载模板。 | *   使用 `TemplateInfo` 类来储存模板信息。 | *   缓存已加载的模板以提高效率。 | *   提供获取模板图像和掩码的功能。
    │   ├── devtools/
    │   │   ├── compile_po.py    这个 Python 脚本 `compile_po.py` 的主要功能是将 `.po` 文件编译成 `.mo` 文件，用于多语言支持。 |  | *   **核心函数:** |     *   `compile_lang(model: str, lang: str)`:  编译特定模块和语言的 `.po` 文件到 `.mo` 文件。 |     *   `compile_po_files()`: 遍历不同的模块和语言，调用 `compile_lang` 进行编译。 |  | *   **重要功能点:** |     *   使用 `polib` 库读取和处理 `.po` 文件。 |     *   根据模块（例如 `game`, `ui`）和语言（例如 `cn`, `en`）组织文件路径。 |     *   将编译后的 `.mo` 文件保存到 `LC_MESSAGES` 目录下。 |     *   `if __name__ == '__main__':` 块调用 `compile_po_files()` 启动编译过程。
    │   │   └── python_launcher.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 脚本是一个启动器，用于配置 Python 运行环境、执行 Python 脚本，并管理日志。它主要用于自动化构建和运行 Python 项目，特别是在存在依赖管理和代码更新的场景下。 |  | **核心类和函数:** |  | *   `print_message(message, level="INFO")`: 打印带有时间戳和日志级别的消息。 | *   `delay(seconds)`: 暂停指定秒数。 | *   `verify_path_issues()`: 验证当前路径是否存在中文或空格。 | *   `load_yaml_config(file_path)`: 从 YAML 文件加载配置。 | *   `get_python_path_from_yaml(yaml_file_path)`: 从 YAML 文件中获取 Python 解释器路径。 | *   `configure_environment()`: 配置 Python 运行环境，设置 `PYTHON`, `PYTHONPATH`, 和 `PYTHONUSERBASE` 环境变量。 | *   `create_log_folder()`: 创建日志文件夹。 | *   `clean_old_logs(log_folder)`: 清理旧的日志文件。 | *   `execute_python_script(app_path, log_folder, no_windows)`: 执行 Python 脚本，并将输出重定向到日志文件。 | *   `fetch_latest_code(ctx: OneDragonEnvContext)`: 从 Git 获取最新代码。 | *   `check_dependencies(ctx: OneDragonEnvContext)`: 检查并安装最新的依赖。 | *   `run_python(app_path, no_windows=True)`: 主函数，协调整个启动流程。 |  | **重要功能点:** |  | *   **环境配置:**  从 YAML 文件读取 Python 解释器路径，并设置环境变量。 | *   **日志管理:**  创建日志目录，清理旧日志，并将 Python 脚本的输出重定向到日志文件。 | *   **脚本执行:** 使用 PowerShell 启动 Python 脚本，支持无窗口模式。 | *   **代码更新:**  从 Git 获取最新代码，并安装依赖。 | *   **错误处理:**  包含异常处理机制，确保程序在出现问题时能够优雅退出。 | *   **依赖管理:**  检查并安装最新的依赖。
    │   ├── envs/
    │   │   ├── env_config.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于配置环境的类和枚举，包括 Git、Python、代理、Pip 源等相关设置。它使用 `YamlConfig` 类来管理配置文件的读写，并提供了一系列属性来访问和修改配置项。 |  | **核心类和函数:** |  | *   `EnvConfig`: 继承自 `YamlConfig`，用于管理环境配置。 |     *   `__init__()`: 初始化，设置模块名称为 'env'。 |     *   一系列 `@property` 装饰的 getter 和 setter 方法，用于访问和修改各种配置项，如 `git_path`, `python_path`, `proxy_type` 等。 |     *   `write_env_bat()`: 写入环境变量的 bat 文件。 | *   `ProxyTypeEnum`, `RepositoryTypeEnum`, `GitMethodEnum`, `PipSourceEnum`, `GitBranchEnum`: 枚举类，定义了配置中使用的选项，如代理类型、仓库类型、Git 方法、Pip 源和 Git 分支。 |  | **重要功能点:** |  | *   **配置管理:** 使用 `YamlConfig` 读写配置文件，存储和加载环境配置。 | *   **环境变量设置:**  `write_env_bat()` 函数用于生成 `env.bat` 文件，设置 Python 环境变量。 | *   **代理设置:** 支持多种代理类型，包括个人代理和 Github 免费代理，并提供相关配置项。 | *   **Git 相关配置:**  配置 Git 路径、仓库类型、Git 方法（HTTPS/SSH）和 Git 分支。 | *   **Pip 源配置:**  配置 pip 源，包括官方、清华大学、阿里云等。 | *   **调试模式和快捷键设置:**  配置调试模式和快捷键。 | *   **自动更新和强制更新:**  配置代码自动更新和强制更新选项。 | *   **默认路径定义:** 定义了多个默认路径，如 Git、Python、虚拟环境等。
    │   │   ├── ghproxy_service.py    这个 Python 文件 `ghproxy_service.py` 实现了一个从 ghproxy.link 获取免费代理 URL 的服务。 |  | *   **主要功能:** 从 ghproxy.link 网站抓取 JavaScript 文件，解析其中的 HTML 链接，提取免费代理 URL，并将其更新到 `EnvConfig` 中。 | *   **核心类和函数:** |     *   `GhProxyService`: 负责获取和更新代理 URL。 |         *   `__init__(self, env_config: EnvConfig)`: 初始化，接收 `EnvConfig` 实例。 |         *   `update_proxy_url(self) -> None`: 核心函数，执行获取和更新代理 URL 的逻辑。 | *   **重要功能点:** |     *   使用 `urllib.request.urlopen` 获取 JavaScript 文件内容。 |     *   使用字符串查找方法定位 URL。 |     *   使用正则表达式验证提取的 URL 是否有效。 |     *   将获取的代理 URL 更新到 `EnvConfig` 实例中。 |     *   包含一个 `__debug()` 函数用于测试，以及一个 `if __name__ == '__main__':` 块，用于在脚本直接运行时执行调试。
    │   │   ├── git_service.py    **摘要:** |  | 该 Python 脚本定义了一个 `GitService` 类，用于管理与 Git 仓库的交互，包括下载、安装 Git 工具、克隆、更新代码、获取版本信息等。 |  | **核心类和函数:** |  | *   **`GitLog`**: 用于存储 Git 提交信息的类。 | *   **`GitService`**:  核心类，负责 Git 操作。 |     *   `download_env_file()`: 下载环境文件。 |     *   `get_git_version()`: 获取 Git 版本。 |     *   `install_default_git()`: 安装默认的 Git。 |     *   `fetch_latest_code()`: 获取最新代码（克隆或更新）。 |     *   `clone_repository()`: 克隆仓库。 |     *   `checkout_latest_project_branch()`: 切换到最新的分支。 |     *   `get_current_branch()`: 获取当前分支。 |     *   `is_current_branch_clean()`: 检查当前分支是否干净。 |     *   `get_requirement_time()`: 获取 requirements.txt 的最后更新时间。 |     *   `fetch_total_commit()`: 获取提交总数。 |     *   `fetch_page_commit()`: 获取分页的提交记录。 |     *   `get_git_repository()`: 获取仓库地址。 |     *   `init_git_proxy()`: 初始化 Git 代理。 |     *   `update_git_remote()`: 更新远程仓库地址。 |     *   `set_safe_dir()`: 设置安全目录。 |     *   `reset_to_commit()`: 回滚到特定提交。 |     *   `get_current_version()`: 获取当前代码版本。 |  | **重要功能点:** |  | *   **Git 工具管理:**  能够下载和安装 Git。 | *   **代码更新:**  支持克隆和更新代码，包括分支切换和合并。 | *   **代理设置:**  可以配置和使用代理进行 Git 操作。 | *   **版本控制:**  获取 Git 版本、当前分支、提交历史和代码状态。 | *   **错误处理:**  包含一些错误处理机制，例如在克隆或更新失败时进行重试。 | *   **进度回调:**  提供进度回调，
    │   │   ├── project_config.py    这个 Python 文件定义了 `ProjectConfig` 类，用于读取和管理项目的配置信息。 |  | *   **主要功能:** 读取并提供项目的配置信息，这些信息来自于 YAML 配置文件。 | *   **核心类:** `ProjectConfig` 继承自 `YamlConfig`。 | *   **重要功能点:** |     *   初始化时，使用 `YamlConfig` 加载名为 "project" 的配置文件。 |     *   定义了多个属性，用于存储从配置文件中读取的项目配置，例如 `project_name`, `python_version`, Git 仓库地址等。 |     *   将 `screen_standard_width` 和 `screen_standard_height` 转换为整数。
    │   │   └── python_service.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 文件定义了一个 `PythonService` 类，用于管理 Python 环境的安装、配置和依赖安装。它提供了安装 Python 解释器、pip、virtualenv，创建虚拟环境，以及安装项目依赖的功能。 |  | **核心类和函数:** |  | *   **`PythonService` 类:** |     *   `__init__(self, project_config: ProjectConfig, env_config: EnvConfig, git_service: GitService)`: 初始化函数，接收项目配置、环境配置和 Git 服务。 |     *   `install_default_python(...)`: 安装默认的 Python 解释器。 |     *   `install_default_pip(...)`: 安装默认的 pip。 |     *   `install_default_virtualenv(...)`: 安装默认的 virtualenv。 |     *   `create_default_venv(...)`: 创建默认的虚拟环境。 |     *   `install_default_python_venv(...)`: 完整流程安装 Python 环境。 |     *   `install_requirements(...)`: 安装项目依赖。 |     *   `get_python_version(...)`: 获取当前 Python 版本。 |     *   `get_pip_version(...)`: 获取当前 pip 版本。 |     *   `choose_best_pip_source(...)`: 选择最佳的 pip 源。 |     *   `is_virtual_python(...)`: 检查是否在虚拟环境中运行。 |     *   `get_os_python_path(...)`: 获取系统环境变量中的 Python 路径。 |     *   `get_os_pip_path(...)`: 获取系统环境变量中的 pip 路径。 |     *   `get_module_version(...)`: 获取模块版本。 |  | **重要功能点:** |  | *   **Python 和 Pip 的安装:**  下载并解压 Python，安装 pip，支持重试机制和进度回调。 | *   **虚拟环境管理:**  创建和管理虚拟环境。 | *   **依赖安装:**  使用 pip 安装项目所需的依赖，并支持更新 pip。 | *   **Pip 源选择:**  通过测速选择最佳的 pip 源，提高下载速度。 | *   **环境配置:**  使用 `EnvConfig` 管理 Python 路径和 pip 源等环境配置。 | *   **进度回调:**  使用 `progress_callback` 提供安装过程的进度更新。 | *   **
    │   ├── thread/
    │   │   ├── atomic_bool.py    这个 Python 文件定义了一个 `AtomicBool` 类，它提供了一个线程安全的布尔值。 |  | *   **主要功能**: 提供线程安全的布尔值读取和设置操作。 | *   **核心类**: `AtomicBool` | *   **重要功能点**: |     *   `__init__(self, value: bool = False)`: 初始化布尔值，默认值为 `False`，并创建一个 `threading.Lock` 用于线程同步。 |     *   `get(self)`: 获取当前布尔值，使用锁来保证线程安全。 |     *   `set(self, value: bool)`: 设置布尔值，使用锁来保证线程安全。 |     *   `set_true(self)`: 将布尔值设置为 `True`，使用锁来保证线程安全。 |     *   `set_false(self)`: 将布尔值设置为 `False`，使用锁来保证线程安全。
    │   │   └── atomic_int.py    这个 Python 文件实现了一个线程安全的原子整数类 `AtomicInt`。 |  | *   **主要功能:** 提供线程安全的整数操作，包括获取、设置、增加和减少。 | *   **核心类:** `AtomicInt` | *   **重要功能点:** |     *   `__init__(self, value=0)`: 初始化原子整数，默认值为 0，并创建一个 `threading.Lock` 用于线程同步。 |     *   `get(self)`: 获取当前原子整数的值，使用锁保护。 |     *   `set(self, value)`: 设置原子整数的值，使用锁保护。 |     *   `inc(self)`: 原子地增加原子整数的值，使用锁保护。 |     *   `dec(self)`: 原子地减少原子整数的值，使用锁保护。
    │   ├── utils/
    │   │   ├── app_utils.py    这个 Python 脚本 `app_utils.py` 提供了启动和重启 "OneDragon" 应用程序的功能。 |  | *   **主要功能:** 启动和重启 "OneDragon" 应用程序。 | *   **核心函数:** |     *   `start_one_dragon(restart: bool)`: 启动 "OneDragon Launcher.exe" 应用程序。如果 `restart` 为 True，则在启动后退出脚本。 |     *   `restart_one_dragon()`: 启动 `restart_app.bat` 脚本，用于重启 "OneDragon" 应用程序。 | *   **重要功能点:** |     *   使用 `subprocess.Popen` 执行外部命令来启动应用程序。 |     *   使用 `os_utils.get_work_dir()` 获取工作目录。 |     *   `if __name__ == '__main__':` 块在脚本直接执行时，会启动 "OneDragon" 并立即重启。
    │   │   ├── cal_utils.py    代码摘要： |  | 该文件定义了一系列用于几何计算的实用函数。 |  | 核心函数： |  | *   `distance_between(pos1: Point, pos2: Point) -> float`: 计算两点之间的距离。 | *   `get_angle_by_pts(from_pos: Point, to_pos: Point) -> float`: 计算两点形成向量的角度。 | *   `angle_delta(from_angle: float, to_angle: float) -> float`: 计算从一个角度转到另一个角度需要的角度。 | *   `angle_add(current_angle: float, delta_angle: float) -> float`: 计算一个角度加上一个偏移角度后的结果。 | *   `in_rect(point: Point, rect: Rect) -> bool`: 判断点是否在矩形内。 | *   `calculate_overlap_area(rect1, rect2)`: 计算两个矩形的重叠面积。 | *   `distance_to_line(target: Point, p1: Point, p2: Point) -> float`: 计算点到直线的距离。 | *   `random_in_range(r: Union[List[float], float]) -> float`: 在范围内随机一个数。 | *   `coalesce(*args)`: 返回第一个非空元素。 |  | 重要功能点： |  | *   提供了计算点、角度、矩形等几何相关的常用函数。 | *   包含计算重叠面积和点到直线距离的功能。 | *   包含随机数生成函数。
    │   │   ├── cmd_utils.py    这个 Python 脚本 `cmd_utils.py` 提供了用于执行命令行命令的工具函数。 |  | **主要功能:** |  | *   执行命令行命令，捕获 stdout 和 stderr 输出，并提供回调函数。 | *   提供关闭和取消关闭系统的函数。 |  | **核心类和函数:** |  | *   `run_command(commands: List[str], cwd: Optional[str] = None, message_callback: Optional[Callable[[str], None]] = None) -> Optional[str]`:  执行给定的命令行命令，支持指定工作目录和消息回调。使用多线程处理 stdout 和 stderr，并返回命令的 stdout 输出。 | *   `shutdown_sys(seconds: int)`: 使用 `shutdown` 命令关闭系统，延迟指定秒数。 | *   `cancel_shutdown_sys()`: 使用 `shutdown /a` 命令取消计划的关机。 |  | **重要功能点:** |  | *   使用 `subprocess.Popen` 执行命令，并捕获 stdout 和 stderr。 | *   使用多线程处理 stdout 和 stderr，避免阻塞。 | *   提供消息回调，用于实时显示命令输出。 | *   处理 Windows 系统下 `subprocess` 的特殊参数，例如 `startupinfo` 和 `creationflags`，以避免弹出控制台窗口。 | *   包含错误处理，捕获命令执行失败的异常。 | *   提供关机和取消关机的功能。
    │   │   ├── cv2_utils.py    **摘要:** |  | 该 Python 脚本 `cv2_utils.py` 提供了基于 OpenCV (cv2) 的图像处理工具函数，主要用于图像的读取、保存、显示、变换、匹配和分析。 |  | **核心类和函数:** |  | *   **`read_image(file_path)`**: 读取图片，支持多种颜色空间转换。 | *   **`save_image(img, file_path)`**: 保存图片。 | *   **`show_image(img, rects=None, win_name='DEBUG', wait=None, destroy_after=False)`**: 显示图片，可绘制矩形框。 | *   **`image_rotate(img, angle, show_result=False)`**: 旋转图片。 | *   **`mark_area_as_color(image, pos, color, new_image=False)`**: 将图片的一个区域变颜色。 | *   **`match_template(source, template, threshold, mask=None, only_best=True, ignore_inf=False)`**: 模板匹配。 | *   **`concat_vertically(img, next_img, decision_height=150)`**: 垂直拼接图片。 | *   **`concat_horizontally(img, next_img, decision_width=200)`**: 水平拼接图片。 | *   **`is_same_image(i1, i2, threshold=1)`**: 判断两张图片是否相同。 | *   **`color_similarity_2d(image, color)`**: 计算颜色相似度。 | *   **`show_overlap(source, template, x, y, template_scale=1, win_name='DEBUG', wait=1)`**: 在原图上覆盖模板图。 | *   **`feature_detect_and_compute(img, mask=None)`**: 特征检测和计算。 | *   **`feature_match(source_kp, source_desc, template_kp, template_desc, source_mask=None)`**: 特征匹配。 | *   **`feature_match_for_one(...)`**: 使用特征匹配找到一个匹配结果。 | *   **`feature_match_for_multi(...)`**: 使用特征匹配找到多个匹配结果。 | *   **`connection_erase(
    │   │   ├── debug_utils.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件提供用于调试的工具函数，主要用于在工作目录下创建和管理调试文件夹，以及保存和读取调试图像。 |  | **核心类和函数：** |  | *   `get_debug_dir_path()`:  获取调试目录的路径。使用 `lru_cache` 进行缓存。 | *   `get_debug_image_dir_path()`: 获取调试图像目录的路径。使用 `lru_cache` 进行缓存。 | *   `get_debug_image_path(filename, suffix)`:  获取调试图像文件的完整路径。 | *   `get_debug_image(filename, suffix)`:  从文件路径读取调试图像。 | *   `save_debug_image(image, file_name, prefix)`:  保存调试图像到指定路径，支持自动生成文件名。 |  | **重要功能点：** |  | *   使用 `lru_cache` 缓存调试目录路径，提高效率。 | *   提供方便的函数用于创建调试图像文件路径。 | *   `save_debug_image` 函数将 RGB 图像转换为 BGR 格式后保存，并支持生成带时间戳的文件名。 | *   使用 `log.debug` 记录保存图像的操作。
    │   │   ├── file_utils.py    这个 Python 文件 `file_utils.py` 提供了用于解压缩 ZIP 文件的工具函数。 |  | *   **主要功能:** 解压缩 ZIP 压缩包。 | *   **核心函数:** `unzip_file(zip_file_path, unzip_dir_path)`: 接收 ZIP 文件路径和解压目标文件夹路径，将 ZIP 文件解压缩到指定文件夹。 | *   **重要功能点:** |     *   使用 `zipfile` 模块进行 ZIP 文件处理。 |     *   包含错误处理，如果解压缩失败，则返回 `False`。
    │   │   ├── http_utils.py    这个 Python 文件 `http_utils.py` 提供了下载文件的功能。 |  | *   **主要功能:**  从给定的 URL 下载文件并保存到指定路径，支持代理和进度回调。 | *   **核心函数:** |     *   `download_file(download_url, save_file_path, proxy=None, progress_callback=None)`:  下载文件的主要函数。 | *   **重要功能点:** |     *   支持使用代理下载文件。 |     *   提供进度回调，用于实时监控下载进度。 |     *   包含下载进度的日志记录。 |     *   处理下载过程中可能发生的异常。
    │   │   ├── i18_utils.py    这个 Python 文件 `i18_utils.py` 提供了多语言支持的工具函数。 |  | **主要功能:** |  | *   加载和管理不同模块和语言的翻译文本。 | *   提供获取翻译文本的函数，并支持默认值。 | *   管理和设置默认语言。 |  | **核心类和函数:** |  | *   `get_translations(model: str, lang: str)`: 加载指定模块和语言的翻译。 | *   `gt(msg: str, model: str = 'game', lang: str = _default_lang) -> str`: 获取指定文本的翻译。 | *   `coalesce_gt(msg: Optional[str], default: str, model: str = 'game', lang: str = _default_lang) -> str`: 获取翻译文本，如果原始文本为空，则返回默认值。 | *   `update_default_lang(lang: str)`: 更新默认语言。 | *   `get_default_lang() -> str`: 获取默认语言。 |  | **重要功能点:** |  | *   使用 `gettext` 库进行翻译。 | *   根据模块 (model) 和语言 (lang) 区分翻译。 | *   缓存已加载的翻译，提高效率。 | *   提供默认语言支持。 | *   `coalesce_gt` 函数提供了方便的默认值处理。
    │   │   ├── log_utils.py    这个 Python 文件 `log_utils.py` 提供了用于配置和使用日志记录的功能。 |  | *   **主要功能:** 设置和管理日志记录器，包括文件和控制台输出，以及文本脱敏功能。 | *   **核心类和函数:** |     *   `get_logger()`:  配置并返回一个 `logging.Logger` 实例，包含文件和控制台处理程序，设置日志格式和级别。 |     *   `set_log_level(level: int)`:  设置日志记录器的全局日志级别。 |     *   `mask_text(text: str)`:  对文本进行脱敏处理，隐藏中间字符。 | *   **重要功能点:** |     *   使用 `TimedRotatingFileHandler` 实现基于时间的日志文件轮换。 |     *   同时将日志输出到文件和控制台。 |     *   提供文本脱敏功能，用于保护敏感信息。 |     *   定义了全局日志记录器实例 `log`，方便在其他模块中使用。
    │   │   ├── os_utils.py    ```python | # 摘要 | # 文件功能：提供与操作系统交互和时间相关的实用工具函数，包括文件路径处理、环境变量获取、时间日期格式化和计算，以及清理过期文件。 | # 核心类和函数： | #   - join_dir_path_with_mk: 拼接目录路径，如果不存在则创建。 | #   - get_path_under_work_dir: 获取当前工作目录下的子目录路径。 | #   - run_in_exe: 判断是否在exe中运行。 | #   - get_work_dir: 获取项目根目录。 | #   - get_env, get_env_def: 获取环境变量。 | #   - now_timestamp_str: 获取当前时间字符串。 | #   - get_dt: 获取当前日期字符串，支持UTC偏移。 | #   - add_dt_offset: 根据日期和偏移量计算新日期。 | #   - get_sunday_dt, get_monday_dt: 获取对应星期天/星期一的日期。 | #   - is_monday: 判断是否为星期一。 | #   - get_current_day_of_week: 获取当前星期几。 | #   - dt_day_diff: 计算两个日期之间的天数差。 | #   - clear_outdated_debug_files: 清理过期的调试文件。 | # 重要功能点： | #   - 提供了方便的路径拼接和目录创建功能。 | #   - 能够判断程序运行环境（是否为exe）。 | #   - 提供了获取环境变量的工具，并支持默认值。 | #   - 提供了多种日期和时间相关的格式化和计算函数，包括时区处理。 | #   - 能够清理过期的调试文件。 | ```
    │   │   ├── str_utils.py    这个 Python 文件 `str_utils.py` 提供了多种字符串处理工具函数。 |  | *   **主要功能:** 字符串查找、比较、数字提取和相似度匹配。 | *   **核心类和函数:** |     *   `find(source, target, ignore_case)`: 在字符串中查找子字符串。 |     *   `find_by_lcs(source, target, percent, ignore_case)`: 使用最长公共子序列 (LCS) 判断字符串是否包含。 |     *   `longest_common_subsequence_length(str1, str2)`: 计算两个字符串的 LCS 长度。 |     *   `get_positive_digits(v, err)`: 提取字符串中的正整数。 |     *   `get_positive_float(v, err)`: 提取字符串中的正浮点数。 |     *   `remove_not_digit(v)`: 移除字符串中的非数字字符。 |     *   `find_best_match_by_lcs(word, target_word_list, lcs_percent_threshold)`: 根据 LCS 找到最匹配的字符串。 |     *   `find_best_match_by_difflib(word, target_word_list, cutoff)`: 使用 difflib 找到最匹配的字符串。 |     *   `find_most_similar(str_list1, str_list2)`: 在两个字符串列表中找到最匹配的一对。 |     *   `with_chinese(s)`: 判断字符串是否包含中文。 | *   **重要功能点:** |     *   基于 LCS 的字符串相似度比较，用于 OCR 结果匹配。 |     *   使用 `difflib` 进行字符串相似度匹配。 |     *   提取字符串中的数字。 |     *   判断字符串是否包含中文。
    │   │   ├── thread_utils.py    这个 Python 文件 `thread_utils.py` 包含用于处理线程相关操作的工具函数。 |  | *   **主要功能:** 提供一个用于处理 `concurrent.futures.Future` 执行结果的函数，用于捕获和记录线程执行期间发生的异常。 | *   **核心函数:** |     *   `handle_future_result(future: Future)`: 尝试获取 `Future` 的结果，如果发生异常，则记录错误信息。 | *   **重要功能点:** |     *   异常处理：使用 `try-except` 块捕获 `Future` 执行期间的异常，并使用 `log.error` 记录错误信息，包括堆栈跟踪。
    │   │   └── yolo_config_utils.py    这个 Python 文件 `yolo_config_utils.py` 提供了用于管理 YOLO 模型配置的工具函数。 |  | *   **主要功能:**  管理和查找 YOLO 模型文件，包括获取模型目录、列出可用模型以及检查模型是否存在。 | *   **核心函数:** |     *   `get_model_category_dir(category: str) -> str`:  获取特定类别模型的目录路径。 |     *   `get_available_models(category: str) -> List[str]`:  获取指定类别下可用的模型列表。 |     *   `is_model_existed(category: str, model_name: str) -> bool`:  检查特定模型是否存在，通过检查 `labels.csv` 和 `model.onnx` 文件来判断。 | *   **重要功能点:**  文件主要用于定位和验证 YOLO 模型文件，方便后续的模型加载和使用。
    │   └── yolo/
    │       ├── detect_utils.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了用于目标检测的工具类和函数，包括检测结果的数据结构、非极大值抑制 (NMS) 算法、边界框转换以及在图像上绘制检测结果的函数。 |  | **核心类和函数:** |  | *   **DetectContext:**  存储推理过程的上下文信息，如原始图像、运行时间、图像尺寸、检测阈值等。 | *   **DetectClass:**  定义检测到的类别，包含类别 ID、名称和类别类别。 | *   **DetectObjectResult:**  表示单个检测到的目标，包含边界框坐标、置信度得分和检测类别。 | *   **DetectFrameResult:**  表示一帧图像的检测结果，包含原始图像和检测到的目标列表。 | *   **nms(boxes, scores, iou_threshold):**  执行非极大值抑制，用于过滤重叠的边界框。 | *   **multiclass\_nms(boxes, scores, class\_ids, iou\_threshold):** 执行多类别非极大值抑制。 | *   **compute\_iou(box, boxes):**  计算两个边界框之间的交并比 (IoU)。 | *   **xywh2xyxy(x):**  将边界框从 (x, y, w, h) 格式转换为 (x1, y1, x2, y2) 格式。 | *   **draw\_detections(detect\_result, mask\_alpha=0.3):**  在图像上绘制检测结果，包括边界框和标签。 | *   **draw\_text(image, text, result, font\_size, text\_thickness):** 在图像上绘制文本标签。 | *   **draw\_masks(image, results, mask\_alpha):** 在图像上绘制检测到的目标的mask。 |  | **重要功能点:** |  | *   定义了目标检测结果的数据结构，方便存储和处理检测结果。 | *   实现了 NMS 算法，用于消除冗余的检测结果。 | *   提供了边界框格式转换的工具函数。 | *   提供了在图像上可视化检测结果的函数，包括绘制边界框、标签和mask。
    │       ├── log_utils.py    这个 Python 脚本 `log_utils.py` 实现了一个用于 OneDragon-YOLO 模型的自定义日志记录器。 |  | *   **主要功能:**  配置和提供一个用于记录日志消息的全局日志记录器。 | *   **核心类和函数:** |     *   `get_logger()`:  创建并配置日志记录器。它设置了日志级别（INFO 或 ERROR，取决于环境变量 `OD_YOLO_VERBOSE`），格式化程序，以及将日志消息输出到控制台的处理程序。 |     *   `log`:  `get_logger()` 函数创建的日志记录器实例，供其他模块使用。 | *   **重要功能点:** |     *   基于环境变量 `OD_YOLO_VERBOSE` 决定日志级别，控制日志的详细程度。 |     *   使用标准的 `logging` 模块。 |     *   日志消息包含时间戳、文件名、行号和日志级别。 |     *   将日志消息输出到控制台。
    │       ├── onnx_model_loader.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个用于加载和管理 ONNX 模型的类 `OnnxModelLoader`。它负责从指定的 URL 下载模型，解压缩，加载到 ONNX Runtime 中，并提供获取模型输入输出信息的功能。同时支持使用备用模型，以及通过代理下载。 |  | **核心类和函数:** |  | *   **`OnnxModelLoader`**:  核心类，用于加载、下载和管理 ONNX 模型。 |     *   `__init__`: 初始化函数，设置模型名称、下载地址、代理等参数，并尝试下载和加载模型。 |     *   `check_and_download_model`: 检查模型是否存在，如果不存在则下载。 |     *   `check_model_exists`: 检查模型文件是否存在。 |     *   `download_model`: 从指定 URL 下载模型。 |     *   `unzip_model`: 解压下载的 zip 文件。 |     *   `load_model`: 加载 ONNX 模型到 ONNX Runtime。 |     *   `get_input_details`: 获取模型的输入信息，包括输入名称和尺寸。 |     *   `get_output_details`: 获取模型的输出信息，包括输出名称。 |  | **重要功能点:** |  | *   **模型下载与管理:**  支持从 URL 下载模型，并在本地存储。 | *   **代理支持:**  支持使用个人代理和 GitHub 代理进行下载。 | *   **备用模型:**  如果主模型下载失败，则使用备用模型。 | *   **GPU 加速:**  可以选择使用 GPU (DirectML) 进行推理，如果可用。 | *   **模型加载:**  使用 ONNX Runtime 加载模型。 | *   **输入/输出信息获取:**  提供获取模型输入和输出名称和尺寸的功能。 | *   **下载进度显示:**  在下载过程中显示下载进度。
    │       ├── onnx_utils.py    这个 Python 文件的主要功能是**按照 Ultralytics 的方式，将输入图像缩放至 ONNX 模型所需的尺寸**。 |  | 核心函数： |  | *   `scale_input_image_u(image, onnx_input_width, onnx_input_height)`：接收输入图像和 ONNX 模型所需的宽高，返回缩放后的图像张量、缩放后的高度和宽度。 |  | 重要功能点： |  | *   使用 `cv2.resize` 进行图像缩放。 | *   使用填充（padding）来保持图像的长宽比，填充值为 114。 | *   将图像归一化到 0-1 范围。 | *   将图像转换为模型所需的张量格式 (NCHW)。
    │       ├── yolov8_onnx_cls.py    这个 Python 文件定义了一个使用 ONNX 模型的 YOLOv8 分类器。 |  | **主要功能:** |  | *   使用 ONNX 模型进行图像分类。 | *   提供图像预处理、推理和后处理流程。 | *   管理识别结果的历史记录。 |  | **核心类和函数:** |  | *   **`RunContext`**: 储存推理过程中的上下文信息，如图像、时间和配置。 | *   **`ClassificationResult`**: 储存分类结果，包括原始图像、分类索引和运行时间。 | *   **`Yolov8Classifier`**: 继承自 `OnnxModelLoader`，负责模型的加载、推理和结果处理。 |     *   `__init__`: 初始化分类器，加载 ONNX 模型。 |     *   `run`: 对给定的图像进行分类，返回 `ClassificationResult`。 |     *   `prepare_input`: 预处理图像，调整大小。 |     *   `inference`: 使用 ONNX 模型进行推理。 |     *   `process_output`: 处理推理结果，获取分类索引和置信度。 |     *   `record_result`: 记录识别结果的历史记录。 |     *   `last_run_result`: 获取最后一次的识别结果。 |  | **重要功能点:** |  | *   使用 `OnnxModelLoader` 加载 ONNX 模型。 | *   图像预处理包括缩放。 | *   使用置信度阈值筛选分类结果。 | *   管理识别结果的历史记录，并根据 `keep_result_seconds` 进行清理。
    │       ├── yolov8_onnx_det.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个 `Yolov8Detector` 类，用于使用 ONNX 格式的 YOLOv8 模型进行目标检测。它封装了模型的加载、输入预处理、推理、后处理以及结果记录等流程。 |  | **核心类和函数:** |  | *   **`Yolov8Detector(OnnxModelLoader)`**:  继承自 `OnnxModelLoader`，用于加载和运行 YOLOv8 ONNX 模型。 |     *   `__init__()`: 初始化模型，加载分类信息，并设置结果保留时间。 |     *   `run(image, conf, iou, run_time, label_list, category_list)`:  对输入图像进行目标检测，返回检测结果。 |     *   `prepare_input(context)`:  对输入图像进行预处理，包括缩放。 |     *   `inference(input_tensor)`:  使用 ONNX 运行时进行推理。 |     *   `process_output(output, context)`:  处理推理结果，进行 NMS 等后处理，生成检测结果列表。 |     *   `record_result(context, results)`:  记录检测结果。 |     *   `last_run_result`:  获取最近一次的检测结果。 |     *   `_load_detect_classes(model_dir_path)`:  从 `labels.csv` 文件加载类别信息。 |  | **重要功能点:** |  | *   **模型加载和管理**:  继承 `OnnxModelLoader`，负责模型的下载、加载和管理。 | *   **图像预处理**:  使用 `onnx_utils.scale_input_image_u` 对输入图像进行缩放。 | *   **推理**:  使用 ONNX 运行时进行推理。 | *   **后处理**:  包括置信度过滤、类别选择、边界框转换和 NMS (非极大值抑制)。 | *   **结果记录**:  保留历史检测结果，并提供获取最近结果的接口。 | *   **类别过滤**: 支持通过 `label_list` 和 `category_list` 过滤检测类别。
    │       └── yolo_utils.py    这个 Python 文件 `yolo_utils.py` 包含用于 OneDragon-YOLO 模型的下载 URL。 |  | *   **主要功能:** 定义了用于下载超分辨率 (SR) 模型和 ZZZ 模型的 URL。 | *   **核心变量:** |     *   `SR_MODEL_DOWNLOAD_URL`:  超分辨率模型的下载链接。 |     *   `ZZZ_MODEL_DOWNLOAD_URL`: ZZZ 模型的下载链接。 | *   **重要功能点:**  提供了预训练模型的下载链接，方便用户获取模型文件。
    ├── one_dragon_qt/
    │   ├── README.md    这个文件的摘要如下： |  | *   **主要功能:** 描述了如何使用 `pyside6-rcc` 工具将资源文件 (`.qrc`) 打包成 Python 模块 (`.py`)。 | *   **核心类和函数:**  无，此文件主要提供命令行指令。 | *   **重要功能点:** |     *   使用 `pyside6-rcc` 工具打包资源。 |     *   指定输入文件 (`resource.qrc`) 和输出文件 (`resource.py`)。 |     *   需要在 `_rc` 目录下执行命令。
    │   ├── app/
    │   │   └── installer.py    **摘要：** |  | 该文件定义了一个基于 `PySide6` 和 `qfluentwidgets` 的安装程序窗口基类 `InstallerWindowBase`。它负责创建和管理安装程序的用户界面，包括窗口初始化、子界面切换和样式设置。 |  | **核心类和函数：** |  | *   `InstallerWindowBase`:  继承自 `AppWindowBase`，是安装程序的主窗口类。 |     *   `__init__`:  初始化窗口，设置标题、图标、启动画面，并创建子界面。 |     *   `create_sub_interface`:  用于创建子界面的占位符。 |     *   `add_sub_interface`:  添加子界面到导航栏。 |     *   `init_interface_on_shown`:  在子界面切换时初始化界面显示。 |     *   `init_window`:  初始化窗口的尺寸、位置、对象名称和样式。 |  | **重要功能点：** |  | *   窗口初始化：设置窗口标题、图标、启动画面和初始大小。 | *   子界面管理：添加、切换和初始化子界面。 | *   样式设置：应用预定义的样式表，包括窗口、导航栏、堆叠窗口和标题栏。 | *   事件处理：处理子界面显示和隐藏事件。 | *   配置加载：从 `OneDragonEnvContext` 加载项目配置，并设置问题报告链接。
    │   ├── services/
    │   │   └── styles_manager.py    这个 Python 文件定义了一个用于管理 One Dragon Qt 应用程式样式的类。 |  | *   **主要功能:** 提供样式表管理，包括定义样式表类型和获取样式表文件路径。 | *   **核心类和函数:** |     *   `OdQtStyleSheet` (继承自 `StyleSheetBase` 和 `Enum`):  一个枚举类，定义了各种样式表类型，例如 `SAMPLE_CARD`, `LINK_CARD` 等，以及窗口相关的样式。 |     *   `path(self, theme=Theme.AUTO)`:  根据主题（浅色或深色）返回对应的 `.qss` 样式表文件路径。 | *   **重要功能点:** |     *   使用枚举定义样式表类型，方便管理和引用。 |     *   根据主题动态获取样式表文件路径，实现主题切换。 |     *   依赖于 `qfluentwidgets` 库和资源文件 (`_rc`) 来加载和应用样式。
    │   ├── utils/
    │   │   └── layout_utils.py    这个 Python 文件定义了两个用于 GUI 布局的简单数据结构： |  | *   **主要功能：** 提供用于管理边距和图标大小的数据结构。 | *   **核心类：** |     *   `Margins`:  用于表示四个方向的边距 (左、上、右、下)。 |     *   `IconSize`:  用于表示图标的宽度和高度。 | *   **重要功能点：** 提供了 `Margins` 和 `IconSize` 两个类，用于储存和管理布局相关的数值。
    │   ├── view/
    │   │   ├── app_run_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AppRunInterface` 类，用于在 Qt 界面中展示和控制应用程序的运行状态。它提供了一个用户界面，用于启动、停止和暂停应用程序，并显示运行状态和日志信息。 |  | **核心类和函数:** |  | *   **`AppRunner(QThread)`:** |     *   `__init__(self, ctx: OneDragonContext, app: Optional[Application] = None)`: 初始化线程，接收 `OneDragonContext` 和 `Application` 实例。 |     *   `run(self)`: 线程的运行方法，监听运行状态事件，并执行应用程序的 `execute()` 方法。 |     *   `_on_state_changed(self, ignored)`: 响应运行状态改变的槽函数，触发 `state_changed` 信号。 | *   **`AppRunInterface(VerticalScrollInterface)`:** |     *   `__init__(self, ctx: OneDragonContext, object_name: str, nav_text_cn: str, nav_icon: Union[FluentIconBase, QIcon, str] = None, parent=None)`: 初始化界面，接收 `OneDragonContext` 实例。 |     *   `get_content_widget(self) -> QWidget`: 构建界面的主要内容，包括状态显示、开始/停止按钮、日志显示卡片。 |     *   `get_widget_at_top(self) -> QWidget`:  用于获取顶部部件，留给子类实现。 |     *   `get_widget_at_bottom(self) -> QWidget`:  用于获取底部部件，留给子类实现。 |     *   `on_interface_shown(self) -> None`: 界面显示时，监听键盘事件。 |     *   `on_interface_hidden(self) -> None`: 界面隐藏时，取消所有事件监听。 |     *   `_on_key_press(self, event: ContextEventItem) -> None`: 响应键盘按键事件，触发开始运行。 |     *   `run_app(self) -> None`: 启动应用程序运行。 |     *   `get_app(self) -> Application`:  获取要运行的应用程序实例，由子类实现。 |     *   `on_context_
    │   │   ├── code_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `CodeInterface` 类，用于在 OneDragon Qt 应用程序中展示和管理代码同步相关的功能，包括 Git 代码更新、代码安装、Venv 环境管理以及 Git 日志的显示和回滚。 |  | **核心类和函数:** |  | *   **`FetchTotalRunner`**:  继承自 `QThread`，用于在后台线程中获取 Git 提交总数。 |     *   `run()`: 执行获取总数的方法，并发出 `finished` 信号。 | *   **`FetchPageRunner`**: 继承自 `QThread`，用于在后台线程中获取 Git 提交分页数据。 |     *   `run()`: 执行获取分页数据的方法，并发出 `finished` 信号。 | *   **`CodeInterface`**: 继承自 `VerticalScrollInterface`，是代码同步界面的主类。 |     *   `__init__()`: 初始化界面，包括设置界面布局、添加各种设置卡片（强制更新、Git 安装、代码安装、分支选择、Venv 安装）、创建日志表格、分页器，并连接信号和槽。 |     *   `on_interface_shown()`:  界面显示时进行初始化，包括初始化设置卡片，开始获取总数，并更新 Git、代码和 Venv 卡片的显示。 |     *   `start_fetch_total()`:  启动获取总数的线程。 |     *   `update_total()`:  更新分页器总页数，并启动获取第一页数据。 |     *   `start_fetch_page()`:  启动获取分页数据的线程。 |     *   `fetch_page()`:  从 Git 服务获取分页数据。 |     *   `update_page()`:  更新日志表格的内容。 |     *   `on_page_changed()`:  处理分页器翻页事件，重新获取并显示对应页的数据。 |     *   `_on_git_updated()`:  Git 更新完成后，更新 Git 和代码安装卡片的显示。 |     *   `on_code_updated()`:  代码同步完成后，更新 Venv 卡片的显示，重置分页，并重新获取总数。 |     *   `on_reset_commit_clicked()`:  处理回滚到特定 commit 的点击事件，执行
    │   │   ├── context_event_signal.py    这个 Python 文件定义了一个名为 `ContextEventSignal` 的类，它继承自 `QObject`，用于在上下文事件发生时发出信号。 |  | *   **主要功能:** 提供一个信号，用于通知其他组件上下文实例已更改。 | *   **核心类:** `ContextEventSignal` 继承自 `QObject`。 | *   **重要功能点:** |     *   `instance_changed`:  一个 `Signal`，当上下文实例发生变化时发出。 |     *   `__init__`:  初始化 `ContextEventSignal` 实例。
    │   │   ├── installer_setting_interface.py    这个 Python 文件的摘要如下： |  | *   **主要功能：** `InstallerSettingInterface` 是一个用于安装程式设置的界面，它继承自 `PivotNavigatorInterface`，并负责管理和显示设置相关的子界面。 | *   **核心类和函数：** |     *   `InstallerSettingInterface`: 核心类，继承自 `PivotNavigatorInterface`，用于管理安装程式的设置界面。 |     *   `__init__(self, ctx: OneDragonEnvContext, parent=None)`: 构造函数，初始化界面，接收 `OneDragonEnvContext` 作为上下文。 |     *   `create_sub_interface(self)`: 创建子界面，添加 `SettingEnvInterface` 到界面中。 | *   **重要功能点：** |     *   使用 `PivotNavigatorInterface` 提供导航功能。 |     *   添加 `SettingEnvInterface` 作为子界面，用于显示和管理环境设置。 |     *   使用 `OneDragonEnvContext` 作为上下文，提供环境相关的数据和操作。
    │   │   ├── install_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `InstallerInterface` 类，用于构建一个一键安装界面，该界面集成了 Git、代码、Python 环境和虚拟环境的安装功能，并提供进度显示和日志输出。 |  | **核心类和函数:** |  | *   **`InstallerInterface(VerticalScrollInterface)`**:  主界面类，继承自 `VerticalScrollInterface`。 |     *   `__init__(self, ctx: OneDragonEnvContext, parent=None)`: 初始化界面，接收 `OneDragonEnvContext` 上下文。 |     *   `get_content_widget(self) -> QWidget`: 构建界面内容，包括进度条、安装卡片（Git、代码、Python、Venv、AllInstallCard）和日志显示卡片。 |     *   `on_interface_shown(self) -> None`: 界面显示时，检查并更新各个组件的状态，并启动日志更新。 |     *   `on_interface_hidden(self) -> None`: 界面隐藏时，停止日志更新。 |     *   `update_progress(self, progress: float, message: str) -> None`: 更新进度条显示。 |     *   `_on_code_updated(self, success: bool) -> None`: 代码更新完成后，更新 Venv 组件的状态。 |  | **重要功能点:** |  | *   **集成安装功能**:  界面整合了 Git、代码、Python 环境和虚拟环境的安装功能，通过不同的 `InstallCard` 实现。 | *   **进度显示**:  使用 `ProgressBar` 和 `IndeterminateProgressBar` 显示安装进度。 | *   **日志显示**:  使用 `LogDisplayCard` 显示安装日志。 | *   **界面状态更新**:  `on_interface_shown` 和 `on_interface_hidden` 用于在界面显示和隐藏时更新组件状态。 | *   **组件联动**:  `_on_code_updated` 函数用于在代码更新完成后，更新 Venv 组件的状态，实现组件间的联动。 | *   **多语言支持**: 使用 `gt` 函数进行多语言支持。
    │   │   ├── like_interface.py    这个 Python 文件定义了一个名为 `LikeInterface` 的 Qt 界面，用于展示点赞相关的信息和选项。 |  | *   **主要功能:** 提供用户点赞、支持项目的方式，包括 GitHub Star、访问指南和赞赏。 | *   **核心类和函数:** |     *   `LikeInterface`: 继承自 `VerticalScrollInterface`，是主要的界面类。 |     *   `get_content_widget()`: 构建界面内容，包括 `HyperlinkCard` 用于展示链接，`ImageLabel` 用于展示图片。 |     *   `on_interface_shown()`: 界面显示时的处理函数。 | *   **重要功能点:** |     *   使用 `HyperlinkCard` 展示 GitHub Star、访问指南和赞赏链接。 |     *   使用 `ImageLabel` 展示赞赏的二维码图片。 |     *   使用 `Column` 布局管理界面元素。 |     *   使用 `OneDragonEnvContext` 获取项目配置信息。
    │   │   ├── devtools/
    │   │   │   ├── devtools_screen_manage_interface.py    ```python | """ | 该文件定义了 DevtoolsScreenManageInterface 类，用于在开发者工具中管理屏幕信息。 |  | 主要功能： | 1.  管理屏幕信息的创建、保存、删除和编辑。 | 2.  提供界面用于选择和显示屏幕截图。 | 3.  允许用户定义和编辑屏幕区域，包括区域名称、位置、文本、模板匹配等。 |  | 核心类和函数： | *   DevtoolsScreenManageInterface:  主界面类，继承自 VerticalScrollInterface，负责界面布局和交互。 |     *   _init_left_part(): 初始化左侧界面，包含按钮、文本框和区域表格。 |     *   _init_right_part(): 初始化右侧界面，包含图片显示和设置选项。 |     *   on_interface_shown():  界面显示时初始化，更新显示。 |     *   _update_display_by_screen():  根据屏幕信息更新界面显示。 |     *   _update_area_table_display():  更新区域表格的显示。 |     *   _update_image_display():  更新图片显示。 |     *   _on_choose_existed_yml():  选择已有的yml文件。 |     *   _on_create_clicked():  创建新的屏幕信息。 |     *   _on_save_clicked():  保存屏幕信息。 |     *   _on_delete_clicked():  删除屏幕信息。 |     *   _on_cancel_clicked():  取消编辑。 |     *   choose_existed_image():  选择已有的图片。 |     *   _on_image_chosen():  选择图片后的回调。 |     *   choose_existed_template():  选择已有的模板。 |     *   _on_template_chosen():  选择模板后的回调，导入模板区域。 |     *   _on_screen_id_changed():  屏幕ID改变。 |     *   _on_screen_name_changed():  屏幕名称改变。 |     *   _on_pc_alt_changed():  PC Alt 状态改变。 |     *   _on_area_add_clicked():  添加区域。 |     *   _on_row_delete_clicked():  删除区域。 |     *   _on_area_table_cell_changed():
    │   │   │   └── devtools_template_helper_interface.py    **摘要:** |  | *   **主要功能:**  `DevtoolsTemplateHelperInterface` 是一个用于管理和编辑模板的界面，主要用于开发工具中，允许用户创建、修改、保存和删除模板，并提供图片显示和点位编辑功能。 | *   **核心类和函数:** |     *   `DevtoolsTemplateHelperInterface`:  主界面类，继承自 `VerticalScrollInterface`。 |     *   `_init_left_part`, `_init_mid_part`, `_init_right_part`:  初始化界面各个部分的函数，分别负责按钮、图片显示和设置区域的布局。 |     *   `_update_whole_display`:  根据模板状态更新整个界面的显示。 |     *   `_on_choose_existed_yml`:  处理选择已存在模板的事件。 |     *   `_on_create_clicked`:  处理创建新模板的事件。 |     *   `_on_copy_clicked`:  处理复制模板的事件。 |     *   `_on_save_config_clicked`, `_on_save_raw_clicked`, `_on_save_mask_clicked`:  处理保存配置、原始图片和掩码的事件。 |     *   `_on_delete_clicked`:  处理删除模板的事件。 |     *   `choose_existed_image`:  打开文件对话框选择图片。 |     *   `_on_image_clicked`:  处理在图片上点击事件，添加点位。 |     *   `_on_h_move_clicked`, `_on_v_move_clicked`:  处理水平和垂直移动所有点位的事件。 | *   **重要功能点:** |     *   模板的创建、复制、删除和取消操作。 |     *   选择和显示模板的原始图片、掩码和抠图结果。 |     *   编辑模板的子目录、ID、名称和形状。 |     *   自动生成掩码的开关。 |     *   点位的添加、删除和编辑（通过表格）。 |     *   图片显示大小的调整。 |     *   通过滑鼠点击图片添加点位。 |     *   批量移动所有点位。
    │   │   ├── one_dragon/
    │   │   │   └── one_dragon_run_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `OneDragonRunInterface` 类，该类是用于在用户界面中管理和控制“一条龙”运行流程的界面。它提供了启动、停止、配置应用程序运行顺序和设置运行参数的功能。 |  | **核心类和函数:** |  | *   **`OneDragonRunInterface(VerticalScrollInterface)`**:  主界面类，继承自 `VerticalScrollInterface`。 |     *   `__init__`: 初始化界面，包括上下文 ( `OneDragonContext` )、导航文本、多实例和结束操作选项。 |     *   `get_content_widget`: 构建界面内容，包括左右布局，以及 `AppRunner` 实例。 |     *   `_get_left_layout`:  创建左侧布局，包含应用列表。 |     *   `_get_right_layout`: 创建右侧布局，包含运行设置、状态显示、启动/停止按钮和日志显示。 |     *   `_init_app_list`: 初始化应用列表，并根据配置设置应用运行状态。 |     *   `on_interface_shown`:  界面显示时初始化应用列表，注册事件监听器，设置配置选项。 |     *   `on_interface_hidden`:  界面隐藏时取消事件监听。 |     *   `_on_after_done_changed`: 处理“结束后”选项的更改。 |     *   `run_app`: 运行指定的应用程序。 |     *   `_on_start_clicked`:  处理“开始”按钮的点击事件。 |     *   `_on_stop_clicked`:  处理“停止”按钮的点击事件。 |     *   `_on_key_press`:  处理键盘按键事件，实现快捷键启动。 |     *   `on_context_state_changed`:  根据运行状态更新界面显示。 |     *   `_on_app_state_changed`:  处理应用状态变化。 |     *   `on_app_card_move_up`:  处理应用在列表中的上移操作。 |     *   `_on_app_card_run`:  处理运行特定应用的操作。 |     *   `on_app_switch_run`:  处理应用运行状态切换。 |     *   `_on_instance_event`:
    │   │   └── setting/
    │   │       ├── setting_custom_interface.py    ```python | 文件摘要： | 该文件定义了 `SettingCustomInterface` 类，用于在 OneDragon 应用程序中提供自定义设置界面。该界面允许用户更改主题、设置自定义主页背景。 |  | 核心类和函数： | *   `SettingCustomInterface`: 继承自 `VerticalScrollInterface`，是自定义设置界面的主类。 |     *   `__init__`: 初始化界面，设置上下文和导航文本。 |     *   `get_content_widget`: 构建界面内容，包括主题设置和自定义背景设置。 |     *   `_init_basic_group`: 初始化基本设置组，包含主题选择和自定义背景开关。 |     *   `on_interface_shown`: 初始化界面显示时，从配置适配器加载设置。 |     *   `_on_theme_changed`: 当主题改变时，更新应用程序主题。 |     *   `_on_banner_changed`: 当自定义背景开关改变时，验证密码并启用/禁用选择按钮。 |     *   `_on_banner_select_clicked`: 选择背景图片，复制到指定目录，并显示提示对话框。 |     *   `_show_dialog_after_banner_updated`: 显示设置主页背景后的对话框，提示重启。 |  | 重要功能点： | *   主题设置：使用 `ComboBoxSettingCard` 提供主题选择功能，并根据选择更新应用程序主题。 | *   自定义背景设置：使用 `SwitchSettingCard` 启用/禁用自定义背景功能，并提供密码验证和文件选择功能。 | *   密码验证：使用 SHA256 算法对密码进行哈希，验证用户输入的密码。 | *   文件选择：使用 `QFileDialog` 选择背景图片，并复制到指定目录。 | *   重启提示：在更新背景后，提示用户重启应用程序以应用更改。 | ```
    │   │       ├── setting_env_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `SettingEnvInterface` 类，用于在 Qt 界面中展示和管理脚本环境的设置。它提供了用户界面，允许用户配置调试模式、代码源、拉取方式、更新策略、Pip 源、网络代理、个人代理、GitHub 代理以及快捷键等环境相关设置。 |  | **核心类和函数:** |  | *   **`SettingEnvInterface(ctx: OneDragonEnvContext, parent=None)`**:  主界面类，继承自 `VerticalScrollInterface`，用于展示设置界面。 |     *   `__init__`: 初始化界面，接收 `OneDragonEnvContext` 实例。 |     *   `get_content_widget()`: 构建设置界面的内容，包括多个 `SettingCardGroup`。 |     *   `_init_basic_group()`: 初始化“基础”设置组，包含调试模式开关。 |     *   `_init_code_group()`: 初始化“Git 相关”设置组，包含代码源、拉取方式、强制更新、自动更新和 Pip 源设置。 |     *   `_init_web_group()`: 初始化“网络相关”设置组，包含代理类型、个人代理、GitHub 代理设置和自动获取 GitHub 代理地址。 |     *   `_init_key_group()`: 初始化“脚本按键”设置组，包含开始运行、停止运行、截图和调试快捷键设置。 |     *   `on_interface_shown()`:  界面显示时，从 `OneDragonEnvContext` 加载配置并初始化 UI 控件。 |     *   `_on_debug_changed(value: bool)`: 调试模式改变时的处理函数。 |     *   `_on_repo_type_changed(index: int, value: str)`: 代码源改变时的处理函数。 |     *   `_on_git_method_changed(index: int, value: str)`: 拉取方式改变时的处理函数。 |     *   `_on_force_update_changed(value: bool)`: 强制更新改变时的处理函数。 |     *   `_on_auto_update_changed(value: bool)`: 自动更新改变时的处理函数。 |     *   `_on_proxy_type_changed(index: int,
    │   │       └── setting_instance_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于管理和配置多个游戏实例的界面，包括实例的创建、删除、启用、登录，以及游戏路径、区服、账号和密码的设置。 |  | **核心类和函数:** |  | *   **`InstanceSettingCard`**: |     *   继承自 `MultiPushSettingCard`，用于显示和管理单个游戏实例的设置。 |     *   包含实例名称输入框、运行方式选择框、启用、登录和删除按钮。 |     *   `changed`、`active`、`login`、`delete` 信号用于与父界面交互。 |     *   `_on_name_changed`、`_on_run_changed`、`_on_active_clicked`、`_on_login_clicked`、`_on_delete_clicked` 处理用户交互事件。 |     *   `check_active` 用于更新实例的启用状态显示。 | *   **`SettingInstanceInterface`**: |     *   继承自 `VerticalScrollInterface`，是多账户管理界面的主界面。 |     *   `get_content_widget` 构建界面内容，包括引导卡片、实例设置组和实例切换组。 |     *   `_init_content_widget` 初始化界面内容，包括创建 `InstanceSettingCard` 实例。 |     *   `_get_instanceSwitch_group` 构建实例切换组，包含所有 `InstanceSettingCard` 和新增按钮。 |     *   `_get_instanceSettings_group` 构建当前账户设置组，包含游戏路径、区服、账号和密码的设置。 |     *   `_on_add_clicked` 创建新的游戏实例。 |     *   `_on_instance_changed`、`_on_instance_active`、`_on_instance_login`、`_on_instance_delete` 处理实例相关的事件。 |     *   `_on_game_path_clicked` 弹出文件选择对话框，选择游戏路径。 |     *   `_on_game_path_chosen` 更新游戏路径设置。 |     *   `init_game_account_config` 初始化游戏账号配置。 |  | **重要功能点:** |  | *   **多实例管理:** 支持创建、删除、启用和切换多个游戏实例
    │   ├── widgets/
    │   │   ├── banner.py    这个 Python 文件的主要功能是创建一个带有圆角的横幅小部件，用于在 Qt 应用程序中显示图像。 |  | 核心类： |  | *   `Banner`：继承自 `QWidget`，负责加载、缩放和绘制横幅图片，并提供设置大小的方法。 |  | 核心函数： |  | *   `__init__(self, image_path: str, parent=None)`：初始化 Banner，加载图片，并初始化缩放后的图片。 | *   `load_banner_image(self, image_path: str)`：加载横幅图片，如果文件不存在，则创建一个灰色的备用图片。 | *   `_create_fallback_image(self)`：创建一个灰色的备用图片。 | *   `update_scaled_image(self)`：根据控件大小缩放图片。 | *   `paintEvent(self, event)`：重载 `paintEvent`，用于绘制带有圆角的缩放后的图片。 | *   `resizeEvent(self, event)`：重载 `resizeEvent`，在控件大小改变时更新缩放后的图片。 | *   `set_percentage_size(self, width_percentage, height_percentage)`：设置 Banner 的大小为父窗口大小的百分比。 |  | 重要功能点： |  | *   加载图片，如果图片不存在，则使用备用图片。 | *   按比例缩放图片，并裁剪超出部分。 | *   绘制带有圆角的横幅。 | *   根据控件大小变化更新图片。 | *   支持设置横幅大小为父窗口的百分比。
    │   │   ├── base_interface.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 定义了一个 `BaseInterface` 类，用于包装应用程式中子页面的基本功能，包括导航文本、图标和生命周期回调。 |  | **核心类和函数：** |  | *   `BaseInterface`: 继承自 `QWidget`，是所有子页面的基类。 |     *   `__init__(self, object_name: str, nav_text_cn: str, nav_icon: Union[FluentIconBase, QIcon, str] = None, parent=None)`: 构造函数，初始化页面的导航相关属性。 |     *   `on_interface_shown(self) -> None`: 子界面显示时的回调函数，用于初始化。 |     *   `on_interface_hidden(self) -> None`: 子界面隐藏时的回调函数。 |  | **重要功能点：** |  | *   提供了一个基类，用于统一管理子页面的导航信息（文本和图标）。 | *   定义了子页面显示和隐藏时的回调函数，方便子页面的初始化和清理工作。 | *   使用 `gt` 函数进行文本国际化。
    │   │   ├── click_image_label.py    这个 Python 文件定义了一个名为 `ClickImageLabel` 的自定义 `ImageLabel` 小部件，它扩展了 `qfluentwidgets` 库中的 `ImageLabel`。 |  | *   **主要功能:** 实现带有鼠标点击和拖动事件处理的图像显示。 | *   **核心类和函数:** |     *   `ImageScaleEnum`: 是一个枚举，用于定义图像缩放比例。 |     *   `ClickImageLabel`: 继承自 `ImageLabel`，重写了 `mousePressEvent` 和 `mouseReleaseEvent` 方法，以处理鼠标点击和拖动事件。 |         *   `clicked_with_pos`:  信号，在鼠标点击时发射，传递点击位置的 x 和 y 坐标。 |         *   `drag_released`: 信号，在鼠标释放时发射，传递拖动的起始和结束位置的 x 和 y 坐标。 |         *   `mousePressEvent(self, event: QMouseEvent)`: 处理鼠标按下事件，记录按下位置，并发射 `clicked_with_pos` 信号。 |         *   `mouseReleaseEvent(self, event: QMouseEvent)`: 处理鼠标释放事件，记录释放位置，并发射 `drag_released` 信号。 | *   **重要功能点:** |     *   鼠标点击事件处理，发射 `clicked_with_pos` 信号。 |     *   鼠标拖动事件处理，发射 `drag_released` 信号，提供拖动的起始和结束位置。
    │   │   ├── column.py    这个 Python 文件定义了一个名为 `Column` 的自定义 Qt widget，它使用垂直布局 (`QVBoxLayout`) 来排列其子 widget。 |  | *   **核心类:** `Column` (继承自 `QWidget`) | *   **核心函数:** |     *   `__init__`: 初始化 `Column` widget，创建垂直布局。 |     *   `add_widget`: 将 widget 添加到垂直布局中，可以设置 stretch 和对齐方式。 |     *   `remove_widget`: 从垂直布局中移除指定的 widget。 |     *   `add_stretch`: 在垂直布局中添加 stretch。 |     *   `clear_widgets`: 移除垂直布局中的所有 widget。 | *   **重要功能点:** 提供了一个方便的方式来创建具有垂直布局的自定义 widget，方便添加、移除和管理子 widget。
    │   │   ├── combo_box.py    这个 Python 文件定义了一个自定义的 `ComboBox` 控件，它继承自 `qfluentwidgets.ComboBox`，并增加了处理 `ConfigItem` 列表的功能。 |  | *   **主要功能:**  提供一个可更新选项的下拉框，并支持根据目标值初始化。 | *   **核心类和函数:** |     *   `ComboBox`: 自定义的下拉框控件。 |     *   `set_items(self, items: List[ConfigItem], target_value: Any = None)`:  更新下拉框的选项，尽量复用现有选项，并设置当前选中的值。 |     *   `init_with_value(self, target_value: Any = None)`: 根据目标值初始化下拉框，禁用信号以避免触发事件。 | *   **重要功能点:** |     *   高效的选项更新，尝试复用现有选项以提高性能。 |     *   支持根据 `ConfigItem` 列表更新选项，`ConfigItem` 包含 `ui_text` 和 `value` 属性。 |     *   提供初始化方法，允许在不触发信号的情况下设置选定的值。 |     *   使用 `blockSignals` 禁用和启用信号，以避免在更新选项时触发不必要的事件。
    │   │   ├── cv2_image.py    这个 Python 文件 `cv2_image.py` 定义了一个 `Cv2Image` 类，它继承自 `QImage`，用于将 OpenCV (cv2) 的图像转换为 Qt 的 `QImage` 格式，以便在 Qt 应用程序中显示。 |  | *   **核心类:** `Cv2Image` | *   **核心函数:** `__init__(self, cv_image: MatLike)` 构造函数，接收一个 OpenCV 的图像 (`MatLike` 类型) 作为输入。 | *   **重要功能点:** |     *   根据 OpenCV 图像的通道数和类型（灰度、BGR、BGRA）进行转换。 |     *   使用 `cv2.cvtColor` 函数将灰度图像转换为 RGB 图像。 |     *   直接使用 BGR 或 BGRA 图像。 |     *   使用转换后的 OpenCV 图像的数据、宽度、高度和格式（`Format_RGB888`）创建 `QImage` 对象。
    │   │   ├── editable_combo_box.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了一个自定义的 `EditableComboBox` 小部件，它继承自 `qfluentwidgets.EditableComboBox`，并增加了根据 `ConfigItem` 列表更新选项、初始化值以及设置自动补全器的功能。 |  | **核心类和函数:** |  | *   **`EditableComboBox`**:  继承自 `qtEditableComboBox`，是主要的小部件类。 |     *   `__init__(self, parent=None)`:  初始化函数。 |     *   `set_items(self, items: List[ConfigItem], target_value: Any = None)`:  更新下拉列表的选项，并尽量复用现有选项，同时设置当前选中的值。 |     *   `init_with_value(self, target_value: Any = None)`:  根据目标值初始化下拉列表，不触发信号。 |     *   `set_completer_options(self, options_list: List[ConfigItem])`:  初始化自动补全器，设置大小写不敏感和包含匹配模式。 |  | **重要功能点:** |  | *   **选项更新**:  `set_items` 方法高效地更新下拉列表的选项，通过复用现有选项来优化性能。 | *   **值初始化**:  `init_with_value` 方法允许在不触发信号的情况下初始化下拉列表的选定值。 | *   **自动补全**:  `set_completer_options` 方法为下拉列表设置了自动补全功能，包括大小写不敏感的匹配和包含匹配模式，提升了用户体验。
    │   │   ├── game_dialog.py    这个 Python 文件定义了一个 `GameDialog` 类，它是一个用于在游戏加载时显示的自定义对话框。 |  | *   **主要功能:** 显示带有跳跃动画的文本，用于指示游戏正在加载。 | *   **核心类和函数:** |     *   `GameDialog`: 继承自 `MaskDialogBase`，用于创建对话框。 |         *   `__init__(self, text: str, parent=None)`: 初始化对话框，设置阴影、遮罩颜色，创建文本标签，并启动计时器。 |         *   `animate_text(self)`: 触发文本动画。 |         *   `jump_start(self)`: 开始跳跃动画。 |         *   `jump_end(self)`: 结束跳跃动画。 |         *   `update_index(self)`: 更新当前文本标签的索引。 |         *   `close_dialog(self)`: 关闭对话框并停止计时器。 | *   **重要功能点:** |     *   使用 `QTimer` 定时触发文本动画。 |     *   使用 `QPropertyAnimation` 实现文本标签的跳跃动画。 |     *   使用 `OdQtStyleSheet.GAME_DIALOG.apply(self)` 应用样式。 |     *   循环显示文本，每个字符交替跳跃。
    │   │   ├── icon_button.py    这个 Python 文件定义了一个名为 `IconButton` 的自定义按钮小部件，它继承自 `TransparentToolButton` 并添加了工具提示功能。 |  | *   **主要功能:** 创建一个带有图标的按钮，并在鼠标悬停时显示工具提示。 | *   **核心类:** `IconButton` 继承自 `TransparentToolButton`。 | *   **重要功能点:** |     *   `__init__`: 具有多个重载，用于初始化按钮，可以接受图标、工具提示的标题和内容作为参数。 |     *   `eventFilter`: 监听鼠标进入和离开事件，并分别调用 `_show_tooltip` 和 `_hide_tooltip`。 |     *   `_show_tooltip`: 创建并显示 `TeachingTip` 作为工具提示，并设置其位置。 |     *   `_hide_tooltip`: 关闭工具提示。 |     *   `__hash__` 和 `__eq__`: 实现了对象的哈希和相等性比较。
    │   │   ├── label.py    这个 Python 文件定义了一个名为 `EllipsisLabel` 的自定义 QLabel 小部件，它会在文本超出其可用宽度时自动添加省略号。 |  | *   **核心类:** `EllipsisLabel` (继承自 QLabel) | *   **核心函数:** |     *   `__init__`: 初始化 QLabel 并设置文本。 |     *   `setText`: 设置文本，并调用 `updateText`。 |     *   `resizeEvent`: 处理调整大小事件，并调用 `updateText`。 |     *   `updateText`:  根据 QLabel 的宽度截断文本，并添加省略号。 | *   **重要功能点:**  当文本过长时，使用省略号截断文本以适应 QLabel 的宽度。
    │   │   ├── log_display_card.py    这个 Python 文件定义了一个用于在 Qt 应用程序中显示和管理日志的 `LogDisplayCard` 小部件。 |  | *   **主要功能:** 实时显示来自 `logging` 模块的日志消息，支持启动、暂停、停止和自动滚动功能，并提供日志格式化和颜色高亮显示。 | *   **核心类和函数:** |     *   `LogSignal`:  用于发射新日志信号的 `QObject`。 |     *   `LogReceiver`:  继承自 `logging.Handler`，用于接收日志消息，缓存日志，并获取新日志。 |         *   `emit(self, record)`:  将新日志记录添加到日志队列。 |         *   `get_new_logs(self) -> list[str]`:  获取新的日志。 |         *   `clear_logs(self)`:  清空日志队列。 |     *   `LogDisplayCard`:  继承自 `PlainTextEdit`，用于显示日志。 |         *   `init_color(self)`:  根据主题设置文本颜色。 |         *   `start(self, clear_log: bool = False)`:  启动日志显示。 |         *   `pause(self)`:  暂停日志显示。 |         *   `stop(self)`:  停止日志显示。 |         *   `update_logs(self) -> None`:  更新日志显示区域。 |         *   `_format_logs(self, log_list: list[str]) -> str`:  格式化日志，包括颜色高亮显示。 | *   **重要功能点:** |     *   使用 `LogReceiver` 接收和缓存日志。 |     *   使用 `QTimer` 定期更新日志显示。 |     *   支持自动滚动到最新的日志消息。 |     *   提供启动、暂停和停止日志显示的功能。 |     *   对日志消息中的特定文本（例如方括号内的文本）进行颜色高亮显示。 |     *   限制显示的日志行数。
    │   │   ├── notice_card.py    ## 摘要 |  | 该 Python 文件定义了一个用于在 Qt 应用程式中显示游戏公告的 `NoticeCard` 控件。它从米哈游的 API 获取公告数据，并以轮播横幅和列表的形式显示。 |  | **核心类和函数:** |  | *   **`DataFetcher`**: 继承自 `QThread`，负责从 API 获取公告数据，包括横幅图片和文章列表。它使用缓存机制（文件缓存，有效期 3 天）来减少 API 调用，并处理网络错误。 |     *   `run()`: 执行数据获取，包括 API 请求、数据解析、缓存保存和相关文件下载。 |     *   `is_cache_valid()`: 检查缓存是否有效。 |     *   `save_cache()`: 保存数据到缓存文件。 |     *   `download_related_files()`: 下载与公告相关的文件。 |     *   `data_fetched`:  信号，用于发布获取的数据。 | *   **`NoticeCard`**: 继承自 `SimpleCardWidget`，是显示公告的主控件。 |     *   `__init__()`: 初始化控件，设置布局，并启动数据获取。 |     *   `fetch_data()`: 创建并启动 `DataFetcher` 执行数据获取。 |     *   `handle_data()`: 处理从 `DataFetcher` 接收到的数据，更新 UI。 |     *   `load_banners()`: 加载横幅图片。 |     *   `load_posts()`: 加载公告文章。 |     *   `setup_ui()`: 设置 UI 元素，包括横幅轮播、文章列表和导航标签。 |     *   `update_ui()`: 更新 UI，例如在数据加载后重新添加横幅和文章。 |     *   `scrollNext()`: 轮播到下一张横幅。 |     *   `addSubInterface()`: 添加子界面到堆叠窗口和导航标签。 |     *   `onCurrentIndexChanged()`: 当堆叠窗口的索引更改时更新导航标签。 |     *   `open_banner_link()`: 打开横幅链接。 |     *   `open_
    │   │   ├── pivot.py    这个 Python 文件定义了用于构建导航栏和选项卡的自定义 Qt 小部件。 |  | **主要功能:** |  | *   创建自定义的 Pivot 控件，用于导航和选项卡。 | *   提供 PivotItem 的自定义实现，用于显示导航选项。 | *   提供一个容器小部件，用于管理 Pivot 控件和 StackedWidget，实现页面切换。 |  | **核心类和函数:** |  | *   **PhosPivot:** 继承自 `qfluentwidgets.Pivot`，用于创建自定义的 Pivot 控件。 |     *   `insertItem()`: 插入 PivotItem。 |     *   `insertWidget()`: 插入 PivotItem 和间隔。 |     *   `paintEvent()`: 绘制指示器。 | *   **PhosPivotItem:** 继承自 `qfluentwidgets.components.navigation.pivot.PivotItem`，表示 Pivot 中的单个选项。 |     *   `setSelected()`: 设置选项的选择状态。 | *   **CustomListItemDelegate:** 继承自 `qfluentwidgets.ListItemDelegate`，用于自定义列表项的绘制。 | *   **PivotNavigatorContainer:** 包含 Pivot 和 StackedWidget，用于管理页面导航。 |     *   `add_sub_interface()`: 添加子界面到 StackedWidget 和 Pivot。 |     *   `on_current_index_changed()`: 处理 StackedWidget 的 currentChanged 信号，更新 Pivot 的选择状态和路由。 |  | **重要功能点:** |  | *   自定义 Pivot 控件的样式和行为。 | *   使用动画来指示当前选中的选项。 | *   通过 `PivotNavigatorContainer` 实现页面导航和切换。 | *   使用 `qrouter` 进行路由管理。 | *   使用 `OdQtStyleSheet` 应用样式。
    │   │   ├── pivot_navi_interface.py    这个 Python 文件定义了一个 `PivotNavigatorInterface` 类，它是一个用于管理多个子界面的导航界面，使用 `Pivot` 和 `QStackedWidget` 实现。 |  | *   **主要功能:** 提供一个带有导航栏的界面，用于在多个子界面之间切换。 | *   **核心类和函数:** |     *   `PivotNavigatorInterface`: 继承自 `BaseInterface`，是主要的导航界面类。 |         *   `__init__`: 初始化界面，包括 `Pivot`、`QStackedWidget` 和布局。 |         *   `add_sub_interface`: 添加子界面到 `QStackedWidget` 和 `Pivot`。 |         *   `create_sub_interface`: 创建子界面的虚拟函数，需要子类实现。 |         *   `on_current_index_changed`: 当 `QStackedWidget` 的当前索引改变时，更新 `Pivot` 的选中项和触发界面显示/隐藏的回调。 |         *   `on_interface_shown`: 子界面显示时的回调。 |         *   `on_interface_hidden`: 子界面隐藏时的回调。 | *   **重要功能点:** |     *   使用 `Pivot` 实现导航栏。 |     *   使用 `QStackedWidget` 管理子界面。 |     *   `add_sub_interface` 函数用于添加子界面，并将其添加到 `Pivot` 和 `QStackedWidget` 中。 |     *   `on_current_index_changed` 函数用于处理界面切换时的逻辑，包括更新 `Pivot` 的选中项和触发界面显示/隐藏的回调。 |     *   使用 `qrouter` 进行路由管理。
    │   │   ├── row.py    这个 Python 文件定义了一个名为 `Row` 的自定义 Qt widget，用于水平排列其他 widget。 |  | *   **核心类:** `Row` (继承自 `QWidget`) | *   **核心函数:** |     *   `__init__(self, parent=None)`: 初始化 `Row` widget，并创建一个 `QHBoxLayout`。 |     *   `add_widget(self, widget: QWidget, stretch: int = 0, alignment: Qt.AlignmentFlag = Qt.AlignmentFlag.AlignLeft)`:  将给定的 widget 添加到水平布局中，可以指定拉伸因子和对齐方式。 |     *   `add_stretch(self, stretch: int)`:  向水平布局添加弹簧，用于控制 widget 之间的间距。 | *   **重要功能点:**  提供一个水平布局容器，方便在 Qt 应用程序中组织和排列 widget。
    │   │   ├── shared_battle_dialog.py    ## 摘要 |  | 该文件定义了一个 `SharedConfigDialog` 类，用于显示和管理共享的自动战斗配置。它允许用户从远程服务器下载配置，并管理本地存储的配置。 |  | **核心类和函数:** |  | *   **`SharedConfigDialog(FramelessDialog)`**:  主对话框，用于显示在线和本地配置列表，并提供下载和删除功能。 |     *   `init_ui()`: 初始化 UI 界面，包括搜索栏、在线配置表格、本地配置表格和按钮。 |     *   `load_data_from_api()`: 从 API 获取在线配置信息，并填充在线配置表格。 |     *   `populate_online_table(data: list[BattleInfo])`: 将从 API 获取的配置数据填充到在线配置表格中。 |     *   `on_download_clicked()`:  处理下载按钮点击事件，从服务器下载选定的配置。 |     *   `load_local_configs()`: 加载本地配置文件，并在本地配置表格中显示。 |     *   `delete_local_config(file_path)`:  删除本地配置文件。 |     *   `filter_table(text: str)`: 根据搜索栏的输入过滤在线配置表格。 |     *   `show_error(title: str, content: str)`: 显示错误提示对话框。 |     *   `find_project_root(start_path, marker="src")`: 查找项目根目录。 |     *   `save_downloaded_file(file_name, data, base_folder)`: 保存下载的文件。 |  | *   **`BattleInfo`**:  一个数据类，用于存储战斗配置的信息。 |  | **重要功能点:** |  | *   **在线配置列表**: 从远程服务器获取并显示可用的配置列表。 | *   **本地配置列表**: 显示本地存储的配置，并提供删除功能。 | *   **下载功能**:  允许用户下载选定的在线配置。 | *   **搜索功能**:  允许用户搜索在线配置。 | *   **错误处理**:  提供错误提示，处理网络请求和文件操作中的异常。 | *   **文件管理**:  下载和保存配置文件到本地，并提供删除本地文件的功能。
    │   │   ├── vertical_scroll_interface.py    这个 Python 文件定义了一个名为 `VerticalScrollInterface` 的类，它继承自 `BaseInterface`，用于创建具有垂直滚动功能的子页面。 |  | **主要功能:** |  | *   提供一个可垂直滚动的界面，用于显示内容。 | *   在子页面显示时进行初始化，包括布局设置。 |  | **核心类和函数:** |  | *   `VerticalScrollInterface`:  主要的类，用于创建垂直滚动的子页面。 |     *   `__init__(...)`:  初始化函数，接收内容部件、对象名称、导航文本和图标等参数。 |     *   `on_interface_shown()`:  子界面显示时调用的函数，用于初始化布局。 |     *   `_init_layout()`:  初始化布局，包括创建垂直布局、滚动区域，并将内容部件添加到滚动区域。 |     *   `get_content_widget()`:  抽象方法，由子类实现，用于提供子界面中的内容部件。 |  | **重要功能点:** |  | *   使用 `SingleDirectionScrollArea` 实现垂直滚动。 | *   在子界面显示时才进行布局初始化，提高性能。 | *   `get_content_widget()` 方法允许子类自定义内容部件。 | *   设置了内容部件和滚动区域的样式，使其背景透明，并移除边框。
    │   │   ├── welcome_dialog.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个欢迎对话框，用于在应用程序首次运行时向用户展示重要信息和操作指引。 |  | **核心类和函数:** |  | *   `WelcomeDialog`:  继承自 `MessageBoxBase`，是欢迎对话框的主类。 |     *   `__init__(self, parent=None)`: 初始化对话框，设置标题、内容和按钮。 |     *   `_setup_buttons(self)`:  创建并设置“快速开始”、“自助排障”和“开源地址”等按钮，并绑定点击事件，打开相应的 URL。 |     *   `_start_countdown(self)`:  启动一个 5 秒倒计时，用于启用“确定”按钮。 |     *   `_update_countdown(self)`:  更新“确定”按钮上的倒计时文本，并在倒计时结束后启用该按钮。 |  | **重要功能点:** |  | *   显示欢迎信息，强调软件的开源免费性质，并提醒用户注意安全。 | *   提供“快速开始”、“自助排障”和“开源地址”等按钮，方便用户获取帮助和了解项目。 | *   实现 5 秒倒计时，在倒计时结束后启用“确定”按钮，引导用户继续操作。
    │   │   ├── install_card/
    │   │   │   ├── all_install_card.py    这个 Python 文件定义了一个名为 `AllInstallCard` 的 Qt 窗口部件，用于一次性安装多个组件。 |  | **主要功能:** |  | *   提供一个“一键安装”功能，按顺序安装多个 `BaseInstallCard` 实例。 | *   提供“启动一条龙”按钮，用于启动应用程式。 |  | **核心类和函数:** |  | *   `AllInstallCard`: 继承自 `BaseInstallCard`，负责管理多个安装卡片的安装流程。 |     *   `__init__`: 初始化，接收一个 `OneDragonEnvContext` 和一个 `BaseInstallCard` 列表。 |     *   `install_all`: 启动所有安装卡片的安装流程。 |     *   `on_install_done`: 处理单个安装卡片完成的回调，启动下一个安装或更新 UI。 |     *   `_on_run_clicked`: 处理“启动一条龙”按钮的点击事件，启动应用程式。 |  | **重要功能点:** |  | *   使用 `BaseInstallCard` 的 `finished` 信号来触发安装完成的回调。 | *   按顺序安装 `install_cards` 列表中的卡片。 | *   提供安装指南的超连结。 | *   提供“启动一条龙”按钮。
    │   │   │   ├── base_install_card.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了用于安装和状态检查的自定义 Qt 界面组件，主要用于在用户界面中展示安装进度、状态信息和执行安装操作。 |  | **核心类和函数:** |  | *   **`InstallRunner(QThread)`:**  一个 QThread，用于在后台执行安装方法。 |     *   `run()`:  执行安装方法，并处理进度更新和完成信号。 |     *   `progress_callback()`:  进度回调函数，用于将进度信息传递给主线程。 | *   **`DisplayChecker(QThread)`:**  一个 QThread，用于在后台检查并获取显示内容。 |     *   `run()`: 执行获取显示内容的方法，并发送完成信号。 | *   **`BaseInstallCard(MultiPushSettingCard)`:**  继承自 `MultiPushSettingCard` 的基类，用于创建安装卡片。 |     *   `__init__()`:  初始化卡片，包括设置标题、按钮、安装运行器和显示检查器。 |     *   `start_progress()`:  启动安装进程。 |     *   `update_progress()`:  更新安装进度。 |     *   `on_progress_done()`:  安装完成后处理。 |     *   `after_progress_done()`:  安装完成后的回调函数，由子类实现。 |     *   `check_and_update_display()`:  检查并更新显示状态。 |     *   `get_display_content()`:  获取显示内容，由子类实现。 |     *   `update_display()`:  更新显示。 |  | **重要功能点:** |  | *   **多线程操作:** 使用 `QThread` 在后台执行安装和状态检查，避免阻塞 UI 线程。 | *   **进度更新:**  通过信号和槽机制，将安装进度和信息传递给 UI。 | *   **状态显示:**  支持显示安装状态，包括图标和文本。 | *   **可扩展性:**  `BaseInstallCard` 提供了抽象方法，允许子类自定义安装行为和状态显示。 | *   **用户交互:**  包含一个安装按钮，用于触发安装操作。
    │   │   │   ├── code_install_card.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | `CodeInstallCard` 是一个用于在 One Dragon 应用程序中显示和管理代码版本安装状态的 UI 卡片。它允许用户同步代码，并显示代码的当前状态，包括是否已同步、是否为最新版本以及分支信息。 |  | **核心类和函数:** |  | *   `CodeInstallCard`: 继承自 `BaseInstallCard`，负责显示代码安装状态的 UI 元素。 |     *   `__init__(self, ctx: OneDragonEnvContext, parent=None)`: 初始化卡片，设置标题、安装方法（`ctx.git_service.fetch_latest_code`）和按钮文本。 |     *   `after_progress_done(self, success: bool, msg: str) -> None`:  在代码同步完成后的回调函数，更新显示状态。 |     *   `get_display_content(self) -> Tuple[QIcon, str]`: 获取要显示的状态信息，包括图标和文本，根据 Git 状态（例如分支、是否为最新版本）进行显示。 |  | **重要功能点:** |  | *   **代码同步:** 使用 `ctx.git_service.fetch_latest_code` 同步代码。 | *   **状态显示:** 根据 Git 状态显示不同的信息，包括是否已同步、分支信息和更新提示。 | *   **国际化:** 使用 `gt` 函数进行文本的国际化。 | *   **更新提示:** 在代码更新后，提示用户需要重启脚本。 | *   **错误处理:** 针对 Git 未配置或未同步的情况，提供相应的提示。
    │   │   │   ├── git_install_card.py    这个 Python 文件定义了一个名为 `GitInstallCard` 的 Qt 窗口部件，用于处理 Git 的安装和配置。 |  | **核心类和函数:** |  | *   **`GitInstallCard(ctx: OneDragonEnvContext)`**:  继承自 `WithExistedInstallCard`，初始化 Git 安装卡片，并设置安装方法。 | *   **`get_existed_os_path() -> Optional[str]`**:  获取系统环境变量中 Git 的路径。 | *   **`on_existed_chosen(file_path: str) -> None`**:  当选择本地 Git 文件后的回调，更新环境配置。 | *   **`after_progress_done(success: bool, msg: str) -> None`**:  安装完成后的回调，更新显示状态。 | *   **`get_display_content() -> Tuple[QIcon, str]`**:  根据 Git 的安装状态，返回显示的图标和文本信息。 |  | **重要功能点:** |  | *   集成 `WithExistedInstallCard`，提供已存在安装的处理逻辑。 | *   使用 `OneDragonEnvContext` 获取环境配置和 Git 服务。 | *   根据 Git 的安装状态（未安装、文件不存在、版本获取失败、已安装）显示不同的状态信息。 | *   支持选择已存在的 Git 执行文件，并更新配置。 | *   使用 i18n 进行多语言支持。
    │   │   │   ├── python_install_card.py    这个 Python 脚本定义了一个名为 `PythonInstallCard` 的 Qt 窗口部件，用于管理和显示 Python 虚拟环境的安装状态。 |  | *   **主要功能:** 显示 Python 虚拟环境的安装状态，并提供安装选项。 | *   **核心类和函数:** |     *   `PythonInstallCard`: 继承自 `WithExistedInstallCard`，负责管理 Python 虚拟环境的显示和安装。 |     *   `__init__(self, ctx: OneDragonEnvContext)`: 初始化函数，设置标题和安装方法。 |     *   `get_existed_os_path(self) -> Optional[str]`: 获取系统环境变量中的 Python 路径。 |     *   `on_existed_chosen(self, file_path: str) -> None`: 选择本地 Python 文件后的回调函数。 |     *   `after_progress_done(self, success: bool, msg: str) -> None`: 安装完成后的回调函数。 |     *   `get_display_content(self) -> Tuple[QIcon, str]`: 根据 Python 环境状态返回显示的图标和文本。 | *   **重要功能点:** |     *   检查 Python 虚拟环境是否已安装，以及版本是否匹配。 |     *   根据 Python 环境状态显示不同的图标和提示信息。 |     *   提供选择本地 Python 文件或默认安装的选项。
    │   │   │   ├── venv_install_card.py    这个 Python 文件定义了一个名为 `VenvInstallCard` 的 Qt 界面组件，用于显示和管理 Python 虚拟环境的依赖项安装状态。 |  | *   **主要功能:** 显示虚拟环境依赖项的安装状态，并提供安装功能。 | *   **核心类:** `VenvInstallCard` 继承自 `BaseInstallCard`，负责处理依赖项安装的 UI 展示和状态更新。 | *   **重要功能点:** |     *   `__init__`: 初始化卡片，设置标题和安装方法。 |     *   `after_progress_done`: 安装完成后的回调函数，根据安装结果更新显示，并更新依赖项时间戳。 |     *   `get_display_content`: 获取要显示的状态信息，包括图标和文本，用于指示依赖项是否需要更新。
    │   │   │   └── wtih_existed_install_card.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件定义了一个 `WithExistedInstallCard` 类，用于在 OneDragon 应用程序中处理已存在安装的安装卡。它允许用户选择已安装的可执行文件，并提供相应的回调处理。 |  | **核心类和函数：** |  | *   `WithExistedInstallCard`: 继承自 `BaseInstallCard`，负责处理已存在安装的逻辑。 |     *   `__init__`: 初始化卡片，包括选择文件按钮。 |     *   `choose_existed_file`: 弹出文件选择对话框，让用户选择已安装的可执行文件。 |     *   `get_existed_os_path`: 获取系统环境变量中的路径（由子类实现）。 |     *   `on_existed_chosen`: 选择文件后的回调函数（由子类实现）。 |  | **重要功能点：** |  | *   提供一个按钮，用于选择已安装的可执行文件。 | *   使用 `QFileDialog` 让用户选择 `.exe` 文件。 | *   提供 `get_existed_os_path` 和 `on_existed_chosen` 两个抽象方法，供子类实现特定于环境的逻辑。 | *   在选择文件后，触发 `finished` 信号。
    │   │   └── setting_card/
    │   │       ├── app_run_card.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | `AppRunCard` 是一个用于在应用程式设定介面中显示和控制应用程式运行的卡片。它展示了应用程式的名称、运行状态，并提供了向上移动、运行和切换启动状态的功能。 |  | **核心类和函数:** |  | *   **`AppRunCard`**: 继承自 `MultiPushSettingCard`，负责显示应用程式的资讯和控制元件。 |     *   `__init__(self, app: Application, switch_on: bool = False, parent: Optional[QWidget] = None)`: 初始化卡片，设置应用程式、按钮和信号连接。 |     *   `update_display(self) -> None`: 更新卡片的显示，包括标题、内容和图标，反映应用程式的运行状态。 |     *   `_on_move_up_clicked(self) -> None`: 处理向上移动按钮的点击事件，发射 `move_up` 信号。 |     *   `_on_run_clicked(self) -> None`: 处理运行按钮的点击事件，发射 `run` 信号。 |     *   `_on_switch_changed(self, value: bool) -> None`: 处理开关按钮的状态变化事件，发射 `switched` 信号。 |     *   `set_app(self, app: Application)`: 更新卡片关联的应用程式，并更新显示。 |     *   `setDisabled(self, arg__1: bool) -> None`: 禁用卡片及其子元件。 |     *   `set_switch_on(self, on: bool) -> None`: 设置开关按钮的状态。 | *   **`MultiPushSettingCard`**: 来自 `one_dragon_qt.widgets.setting_card.multi_push_setting_card`，是 `AppRunCard` 的父类，提供多按钮设置卡片的基本结构。 | *   **`Application`**: 来自 `one_dragon.base.operation.application_base`，表示应用程式的基类。 | *   **`AppRunRecord`**: 来自 `one_dragon.base.operation.application_run_record`，用于记录
    │   │       ├── check_box_setting_card.py    这个 Python 文件的主要功能是创建一个带有复选框的设置卡片，用于在 Qt 应用程序中显示和修改布尔值设置。 |  | 核心类和函数： |  | *   **CheckBoxSettingCard**: 继承自 `SettingCardBase`，是主要的设置卡片类。 |     *   `__init__`: 初始化卡片，包括设置图标、标题、内容、边距和复选框。 |     *   `_on_value_changed`: 当复选框状态改变时，发射 `value_changed` 信号。 |     *   `setContent`: 覆盖父类的 `setContent` 方法，用于更新左侧的详细文本，并支持国际化。 |     *   `setValue`: 设置复选框的值。 | *   `value_changed`:  `Signal(bool)`，当复选框的值改变时发射的信号。 |  | 重要功能点： |  | *   使用 `CheckBox` 控件来显示和修改布尔值。 | *   通过信号和槽机制，将复选框的状态变化与 `value_changed` 信号连接起来，以便外部可以监听值的变化。 | *   提供 `setContent` 方法，用于更新卡片的内容，并支持国际化。 | *   提供 `setValue` 方法，用于设置复选框的状态。
    │   │       ├── combo_box_setting_card.py    **摘要:** |  | 该文件定义了 `ComboBoxSettingCard` 类，它是一个自定义的设置卡片，用于在 Qt 应用程序中显示带有下拉框的设置选项。 |  | **核心类和函数:** |  | *   **`ComboBoxSettingCard`**: 继承自 `SettingCardBase`，用于创建包含下拉框的设置卡片。 |     *   `__init__()`: 初始化卡片，包括创建 `ComboBox` 控件，设置选项，连接信号与槽。 |     *   `_initialize_options()`: 从枚举或 `ConfigItem` 列表初始化下拉框选项。 |     *   `eventFilter()`: 处理标题标签的鼠标事件，用于显示和隐藏工具提示。 |     *   `with_tooltip`: 属性，判断是否有工具提示。 |     *   `_show_tooltip()`: 显示工具提示。 |     *   `_hide_tooltip()`: 隐藏工具提示。 |     *   `set_options_by_list()`: 通过 `ConfigItem` 列表设置下拉框选项。 |     *   `init_with_adapter()`: 初始化配置适配器。 |     *   `_on_index_changed()`: 当下拉框索引改变时，更新描述并发射 `value_changed` 信号。 |     *   `_update_desc()`: 更新描述显示。 |     *   `setValue()`: 设置下拉框的值。 |     *   `getValue()`: 获取当前选中的值。 |  | **重要功能点:** |  | *   使用下拉框选择配置选项。 | *   支持从枚举或 `ConfigItem` 列表初始化下拉框选项。 | *   提供工具提示功能，用于显示选项的详细信息。 | *   通过 `YamlConfigAdapter` 与配置文件交互。 | *   当下拉框的值改变时，发射 `value_changed` 信号。 | *   支持设置和获取下拉框的值。
    │   │       ├── editable_combo_box_setting_card.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个 `EditableComboBoxSettingCard` 类，用于创建包含可编辑下拉框的设置卡片。它继承自 `SettingCardBase`，并提供了从枚举或列表初始化下拉框选项、处理工具提示、设置自动补全、响应值变化等功能。 |  | **核心类和函数:** |  | *   **`EditableComboBoxSettingCard`**:  核心类，继承自 `SettingCardBase`，用于创建可编辑下拉框设置卡片。 |     *   `__init__`: 初始化卡片，包括创建 `EditableComboBox`，设置选项，连接信号与槽。 |     *   `_initialize_options`:  从枚举或列表初始化下拉框选项。 |     *   `eventFilter`:  处理标题标签的鼠标事件，用于显示和隐藏工具提示。 |     *   `_show_tooltip`:  显示工具提示。 |     *   `_hide_tooltip`:  隐藏工具提示。 |     *   `set_options_by_list`:  通过 `ConfigItem` 列表设置下拉框选项。 |     *   `init_with_adapter`: 初始化配置适配器。 |     *   `set_completer_options`:  设置自动补全器。 |     *   `_on_index_changed`:  当下拉框索引改变时，发射 `value_changed` 信号。 |     *   `_update_desc`:  更新描述显示。 |     *   `setValue`:  设置下拉框的值。 |     *   `getValue`:  获取当前选中的值。 |  | **重要功能点:** |  | *   **可编辑下拉框**: 使用 `EditableComboBox` 组件，允许用户输入自定义值。 | *   **选项初始化**:  支持从 `Enum` 或 `List[ConfigItem]` 初始化下拉框选项。 | *   **工具提示**:  在标题上显示工具提示，提供额外信息。 | *   **自动补全**:  提供自动补全功能，方便用户选择。 | *   **值改变信号**:  `value_changed` 信号，用于通知外部值已更改。 | *   **配置适配器集成**:  与 `YamlConfigAdapter` 集成，用于配置值的存储和加载。 | *   **动态描述更新**:  根据选中的选项更新描述。
    │   │       ├── key_setting_card.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个 `KeySettingCard` 类，用于在设置界面中显示和编辑键盘按键设置。它继承自 `SettingCardBase`，并使用 `PushButton` 来触发按键监听，从而允许用户设置键盘快捷键。 |  | **核心类和函数:** |  | *   **`KeyEventWorker`**:  一个 `QObject`，用于在按键按下时发出 `key_pressed` 信号。 |     *   `on_key_press(self, key: str)`: 接收按键，并发出 `key_pressed` 信号。 | *   **`KeySettingCard`**: 继承自 `SettingCardBase`，用于显示和编辑键盘按键设置。 |     *   `__init__(...)`:  初始化 `KeySettingCard`，包括设置 UI 元素（`PushButton`），连接信号和槽，以及初始化按键监听器。 |     *   `_on_btn_clicked()`:  当按钮被点击时，启动按键监听器。 |     *   `_on_key_press(self, key)`:  当监听到按键时，停止监听器，并将按键传递给 `key_worker`。 |     *   `_on_key_signal(self, key: str)`:  接收来自 `key_worker` 的信号，设置 `value`，并使用 `YamlConfigAdapter` 保存设置。 |     *   `init_with_adapter(self, adapter: YamlConfigAdapter)`:  使用 `YamlConfigAdapter` 初始化值。 |     *   `setContent(self, content: str)`:  设置卡片内容文本，并进行国际化翻译。 |     *   `setValue(self, value: str, emit_signal: bool = True)`:  设置按键值，更新按钮文本，并发出 `value_changed` 信号。 |     *   `_stop_listener()`:  停止键盘和鼠标的监听。 |  | **重要功能点:** |  | *   **按键监听:**  使用 `PcButtonListener` 监听键盘和鼠标事件，获取按键输入。 | *   **信号和槽机制:**  使用信号和槽来处理按键事件，更新 UI 和保存设置。 | *   **配置适配器:**  使用 `
    │   │       ├── multi_push_setting_card.py    这个 Python 文件定义了两个自定义的设置卡片类，用于在 Qt 应用程序中显示带有多个按钮的设置选项。 |  | *   **主要功能:** 创建具有自定义图标、标题、内容和按钮的设置卡片，并支持多个按钮的水平或多行排列。 | *   **核心类和函数:** |     *   `MultiPushSettingCard`: 继承自 `SettingCardBase`，用于创建带有多个水平排列按钮的设置卡片。 |     *   `MultiLineSettingCard`: 继承自 `SettingCardBase`，用于创建带有多行按钮的设置卡片。 |     *   `__init__`: 两个类都重写了初始化函数，用于设置卡片的属性，包括图标、标题、内容、边距和按钮。 | *   **重要功能点:** |     *   使用 `QHBoxLayout` 和 `QVBoxLayout` 布局管理按钮的排列。 |     *   `MultiPushSettingCard` 水平排列按钮，并在右侧对齐。 |     *   `MultiLineSettingCard` 垂直排列多行按钮，每行按钮水平排列，并在右侧对齐。 |     *   `MultiLineSettingCard` 根据按钮行数调整卡片高度。
    │   │       ├── push_setting_card.py    这个 Python 文件定义了一个名为 `PushSettingCard` 的自定义设置卡片小部件，它继承自 `SettingCardBase`。 |  | *   **主要功能:** 创建一个带有推送按钮的设置卡片，用于在 UI 中显示设置信息。 | *   **核心类和函数:** |     *   `PushSettingCard`: 继承自 `SettingCardBase`，负责创建和管理带有按钮的设置卡片。 |     *   `__init__(...)`: 构造函数，初始化卡片的 UI 元素，包括图标、标题、内容和按钮。 | *   **重要功能点:** |     *   `clicked` 信号:  当按钮被点击时发射的信号。 |     *   使用 `QPushButton` 创建按钮，并将其添加到卡片的水平布局中。 |     *   将按钮的 `clicked` 信号连接到 `PushSettingCard` 的 `clicked` 信号，以便外部可以响应按钮点击事件。
    │   │       ├── setting_card_base.py    这个 Python 文件定义了一个名为 `SettingCardBase` 的自定义设置卡片小部件，它继承自 `qfluentwidgets.SettingCard`。 |  | *   **主要功能:** 创建一个可定制的设置卡片，用于在 Qt 应用程序中显示设置选项。它支持标题、内容和可选的图标。 | *   **核心类和函数:** |     *   `SettingCardBase`:  继承自 `SettingCard`，是主要的设置卡片类。 |     *   `__init__(self, icon, title, content, icon_size, margins, parent)`:  初始化设置卡片，设置布局，添加标题、内容和图标。 |     *   `setContent(self, content)`:  设置卡片的内容文本，并根据内容是否为空来设置其可见性。 |     *   `setIconSize(self, width, height)`:  设置图标的固定大小。 | *   **重要功能点:** |     *   使用 `QHBoxLayout` 和 `QVBoxLayout` 进行布局。 |     *   支持自定义图标、标题和内容。 |     *   使用 `gt` 函数进行国际化。 |     *   使用 `FluentStyleSheet.SETTING_CARD.apply(self)` 应用 Fluent UI 样式。 |     *   根据内容是否为空来控制内容标签的可见性。 |     *   提供设置图标大小的功能。
    │   │       ├── switch_setting_card.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 此文件定义了一个 `SwitchSettingCard` 类，它是一个带有切换开关的设置卡片，用于在 Qt 应用程序中显示和管理布尔值设置。它继承自 `SettingCardBase`，并集成了 `SwitchButton`。 |  | **核心类和函数:** |  | *   `SwitchSettingCard`:  继承自 `SettingCardBase`，实现了带有切换开关的设置卡片。 |     *   `__init__`: 初始化卡片，包括设置图标、标题、内容、边距，创建 `SwitchButton`，并将其添加到布局中。 |     *   `_on_value_changed`:  当切换开关的值改变时触发，更新配置适配器中的值，并发出 `value_changed` 信号。 |     *   `init_with_adapter`: 使用配置适配器初始化切换开关的值。 |     *   `setValue`: 设置切换开关的状态，并更新文本。 | *   `SettingCardBase`:  基类，提供设置卡片的基本结构。 | *   `SwitchButton`:  来自 `qfluentwidgets` 库的切换按钮。 | *   `YamlConfigAdapter`:  用于从 YAML 配置文件读取和写入设置的适配器。 |  | **重要功能点:** |  | *   使用 `SwitchButton` 实现切换开关。 | *   使用 `YamlConfigAdapter` 读取和写入设置值。 | *   `value_changed` 信号用于通知外部，切换开关的值已更改。 | *   支持自定义图标、标题、内容和边距。 | *   支持本地化文本。
    │   │       ├── text_setting_card.py    **摘要:** |  | 该文件定义了一个 `TextSettingCard` 类，用于在 Qt 界面中创建带有文本输入框的设置卡片。它继承自 `SettingCardBase`，并提供了文本输入、密码模式切换、以及与配置适配器交互的功能。 |  | **核心类和函数:** |  | *   **`TextSettingCard`**:  继承自 `SettingCardBase`，用于创建带文本输入框的设置卡片。 |     *   `__init__`: 初始化卡片，创建 `LineEdit` 输入框，并根据 `is_password` 参数设置密码模式。 |     *   `_toggle_password_visibility`: 切换密码显示模式（明文/密文）。 |     *   `_on_text_changed`:  处理文本更改事件，更新配置适配器中的值，并发出 `value_changed` 信号。 |     *   `init_with_adapter`: 使用配置适配器初始化输入框的值。 |     *   `setValue`: 设置输入框的值，并可以选择是否发出信号。 |  | **重要功能点:** |  | *   **文本输入框**:  使用 `LineEdit` 控件提供文本输入功能。 | *   **密码模式**:  通过 `is_password` 参数启用密码模式，并提供切换显示/隐藏明文的按钮。 | *   **配置适配器集成**:  与 `YamlConfigAdapter` 集成，用于保存和加载设置值。 | *   **信号**:  `value_changed` 信号，用于在文本值更改时发出通知。 | *   **可定制性**:  支持自定义图标、标题、内容、输入框占位符、最大宽度和边距。
    │   │       ├── yaml_config_adapter.py    这个 Python 文件定义了一个 `YamlConfigAdapter` 类，用于适配和操作 `YamlConfig` 实例中的特定配置字段。 |  | *   **主要功能:** 提供一个接口，用于获取和设置 `YamlConfig` 中的配置值，并支持数据类型转换。 | *   **核心类:** `YamlConfigAdapter` | *   **重要功能点:** |     *   `__init__`: 初始化 `YamlConfigAdapter` 实例，接收 `YamlConfig` 实例、字段名、默认值以及可选的 getter 和 setter 转换器。 |     *   `get_value`: 获取 `YamlConfig` 中指定字段的值，并根据 `getter_convert` 进行类型转换（`str`, `int`, `float`）。 |     *   `set_value`: 设置 `YamlConfig` 中指定字段的值，并根据 `setter_convert` 进行类型转换，然后使用 `config.update` 更新配置。
    │   │       └── yolo_model_card.py    这个 Python 文件定义了一个用于下载 YOLO 模型的自定义设置卡。 |  | **主要功能:** |  | *   提供一个下拉框，用于选择不同的 YOLO 模型。 | *   提供一个下载按钮，用于下载所选模型。 | *   显示模型下载状态。 |  | **核心类和函数:** |  | *   `DownloadRunner`:  一个 QThread，用于在后台下载模型。 |     *   `run()`:  执行模型下载，使用 `OnnxModelLoader`。 |     *   `finished`:  信号，指示下载完成并带有成功/失败状态和消息。 | *   `ModelDownloadSettingCard`:  继承自 `MultiPushSettingCard`，用于显示模型选择和下载控件。 |     *   `__init__()`:  初始化卡片，包括下拉框、下载按钮和连接信号。 |     *   `set_options_by_list()`:  使用给定的选项列表更新下拉框。 |     *   `_on_index_changed()`:  当下拉框的选中项更改时发送信号。 |     *   `setContent()`:  更新卡片的内容文本。 |     *   `setValue()`:  设置下拉框的选中值。 |     *   `getValue()`:  获取下拉框的当前选中值。 |     *   `check_and_update_display()`:  检查模型是否已下载，并更新下载按钮的状态。 |     *   `_on_download_click()`:  处理下载按钮的点击事件，启动下载线程。 |     *   `_on_download_finish()`:  处理下载完成信号，更新 UI。 |  | **重要功能点:** |  | *   使用 `QThread` 在后台执行模型下载，避免阻塞 UI。 | *   使用 `OnnxModelLoader` 进行模型下载。 | *   提供下载状态指示，包括“下载中”、“已下载”和错误消息。 | *   使用 `MultiPushSettingCard` 布局，包含下拉框和按钮。 | *   使用 `ConfigItem` 存储下拉框选项的值。
    │   ├── windows/
    │   │   ├── app_window_base.py    这个 Python 文件定义了一个名为 `AppWindowBase` 的基类，用于创建应用程序的主窗口。 |  | **主要功能:** |  | *   创建和初始化应用程序的主窗口，包括设置窗口标题、图标和大小。 | *   管理子界面的创建和显示，并在界面切换时触发初始化操作。 | *   提供添加子界面的方法。 |  | **核心类和函数:** |  | *   `AppWindowBase`: 继承自 `PhosWindow`，是主窗口的基类。 |     *   `__init__(self, win_title: str, project_config: ProjectConfig, app_icon: Optional[str] = None, parent=None)`: 初始化窗口，设置标题、图标，创建启动页面，并初始化子界面。 |     *   `create_sub_interface(self) -> None`: 虚拟函数，用于创建子界面，由子类实现。 |     *   `add_sub_interface(self, interface: BaseInterface, position=NavigationItemPosition.TOP)`: 添加子界面到导航栏。 |     *   `init_window(self)`: 初始化窗口大小和位置。 |     *   `init_interface_on_shown(self, index: int) -> None`: 在子界面显示时触发初始化操作，包括隐藏上一个界面和显示当前界面。 |  | **重要功能点:** |  | *   使用 `SplashScreen` 显示启动页面。 | *   使用 `stackedWidget` 管理子界面，并在界面切换时触发 `on_interface_hidden` 和 `on_interface_shown` 方法。 | *   提供添加子界面的方法，并设置导航栏中的位置。 | *   设置窗口的标题和图标。
    │   │   └── window.py    **摘要:** |  | 该 Python 文件定义了用于构建 One Dragon 应用程序窗口的自定义窗口部件。它基于 `qfluentwidgets` 库，并提供了 Fluent Design 风格的界面。 |  | **核心类和函数:** |  | *   **`PhosFluentWindowBase`**:  一个基类，继承自 `BackgroundAnimationWidget` 和 `FramelessWindow`，用于提供窗口的基础功能。 | *   **`PhosWindow`**:  主窗口类，继承自 `MSFluentWindow` 和 `PhosFluentWindowBase`。它负责窗口的整体布局，包括导航栏 (`PhosNavigationBar`)、堆叠部件 (`PhosStackedWidget`) 和标题栏 (`PhosTitleBar`)。 |     *   `setAeroEffectEnabled(self, isEnabled: bool)`:  控制 Aero 磨砂效果的启用和禁用。 |     *   `_onThemeChangedFinished(self)`:  响应主题变化，更新 Aero 效果。 |     *   `resizeEvent(self, e)`:  重写调整大小事件，调整标题栏的位置和大小。 | *   **`PhosNavigationBar`**:  自定义导航栏，继承自 `NavigationBar`。它包含导航项，并管理路由切换。 |     *   `insertItem(...)`:  插入导航项。 |     *   `_onWidgetClicked(self)`:  处理导航按钮的点击事件，进行路由切换。 | *   **`PhosNavigationBarPushButton`**:  自定义导航按钮，继承自 `NavigationBarPushButton`。它定义了按钮的样式和外观，包括图标、文本和背景颜色。 |     *   `paintEvent(self, event)`:  重写绘制事件，自定义按钮的绘制。 |     *   `_get_bg_color(self)`: 获取自适应主题的背景颜色 |     *   `_get_icon_color(self)`: 获取图标颜色(含选中状态处理) |     *   `_get_text_color(self)`: 获取文本颜色 |     *   `setSelected(self, isSelected)`: 更新选中状态 | *   **`PhosTitleBar`**:  自定义标题栏，继承自 `SplitTitleBar`。它包含窗口图标、标题、版本信息和反馈按钮。 |     *   `setIcon(self, icon: QIcon)`:  设置
    │   └── _rc/
    │       └── resource.py    ## 摘要 |  | **1. 文件主要功能:** |  | 这个 Python 文件定义了 Qt 资源，包含 CSS 样式表和二进制数据，用于设定应用程式的 UI 外观。它使用 PySide6 库来管理和注册这些资源。 |  | **2. 核心类和函数:** |  | *   **`qInitResources()`**:  初始化资源，将 CSS 样式表和二进制数据注册到 Qt 资源系统中。 | *   **`qCleanupResources()`**: 清理资源，从 Qt 资源系统中取消注册。 | *   **`qt_resource_data`**:  包含 CSS 样式表的二进制数据。 | *   **`qt_resource_name`**: 包含资源名称的二进制数据。 | *   **`qt_resource_struct`**: 包含资源结构的二进制数据。 |  | **3. 重要功能点:** |  | *   **CSS 样式表:**  定义了多个 UI 元素的样式，例如标题、日期、列表、堆叠部件、错误提示、导航界面、按钮等。 样式表包含浅色和深色两种主题。 | *   **资源管理:** 使用 `QtCore.qRegisterResourceData` 和 `QtCore.qUnregisterResourceData` 函数来管理 Qt 资源。 | *   **UI 外观定制:**  通过 CSS 样式表，可以定制应用程式的 UI 外观，包括颜色、字体、边框、背景等。 | *   **主题切换:** 包含浅色和深色两种主题的样式，可能用于支持应用程序的主题切换功能。
    ├── onnxocr/
    │   ├── cls_postprocess.py    这个 Python 文件 `cls_postprocess.py` 实现了一个用于文本分类的后处理类 `ClsPostProcess`。 |  | *   **主要功能:** 将分类模型的预测结果转换为可读的文本标签，并可选择与真实标签进行比较。 | *   **核心类和函数:** |     *   `ClsPostProcess`: 类，用于执行分类后处理。 |     *   `__init__`: 初始化函数，接收标签列表和可选的 key。 |     *   `__call__`: 核心函数，接收模型的预测结果，将其转换为文本标签，并可选地与真实标签进行比较。 | *   **重要功能点:** |     *   使用 `argmax` 找到每个预测的最高概率标签的索引。 |     *   使用 `label_list` 将索引转换为文本标签。 |     *   如果提供了真实标签，则返回预测结果和真实标签。
    │   ├── db_postprocess.py    ## 摘要 |  | 该 Python 文件定义了用于 DB (Differentiable Binarization) 后处理的类，主要用于文本检测任务。 |  | **核心类和函数:** |  | *   **DBPostProcess:**  执行 DB 模型的后处理，包括： |     *   `__init__`: 初始化后处理参数，如阈值、框阈值、unclip 比例等。 |     *   `polygons_from_bitmap`: 从二值化图像中提取多边形框。 |     *   `boxes_from_bitmap`: 从二值化图像中提取矩形框。 |     *   `unclip`:  对框进行扩张操作。 |     *   `get_mini_boxes`:  获取最小外接矩形框。 |     *   `box_score_fast`:  快速计算框的置信度分数。 |     *   `box_score_slow`:  慢速计算框的置信度分数。 |     *   `__call__`:  执行整个后处理流程，从模型输出中提取文本框。 | *   **DistillationDBPostProcess:**  用于蒸馏场景的 DB 后处理，它包装了 DBPostProcess，并处理多个模型的输出。 |  | **重要功能点:** |  | *   从模型输出（二值化图）中提取文本框。 | *   支持多边形框和矩形框的提取。 | *   使用 unclip 操作扩张文本框。 | *   计算框的置信度分数。 | *   支持蒸馏场景，处理多个模型的输出。
    │   ├── imaug.py    这个 Python 文件 `imaug.py` 实现了图像增强（augmentation）的功能，主要用于 OCR 领域。 |  | *   **主要功能:** 提供图像转换和操作符创建的工具，用于图像预处理和数据增强。 | *   **核心类和函数:** |     *   `transform(data, ops=None)`: 应用一系列操作符 `ops` 到输入数据 `data` 上。 |     *   `create_operators(op_param_list, global_config=None)`: 根据配置列表 `op_param_list` 创建一系列操作符。 | *   **重要功能点:** |     *   使用 `onnxocr.operators` 模块中的操作符。 |     *   `transform` 函数支持链式操作，允许将多个图像处理操作串联起来。 |     *   `create_operators` 函数动态创建操作符，并支持全局配置。 |     *   通过 `eval` 函数根据字符串名称实例化操作符，增加了配置的灵活性。
    │   ├── logger.py    这个 Python 文件 `logger.py` 实现了一个自定义的日志记录器。 |  | *   **主要功能:** 提供一个全局的日志记录器，用于记录程序运行时的调试信息和错误信息。 | *   **核心类和函数:** |     *   `Logger` 类：初始化和配置日志记录器。 |     *   `initLogger()` 方法：配置日志记录器的格式、输出目标（控制台和文件）。 |     *   `GetLog()` 函数：返回全局的日志记录器实例。 | *   **重要功能点:** |     *   使用 `logging` 模块创建和配置日志记录器。 |     *   日志输出到控制台和文件 (目前文件输出被注释掉)。 |     *   定义了日志的格式，包括级别、时间、消息、文件、函数、行号和线程信息。 |     *   提供一个全局的 `LOG` 实例，方便在其他模块中使用。
    │   ├── onnx_paddleocr.py    代码摘要： |  | 该Python文件定义了一个基于ONNX的PaddleOCR文本识别系统，并提供了OCR功能。 |  | *   **主要功能:** |     *   使用ONNX模型进行文本检测、识别和分类。 |     *   提供 `ocr` 函数，用于对图像进行OCR处理，支持检测、识别和分类的组合。 |     *   提供 `sav2Img` 函数，用于将OCR结果绘制到图像上并保存。 |     *   包含一个 `ONNXPaddleOcr` 类，用于初始化模型并执行OCR。 | *   **核心类和函数:** |     *   `ONNXPaddleOcr` 类: 继承自 `TextSystem`，用于初始化模型和执行OCR。 |         *   `__init__`: 初始化模型，加载参数。 |         *   `ocr`: 执行OCR，根据参数选择是否进行检测、识别和分类。 |     *   `sav2Img` 函数: 将OCR结果绘制到图像上并保存。 | *   **重要功能点:** |     *   支持自定义模型路径、是否使用GPU等参数。 |     *   `ocr` 函数根据参数灵活控制OCR流程。 |     *   提供示例代码，演示如何使用 `ONNXPaddleOcr` 类进行OCR。 |     *   使用 `draw_ocr` 函数将结果可视化。
    │   ├── operators.py    此 Python 文件定义了用于图像预处理的自定义操作符，主要用于 OCR 任务。 |  | *   **主要功能:** 实现图像的归一化、调整大小和通道顺序转换，以及选择性地保留数据中的特定键。 | *   **核心类和函数:** |     *   `NormalizeImage`: 归一化图像，包括缩放、减去均值和除以标准差。 |     *   `DetResizeForTest`: 调整图像大小，支持多种调整大小类型，包括保持比例。 |         *   `resize_image_type0`: 调整图像大小，使图像的边长是 32 的倍数。 |         *   `resize_image_type1`: 调整图像大小，保持比例。 |         *   `resize_image_type2`: 调整图像大小，根据长边进行调整。 |     *   `ToCHWImage`: 将图像的通道顺序从 HWC 转换为 CHW。 |     *   `KeepKeys`: 保留数据字典中指定的键。 | *   **重要功能点:** |     *   支持不同的调整大小策略，包括保持比例和调整到特定尺寸。 |     *   `DetResizeForTest` 类中的调整大小操作会计算图像的缩放比例，并将其储存在 `data['shape']` 中。 |     *   `NormalizeImage` 类使用预定义的均值和标准差进行归一化。 |     *   `ToCHWImage` 类用于将图像的通道顺序转换为模型所需的格式。
    │   ├── predict_base.py    这个 Python 文件 `predict_base.py` 定义了一个基类 `PredictBase`，用于使用 ONNX Runtime 进行模型预测。 |  | *   **主要功能:** 提供基础功能，用于加载 ONNX 模型、获取输入/输出名称，以及构建输入 feed。 | *   **核心类:** `PredictBase` | *   **核心函数:** |     *   `get_onnx_session(self, model_dir, use_gpu)`: 根据 `use_gpu` 参数选择 CPU 或 GPU 执行提供者，并加载 ONNX 模型。 |     *   `get_output_name(self, onnx_session)`: 获取 ONNX 模型的所有输出名称。 |     *   `get_input_name(self, onnx_session)`: 获取 ONNX 模型的所有输入名称。 |     *   `get_input_feed(self, input_name, image_numpy)`: 构建用于模型推理的输入 feed 字典。 | *   **重要功能点:** |     *   支持 GPU 和 CPU 执行。 |     *   获取模型的输入和输出名称，为后续推理做准备。 |     *   构建输入 feed，将图像数据与输入名称关联起来。
    │   ├── predict_cls.py    这个 Python 文件定义了一个 `TextClassifier` 类，用于使用 ONNX 模型对文本图像进行分类，主要用于文字方向校正。 |  | **核心类和函数:** |  | *   **`TextClassifier(PredictBase)`**: 继承自 `PredictBase`，负责文本图像的分类。 |     *   `__init__(self, args)`: 初始化分类器，包括模型路径、图像形状、批次大小、置信度阈值和后处理操作。 |     *   `resize_norm_img(self, img)`: 调整图像大小并进行归一化处理，以符合模型的输入要求。 |     *   `__call__(self, img_list)`: 核心函数，接收图像列表，对图像进行预处理，使用 ONNX 模型进行预测，并进行后处理以获取分类结果。它还根据分类结果旋转图像。 |  | **重要功能点:** |  | *   **图像预处理**: 调整图像大小、归一化和填充，以符合模型的输入形状。 | *   **ONNX 模型推理**: 使用 ONNX 运行时加载和执行分类模型。 | *   **后处理**: 使用 `ClsPostProcess` 类处理模型的输出，获取文本方向的预测结果。 | *   **图像旋转**: 如果预测到文本方向为 180 度，则旋转图像。 | *   **批次处理**: 为了提高效率，对图像进行批次处理。 | *   **排序优化**: 根据图像的宽高比对图像进行排序，以加速分类过程。
    │   ├── predict_det.py    这个 Python 脚本定义了一个文本检测器，它使用 ONNX 模型来检测图像中的文本区域。 |  | **主要功能：** |  | *   文本检测：使用 ONNX 模型预测图像中的文本框。 | *   预处理和后处理：对图像进行预处理，并对模型输出进行后处理以提取文本框。 | *   边界框过滤：过滤掉过小或超出图像边界的边界框。 |  | **核心类和函数：** |  | *   `TextDetector(PredictBase)`：继承自 `PredictBase`，用于初始化模型、预处理和后处理操作，以及执行文本检测。 |     *   `__init__(self, args)`：初始化检测器，包括加载模型、设置预处理和后处理操作。 |     *   `__call__(self, img)`：对输入图像执行文本检测，返回检测到的文本框。 |     *   `order_points_clockwise(self, pts)`：将边界框的点按顺时针排序。 |     *   `clip_det_res(self, points, img_height, img_width)`：将边界框的点裁剪到图像边界内。 |     *   `filter_tag_det_res(self, dt_boxes, image_shape)`：过滤掉过小或不合理的边界框。 |     *   `filter_tag_det_res_only_clip(self, dt_boxes, image_shape)`：仅裁剪边界框到图像边界内。 |  | **重要功能点：** |  | *   使用 `onnxruntime` 运行 ONNX 模型。 | *   使用 `transform` 和 `create_operators` 进行图像预处理。 | *   使用 `DBPostProcess` 进行后处理，提取文本框。 | *   支持多种边界框类型（'poly'）。 | *   边界框过滤，以提高检测质量。
    │   ├── predict_rec.py    ## 摘要 |  | 该 Python 脚本定义了一个 `TextRecognizer` 类，用于使用 ONNX 模型进行文本识别。它继承自 `PredictBase` 类，并使用不同的图像预处理方法，具体取决于所使用的识别算法。 |  | **核心类和函数:** |  | *   **`TextRecognizer(PredictBase)`**: 文本识别器类，初始化模型、图像形状、批次大小和后处理操作。 |     *   `__init__(self, args)`: 初始化 TextRecognizer，加载模型，设置参数。 |     *   `resize_norm_img(self, img, max_wh_ratio)`: 根据不同的识别算法，对图像进行调整大小和归一化处理。 |     *   `__call__(self, img_list)`: 核心函数，接收图像列表，预处理图像，使用 ONNX 模型进行预测，并使用后处理操作解码结果。 |     *   `resize_norm_img_vl(self, img, image_shape)`: 图像预处理函数，用于 ViL 算法。 |     *   `resize_norm_img_srn(self, img, image_shape)`: 图像预处理函数，用于 SRN 算法。 |     *   `srn_other_inputs(self, image_shape, num_heads, max_text_length)`: SRN 算法的辅助输入生成。 |     *   `process_image_srn(self, img, image_shape, num_heads, max_text_length)`: SRN 算法的图像处理流程。 |     *   `resize_norm_img_sar(self, img, image_shape, width_downsample_ratio=0.25)`: 图像预处理函数，用于 SAR 算法。 |     *   `resize_norm_img_spin(self, img)`: 图像预处理函数，用于 SPIN 算法。 |     *   `resize_norm_img_svtr(self, img, image_shape)`: 图像预处理函数，用于 SVTR 算法。 |     *   `resize_norm_img_abinet(self, img, image_shape)`: 图像预处理函数，用于 ABINet 算法。 |     *
    │   ├── predict_system.py    这个 Python 脚本 `predict_system.py` 实现了一个文本检测和识别系统。 |  | *   **主要功能:** 整合文本检测、方向分类（可选）和文本识别，用于从图像中提取文本。 | *   **核心类和函数:** |     *   `TextSystem`: 系统的主类，初始化文本检测器、文本识别器和（可选）文本分类器。`__call__` 方法执行整个流程，包括检测、裁剪、分类（如果启用）和识别。 |     *   `sorted_boxes`: 对检测到的文本框进行排序，从上到下，从左到右。 | *   **重要功能点:** |     *   使用 `TextDetector` 检测文本框。 |     *   使用 `get_rotate_crop_image` 或 `get_minarea_rect_crop` 裁剪文本区域。 |     *   可选地使用 `TextClassifier` 进行方向分类。 |     *   使用 `TextRecognizer` 识别文本。 |     *   根据 `drop_score` 筛选结果。 |     *   `draw_crop_rec_res` 函数用于保存裁剪后的图像。
    │   ├── readme.md    这个文件的摘要如下： |  | **主要功能：** |  | *   说明文件，描述了 OnnxOCR 专案的相关资讯。 |  | **核心类和函数：** |  | *   无程式码，只有说明文字。 |  | **重要功能点：** |  | *   说明文件指出专案是从 GitHub 上的 OnnxOCR 专案复制而来。 | *   更新时间为 2024.08.08。 | *   说明了将模型、字体和文本放置在 `assets/models/onnx_ocr` 目录中的变更。
    │   ├── rec_postprocess.py    这个 Python 脚本定义了多个用于光学字符识别 (OCR) 后处理的类，主要功能是将模型预测的索引转换为文本标签。 |  | 核心类和函数： |  | *   **BaseRecLabelDecode**: 基础类，定义了字符字典的初始化、特殊字符的添加、以及将索引解码为文本的基本方法 `decode`。 | *   **CTCLabelDecode**: 继承自 `BaseRecLabelDecode`，专门用于 CTC (Connectionist Temporal Classification) 模型，处理 CTC 模型的输出，并移除重复字符。 | *   **DistillationCTCLabelDecode**: 继承自 `CTCLabelDecode`，用于蒸馏训练，处理多个模型的输出。 | *   **AttnLabelDecode**: 继承自 `BaseRecLabelDecode`，用于 Attention 模型，处理 Attention 模型的输出，包含开始和结束标记。 | *   **RFLLabelDecode**: 继承自 `BaseRecLabelDecode`，用于 RFL 模型，处理 RFL 模型的输出。 | *   **SEEDLabelDecode**: 继承自 `BaseRecLabelDecode`，用于 SEED 模型，处理 SEED 模型的输出。 | *   **SRNLabelDecode**: 继承自 `BaseRecLabelDecode`，用于 SRN 模型，处理 SRN 模型的输出。 | *   **SARLabelDecode**: 继承自 `BaseRecLabelDecode`，用于 SAR 模型，处理 SAR 模型的输出，包含特殊字符处理和可选的符号移除。 | *   **DistillationSARLabelDecode**: 继承自 `SARLabelDecode`，用于蒸馏训练，处理多个模型的输出。 | *   **PRENLabelDecode**: 继承自 `BaseRecLabelDecode`，用于 PREN 模型，处理 PREN 模型的输出。 | *   **NRTRLabelDecode**: 继承自 `BaseRecLabelDecode`，用于 NRTR 模型，处理 NRTR 模型的输出。 | *   **ViTSTRLabelDecode**: 继承自 `NRTRLabelDecode`，用于 ViTSTR 模型，处理 ViTSTR 模型的输出。 | *   **ABINetLabelDecode**: 继承自 `NRTRLabelDecode`，用于 ABINet 模型，处理 ABINet 模型的输出。 | *   **SP
    │   └── utils.py    **摘要:** |  | 该 Python 脚本 `utils.py` 提供了用于 OCR 任务的实用函数，包括图像处理、文本可视化和参数解析。 |  | **核心类和函数:** |  | *   `get_rotate_crop_image(img, points)`: 根据给定的四边形坐标，从图像中裁剪并旋转校正文本区域。 | *   `get_minarea_rect_crop(img, points)`: 使用最小外接矩形裁剪图像。 | *   `resize_img(img, input_size=600)`: 调整图像大小，限制最长边长。 | *   `str_count(s)`: 计算字符串中中文字符的数量。 | *   `text_visual(texts, scores, img_h=400, img_w=600, threshold=0., font_path="./onnx/fonts/simfang.ttf")`: 创建空白图像，并在其上绘制文本和分数。 | *   `draw_ocr(image, boxes, txts=None, scores=None, drop_score=0.5, font_path="./onnxocr/fonts/simfang.ttf")`: 视觉化 OCR 结果，在图像上绘制边框和文本。 | *   `base64_to_cv2(b64str)`: 将 base64 编码的字符串转换为 OpenCV 图像。 | *   `str2bool(v)`: 将字符串转换为布尔值。 | *   `infer_args()`: 使用 `argparse` 创建并返回一个参数解析器，用于配置 OCR 推理。 |  | **重要功能点:** |  | *   图像裁剪和旋转校正，用于处理倾斜的文本。 | *   文本可视化，用于显示 OCR 检测和识别结果。 | *   参数解析，用于配置 OCR 模型的推理。 | *   提供图像大小调整功能。 | *   提供将 base64 编码的字符串转换为 OpenCV 图像的功能。
    └── zzz_od/
        ├── action_recorder/
        │   ├── monitor.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件实现了用于记录游戏战斗过程中的动作和状态的模块，主要用于自动战斗的录制和分析。它集成了键盘、鼠标事件的监听，以及游戏内状态的识别，如角色信息、闪避、连携技等，并将这些信息保存到文件中。 |  | **核心类和函数:** |  | *   **`BattleAgentContext4Recording`**: 继承自 `AutoBattleAgentContext`，重写了 `init_battle_agent_context` 和 `check_agent_related` 方法，用于识别和记录战斗中角色相关信息。 | *   **`BattleDodgeContext4Recording`**: 继承自 `AutoBattleDodgeContext`，重写了 `init_battle_dodge_context` 和 `check_dodge_flash` 方法，用于识别和记录闪避相关信息。 | *   **`BattleContext4Recording`**: 继承自 `AutoBattleContext`，用于整合角色信息、闪避信息，并提供 `check_battle_state` 方法作为战斗状态的总入口。 | *   **`PcButtonListener`**: 监听键盘和鼠标事件，记录用户操作。 | *   **`RecordContext`**:  核心类，负责初始化战斗上下文、启动录制、收集状态和动作数据，并将数据输出到文件。 | *   **`_debug()`**:  用于调试的函数，初始化上下文，启动录制，并输出记录。 | *   **`records_status_and_action()`**: 核心函数，循环获取游戏截图，识别战斗状态，记录动作和状态数据。 | *   **`output_records()`**: 将录制的数据（键盘、鼠标动作，以及战斗状态）保存到文件中。 |  | **重要功能点:** |  | *   **动作记录**: 监听键盘和鼠标事件，记录用户操作的时间戳和事件类型。 | *   **状态识别**:  使用 `BattleContext4Recording` 识别游戏内的战斗状态，包括角色信息、闪避、连携技、快速支援等。 | *   **异步处理**: 使用 `ThreadPoolExecutor` 并行处理状态识别任务，提高效率。 | *   **数据输出**: 将录制的数据保存为 pickle 文件，方便后续分析。 | *   **战斗流程控制**:  通过 `is_normal_attack_btn
        │   └── template_generator.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 脚本用于从录制的键盘、鼠标和游戏状态数据中生成自动战斗的 YAML 模板。它通过预处理数据、使用 Word2Vec 模型进行聚类分析，并结合特殊状态识别，最终生成可用于自动战斗的 YAML 配置文件。 |  | **核心类和函数:** |  | *   **`ImportantOperation(Enum)`**: 定义了游戏中重要的操作，如鼠标点击、键盘按键、闪避状态等，以及它们之间的映射关系。 | *   **`PreProcessor`**: |     *   `__init__`: 从文件中加载键盘、鼠标和状态数据。 |     *   `keyboard_pre_process`: 预处理键盘按键数据，识别长按和短按。 |     *   `mouse_pre_process`: 预处理鼠标按键数据，识别长按和短按。 |     *   `status_pre_process`: 预处理游戏状态数据，提取关键状态信息。 |     *   `_merge_status_and_ops`: 将状态和操作合并，并根据状态优先级更新操作。 |     *   `_drop_duplicates`: 去除重复的操作。 |     *   `pre_process`: 整合所有预处理步骤，生成合并后的状态和操作列表。 | *   **`SelfAdaptiveGenerator`**: |     *   `__init__`: 初始化，接收预处理后的数据。 |     *   `_groupby_agents`: 按角色分组操作。 |     *   `_prepare_sentences`: 准备用于 Word2Vec 模型训练的句子。 |     *   `_word2vec`: 使用 Gensim 的 Word2Vec 模型训练词向量。 |     *   `_estimate_cluster`: 对操作进行聚类，生成动作模板。 |     *   `_get_special_status_freq`: 获取特定状态下对应的动作频率。 |     *   `_get_switch_habit`: 获取换人习惯。 |     *   `get_templates`: 生成动作模板和特殊状态信息。 |     *   `_reserved_states`: 保留特定状态动作。 |     *   `_not_reserved_states`: 不保留特定状态动作。 |     *   `_default_setting`: 设置默认配置。 |     *   `_generate_dodge_template`: 生成
        ├── application/
        │   ├── zzz_application.py    这个 Python 文件定义了一个名为 `ZApplication` 的类，它继承自 `Application` 类，用于处理与游戏相关的操作。 |  | **主要功能:** |  | *   管理游戏应用程序的生命周期，包括启动、运行和停止。 | *   处理游戏进入流程，并在需要时进行重试。 | *   提供上下文管理和回调功能。 |  | **核心类和函数:** |  | *   `ZApplication`: 继承自 `Application`，是应用程序的主要类。 |     *   `__init__`: 初始化 `ZApplication` 实例，包括上下文、应用程序 ID、重试次数、超时时间、回调函数等。它还初始化了 `OpenAndEnterGame` 操作。 |     *   `handle_resume`: 恢复应用程序的操作，激活窗口并调用父类的 `handle_resume` 方法。 | *   `OpenAndEnterGame`: 是一个操作类，用于打开并进入游戏。 (从初始化中推断) | *   `Application`:  基类，提供应用程序的基本功能。 (继承自) | *   `ZContext`:  上下文类，提供应用程序的上下文信息。 (参数) |  | **重要功能点:** |  | *   初始化时使用 `OpenAndEnterGame` 类来处理游戏进入流程。 | *   `handle_resume` 方法用于恢复应用程序，激活窗口并调用父类的恢复方法。 | *   支持配置重试次数、超时时间和回调函数。 | *   `init_context_before_start` 和 `stop_context_after_stop` 标志控制上下文的初始化和停止。 | *   `need_ocr` 和 `retry_in_od` 标志控制 OCR 和 OD 内的重试行为。
        │   ├── zzz_one_dragon_app.py    这个 Python 文件定义了 `ZOneDragonApp` 类，它是一个整合了多个子应用程序的总应用程序，用于执行与游戏相关的任务。 |  | **主要功能:** |  | *   整合并管理多个子应用程序，例如兑换码、随机游戏、刮刮卡等。 | *   初始化上下文环境，包括配置加载、OCR 初始化和代理更新。 | *   根据配置执行自动更新。 | *   执行所有子应用程序。 | *   在完成后根据配置执行关机或关闭游戏。 |  | **核心类和函数:** |  | *   `ZOneDragonApp`: 继承自 `OneDragonApp` 和 `ZApplication`，是主应用程序类。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用程序，包括应用程序 ID 和进入游戏/切换账号的操作。 |     *   `get_app_list(self) -> List[ZApplication]`: 返回一个包含所有子应用程序实例的列表。 | *   `ZContext`: 应用程序的上下文，包含环境配置、OCR 服务、Git 服务等。 | *   `OpenAndEnterGame`: 进入游戏的操作。 | *   `SwitchAccount`: 切换账号的操作。 | *   `__debug()`: 测试函数，用于初始化上下文、执行应用程序和处理完成后的动作。 |  | **重要功能点:** |  | *   **应用程序整合:**  `ZOneDragonApp` 将多个子应用程序（如 `RedemptionCodeApp`, `RandomPlayApp` 等）组合在一起，提供一个统一的入口点。 | *   **上下文管理:** 使用 `ZContext` 管理应用程序的环境配置、资源和服务。 | *   **自动更新:** 根据配置，可以自动从 Git 获取最新代码。 | *   **完成后操作:** 根据配置，在应用程序完成后可以关机或关闭游戏。 | *   **测试入口:** `__debug()` 函数提供了一个方便的测试和调试入口。
        │   ├── battle_assistant/
        │   │   ├── auto_battle_app.py    这个 Python 文件定义了一个名为 `AutoBattleApp` 的应用程式，用于自动化游戏中的战斗。 |  | **主要功能:** |  | *   自动化游戏战斗流程，包括手柄检测、加载战斗指令、画面识别和执行操作。 |  | **核心类和函数:** |  | *   `AutoBattleApp`: 继承自 `ZApplication`，是自动战斗应用程式的主类。 |     *   `__init__`: 初始化应用程式，设置应用程式 ID、名称和是否需要 OCR。 |     *   `handle_init`: 初始化函数，由子类实现。 |     *   `check_gamepad`: 检测手柄类型并启用相应的控制器。 |     *   `load_op`: 加载自动战斗指令，并启动 `AutoBattleOperator`。 |     *   `check_screen`: 截取萤幕画面，并由 `AutoBattleOperator` 处理战斗状态。 |     *   `_on_pause`: 暂停时停止自动战斗。 |     *   `_on_resume`: 恢复时恢复自动战斗。 |     *   `after_operation_done`: 在操作完成后清理资源。 |  | **重要功能点:** |  | *   手柄检测和控制器启用。 | *   加载和启动 `AutoBattleOperator`，用于执行自动战斗逻辑。 | *   周期性地截取萤幕画面，并根据画面状态执行操作。 | *   处理应用程式的暂停和恢复事件，以控制自动战斗的运行状态。
        │   │   ├── auto_battle_config.py    这个 Python 文件定义了用于自动战斗配置的功能。 |  | *   **主要功能:** 加载、获取和管理自动战斗指令的配置信息。 | *   **核心类和函数:** |     *   `get_auto_battle_op_config_list(sub_dir: str)`: 获取用于配置页面显示的指令列表。 |     *   `get_all_auto_battle_op(sub_dir: str)`: 加载所有自动战斗指令，从配置文件中读取。 |     *   `get_auto_battle_op_by_name(sub_dir: str, template_name: str)`: 根据名称获取特定的自动战斗指令。 |     *   `get_auto_battle_config_file_path(sub_dir: str, template_name: str)`: 获取自动战斗配置文件的路径。 | *   **重要功能点:** |     *   从指定目录下的 `.yml` 文件中加载自动战斗指令配置。 |     *   使用 `ConditionalOperator` 类来表示自动战斗指令。 |     *   提供按名称获取特定指令的功能。 |     *   提供获取配置文件路径的功能。
        │   │   ├── auto_battle_debug_app.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AutoBattleDebugApp` 类，用于调试自动战斗功能。它继承自 `ZApplication`，并实现了自动战斗的初始化、手柄检测、战斗指令加载和画面识别等功能。 |  | **核心类和函数:** |  | *   **`AutoBattleDebugApp(ZContext)`**:  `ZApplication` 的子类，负责自动战斗调试。 |     *   `check_gamepad()`:  检测手柄类型并启用相应的控制器。 |     *   `load_op()`:  加载自动战斗指令。 |     *   `check_screen()`:  识别当前画面并执行相应的操作。 |     *   `_on_pause(e=None)`: 暂停时停止自动战斗。 |     *   `_on_resume(e=None)`: 恢复时继续自动战斗。 |     *   `after_operation_done(result: OperationResult)`:  在操作完成后清理资源。 |  | **重要功能点:** |  | *   手柄检测和控制器初始化。 | *   加载自动战斗指令，并触发 `AutoBattleApp.EVENT_OP_LOADED` 事件。 | *   画面识别，调用 `auto_battle_context.check_battle_state` 进行状态检查，并执行相关操作。 | *   支持暂停和恢复自动战斗。 | *   在操作完成后清理自动战斗操作符。
        │   │   ├── battle_assistant_config.py    这个 Python 文件的主要功能是定义和管理战斗助手 (Battle Assistant) 的配置。 |  | *   **核心类:** `BattleAssistantConfig` 继承自 `YamlConfig`，用于从 YAML 文件中加载和保存战斗助手的配置。 | *   **重要功能点:** |     *   提供多个 `@property` 装饰器，用于获取和设置战斗助手的配置选项，例如闪避配置、是否使用 GPU、截图间隔、手柄类型、自动战斗配置、调试操作配置以及调试操作重复。 |     *   使用 `YamlConfig` 的 `get` 方法从配置文件中读取配置值，并使用 `update` 方法更新配置值。 |     *   使用 `GamepadTypeEnum` 枚举定义手柄类型。
        │   │   ├── dodge_assistant_app.py    **摘要:** |  | 该文件定义了 `DodgeAssistantApp` 类，它是一个用于在游戏中执行闪避操作的应用程序。它基于 `ZApplication` 类，并使用自动战斗逻辑。 |  | **核心类和函数:** |  | *   **`DodgeAssistantApp(ZContext)`:**  主类，负责闪避助手的初始化和运行。 |     *   `check_gamepad()`: 检查并启用游戏手柄。 |     *   `load_op()`: 加载自动战斗指令，特别是与闪避相关的指令。 |     *   `check_dodge()`:  截取屏幕截图，并根据自动战斗逻辑判断是否需要闪避。 |     *   `_on_pause(e=None)`: 暂停时停止自动战斗。 |     *   `_on_resume(e=None)`: 恢复时继续自动战斗。 |  | **重要功能点:** |  | *   **手柄检测:**  根据配置检测并启用游戏手柄（Xbox 或 DS4）或键盘。 | *   **自动战斗指令加载:**  加载与闪避相关的自动战斗操作。 | *   **闪避判断:**  根据游戏画面和自动战斗逻辑，判断是否需要执行闪避操作。 | *   **暂停/恢复功能:**  在应用程序暂停和恢复时，正确地停止和启动自动战斗。
        │   │   ├── log_app.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 这个文件定义了一个名为 `LogTestApp` 的应用程式，用于测试在战斗中记录日志的功能。它模拟了通过发送移动按钮事件来触发日志记录。 |  | **核心类和函数:** |  | *   `LogTestApp`: 继承自 `ZApplication`，是主要的应用程式类。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用程式，设置应用程式 ID、名称，并禁用游戏胜利检查。 |     *   `add_edges_and_nodes(self) -> None`: 添加操作节点，这里添加了一个用于打印日志的节点。 |     *   `log(self) -> OperationRoundResult`: 模拟发送移动按钮事件（W、S、A、D），并等待一小段时间。 |  | **重要功能点:** |  | *   模拟了战斗中的按钮事件，用于测试日志记录。 | *   使用了 `OperationNode` 和 `OperationRoundResult` 类，表明它与战斗流程中的操作相关。 | *   `check_game_win=False` 表明此应用程式不关心游戏的胜负状态，专注于日志记录。
        │   │   ├── operation_debug_app.py    **摘要:** |  | 该文件定义了 `OperationDebugApp` 类，用于调试自动战斗指令。它继承自 `ZApplication`，并提供了一系列方法来加载、执行和调试战斗操作。 |  | **核心类和函数:** |  | *   **`OperationDebugApp(ctx: ZContext)`**:  构造函数，初始化应用，设置应用ID、名称和是否需要OCR。 | *   **`add_edges_and_nodes()`**:  定义了应用的状态转换流程，包括手柄检测、加载指令、初始化上下文和执行指令。 | *   **`check_gamepad()`**:  检测手柄类型并启用相应的控制器。 | *   **`load_op()`**:  加载指定的自动战斗指令模板。 | *   **`init_context()`**:  初始化上下文。 | *   **`run_operations()`**:  执行加载的战斗指令，并支持循环执行。 |  | **重要功能点:** |  | *   **手柄检测和控制**:  根据配置检测并启用不同的手柄类型（键盘、Xbox、DS4）。 | *   **指令加载**:  从模板加载自动战斗指令。 | *   **指令执行**:  顺序执行加载的指令，并支持循环执行。 | *   **调试模式**:  用于调试自动战斗指令，方便开发者测试和优化。
        │   │   └── operation_template_config.py    这个 Python 文件定义了用于自动战斗的指令模板配置。 |  | *   **主要功能:** 加载和管理自动战斗指令模板，并提供获取配置选项和文件路径的功能。 | *   **核心类和函数:** |     *   `get_operation_template_config_list()`: 获取用于配置页面显示的指令列表。 |     *   `get_all_operation_template()`: 加载所有自动战斗指令模板，支持子目录。 |     *   `get_operation_template_config_file_path(template_name: str)`: 获取指定模板的完整文件路径。 |     *   `OperationTemplate`:  (来自 `one_dragon.base.conditional_operation.operation_template`) 表示一个指令模板。 |     *   `ConfigItem`: (来自 `one_dragon.base.config.config_item`)  用于配置页面选项。 | *   **重要功能点:** |     *   支持从 `config/auto_battle_operation` 目录及其子目录中加载 `.yml` 模板文件。 |     *   使用 `os.walk` 递归遍历目录。 |     *   使用 `os.path.relpath` 处理相对路径。 |     *   生成用于配置页面的选项列表。
        │   ├── charge_plan/
        │   │   ├── charge_plan_app.py    ## 代码摘要 |  | **文件功能:**  该文件定义了 `ChargePlanApp` 类，用于根据配置的体力计划，在游戏中自动执行各种副本（如实战模拟室、定期清剿等）的刷取任务。 |  | **核心类和函数:** |  | *   **`ChargePlanApp(ZApplication)`:**  主类，继承自 `ZApplication`，负责体力计划的执行流程。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用，设置应用ID、名称和运行记录。 |     *   `goto_menu()`:  打开游戏菜单。 |     *   `check_charge_power()`:  识别并获取当前剩余电量。 |     *   `transport()`:  根据体力计划传送至指定副本。 |     *   `check_mission_type()`: 识别副本类型。 |     *   `combat_simulation()`: 执行实战模拟室副本。 |     *   `routine_cleanup()`: 执行定期清剿副本。 |     *   `expert_challenge()`: 执行专业挑战室副本。 |     *   `notorious_hunt()`: 执行恶名狩猎副本。 |     *   `back_to_world()`:  返回大世界。 |  | **重要功能点:** |  | *   **体力计划管理:**  从 `ZContext` 中获取体力计划配置，并根据计划执行任务。 | *   **电量检测:**  在执行任务前，检测剩余电量是否足够。 | *   **副本传送:**  使用 `TransportByCompendium` 操作传送至指定副本。 | *   **副本执行:**  根据副本类型，调用相应的操作类（如 `CombatSimulation`、`RoutineCleanup` 等）执行副本。 | *   **循环执行:**  支持循环执行体力计划，直到计划完成或电量不足。 | *   **状态处理:**  处理各种状态，如“未配置体力计划”、“已完成一轮计划”等。 | *   **错误处理:**  处理电量不足等错误情况，并返回大世界。
        │   │   ├── charge_plan_config.py    此 Python 脚本定义了用于管理游戏中收费计划的配置。 |  | **主要功能:** |  | *   管理和储存收费计划配置，包括任务、运行次数和卡片数量等。 | *   提供添加、删除、更新和重新排序计划的功能。 | *   追踪计划的运行状态，并提供获取下一个计划和判断所有计划是否完成的方法。 |  | **核心类和函数:** |  | *   `CardNumEnum`:  定义卡片数量选项的枚举。 | *   `ChargePlanItem`:  表示单个收费计划项，包含任务、配置和运行次数等信息。 |     *   `uid`:  生成计划项的唯一标识符。 | *   `ChargePlanConfig(YamlConfig)`:  继承自 `YamlConfig`，用于管理收费计划的配置。 |     *   `__init__`:  初始化配置，从 YAML 文件加载计划列表。 |     *   `save`:  保存配置到 YAML 文件。 |     *   `add_plan`, `delete_plan`, `update_plan`:  添加、删除和更新计划。 |     *   `move_up`, `move_top`:  重新排序计划。 |     *   `reset_plans`:  根据运行次数重置运行计划。 |     *   `get_next_plan`:  获取下一个要执行的计划。 |     *   `all_plan_finished`:  检查是否所有计划都已完成。 |     *   `add_plan_run_times`:  增加计划的运行次数。 |     *   `_is_same_plan`:  判断两个计划是否相同。 |     *   `history_list`:  获取历史计划列表。 |     *   `get_history_by_uid`:  根据 UID 获取历史计划。 |  | **重要功能点:** |  | *   使用 `YamlConfig` 储存和加载配置。 | *   支持循环执行计划。 | *   提供计划的运行状态管理，包括重置和获取下一个计划。 | *   支持添加运行次数，并保存。 | *   提供了计划的历史记录。
        │   │   └── charge_plan_run_record.py    这个 Python 文件的摘要如下： |  | *   **主要功能:**  `ChargePlanRunRecord` 类别用于记录和管理计费方案的运行状态。它继承自 `AppRunRecord`，并提供特定于计费方案的初始化和状态更新功能。 | *   **核心类和函数:** |     *   `ChargePlanRunRecord`: 核心类，继承自 `AppRunRecord`，用于管理计费方案的运行记录。 |     *   `__init__`:  `ChargePlanRunRecord` 的建构子，初始化父类 `AppRunRecord`，并设定相关参数。 |     *   `check_and_update_status`:  重置运行记录。 | *   **重要功能点:** |     *   继承自 `AppRunRecord`，表明它使用了基础的应用程式运行记录框架。 |     *   `check_and_update_status` 函数用于重置运行记录，这表明它可能用于在每次运行时清理或初始化运行状态。
        │   ├── city_fund/
        │   │   ├── city_fund_app.py    这个 Python 文件定义了一个名为 `CityFundApp` 的应用程式，用于在游戏中自动执行丽都城募相关的操作。 |  | **主要功能:** |  | *   自动化丽都城募的流程，包括打开菜单、点击相关按钮、领取任务和等级回馈。 |  | **核心类和函数:** |  | *   `CityFundApp`: 继承自 `ZApplication`，是应用程式的主类。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用程式，设置应用程式 ID、名称和运行记录。 |     *   `open_menu(self) -> OperationRoundResult`: 打开游戏菜单。 |     *   `click_fund(self) -> OperationRoundResult`: 点击丽都城募按钮。 |     *   `click_task(self) -> OperationRoundResult`: 点击成长任务按钮。 |     *   `click_task_claim(self) -> OperationRoundResult`: 领取所有任务奖励。 |     *   `click_level(self) -> OperationRoundResult`: 点击等级回馈按钮。 |     *   `click_level_claim(self) -> OperationRoundResult`: 领取所有等级回馈奖励。 |     *   `back_to_world(self) -> OperationRoundResult`: 返回大世界。 | *   `ZContext`: 游戏上下文，提供游戏环境的相关信息。 | *   `OperationRoundResult`: 操作结果的类。 | *   `GotoMenu`: 导航到菜单的类。 | *   `BackToNormalWorld`: 返回正常世界的类。 |  | **重要功能点:** |  | *   使用 `@operation_node` 装饰器定义操作节点，构建操作流程。 | *   使用 `round_by_ocr_and_click`、`round_by_find_and_click_area` 等方法实现基于 OCR 和图像识别的点击操作。 | *   根据不同的状态和结果，执行不同的操作，例如在任务关闭时返回成功。 | *   `__debug()` 函数用于测试应用程式。
        │   │   └── city_fund_run_record.py    这个 Python 文件的摘要如下： |  | *   **主要功能:**  定义了一个用于记录城市基金应用程序运行状态的类。 | *   **核心类和函数:** |     *   `CityFundRunRecord`: 继承自 `AppRunRecord`，用于记录城市基金的运行信息。 |     *   `__init__`:  `CityFundRunRecord` 的构造函数，初始化父类 `AppRunRecord`，并设置应用程序名称和实例索引。 | *   **重要功能点:**  初始化 `CityFundRunRecord` 实例，并将应用程序名称设置为 'city\_fund'。它还接受可选的实例索引和游戏刷新小时偏移量作为参数，用于配置运行记录。
        │   ├── coffee/
        │   │   ├── coffee_app.py    ## 代码摘要 |  | **1. 主要功能:** |  | 该 Python 文件定义了 `CoffeeApp` 类，用于自动化处理游戏《ZZZ》中的咖啡店相关操作。主要功能包括： |  | *   自动传送至咖啡店。 | *   选择并点单咖啡。 | *   根据配置和体力计划，选择是否进行挑战。 | *   执行相应的挑战操作（实战模拟室、定期清剿、专业挑战室）。 | *   返回大世界。 | *   可选地在完成后运行体力计划。 |  | **2. 核心类和函数:** |  | *   **`CoffeeApp(ZContext)`:**  继承自 `ZApplication`，是咖啡店操作的主类。 |     *   `__init__(self, ctx: ZContext)`: 初始化，设置应用 ID、名称、运行记录等。 |     *   `transport(self)`: 传送至咖啡店。 |     *   `wait_world(self)`: 等待大世界加载。 |     *   `move_and_interact(self)`: 移动并交互。 |     *   `wait_coffee_shop(self)`: 等待咖啡店加载。 |     *   `choose_coffee(self)`: 选择咖啡，使用 OCR 识别咖啡列表，并根据配置和体力计划筛选。 |     *   `order_coffee(self)`: 点单咖啡。 |     *   `extra_order_confirm(self)`: 确认不占用上限的咖啡点单。 |     *   `skip_after_order(self)`: 点单后跳过。 |     *   `charge_confirm(self)`: 电量确认。 |     *   `choose_go(self)`: 选择是否前往挑战。 |     *   `tp_mission(self)`: 传送至副本。 |     *   `combat_simulation(self)`: 执行实战模拟室挑战。 |     *   `routine_cleanup(self)`: 执行定期清剿挑战。 |     *   `expert_challenge(self)`: 执行专业挑战室挑战。 |     *   `back_to_world(self)`: 返回大世界。 |     *   `charge_plan_afterwards(self)`: 运行体力计划。 |     *   `_get_coffee_to_choose(self, day
        │   │   ├── coffee_config.py    ## 代码摘要 |  | **主要功能:** |  | 该文件定义了咖啡相关的配置类，用于存储和管理咖啡相关的设置，例如咖啡选择方式、挑战方式、卡片数量、自动战斗设置以及每日咖啡选择等。 |  | **核心类和函数:** |  | *   **`CoffeeChooseWay`**:  枚举类，定义了咖啡选择方式，包括优先体力计划和汀曼特调。 | *   **`CoffeeChallengeWay`**: 枚举类，定义了咖啡挑战方式，包括全部挑战、只挑战体力计划和不挑战。 | *   **`CoffeeCardNumEnum`**: 枚举类，定义了咖啡挑战时卡片数量的选项。 | *   **`CoffeeConfig`**:  继承自 `YamlConfig`，是核心配置类，负责加载、存储和管理咖啡相关的配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化函数，继承父类并设置模块名称。 |     *   `choose_way`, `challenge_way`, `card_num`, `auto_battle`, `day_coffee_1` - `day_coffee_7`, `predefined_team_idx`, `run_charge_plan_afterwards`:  属性，用于获取和设置各种咖啡配置选项。 |     *   `get_coffee_by_day(self, day: int) -> str`:  根据星期几获取对应的咖啡名称。 |     *   `run_charge_plan_afterwards_adapter`:  用于适配 `run_charge_plan_afterwards` 配置项的 `YamlConfigAdapter` 实例。 |  | **重要功能点:** |  | *   定义了咖啡选择、挑战和卡片数量的多种配置选项。 | *   提供了每日咖啡的配置，可以根据星期几选择不同的咖啡。 | *   支持预设编队和咖啡后再次挑战体力计划的配置。 | *   使用 `YamlConfig` 存储配置，方便配置文件的加载和保存。
        │   │   └── coffee_run_record.py    这个 Python 文件定义了一个名为 `CoffeeRunRecord` 的类，用于记录和管理与 "coffee" 应用程序相关的运行信息。 |  | *   **主要功能:** 记录和管理 "coffee" 应用程序的运行记录。 | *   **核心类:** `CoffeeRunRecord` 继承自 `AppRunRecord`。 | *   **重要功能点:** |     *   `CoffeeRunRecord` 的初始化方法 `__init__`，它继承了 `AppRunRecord` 的初始化方法，并设置了应用程序名称为 'coffee'，以及实例索引和游戏刷新小时偏移量。
        │   ├── commission_assistant/
        │   │   ├── commission_assistant_app.py    ## 摘要 |  | **文件功能:** |  | 该文件定义了 `CommissionAssistantApp` 类，该类是用于自动化游戏内委托任务的应用程序。它主要功能包括自动对话、自动战斗和钓鱼。 |  | **核心类和函数:** |  | *   **`CommissionAssistantApp(ZContext)`**:  主应用程序类，继承自 `ZApplication`。 |     *   `__init__`: 初始化应用程序，设置运行模式、自动战斗操作器等。 |     *   `handle_init`: 初始化时监听键盘事件。 |     *   `_on_key_press`: 响应键盘事件，切换运行模式（对话、闪避、自动战斗）。 |     *   `dialog_mode`:  自动对话模式，处理对话框、选项点击等。 |     *   `_check_dialog`: 检查屏幕上是否有对话框。 |     *   `_click_dialog_options`: 点击对话选项。 |     *   `check_same_opts`: 检查对话选项是否与上次相同。 |     *   `_handle_hollow`: 处理空洞内的逻辑。 |     *   `check_knock_knock`: 检查短信。 |     *   `auto_mode`: 自动战斗模式，控制自动战斗操作器。 |     *   `_load_auto_op`: 加载自动战斗操作器。 |     *   `check_fishing`: 检查是否进入钓鱼界面。 |     *   `check_story_mode`: 检查是否进入剧情模式。 |     *   `on_finishing`:  钓鱼操作，根据屏幕上的指令进行操作。 |     *   `handle_pause`: 暂停时取消键盘事件监听和停止自动战斗。 |     *   `handle_resume`: 恢复时重新监听键盘事件和恢复自动战斗。 |     *   `after_operation_done`: 操作完成后清理资源。 |  | **重要功能点:** |  | *   **自动对话:**  识别对话框和选项，并自动选择选项。 | *   **自动战斗:**  根据配置启动和控制自动战斗。 | *   **钓鱼:**  识别钓鱼界面指令，并执行相应的操作。 | *   **模式切换:**  通过键盘快捷键切换自动对话、闪避和自动战斗模式。 | *   **空洞处理:**  处理空洞
        │   │   └── commission_assistant_config.py    这个 Python 文件的主要功能是定义和管理委托助手 (Commission Assistant) 的配置。它使用 `YamlConfig` 类来读取和写入 YAML 配置文件。 |  | 核心类和函数: |  | *   `DialogOptionEnum`:  一个枚举，定义了对话选项，例如 "第一个" 和 "最后一个"。 | *   `StoryMode`:  一个枚举，定义了剧情模式，例如 "自动点击"、"等待剧情自动播放" 和 "跳过剧情"。 | *   `CommissionAssistantConfig`:  继承自 `YamlConfig`，负责管理委托助手的配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化配置，指定模块名称和实例索引。 |     *   多个属性 (使用 `@property` 和 setter):  定义了配置项，例如 `dialog_click_interval`, `story_mode`, `dialog_option`, `dodge_config`, `dodge_switch`, `auto_battle` 和 `auto_battle_switch`，它们用于获取和设置配置值。 |  | 重要功能点: |  | *   使用 `YamlConfig` 读取和写入 YAML 配置文件，实现配置的持久化。 | *   使用枚举 `DialogOptionEnum` 和 `StoryMode` 来定义配置选项，提高代码的可读性和可维护性。 | *   提供 getter 和 setter 方法来访问和修改配置项，方便配置的管理和修改。
        │   ├── devtools/
        │   │   └── screenshot_helper/
        │   │       ├── screenshot_helper_app.py    这个 Python 脚本定义了一个名为 `ScreenshotHelperApp` 的应用程式，用于在游戏中检测闪避动作并截图，以用于训练模型。 |  | **主要功能:** |  | *   持续截图并检测闪避动作。 | *   通过按键触发保存截图。 |  | **核心类和函数:** |  | *   `ScreenshotHelperApp`: 继承自 `ZApplication`，是应用程式的主类。 |     *   `__init__`: 初始化应用程式，设置截图相关的参数。 |     *   `add_edges_and_nodes`: 定义操作流程，包括初始化上下文、持续截图和保存截图。 |     *   `handle_init`: 初始化应用程式，设置截图的相关配置。 |     *   `init_context`: 初始化上下文，加载自动战斗操作。 |     *   `repeat_screenshot`: 执行持续截图，检测闪避动作，并根据配置决定是否保存截图。 |     *   `_on_key_press`: 监听按键事件，当按下保存按键时，触发保存截图。 |     *   `do_save_screenshot`: 保存截图。 |     *   `after_operation_done`: 应用程式结束后的清理工作。 |  | **重要功能点:** |  | *   使用 `AutoBattleOperator` 检测闪避动作。 | *   使用 `debug_utils.save_debug_image` 保存截图。 | *   通过按键触发保存截图，并限制保存频率。 | *   使用 `ContextKeyboardEventEnum` 监听按键事件。
        │   │       └── screenshot_helper_config.py    这个 Python 文件定义了 `ScreenshotHelperConfig` 类，用于管理截图工具的配置。 |  | *   **主要功能:** 读取和管理截图工具的配置，例如截图频率、截图长度、保存按键和躲避检测。 | *   **核心类:** `ScreenshotHelperConfig` 继承自 `YamlConfig`，用于从 YAML 文件加载配置。 | *   **重要功能点:** |     *   `frequency_second`: 截图频率（秒）。 |     *   `length_second`: 截图持续时间（秒）。 |     *   `key_save`: 保存截图的按键。 |     *   `dodge_detect`: 是否启用躲避检测。 |     *   使用 `@property` 装饰器定义了配置项的 getter 和 setter 方法，方便配置的读取和修改。
        │   ├── drive_disc_dismantle/
        │   │   ├── drive_disc_dismantle_app.py    此 Python 文件定义了 `DriveDiscDismantleApp` 类，该类实现了在游戏 `zzz_od` 中拆解驱动盘的自动化流程。 |  | **核心类和函数:** |  | *   `DriveDiscDismantleApp`: 继承自 `ZApplication`，负责驱动盘拆解的整个流程。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用，设置应用名称和运行记录。 |     *   `back_at_first()`:  流程开始时返回主界面。 |     *   `goto_salvage()`:  导航到驱动盘拆解界面。 |     *   `click_filter()`:  点击快速选择按钮。 |     *   `choose_level()`:  选择拆解等级。 |     *   `choose_abandon()`:  选择是否弃置已弃置的驱动盘。 |     *   `click_filter_confirm()`: 确认快速选择。 |     *   `click_salvage()`:  点击拆解按钮。 |     *   `click_salvage_confirm()`: 确认拆解操作。 |     *   `back_at_last()`:  流程结束时返回主界面。 | *   `__debug()`:  用于调试，创建 `ZContext` 实例并运行 `DriveDiscDismantleApp`。 |  | **重要功能点:** |  | *   自动化流程：通过一系列 `operation_node` 装饰的函数，定义了拆解驱动盘的步骤。 | *   界面交互：使用 `round_by_goto_screen` 和 `round_by_find_and_click_area` 等方法与游戏界面交互，实现点击和导航。 | *   配置驱动：使用 `self.ctx.drive_disc_dismantle_config` 来配置拆解等级和是否弃置已弃置的驱动盘。 | *   错误处理：使用 `success` 参数处理流程中的分支情况，例如可能没有需要拆解的驱动盘。
        │   │   ├── drive_disc_dismantle_config.py    这个 Python 文件定义了用于驱动器拆卸的配置。 |  | *   **主要功能:** 读取和管理驱动器拆卸的配置，包括拆卸级别和是否拆卸已弃置的驱动器。 | *   **核心类和函数:** |     *   `DismantleLevelEnum`: 枚举类，定义了拆卸级别（LEVEL\_B, LEVEL\_A, LEVEL\_S）。 |     *   `DriveDiscDismantleConfig`: 继承自 `YamlConfig`，用于管理拆卸配置。 |         *   `__init__`: 初始化配置，从 YAML 文件加载配置。 |         *   `dismantle_level`: 属性，获取和设置拆卸级别。 |         *   `dismantle_abandon`: 属性，获取和设置是否拆卸已弃置的驱动器。 | *   **重要功能点:** |     *   使用 `YamlConfig` 读取和存储配置。 |     *   提供拆卸级别的配置选项。 |     *   提供是否拆卸已弃置驱动器的配置选项。
        │   │   └── drive_disc_dismantle_run_record.py    这个 Python 文件定义了一个用于记录「Drive Disc Dismantle」应用程式运行情况的类别。 |  | *   **主要功能:** 记录「Drive Disc Dismantle」应用程式的运行资讯。 | *   **核心类:** `DriveDiscDismantleRunRecord` 继承自 `AppRunRecord`。 | *   **重要功能点:** |     *   `DriveDiscDismantleRunRecord` 的建构子 (`__init__`) 初始化了应用程式名称，并可以接收实例索引和游戏刷新小时偏移量。
        │   ├── email_app/
        │   │   ├── email_app.py    这个 Python 文件的主要功能是实现一个自动接收邮件奖励的应用程式。 |  | 核心类： |  | *   `EmailApp`: 继承自 `ZApplication`，负责处理邮件相关的操作。 |  | 核心函数： |  | *   `__init__(self, ctx: ZContext)`: 初始化 `EmailApp`，设置应用程式 ID、名称和运行记录。 | *   `handle_init(self) -> None`: 初始化函数，目前为空。 | *   `goto_email(self) -> OperationRoundResult`: 打开邮件界面。 | *   `click_get_all(self) -> OperationRoundResult`: 在邮件界面点击“全部领取”。 | *   `click_confirm(self) -> OperationRoundResult`: 在领取后点击“确认”。 | *   `back_to_menu(self) -> OperationRoundResult`: 返回主菜单。 |  | 重要功能点： |  | *   使用 `operation_node` 和 `node_from` 装饰器定义操作流程，实现自动化。 | *   通过截图和查找区域的方式与界面交互。 | *   处理了“全部领取”按钮不可用的情况。 | *   处理了领取后点击“确认”按钮的情况。 | *   提供了返回主菜单的功能。
        │   │   └── email_run_record.py    这个 Python 文件定义了一个名为 `EmailRunRecord` 的类，用于记录与邮件应用程序相关的运行信息。 |  | *   **主要功能:** 记录邮件应用程序的运行记录。 | *   **核心类:** `EmailRunRecord` 继承自 `AppRunRecord`。 | *   **重要功能点:** |     *   `EmailRunRecord` 的构造函数初始化了父类 `AppRunRecord`，并指定了应用程序类型为 'email'。 |     *   构造函数接受 `instance_idx` 和 `game_refresh_hour_offset` 作为参数，用于配置运行记录。
        │   ├── engagement_reward/
        │   │   ├── engagement_reward_app.py    这个 Python 脚本定义了一个应用程式 `EngagementRewardApp`，用于自动领取游戏中的活跃度奖励。 |  | **主要功能:** |  | *   自动导航到活跃度奖励界面。 | *   识别活跃度。 | *   点击领取奖励。 | *   检查奖励结果。 | *   如果没有奖励或领取完成，则返回游戏主界面。 |  | **核心类和函数:** |  | *   `EngagementRewardApp`: 继承自 `ZApplication`，是主要的应用程式类，负责整个领取奖励的流程。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用程式，设置应用程式 ID、名称和运行记录。 |     *   `handle_init(self) -> None`: 初始化，设置 `idx`。 |     *   `goto_compendium_daily(self) -> OperationRoundResult`: 导航到快捷手册-日常界面。 |     *   `check_engagement(self) -> OperationRoundResult`: 识别活跃度。 |     *   `click_reward(self) -> OperationRoundResult`: 点击领取奖励。 |     *   `check_reward(self) -> OperationRoundResult`: 检查奖励结果。 |     *   `back_afterwards(self) -> OperationRoundResult`: 完成后返回大世界。 | *   `ZContext`: 游戏上下文，包含游戏环境的相关信息。 | *   `OperationRoundResult`: 操作回合结果。 | *   `BackToNormalWorld`: 返回大世界的操作。 |  | **重要功能点:** |  | *   使用 `operation_node` 装饰器定义操作流程中的节点。 | *   使用 `node_from` 装饰器定义节点之间的依赖关系。 | *   使用 OCR 识别活跃度。 | *   根据活跃度点击相应的奖励按钮。 | *   处理领取失败或没有奖励的情况。 | *   `__debug()` 函数用于测试。
        │   │   └── engagement_reward_run_record.py    这个 Python 文件定义了 `EngagementRewardRunRecord` 类，用于记录和管理与互动奖励相关的应用程式运行记录。 |  | *   **核心类:** `EngagementRewardRunRecord` 继承自 `AppRunRecord`。 | *   **重要功能点:** |     *   `__init__` 方法初始化 `EngagementRewardRunRecord` 实例，并调用父类 `AppRunRecord` 的初始化方法，设定应用程式名称和实例索引等参数。 |     *   `game_refresh_hour_offset` 参数用于指定游戏刷新的小时偏移量。
        │   ├── hollow_zero/
        │   │   ├── lost_void/
        │   │   │   ├── lost_void_app.py    ## 摘要 |  | 该 Python 脚本定义了一个名为 `LostVoidApp` 的应用程式，用于自动化游戏《崩坏：星穹铁道》中「迷失之地」的挑战。 |  | **主要功能：** |  | *   自动执行「迷失之地」的挑战流程，包括初始化、进入战斗、完成关卡、领取奖励等。 | *   处理各种游戏画面，根据画面内容执行相应的操作，例如点击按钮、选择选项等。 | *   记录挑战进度，并在完成每日挑战次数后停止。 |  | **核心类和函数：** |  | *   `LostVoidApp`: 继承自 `ZApplication`，是整个应用程式的核心，定义了挑战的流程和逻辑。 |     *   `init_for_lost_void`: 初始化，检查是否已完成当日挑战。 |     *   `check_initial_screen`: 识别初始画面，判断当前状态。 |     *   `back_at_first`: 返回大世界。 |     *   `goto_compendium`: 前往快捷手册。 |     *   `choose_hollow_zero`: 选择零号空洞。 |     *   `choose_lost_void`: 选择迷失之地。 |     *   `goto_purge`: 前往战线肃清。 |     *   `choose_buff`: 选择增益。 |     *   `click_next`: 点击下一步。 |     *   `deploy`: 部署。 |     *   `run_level`: 执行关卡。 |     *   `after_complete`: 通关后处理。 |     *   `open_reward_list`: 打开悬赏委托。 |     *   `claim_all`: 全部领取。 |     *   `back_at_last`: 完成后返回。 | *   `ZContext`: 游戏上下文，包含游戏状态和配置信息。 | *   `OperationRoundResult`: 操作结果。 | *   `LostVoidRunLevel`: 执行关卡的操作。 | *   `BackToNormalWorld`: 返回普通世界的操作。 | *   `CompendiumChooseCategory`: 选择类别的操作。 | *   `CompendiumChooseMissionType`: 选择任务类型的操作。 | *   `Deploy
        │   │   │   ├── lost_void_challenge_config.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 脚本定义了用于管理“虚空遗失挑战”配置的类和函数，这些配置基于 YAML 文件。它提供了加载、保存、更新和创建配置文件的功能，并定义了与挑战相关的枚举类型。 |  | **核心类和函数:** |  | *   **`LostVoidRegionType`**:  一个枚举类，定义了虚空遗失挑战中的区域类型。 | *   **`LostVoidPeriodBuffNo`**:  一个枚举类，定义了周期性增益编号。 | *   **`LostVoidBuyOnlyPriority`**:  一个枚举类，定义了购买优先级。 | *   **`LostVoidChallengeConfig(YamlConfig)`**:  核心类，继承自 `YamlConfig`，用于加载、保存和管理虚空遗失挑战的配置。 |     *   `__init__`: 初始化配置，加载 YAML 文件。 |     *   `copy_new`: 复制配置并创建一个新的配置文件。 |     *   `remove_sample`: 将配置文件标记为非示例文件。 |     *   `update_module_name`: 更新配置文件的模块名称。 |     *   `save`: 保存配置。 |     *   一系列 `@property` 和 `@*.setter` 方法，用于访问和修改配置中的各种属性，如 `auto_battle`, `artifact_priority` 等。 | *   **`get_all_lost_void_challenge_config(with_sample: bool = True)`**:  从配置文件目录中加载所有虚空遗失挑战配置。 | *   **`get_lost_void_challenge_new_name()`**:  生成一个新的配置文件名。 |  | **重要功能点:** |  | *   **配置加载和保存**:  使用 `YamlConfig` 加载和保存 YAML 格式的配置文件。 | *   **枚举类型**:  使用 `Enum` 定义了区域类型、周期性增益编号和购买优先级，增强了代码的可读性和可维护性。 | *   **配置属性访问**:  通过属性访问器（`@property` 和 `@*.setter`）来方便地获取和设置配置参数。 | *   **配置文件管理**:  提供了复制、重命名和删除配置文件的功能。 | *   **批量加载配置**:  `get_all_lost_void_challenge_config` 函数用于批量
        │   │   │   ├── lost_void_config.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件定义了用于配置「虚空遗忘」功能的配置类。它使用 `YamlConfig` 类来读取和管理配置数据。 |  | **核心类和函数：** |  | *   `LostVoidExtraTask` (Enum):  定义了额外任务的枚举，包括 `NONE`, `EVAL_POINT`, 和 `PERIOD_REWARD`。 | *   `LostVoidConfig` (YamlConfig):  继承自 `YamlConfig`，负责加载和管理与「虚空遗忘」相关的配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化 `LostVoidConfig` 实例。 |     *   `daily_plan_times` (property):  配置每日计划次数，包含 getter 和 setter。 |     *   `weekly_plan_times` (property):  配置每周计划次数，包含 getter 和 setter。 |     *   `extra_task` (property):  配置额外任务，包含 getter 和 setter。 |     *   `mission_name` (property):  配置任务名称，包含 getter 和 setter。 |     *   `challenge_config` (property): 配置挑战配置，包含 getter 和 setter。 |  | **重要功能点：** |  | *   使用 `YamlConfig` 读取和管理配置，配置数据来自 YAML 文件。 | *   定义了 `LostVoidExtraTask` 枚举，用于指定额外任务类型。 | *   提供了多个属性 (property) 来访问和修改配置，例如每日计划次数、每周计划次数、额外任务、任务名称和挑战配置。 | *   每个配置属性都提供了 getter 和 setter 方法，方便读取和更新配置。
        │   │   │   ├── lost_void_run_record.py    这个 Python 文件定义了 `LostVoidRunRecord` 类，用于记录和管理游戏 "Lost Void" 的运行状态。 |  | **核心类和函数:** |  | *   `LostVoidRunRecord`: 继承自 `AppRunRecord`，用于记录 Lost Void 的运行数据。 |     *   `__init__`: 初始化 LostVoidRunRecord，设置游戏名称、实例索引、刷新时间偏移和记录周期。 |     *   `daily_run_times`, `weekly_run_times`: 属性，用于获取和设置每日和每周的运行次数。 |     *   `add_complete_times`: 增加每日和每周的完成次数。 |     *   `eval_point_complete`, `period_reward_complete`: 属性，用于获取和设置是否完成业绩点和周期奖励。 |     *   `is_finished_by_week`: 判断是否按周完成。 |     *   `is_finished_by_day`: 判断是否按天完成。 |     *   `run_status_under_now`: 根据当前时间判断运行状态。 |     *   `check_and_update_status`: 检查并更新运行状态，包括重置记录。 |     *   `reset_for_weekly`: 重置每周的运行数据。 |  | **重要功能点:** |  | *   记录每日和每周的运行次数。 | *   追踪是否完成业绩点和周期奖励。 | *   根据配置和运行次数判断游戏是否完成（按天和按周）。 | *   根据时间判断和更新运行状态，包括重置数据。
        │   │   │   ├── context/
        │   │   │   │   ├── lost_void_artifact.py    这个 Python 文件定义了一个名为 `LostVoidArtifact` 的类，用于表示游戏中遗失虚空的物品。 |  | *   **核心类:** `LostVoidArtifact` | *   **核心函数:** `__init__` (构造函数) | *   **重要功能点:** |     *   储存物品的分类、名称、等级和模板 ID (可选)。 |     *   `display_name` 属性，用于生成物品的显示名称，格式为 "分类 名称"。
        │   │   │   │   ├── lost_void_context.py    ```python | # 摘要 |  | # 主要功能： | # 负责管理《迷失之地》游戏中的上下文信息，包括藏品、挑战配置、自动战斗指令和目标检测。 |  | # 核心类和函数： | # - LostVoidContext:  主类，管理迷失之地相关的上下文。 | #   - init_before_run(): 初始化环境，包括加载模型、数据和配置。 | #   - load_artifact_data(): 加载藏品数据。 | #   - init_lost_void_det_model(): 初始化目标检测模型。 | #   - init_auto_op(): 初始化自动战斗指令。 | #   - load_challenge_config(): 加载挑战配置。 | #   - detect_to_go(): 检测需要前往的目标。 | #   - check_battle_encounter(): 检查是否进入战斗。 | #   - match_artifact_by_ocr_full(): 通过OCR匹配藏品。 | #   - get_artifact_by_priority(): 根据优先级选择藏品。 | #   - get_entry_by_priority(): 根据优先级选择入口。 | # - LostVoidDetector: 目标检测器，用于识别游戏画面中的元素。 | # - LostVoidArtifact: 藏品数据类。 | # - LostVoidChallengeConfig: 挑战配置类。 |  | # 重要功能点： | # - 藏品数据加载和管理。 | # - 目标检测，用于识别游戏元素。 | # - 自动战斗指令的初始化和管理。 | # - 战斗状态检测。 | # - 基于优先级的藏品选择和入口选择。 | ```
        │   │   │   │   ├── lost_void_detector.py    这个 Python 文件定义了一个名为 `LostVoidDetector` 的类，它继承自 `Yolov8Detector`，用于崩坏星穹铁道的 YOLO 模型目标检测。 |  | **主要功能：** |  | *   使用 YOLOv8 模型检测图像中的特定目标。 | *   提供方法来判断帧中是否存在特定类别的目标。 | *   提供方法来获取特定类别目标在帧中的最右侧结果。 |  | **核心类和函数：** |  | *   `LostVoidDetector`: 继承自 `Yolov8Detector`，用于检测崩坏星穹铁道中的目标。 |     *   `__init__`: 初始化检测器，包括模型名称、备份模型名称、是否使用 GPU 等。 |     *   `is_frame_with_all`: 判断帧中是否存在所有指定类别的目标（感叹号、距离、入口）。 |     *   `is_frame_with`: 判断帧中是否存在特定类别的目标。 |     *   `get_result_by_x`: 获取帧中特定类别目标的最右侧结果。 |  | **重要功能点：** |  | *   使用 YOLOv8 模型进行目标检测。 | *   针对崩坏星穹铁道游戏中的特定目标类别进行检测。 | *   提供灵活的方法来查询检测结果。 | *   包含一个 `__debug` 函数，用于测试和演示检测器的功能。
        │   │   │   │   └── lost_void_det_class.py    这个 Python 文件定义了一个名为 `LostVoidDetClass` 的类，用于表示与 Lost Void 检测相关的类别信息。 |  | *   **核心类:** `LostVoidDetClass` | *   **核心函数:** `__init__` (构造函数) | *   **重要功能点:** |     *   `LostVoidDetClass` 类用于存储 Lost Void 检测的类别索引 (`class_idx`) 和类别名称 (`class_name`)。 |     *   构造函数初始化类别索引和类别名称。
        │   │   │   └── operation/
        │   │   │       ├── lost_void_move_by_det.py    ```python | # 1. 文件主要功能 | 该文件定义了一个名为 `LostVoidMoveByDet` 的 ZOperation，用于在迷失之地中识别目标并朝其移动。它处理了移动、转向、脱困、交互等情况，并根据识别结果进行相应的动作。 |  | # 2. 核心类和函数 | -   **`MoveTargetWrapper`**: 封装了检测到的目标信息，包括目标名称、矩形区域，以及合并逻辑，用于处理多个目标的合并。 | -   **`LostVoidMoveByDet`**: 继承自 `ZOperation`，是主要的移动操作类。 |     -   `__init__`: 初始化操作，设置目标类型、停止条件等。 |     -   `turn_at_first`: 初始转向，识别目标并转向。 |     -   `move_towards`: 朝目标移动。 |     -   `turn_to_target`: 根据目标位置转向。 |     -   `get_move_target`: 获取移动目标。 |     -   `get_entry_target`: 获取入口目标，处理合并逻辑。 |     -   `check_stuck`: 判断是否被困。 |     -   `get_out_of_stuck`: 尝试脱困。 |     -   `check_interact_stop`: 判断是否需要停止以进行交互。 |     -   `handle_no_target`: 处理未识别到目标的情况。 |     -   `get_same_as_last_target`: 尝试选择与上次目标最接近的目标。 |  | # 3. 重要功能点 | -   **目标识别与移动**: 使用 `LostVoidDetector` 识别目标，并控制角色朝目标移动。 | -   **脱困机制**: 检测角色是否被困，并提供脱困策略，包括移动和攻击。 | -   **交互处理**: 判断是否需要停止移动以进行交互。 | -   **多目标合并**: `MoveTargetWrapper` 类中的合并逻辑，用于处理多个入口的合并。 | -   **状态管理**: 使用 `STATUS_IN_BATTLE`, `STATUS_ARRIVAL`, `STATUS_NO_FOUND`, `STATUS_CONTINUE`,
        │   │   │       ├── lost_void_run_level.py    ```python | 文件摘要： |  | 该文件定义了 `LostVoidRunLevel` 类，用于处理《崩坏：星穹铁道》游戏中“迷失之地”的层间移动和战斗流程。它集成了目标检测、交互、自动战斗等功能，以完成特定区域类型的挑战。 |  | 核心类和函数： |  | *   **`LostVoidRunLevel`**:  核心类，继承自 `ZOperation`，负责迷失之地的层间移动和战斗。 |     *   `__init__`: 初始化，设置区域类型、检测器、自动战斗操作器等。 |     *   `wait_loading`: 等待加载，识别奖励选择和挑战确认。 |     *   `init_for_region_type`: 根据区域类型初始化流程。 |     *   `non_battle_check`: 非战斗画面识别，检测交互、距离、入口等。 |     *   `try_interact`: 尝试交互。 |     *   `handle_interact`: 处理交互结果，包括选择和对话。 |     *   `after_interact`: 交互后处理，根据交互目标进行移动。 |     *   `in_battle`: 战斗流程，启动自动战斗，并检测战斗状态。 |     *   `handle_challenge_result_confirm`: 处理挑战结果确认。 |     *   `handle_challenge_result_finish`: 处理挑战结果完成。 |     *   `fail_exit_lost_void`: 失败退出空洞。 |     *   `handle_battle_fail`: 处理战斗失败。 |     *   `handle_fail_exit`: 点击失败退出完成。 |     *   `handle_pause`: 暂停时停止自动战斗。 |     *   `after_operation_done`: 操作完成后停止自动战斗。 |     *   `try_talk`: 尝试对话。 |     *   `try_talk_options`: 尝试对话选项。 |     *   `move_after_interact`: 交互后进行移动。 | *   `ZOperation`:  基类，提供操作框架。 | *   `LostVoidDetector`: 用于检测游戏画面中的目标。 | *   `AutoBattleOperator`: 自动战斗操作器。 |  | 重要功能点： |  | *   **区域类型处理**:  根据 `LostVoidRegionType`  处理不同
        │   │   │       └── interact/
        │   │   │           ├── lost_void_bangboo_store.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个名为 `LostVoidBangbooStore` 的类，用于在游戏“迷失之地”中操作邦布商店，实现购买藏品的功能。它通过识别商店类型、藏品信息、价格和购买按钮，并根据优先级选择藏品进行购买。 |  | **核心类和函数:** |  | *   **`StoreItemWrapper`**: 辅助类，用于封装商店中藏品的信息，包括藏品对象、矩形区域、价格和购买按钮矩形。 |     *   `add_price()`: 添加价格信息。 |     *   `add_buy()`: 添加购买按钮信息。 | *   **`LostVoidBangbooStore(ZOperation)`**: 主要操作类，继承自 `ZOperation`。 |     *   `check_store_type()`: 识别商店类型（金币或血量）。 |     *   `buy_artifact_gold()`: 购买藏品，包括识别藏品、筛选优先级、点击购买、处理确认。 |     *   `get_artifact_pos()`: 识别藏品的位置、价格和购买按钮。 |     *   `check_min_blood_valid()`: 检查血量是否满足购买条件。 |     *   `click_confirm()`: 点击购买确认按钮。 |     *   `after_confirm()`: 处理购买后的流程，例如武备升级。 |     *   `finish()`: 结束操作，点击返回按钮。 |  | **重要功能点:** |  | *   **商店类型识别:** 区分金币商店和血量商店。 | *   **藏品识别:** 通过 OCR 技术识别藏品名称、价格和购买按钮。 | *   **优先级选择:** 根据配置和刷新次数，优先购买高优先级藏品。 | *   **血量检查:** 购买血量商店的藏品时，检查当前血量是否满足最低要求。 | *   **流程控制:** 使用 `operation_node` 和 `node_from` 装饰器定义操作流程，包括识别、购买、确认和结束。 | *   **错误处理:** 包含重试机制和失败处理逻辑。
        │   │   │           ├── lost_void_choose_common.py    ## 摘要 |  | **文件功能:** |  | 该 Python 脚本实现了在游戏 "迷失之地" 中选择物品的自动化操作。它根据屏幕上的文本和图像识别，选择符合优先级的藏品或武备，并处理刷新和确认操作。 |  | **核心类和函数:** |  | *   **`LostVoidChooseCommon(ZContext)`**:  继承自 `ZOperation`，负责执行选择操作。 |     *   `__init__(self, ctx: ZContext)`: 初始化，设置操作名称和选择数量。 |     *   `choose_artifact(self) -> OperationRoundResult`:  核心函数，执行选择流程，包括识别屏幕、选择物品、刷新和确认。 |     *   `get_artifact_pos(self, screen: MatLike) -> Tuple[List[MatchResult], List[MatchResult]]`:  识别屏幕上的藏品或武备位置，并确定已选择的物品。 |  | **重要功能点:** |  | *   **屏幕识别和 OCR:** 使用 OCR 识别屏幕上的文本，以确定需要选择的物品数量和类型。 | *   **物品优先级:**  根据配置的优先级选择物品，并处理刷新操作以获取更多选择。 | *   **选择逻辑:**  根据识别到的物品数量和优先级，执行点击操作来选择物品。 | *   **错误处理:**  使用 `round_retry` 和 `round_wait` 处理错误和等待，确保操作的稳定性。 | *   **调试功能:** 包含 `__debug()` 和 `__get_get_artifact_pos()` 函数，用于测试和调试。
        │   │   │           ├── lost_void_choose_gear.py    ```python | # 摘要 | # 文件功能： | #   该文件定义了在“迷失之地”游戏中选择武备的操作。它负责识别屏幕上的武备，并根据优先级选择和点击它们。 | # 核心类和函数： | #   - LostVoidChooseGear: 继承自 ZOperation，负责武备选择操作。 | #   - choose_gear(self) -> OperationRoundResult:  主函数，选择武备。 | #   - get_gear_pos(self, screen_list: List[MatLike], only_no_level: bool = False) -> List[MatchResult]:  识别武备位置。 | #   - get_level_pos(self, screen: MatLike) -> List[MatchResult]:  获取等级的位置。 | #   - click_equip(self) -> OperationRoundResult: 点击携带按钮。 | #   - click_back(self) -> OperationRoundResult: 点击返回按钮。 | # 重要功能点： | #   - 使用图像识别技术（特征匹配）来识别屏幕上的武备。 | #   - 根据优先级选择武备。 | #   - 包含重试机制，以应对识别失败的情况。 | #   - 提供了点击“携带”和“返回”按钮的功能。 | ```
        │   │   │           ├── lost_void_choose_no_detail.py    此 Python 文件定义了一个名为 `LostVoidChooseNoDetail` 的类，用于处理“迷失之地-无详情选择”场景下的交互操作。 |  | **主要功能:** |  | *   在“迷失之地-无详情选择”界面中选择藏品并点击确定。 | *   处理可能出现的二次选择情况。 |  | **核心类和函数:** |  | *   `LostVoidChooseNoDetail(ZContext)`:  继承自 `ZOperation`，初始化操作，并维护已选择的藏品索引列表 `chosen_idx_list`。 | *   `choose_artifact()`:  作为起始节点，尝试选择藏品。它首先移动鼠标到特定位置，然后截图。接着，它会检查当前屏幕是否为“迷失之地-无详情选择”或“迷失之地-通用选择”。如果识别到“通用选择”，则直接返回成功。否则，它会调用 `get_artifact_pos()` 获取藏品位置，并根据优先级选择一个藏品进行点击。 | *   `get_artifact_pos(screen: MatLike) -> List[MatchResult]`:  从屏幕截图中识别藏品的位置。它会裁剪出藏品名称区域，使用 OCR 识别文本，然后匹配藏品信息。 | *   `click_confirm()`:  点击“确定”按钮。它会检查是否需要处理二次选择，并尝试点击“确定”按钮，直到不再找到该按钮。 |  | **重要功能点:** |  | *   **屏幕识别和导航:** 使用 `screen_loader` 和 `round_by_find_area` 等方法进行屏幕识别和导航。 | *   **OCR 识别:** 使用 OCR 识别藏品名称。 | *   **藏品选择逻辑:**  根据优先级选择藏品，并排除已选择的藏品。 | *   **错误处理和重试:** 使用 `round_retry` 处理可能的错误，并进行重试。 | *   **二次选择处理:**  处理可能出现的二次选择情况。
        │   │   │           ├── lost_void_choose_no_num.py    这个 Python 脚本定义了一个名为 `LostVoidChooseNoNum` 的类，它继承自 `ZOperation`，用于处理游戏中“迷失之地”场景中不需要选择数量的选择操作。 |  | **主要功能：** |  | *   处理“迷失之地”场景中不需要数量选择的交互，例如点击“确定”按钮。 |  | **核心类和函数：** |  | *   `LostVoidChooseNoNum(ZOperation)`：继承自 `ZOperation`，处理“迷失之地-无数量选择”的操作。 |     *   `choose_artifact()`：使用 `@operation_node` 装饰器标记，是操作的起始节点。它移动鼠标到特定区域，截图，检查当前屏幕，并点击“确定”按钮。 |  | **重要功能点：** |  | *   使用屏幕截图和图像识别来确认当前屏幕状态。 | *   使用 `round_by_find_and_click_area` 函数来查找并点击屏幕上的特定区域（例如“确定”按钮）。 | *   包含重试机制，以处理可能发生的屏幕识别错误。 | *   `__debug()` 函数用于测试和调试该操作。
        │   │   │           ├── lost_void_interact_target_const.py    此 Python 文件定义了与“虚空”游戏模式中的交互目标相关的常量和类。 |  | *   **主要功能:** 定义了可交互的 NPC、BOSS 和其他目标的枚举，并提供了一个函数来根据 OCR 结果匹配交互目标。 | *   **核心类和函数:** |     *   `LostVoidInteractNPC`:  一个枚举，定义了可交互的 NPC 的名称。 |     *   `LostVoidBoss`:  一个枚举，定义了最终入口交互的 BOSS 的名称。 |     *   `LostVoidInteractTarget`:  一个类，表示一个交互目标，包含名称、图标、交互类型等属性。 |     *   `match_interact_target(ctx: ZContext, ocr_result: str) -> Optional[LostVoidInteractTarget]`:  核心函数，根据 OCR 结果匹配具体的交互目标，并返回 `LostVoidInteractTarget` 对象。 | *   **重要功能点:** |     *   使用枚举定义了可交互的 NPC 和 BOSS。 |     *   `LostVoidInteractTarget` 类用于封装交互目标的信息。 |     *   `match_interact_target` 函数使用字符串匹配来识别交互目标，并根据匹配结果创建 `LostVoidInteractTarget` 对象。 |     *   函数考虑了不同类型的交互，如与 NPC、代理人、入口和 BOSS 的交互。
        │   │   │           ├── lost_void_lottery.py    这段程式码定义了一个名为 `LostVoidLottery` 的类，它继承自 `ZOperation`，用于执行游戏「迷失之地-抽奖机」的抽奖操作。 |  | **主要功能:** |  | *   执行「迷失之地-抽奖机」的抽奖流程，包括点击开始按钮、处理抽奖结果，以及在抽奖次数用尽或出现错误时返回大世界。 | *   根据不同的抽奖结果，导航到不同的交互操作，例如 `LostVoidChooseCommon`、`LostVoidChooseNoDetail` 和 `LostVoidChooseNoNum`。 |  | **核心类和函数:** |  | *   `LostVoidLottery(ZOperation)`:  主类，负责抽奖流程的控制。 |     *   `click_start()`: 点击开始按钮，并检查剩余抽奖次数。 |     *   `confirm_after_click()`: 处理点击开始后的界面，判断并执行相应的交互操作，或者点击获取确定按钮。 |     *   `back_to_world()`: 在抽奖次数用尽或失败时，返回大世界。 |  | **重要功能点:** |  | *   使用 OCR 识别剩余抽奖次数。 | *   根据不同的界面，调用不同的交互操作。 | *   使用 `operation_node` 和 `node_from` 装饰器定义操作流程和状态转换。 | *   包含一个 `__debug()` 函数，用于测试。
        │   │   │           └── lost_void_route_change.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件定义了一个名为 `LostVoidRouteChange` 的操作，用于处理游戏中「迷失之地」的路径迭换。 |  | **核心类和函数：** |  | *   `LostVoidRouteChange`：继承自 `ZOperation`，负责执行迷失之地路径迭换相关的操作。 |     *   `back_to_world()`：尝试返回到游戏世界。 |  | **重要功能点：** |  | *   `back_to_world()` 使用截图判断是否在游戏世界中，如果不在，则尝试通过点击按钮返回。 | *   使用了 `@operation_node` 装饰器来定义操作节点，并指定了重试次数。 | *   使用了 `round_by_find_and_click_area` 函数来查找并点击屏幕上的区域。 | *   使用了 `round_retry` 和 `round_success` 函数来处理操作的结果。
        │   │   └── withered_domain/
        │   │       ├── hollow_zero_app.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了 `HollowZeroApp` 类，用于自动化处理游戏《崩坏：星穹铁道》中“枯萎之都”的日常任务。它通过模拟用户操作，完成传送、选择副本、出战、自动运行等流程。 |  | **核心类和函数:** |  | *   **`HollowZeroApp(ZApplication)`:**  继承自 `ZApplication`，是核心类，负责整个“枯萎之都”任务的自动化流程。 |     *   `__init__(self, ctx: ZContext)`: 初始化，设置任务名称、类型等。 |     *   `handle_init(self)`: 初始化配置。 |     *   `check_first_screen(self) -> OperationRoundResult`: 检查初始屏幕，判断是否在空洞内。 |     *   `tp(self) -> OperationRoundResult`: 传送至“枯萎之都”。 |     *   `wait_entry_loading(self) -> OperationRoundResult`: 等待入口加载。 |     *   `choose_mission_type(self) -> OperationRoundResult`: 选择副本类型。 |     *   `choose_mission(self) -> OperationRoundResult`: 选择副本。 |     *   `click_next(self) -> OperationRoundResult`: 点击“下一步”等按钮。 |     *   `deploy(self) -> OperationRoundResult`: 部署队伍。 |     *   `auto_run(self) -> OperationRoundResult`: 自动运行副本。 |     *   `wait_back_loading(self) -> OperationRoundResult`: 完成后等待加载。 |     *   `finish(self) -> OperationRoundResult`: 返回正常世界。 | *   **`__debug()`:**  用于调试，创建 `ZContext` 实例并运行 `HollowZeroApp`。 |  | **重要功能点:** |  | *   **流程控制:**  使用 `@operation_node` 和 `@node_from` 装饰器定义操作节点和流程依赖关系，构建任务流程。 | *   **屏幕识别:**  使用 `screenshot()` 截屏，并结合 `round_by_find_area`, `round_by_ocr_and_click` 等方法进行屏幕元素识别和点击操作。 | *   **任务执行:**  调用 `
        │   │       ├── hollow_zero_config.py    这个 Python 文件的主要功能是定义和管理 "空洞零" 游戏模块的配置。 |  | 核心类和函数： |  | *   **HollowZeroExtraTask**:  一个枚举，定义了额外的任务选项，例如 "不进行"、"刷满业绩点" 和 "刷满周期奖励"。 | *   **HollowZeroExtraExitEnum**:  一个枚举，定义了额外的退出条件，例如 "通关"、"2层业绩后退出" 和 "3层业绩后退出"。 | *   **HollowZeroConfig**:  继承自 `YamlConfig`，负责加载、保存和管理 "空洞零" 模块的配置。它包含多个属性，用于访问和修改配置项。 |  | 重要功能点： |  | *   使用 `YamlConfig` 处理配置文件的加载和保存。 | *   定义了多个配置属性，例如 `mission_name`, `challenge_config`, `weekly_plan_times`, `daily_plan_times`, `extra_task` 和 `extra_exit`，每个属性都有 getter 和 setter 方法。 | *   使用枚举 `HollowZeroExtraTask` 和 `HollowZeroExtraExitEnum` 来定义额外的任务和退出选项，增强了配置的可读性和可维护性。 | *   `challenge_config_adapter` 属性提供了一个 `YamlConfigAdapter` 实例，用于适配 `challenge_config` 配置项。
        │   │       ├── hollow_zero_debug_app.py    这个 Python 文件定义了一个名为 `HollowZeroDebugApp` 的应用程式，用于调试零号空洞相关的功能。 |  | *   **主要功能:** 启动并运行零号空洞的调试流程。 | *   **核心类:** |     *   `HollowZeroDebugApp`: 继承自 `ZApplication`，负责初始化应用程式，设置任务名称和类型，并触发零号空洞的自动运行。 | *   **核心函数:** |     *   `__init__`: 初始化应用程式，设置应用程式 ID、名称和运行记录。 |     *   `handle_init`: 根据配置初始化任务名称和类型。 |     *   `auto_run`: 使用 `HollowRunner` 执行零号空洞的流程，并返回结果。 | *   **重要功能点:** |     *   初始化任务信息。 |     *   使用 `HollowRunner` 运行零号空洞的逻辑。 |     *   使用 `@operation_node` 装饰器标记 `auto_run` 函数为起始节点。
        │   │       └── hollow_zero_run_record.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `HollowZeroRunRecord` 类，用于管理和跟踪游戏 "Hollow Zero" 的运行状态，包括每日和每周的运行次数、完成状态以及相关的配置信息。 |  | **核心类和函数:** |  | *   **`HollowZeroRunRecord`**: 继承自 `AppRunRecord`，用于记录和管理 Hollow Zero 的运行状态。 |     *   `__init__`: 初始化函数，设置运行记录的类型、实例索引和游戏刷新时间偏移。 |     *   `run_status_under_now`:  根据当前时间计算并返回当前的运行状态（等待、成功）。 |     *   `check_and_update_status`:  检查并更新运行状态，包括重置记录。 |     *   `reset_for_weekly`: 重置每周的运行次数、每日运行次数和相关状态。 |     *   `weekly_run_times`: 属性，用于获取和设置每周的运行次数。 |     *   `daily_run_times`: 属性，用于获取和设置每日的运行次数。 |     *   `add_times`: 增加通关次数。 |     *   `add_daily_times`: 增加每日进入次数。 |     *   `is_finished_by_times`: 检查是否已完成（基于运行次数）。 |     *   `is_finished_by_weekly_times`: 检查是否已完成（基于每周运行次数）。 |     *   `is_finished_by_day`: 检查是否已完成（基于每日）。 |     *   `is_finished_by_week`: 检查是否已完成（基于每周）。 |     *   `no_eval_point`: 属性，用于获取和设置是否获得评估点。 |     *   `period_reward_complete`: 属性，用于获取和设置周期奖励是否完成。 |  | **重要功能点:** |  | *   跟踪每日和每周的运行次数。 | *   根据配置和运行次数判断是否完成。 | *   根据时间（日、周）重置运行状态。 | *   支持额外的任务类型（评估点、周期奖励）。 | *   提供方法来增加运行次数和每日进入次数。
        │   ├── life_on_line/
        │   │   ├── life_on_line_app.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 脚本定义了一个自动化应用程序 `LifeOnLineApp`，用于在游戏中执行“真拿命验收”任务的自动化流程。它通过一系列操作节点，模拟用户操作，完成任务的循环执行，直到达到设定的次数或遇到特定情况。 |  | **核心类和函数:** |  | *   **`LifeOnLineApp(ZApplication)`:**  核心类，继承自 `ZApplication`，负责整个自动化流程的控制。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用程序，设置运行记录等。 |     *   `tp(self)`: 传送操作。 |     *   `wait_world(self)`: 等待加载。 |     *   `interact(self)`: 交互操作。 |     *   `enter_mission(self)`: 进入副本。 |     *   `wait_battle_screen(self)`: 等待战斗画面加载。 |     *   `run_key_sim(self)`: 模拟按键操作。 |     *   `interact_after_mission(self)`: 通关后的交互。 |     *   `talk_after_mission(self)`: 通关后的对话。 |     *   `click_finished(self)`: 点击完成。 |     *   `check_times(self)`: 检查运行次数。 |     *   `back_to_world(self)`: 返回大世界。 |     *   `fail_to_interact(self)`: 交互失败处理。 |     *   `click_exit_battle(self)`: 点击退出战斗。 |     *   `click_exit_battle_confirm(self)`: 点击退出战斗确认。 | *   **`ZContext`:**  上下文对象，包含游戏环境的各种信息。 | *   **`LifeOnLineRunRecord`:**  运行记录，用于跟踪任务的执行次数和状态。 | *   **`OperationRoundResult`:**  操作结果类，用于表示操作的成功与否及状态。 |  | **重要功能点:** |  | *   **流程控制:**  使用 `@node_from` 和 `@operation_node` 装饰器定义操作节点，构建任务流程图，实现自动化流程。 | *   **图像识别:**  使用 `self.
        │   │   ├── life_on_line_config.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 这个文件定义了 `LifeOnLineConfig` 类，用于管理 "life_on_line" 模块的配置，这些配置储存在 YAML 文件中。它提供了访问和修改配置参数的接口。 |  | **核心类和函数:** |  | *   `LifeOnLineConfig`: 继承自 `YamlConfig`，负责加载、保存和管理 "life\_on\_line" 模块的配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化配置，指定模块名称和实例索引。 |     *   `daily_plan_times` (property):  获取和设置每日计划次数。 |     *   `daily_plan_times_adapter` (property):  提供 `daily_plan_times` 的配置适配器，用于在 UI 中显示和编辑配置。 |     *   `predefined_team_idx` (property):  获取和设置预定义队伍的索引。 |     *   `predefined_team_idx_adapter` (property):  提供 `predefined_team_idx` 的配置适配器。 |  | **重要功能点:** |  | *   使用 `YamlConfig` 处理 YAML 配置文件。 | *   使用 property 实现配置参数的获取和设置，提供简洁的 API。 | *   使用 `YamlConfigAdapter` 为配置参数提供 UI 适配器，方便在界面中进行配置。 | *   定义了 `daily_plan_times` 和 `predefined_team_idx` 两个重要的配置参数。
        │   │   └── life_on_line_run_record.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了 `LifeOnLineRunRecord` 类，用于记录和管理游戏 "life_on_line" 的运行记录，包括每日运行次数。 |  | **核心类和函数:** |  | *   `LifeOnLineRunRecord`: 继承自 `AppRunRecord`，用于记录游戏的运行状态。 |     *   `__init__`: 初始化 `LifeOnLineRunRecord`，接收 `LifeOnLineConfig` 实例。 |     *   `reset_record`: 重置运行记录，包括每日运行次数。 |     *   `daily_run_times`: 属性，用于获取和设置每日运行次数。 |     *   `add_times`: 增加每日运行次数。 |     *   `is_finished_by_times`: 检查是否已达到每日运行次数上限。 |  | **重要功能点:** |  | *   记录和管理游戏的每日运行次数。 | *   提供方法增加运行次数。 | *   提供方法判断是否达到每日运行次数上限，依据 `LifeOnLineConfig` 中的配置。
        │   ├── miscellany/
        │   │   ├── miscellany_app.py    这个 Python 文件定义了 `MiscellanyApp` 类，它是一个应用程序，用于管理其他子应用程序。 |  | *   **主要功能:** 管理和执行其他应用程序，例如兑换码、邮件和在线生命应用程序。它还负责初始化、获取和更新子应用程序的运行顺序。 | *   **核心类和函数:** |     *   `MiscellanyApp`: 继承自 `OneDragonApp` 和 `ZApplication`，是主要应用程序类。 |     *   `__init__(self, ctx: ZContext)`: 应用程序的构造函数，初始化应用程序 ID 和操作。 |     *   `handle_init(self) -> None`: 初始化应用程序实例。 |     *   `get_app_list(self) -> List[ZApplication]`: 返回子应用程序的列表。 |     *   `get_app_order_list(self) -> List[str]`: 获取子应用程序的运行顺序。 |     *   `update_app_order_list(self, new_app_orders: List[str]) -> None`: 更新子应用程序的运行顺序。 | *   **重要功能点:** |     *   管理子应用程序的生命周期和执行顺序。 |     *   使用 `ZContext` 获取配置和上下文信息。 |     *   提供用于获取和更新应用程序运行顺序的方法。 |     *   包含一个 `__debug()` 函数，用于测试和调试应用程序。
        │   │   ├── miscellany_config.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 这个文件定义了 `MiscellanyConfig` 类，用于管理与杂项配置相关的设置，特别是应用程序的运行顺序和运行列表。它使用 `YamlConfig` 类来加载和保存配置数据。 |  | **核心类和函数:** |  | *   **`MiscellanyConfig`**:  继承自 `YamlConfig`，负责处理杂项配置。 |     *   `__init__(self, instance_idx: Optional[int] = None)`:  初始化配置，指定配置文件的名称。 |     *   `app_order` (property):  获取和设置应用程序的运行顺序 (List[str])。 |     *   `move_up_app(self, app_id: str)`:  将指定应用程序的运行顺序往前调一位。 |     *   `app_run_list` (property):  获取和设置应用程序的运行列表 (List[str])。 |     *   `set_app_run(self, app_id: str, to_run: bool)`:  根据 `to_run` 参数，将应用程序添加到或从运行列表中移除。 |  | **重要功能点:** |  | *   管理应用程序的运行顺序，允许调整应用程序的执行顺序。 | *   控制哪些应用程序应该运行，通过 `app_run_list` 实现。 | *   使用 `YamlConfig` 类来加载和保存配置，使得配置可以持久化。
        │   │   └── miscellany_run_record.py    这个 Python 文件定义了一个名为 `MiscellanyRunRecord` 的类，用于记录和管理杂项应用程序的运行状态。 |  | *   **主要功能:** 记录杂项应用程序的运行状态，并提供相关的状态检查和更新功能。 | *   **核心类:** `MiscellanyRunRecord` 继承自 `AppRunRecord`。 | *   **重要功能点:** |     *   `__init__`: 初始化 `MiscellanyRunRecord` 实例，并调用父类 `AppRunRecord` 的初始化方法。 |     *   `check_and_update_status`: 重置运行记录。 |     *   `run_status_under_now`: 始终返回 `AppRunRecord.STATUS_WAIT`，表示应用程序始终处于等待状态。
        │   ├── notorious_hunt/
        │   │   ├── notorious_hunt_app.py    这个 Python 文件定义了 `NotoriousHuntApp` 类，它是一个用于处理《原神》游戏中恶名狩猎活动的应用程式。 |  | **主要功能:** |  | *   自动执行恶名狩猎任务。 | *   领取恶名狩猎的奖励。 | *   处理任务流程中的各种状态和错误。 |  | **核心类和函数:** |  | *   `NotoriousHuntApp`: 继承自 `ZApplication`，是恶名狩猎应用程式的主类。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用程式，设置应用程式 ID 和运行记录。 |     *   `handle_init(self) -> None`: 执行前的初始化。 |     *   `transport(self) -> OperationRoundResult`: 传送到恶名狩猎地点。 |     *   `notorious_hunt(self) -> OperationRoundResult`: 执行恶名狩猎。 |     *   `check_left_times(self) -> OperationRoundResult`: 检查剩余次数。 |     *   `click_reward_entry(self) -> OperationRoundResult`: 点击奖励入口。 |     *   `claim_all(self) -> OperationRoundResult`: 领取所有奖励。 |     *   `back_to_world(self) -> OperationRoundResult`: 返回大世界。 |  | **重要功能点:** |  | *   使用 `operation_node` 装饰器定义任务流程中的节点。 | *   使用 `node_from` 装饰器定义节点之间的依赖关系。 | *   根据配置获取下一个恶名狩猎计划。 | *   处理恶名狩猎的剩余次数和奖励领取。 | *   使用 `TransportByCompendium`, `NotoriousHunt` 和 `BackToNormalWorld` 等操作类来执行具体的操作。
        │   │   ├── notorious_hunt_config.py    此 Python 文件定义了恶名狩猎（Notorious Hunt）的配置类，用于管理和存储游戏中的狩猎计划。 |  | *   **主要功能:** 加载、保存和管理恶名狩猎的计划，包括计划的更新、移动、重置和获取下一个计划。 | *   **核心类和函数:** |     *   `NotoriousHuntLevelEnum`: 定义了恶名狩猎的等级枚举。 |     *   `NotoriousHuntBuffEnum`: 定义了恶名狩猎的 Buff 枚举。 |     *   `NotoriousHuntConfig`: 继承自 `YamlConfig`，用于加载和保存恶名狩猎的配置。 |         *   `__init__`: 初始化配置，加载计划列表，并处理版本兼容性问题。 |         *   `_get_default_plan`: 获取默认的周本计划。 |         *   `save`: 保存配置到 YAML 文件。 |         *   `update_plan`: 更新指定索引的计划。 |         *   `move_up`: 向上移动计划的顺序。 |         *   `reset_plans`: 重置所有计划的运行次数。 |         *   `get_next_plan`: 获取下一个需要执行的计划。 |         *   `add_plan_run_times`: 为匹配的计划增加运行次数。 |         *   `_is_same_plan`: 检查两个计划是否相同。 | *   **重要功能点:** |     *   从 YAML 文件加载和保存狩猎计划。 |     *   支持计划的更新、排序和重置。 |     *   提供获取下一个计划的逻辑。 |     *   处理计划的运行次数。 |     *   包含版本兼容性处理，例如更新 TAB 名称。
        │   │   └── notorious_hunt_run_record.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了 `NotoriousHuntRunRecord` 类，用于记录和管理「恶名追捕」游戏的运行记录。它继承自 `AppRunRecord`，并扩展了其功能以适应游戏的特定需求。 |  | **核心类和函数:** |  | *   `NotoriousHuntRunRecord`: 核心类，用于管理恶名追捕的运行记录。 |     *   `__init__(self, instance_idx: Optional[int] = None, game_refresh_hour_offset: int = 0)`: 构造函数，初始化运行记录，设置游戏类型、实例索引、刷新时间偏移和记录周期。 |     *   `reset_record(self) -> None`: 重置记录，包括调用父类的重置方法，并将剩余次数重置为 3。 |     *   `run_status_under_now`: 属性，根据当前时间和剩余次数返回游戏的运行状态（等待、运行中、成功）。 |     *   `left_times`: 属性，用于获取和设置剩余游戏次数。 |  | **重要功能点:** |  | *   记录游戏的运行状态，包括是否需要重置和剩余次数。 | *   提供 `reset_record` 方法，用于重置游戏记录。 | *   使用 `AppRunRecordPeriod.WEEKLY` 作为记录周期。 | *   使用 `left_times` 属性来跟踪玩家剩余的游戏次数。
        │   ├── predefined_team_checker/
        │   │   └── predefined_team_checker.py    这个 Python 脚本 `predefined_team_checker.py` 实现了在游戏中识别预定义编队角色的功能。 |  | **主要功能:** |  | *   识别游戏中的预定义编队角色，并将其与配置的编队信息进行匹配。 | *   通过 OCR 识别编队名称和角色头像，然后匹配角色模板。 | *   支持在屏幕上滑动以识别更多角色。 |  | **核心类和函数:** |  | *   **`TeamWrapper`**: 封装编队名称和角色列表。 | *   **`PredefinedTeamChecker`**: 继承自 `ZApplication`，是主要的功能类。 |     *   `__init__`: 初始化，设置应用 ID 和重试选项。 |     *   `goto_menu`: 前往游戏菜单画面。 |     *   `goto_menu_more`: 前往更多功能画面。 |     *   `click_predefined_team`: 点击预备编队按钮。 |     *   `check_team_members`: 识别编队角色，包括截图、更新角色信息和滑动屏幕。 |     *   `update_team_members`: 使用 OCR 识别编队名称和角色头像，并更新编队成员信息。 | *   `__debug()`: 测试函数，用于初始化上下文并运行 `PredefinedTeamChecker`。 |  | **重要功能点:** |  | *   使用 `operation_node` 装饰器定义操作流程，例如前往菜单、点击按钮等。 | *   使用 OCR 识别编队名称和角色头像。 | *   使用模板匹配来识别角色。 | *   支持屏幕滑动以获取更多编队信息。 | *   将识别到的角色信息更新到 `team_config` 中。
        │   ├── random_play/
        │   │   ├── random_play_app.py    ```python | 摘要: |  | 该 Python 脚本定义了一个名为 RandomPlayApp 的 ZApplication 类，用于在游戏中执行影像店营业的随机播放功能。 |  | 核心类和函数: |  | *   **RandomPlayApp**: 继承自 ZApplication，负责随机播放流程的控制。 |     *   `__init__`: 初始化应用程式，设置应用程式 ID、名称、运行记录等。 |     *   `handle_init`: 初始化，设置录像带主题列表和需要的主题列表。 |     *   `transport`: 传送到指定地点。 |     *   `wait_world`: 等待世界加载。 |     *   `move_and_interact`: 移动和交互。 |     *   `wait_run`: 等待经营画面加载。 |     *   `check_running`: 检查营业状态。 |     *   `click_promoter_entry`: 点击宣传员入口。 |     *   `choose_promoter`: 选择宣传员，支持随机选择和名称/头像匹配。 |     *   `get_pos_by_avatar`: 根据头像匹配宣传员位置。 |     *   `check_video_theme`: 识别录像带主题。 |     *   `click_video_entry`: 点击录像带入口。 |     *   `check_recommended`: 检查推荐上架。 |     *   `click_filter`: 点击上架筛选。 |     *   `choose_theme`: 选择主题。 |     *   `choose_onshelf`: 上架。 |     *   `back`: 返回。 |     *   `start`: 开始营业。 |     *   `confirm`: 确认开始营业。 |     *   `back_to_world`: 返回大世界。 |  | 重要功能点: |  | *   流程控制：使用 operation\_node 装饰器定义了游戏操作的流程，包括传送、等待、交互、检查状态、选择宣传员、选择主题、上架等。 | *   宣传员选择：支持随机选择宣传员，以及通过名称和头像匹配宣传员。 | *   主题识别与筛选：识别录像带主题，并根据主题进行筛选和上架。
        │   │   ├── random_play_config.py    这个 Python 文件定义了 `RandomPlayConfig` 类，用于管理随机游戏配置。 |  | *   **主要功能:** 读取和管理随机游戏的配置参数，例如 agent 的名称。 | *   **核心类:** `RandomPlayConfig` 继承自 `YamlConfig`，用于处理 YAML 配置文件。 | *   **重要功能点:** |     *   `__init__`: 初始化配置，指定模块名称和实例索引。 |     *   `random_agent_name()`: 静态方法，返回默认的 agent 名称 "随机"。 |     *   `agent_name_1` 和 `agent_name_2`: 属性，用于获取和设置 agent 的名称，从配置文件中读取，如果不存在则使用默认值。
        │   │   └── random_play_run_record.py    这个 Python 文件定义了 `RandomPlayRunRecord` 类，用于记录随机游戏的运行信息。 |  | *   **核心类:** `RandomPlayRunRecord` 继承自 `AppRunRecord`。 | *   **主要功能:** 记录随机游戏的运行，并初始化时设定游戏实例索引和游戏刷新小时偏移量。 | *   **重要功能点:**  `__init__` 方法初始化 `RandomPlayRunRecord` 实例，并调用父类 `AppRunRecord` 的初始化方法，设定应用名称为 'random\_play'。
        │   ├── redemption_code/
        │   │   ├── redemption_code_app.py    **摘要:** |  | 该文件定义了一个名为 `RedemptionCodeApp` 的应用程序，用于自动兑换游戏中的兑换码。它继承自 `ZApplication`，并使用一系列操作节点来完成兑换流程。 |  | **核心类和函数:** |  | *   **`RedemptionCodeApp(ZContext)`**:  主应用程序类，负责整个兑换码兑换流程的控制。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用程序，包括设置应用程序 ID、名称和运行记录。 |     *   `check_new_code(self) -> OperationRoundResult`: 检查是否有新的兑换码。 |     *   `open_menu(self) -> OperationRoundResult`: 打开游戏菜单。 |     *   `click_more(self) -> OperationRoundResult`: 点击“更多”按钮。 |     *   `click_code(self) -> OperationRoundResult`: 点击“兑换码”按钮。 |     *   `input_code(self) -> OperationRoundResult`: 输入兑换码。 |     *   `confirm_code(self) -> OperationRoundResult`: 确认兑换码兑换。 |     *   `back(self) -> OperationRoundResult`: 返回到正常游戏世界。 | *   **`ZContext`**:  游戏上下文，包含游戏状态和配置信息。 | *   **`OpenMenu`, `BackToNormalWorld`**:  用于打开菜单和返回正常世界的辅助操作类。 |  | **重要功能点:** |  | *   自动从 `redemption_code_record` 中获取未使用的兑换码列表。 | *   通过模拟点击和 OCR 识别来导航游戏界面，找到兑换码输入框和兑换按钮。 | *   使用键盘输入兑换码。 | *   处理兑换成功和失败的情况，并更新兑换码使用记录。 | *   提供一个调试函数 `__debug()` 用于测试。
        │   │   └── redemption_code_run_record.py    这个 Python 文件的主要功能是管理和追踪兑换码的运行记录。 |  | 核心类和函数： |  | *   **RedemptionCode**:  一个数据类，用于表示兑换码及其失效日期。 | *   **RedemptionCodeRunRecord**:  继承自 `AppRunRecord`，用于管理兑换码的运行状态。 |     *   `__init__`: 初始化，包含有效的兑换码列表。 |     *   `run_status_under_now`: 根据当前日期和未使用的兑换码列表，返回运行状态。 |     *   `check_and_update_status`: 检查并更新运行状态，如果存在未使用的兑换码，则重置记录。 |     *   `used_code_list`:  属性，用于获取和设置已使用的兑换码列表。 |     *   `get_unused_code_list(dt: str)`:  根据日期获取未使用的兑换码列表。 |     *   `add_used_code(code: str)`:  将兑换码添加到已使用列表中。 |  | 重要功能点： |  | *   管理有效的兑换码列表。 | *   根据当前日期和已使用列表，计算未使用的兑换码。 | *   追踪和更新兑换码的运行状态。 | *   记录已使用的兑换码。
        │   ├── ridu_weekly/
        │   │   ├── ridu_weekly_app.py    这个 Python 脚本定义了一个名为 `RiduWeeklyApp` 的应用程序，用于自动化丽都周纪的游戏任务。 |  | **核心类和函数:** |  | *   `RiduWeeklyApp`: 继承自 `ZApplication`，是应用程序的主要类。 |     *   `__init__`: 初始化应用程序，设置应用程序 ID、名称、运行记录和重试选项。 |     *   `open_compendium`: 打开快捷手册。 |     *   `choose_train`: 选择日常。 |     *   `click_schedule`: 点击丽都周纪。 |     *   `claim_score`: 领取积分。 |     *   `confirm_schedule`: 领取奖励。 |     *   `finish`: 完成任务并返回。 | *   `ZContext`: 游戏上下文，提供游戏环境信息。 | *   `OpenCompendium`: 打开快捷手册的操作。 | *   `BackToNormalWorld`: 返回正常世界的操作。 |  | **重要功能点:** |  | *   自动化丽都周纪任务流程，包括打开快捷手册、选择日常、点击丽都周纪、领取积分和奖励，以及完成任务。 | *   使用 `operation_node` 和 `node_from` 装饰器定义任务流程中的节点和依赖关系。 | *   使用 `round_by_op_result`, `round_by_goto_screen`, `round_by_find_and_click_area`, `round_by_ocr_and_click` 等方法处理游戏交互和流程控制。 | *   包含重试机制，以处理游戏中的错误或异常情况。 | *   `__debug` 函数用于测试和调试应用程序。
        │   │   └── ridu_weekly_run_record.py    这个 Python 文件定义了 `RiduWeeklyRunRecord` 类，用于记录和管理 "ridu_weekly" 应用程序的运行记录。 |  | *   **核心类:** `RiduWeeklyRunRecord` 继承自 `AppRunRecord`。 | *   **核心函数:** `__init__` 函数用于初始化 `RiduWeeklyRunRecord` 实例，并调用父类 `AppRunRecord` 的初始化函数。 | *   **重要功能点:** 该类主要用于记录 "ridu\_weekly" 应用程序的运行信息，包括实例索引和游戏刷新小时偏移量。
        │   ├── scratch_card/
        │   │   ├── scratch_card_app.py    **摘要:** |  | 该文件定义了 `ScratchCardApp` 类，用于实现游戏 "刮刮卡" 功能的自动化流程。它继承自 `ZApplication`，并使用一系列操作节点来完成刮刮卡相关的任务。 |  | **核心类和函数:** |  | *   `ScratchCardApp`:  继承自 `ZApplication`，负责整个刮刮卡流程的控制。 |     *   `__init__(self, ctx: ZContext)`: 初始化应用，设置应用 ID、名称、运行记录等。 |     *   `handle_init(self) -> None`: 初始化函数，目前为空。 |     *   `transport(self) -> OperationRoundResult`: 传送至指定地点。 |     *   `wait_world(self) -> OperationRoundResult`: 等待游戏世界加载。 |     *   `move_and_interact(self) -> OperationRoundResult`: 移动并交互。 |     *   `click_scratch_card(self) -> OperationRoundResult`: 点击刮刮卡。 |     *   `scratch(self) -> OperationRoundResult`: 执行刮刮操作。 |     *   `back_to_world(self) -> OperationRoundResult`: 返回大世界。 | *   `__debug()`: 用于调试的函数，创建 `ZContext` 和 `ScratchCardApp` 实例，并执行刮刮卡流程。 |  | **重要功能点:** |  | *   **流程控制:**  使用 `@operation_node` 和 `@node_from` 装饰器定义了流程的节点和依赖关系，构建了完整的刮刮卡自动化流程。 | *   **图像识别:**  使用 `round_by_find_area`, `round_by_find_and_click_area`, `round_by_ocr_and_click` 等方法进行图像识别和点击操作。 | *   **用户交互:**  使用 `ctx.controller` 控制角色移动和交互。 | *   **重试机制:**  使用 `node_max_retry_times` 和 `round_retry` 实现重试机制，提高流程的稳定性。 | *   **刮刮操作:**  通过模拟拖动操作实现刮刮卡功能。
        │   │   └── scratch_card_run_record.py    这个 Python 文件定义了一个名为 `ScratchCardRunRecord` 的类，用于记录刮刮卡游戏的运行记录。 |  | *   **主要功能**: 记录刮刮卡游戏的运行信息。 | *   **核心类**: `ScratchCardRunRecord` 继承自 `AppRunRecord`。 | *   **重要功能点**: |     *   `__init__` 方法初始化 `ScratchCardRunRecord` 实例，并调用父类 `AppRunRecord` 的初始化方法，设置游戏类型为 'scratch\_card'，并处理实例索引和游戏刷新时间偏移量。
        │   └── shiyu_defense/
        │       ├── shiyu_defense_app.py    ## 摘要 |  | 该 Python 文件定义了 `ShiyuDefenseApp` 类，用于自动化式舆防卫战的流程。 |  | **主要功能:** |  | *   自动化式舆防卫战的流程，包括传送、选择节点、识别弱点、选择配队、出战、自动战斗、领取奖励等。 |  | **核心类和函数:** |  | *   `ShiyuDefenseApp`: 继承自 `ZApplication`，负责式舆防卫战的整体流程控制。 |     *   `tp()`: 传送。 |     *   `wait_loading()`: 等待画面加载。 |     *   `choose_node_idx()`: 选择节点。 |     *   `check_weakness()`: 识别弱点并计算配队。 |     *   `choose_team()`: 选择配队。 |     *   `deploy()`: 出战。 |     *   `shiyu_battle()`: 自动战斗。 |     *   `to_next_node()`: 进入下一节点。 |     *   `all_node_finished()`: 所有节点完成。 |     *   `claim_reward()`: 领取奖励。 |     *   `close_reward()`: 关闭奖励。 |     *   `back_after_all()`: 结束后返回。 | *   `ShiyuDefenseBattle`: 封装了战斗逻辑。 | *   `DefensePhaseTeamInfo`: 存储每个阶段的配队信息。 |  | **重要功能点:** |  | *   根据游戏画面识别节点和弱点，并选择合适的配队。 | *   自动进行战斗，并根据战斗结果进行后续操作。 | *   处理战斗失败的情况。 | *   领取奖励。 | *   使用 `operation_node` 装饰器定义流程中的每个步骤。 | *   使用 `node_from` 装饰器定义节点之间的依赖关系。 | *   使用 `ZContext` 管理游戏上下文信息。
        │       ├── shiyu_defense_battle.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 文件定义了 `ShiyuDefenseBattle` 类，用于在游戏“式舆防卫战”中执行自动战斗。它通过加载自动战斗指令、等待战斗画面、移动角色、自动战斗、处理战斗结果（包括胜利、失败和超时）以及退出战斗等步骤来实现自动战斗流程。 |  | **核心类和函数:** |  | *   **`ShiyuDefenseBattle(ZContext, predefined_team_idx)`:**  主类，继承自 `ZOperation`，负责整个式舆防卫战的自动战斗流程。 |     *   `__init__`: 初始化函数，设置上下文、预设队伍信息，并初始化相关变量。 |     *   `load_auto_op`: 加载自动战斗指令。 |     *   `wait_battle_screen`: 等待战斗画面加载。 |     *   `start_move`: 移动角色到战斗位置。 |     *   `auto_battle`: 执行自动战斗，并根据战斗状态进行处理。 |     *   `move_after_battle`: 战斗结束后移动。 |     *   `check_distance`: 检查角色与目标的距离。 |     *   `battle_timeout`: 处理战斗超时情况。 |     *   `voluntary_exit`: 主动退出战斗。 |     *   `click_exit`, `click_exit_confirm`: 点击退出战斗相关的按钮。 |     *   `battle_fail_exit`: 处理战斗失败撤退的情况。 |     *   `wait_exit`: 等待退出战斗。 |     *   `_on_pause`, `_on_resume`: 处理暂停和恢复操作。 |     *   `after_operation_done`: 在操作完成后停止自动战斗。 |  | **重要功能点:** |  | *   **自动战斗流程:**  定义了完整的自动战斗流程，包括加载指令、等待画面、移动、战斗、处理结果和退出。 | *   **状态管理:**  使用 `OperationRoundResult` 和状态字符串（例如 `STATUS_NEED_SPECIAL_MOVE`, `STATUS_FAIL_TO_MOVE`）来管理和控制流程。 | *   **移动控制:**  根据距离信息控制角色的移动。 | *   **战斗结果处理:**  处理战斗胜利、失败、超时等不同情况，并采取相应的操作。 | *
        │       ├── shiyu_defense_config.py    此 Python 文件定义了式舆防卫战的配置类，用于管理和存储游戏中的队伍配置信息。 |  | *   **核心类:** |     *   `ShiyuDefenseTeamConfig`:  表示单个队伍的配置，包含队伍索引、是否参与剧变节点以及弱点列表。 |     *   `ShiyuDefenseConfig`: 继承自 `YamlConfig`，负责加载、保存和管理所有队伍的配置。 |  | *   **重要功能点:** |     *   `init_team_list()`: 从配置文件中初始化队伍配置。 |     *   `save_team_list()`: 将队伍配置保存到配置文件。 |     *   `get_config_by_team_idx()`: 根据队伍索引获取队伍配置。 |     *   `add_weakness()`/`remove_weakness()`:  添加/移除队伍的弱点。 |     *   `change_for_critical()`: 修改队伍是否参与剧变节点。 |     *   `critical_max_node_idx`:  获取和设置剧变节点的最大索引。
        │       ├── shiyu_defense_run_record.py    这个 Python 文件定义了 `ShiyuDefenseRunRecord` 类，用于记录和管理名为 "shiyu_defense" 的应用程序的运行状态。 |  | **主要功能：** |  | *   记录和管理 "shiyu\_defense" 应用程序的运行状态，包括剧变节点的完成情况。 | *   提供方法来获取下一个需要挑战的节点索引，添加已完成的节点，以及重置记录。 |  | **核心类和函数：** |  | *   `CriticalNode`:  表示剧变节点的数据结构，包含节点数、开始时间和结束时间。 | *   `ShiyuDefenseRunRecord(AppRunRecord)`:  继承自 `AppRunRecord`，用于记录 "shiyu\_defense" 应用程序的运行状态。 |     *   `__init__(self, config: ShiyuDefenseConfig, instance_idx: Optional[int] = None, game_refresh_hour_offset: int = 0)`:  初始化方法，设置配置和实例索引。 |     *   `run_status_under_now`:  根据当前时间获取运行状态。 |     *   `next_node_idx()`:  获取下一个需要挑战的节点索引。 |     *   `add_node_finished(self, node_idx: int)`:  将节点标记为已完成。 |     *   `critical_history`:  获取已完成的剧变节点列表。 |     *   `reset_record()`:  重置运行记录。 |  | **重要功能点：** |  | *   管理剧变节点的完成历史。 | *   根据配置和当前时间确定应用程序的运行状态。 | *   提供方法来更新和查询节点的完成情况。
        │       └── shiyu_defense_team_utils.py    此 Python 文件实现了式舆防卫战的配队逻辑。 |  | **主要功能：** |  | *   根据游戏画面识别弱点和抗性，并为每个阶段选择最佳队伍。 |  | **核心类和函数：** |  | *   `DefensePhaseTeamInfo`: 存储每个阶段的队伍信息，包括弱点、抗性、队伍下标和得分计算。 |     *   `cal_score`: 计算队伍的得分，基于与弱点和抗性的匹配程度。 |     *   `score`: 返回队伍的得分。 | *   `DefenseTeamSearcher`: 负责搜索最佳配队。 |     *   `search`: 执行深度优先搜索 (DFS) 以找到最佳队伍组合。 |     *   `dfs`: 递归搜索，尝试不同的队伍组合，并使用剪枝优化。 |     *   `compare_and_save_best`: 比较当前结果与最佳结果，并更新最佳结果。 |     *   `no_way_better`: 剪枝函数，判断当前搜索分支是否可能找到更优解。 |     *   `is_team_conflict`: 检查两支队伍的代理人是否冲突。 | *   `calc_teams`: 主函数，用于计算配队。 |     *   识别每个阶段的弱点和抗性。 |     *   创建 `DefenseTeamSearcher` 实例并调用 `search` 方法。 | *   `check_type_by_area`: 识别特定区域的属性类型。 |  | **重要功能点：** |  | *   **深度优先搜索 (DFS)**：使用 DFS 算法搜索最佳队伍组合。 | *   **剪枝优化**:  `no_way_better` 函数用于优化搜索过程。 | *   **得分计算**:  `cal_score` 函数根据队伍与弱点和抗性的匹配程度计算得分。 | *   **冲突检测**:  `is_team_conflict` 函数用于避免选择代理人冲突的队伍。 | *   **OCR 识别**:  `check_type_by_area` 函数使用 OCR 技术识别游戏画面中的属性类型。
        ├── auto_battle/
        │   ├── auto_battle_agent_context.py    ```python | """ | 文件摘要： |  | 此文件定义了 `AutoBattleAgentContext` 类，用于在自动战斗中管理和识别角色状态。它使用多线程来并行处理图像识别任务，并维护一个 `TeamInfo` 对象来跟踪队伍中的角色信息。 |  | 核心类和函数： |  | *   `AutoBattleAgentContext`:  管理自动战斗中的角色信息和状态。 |     *   `init_battle_agent_context`: 初始化自动战斗上下文，包括角色列表和需要检测的状态。 |     *   `check_agent_related`:  识别角色相关信息，并更新状态。 |     *   `_check_agent_in_parallel`: 并发识别角色头像。 |     *   `_check_agent_state_in_parallel`: 并发识别角色状态。 |     *   `switch_next_agent`, `switch_prev_agent`: 切换角色。 |     *   `chain_left`, `chain_right`: 连携技切换。 | *   `TeamInfo`:  管理队伍中的角色信息，包括角色列表、能量、特殊技和终结技状态。 |     *   `update_agent_list`: 更新角色列表。 |     *   `is_same_agent_list`:  判断角色列表是否一致。 |     *   `switch_next_agent`, `switch_prev_agent`: 切换角色。 |     *   `get_agent_pos`: 获取角色在队伍中的位置。 | *   `AgentInfo`:  存储单个角色的信息，包括角色对象、能量、特殊技和终结技状态。 | *   `CheckAgentState`:  封装需要检查的角色状态信息。 |  | 重要功能点： |  | *   **角色识别**:  通过图像识别和模板匹配来识别角色。 | *   **状态检测**:  检测角色的能量、特殊技、终结技状态，以及其他自定义状态。 | *   **多线程**: 使用 `ThreadPoolExecutor` 并发执行图像识别和状态检测任务，提高效率。 | *   **角色切换**:  提供切换角色功能，并更新状态。 | *   **连携技支持**:  支持连携技的切换。 | *   **状态更新**:  将识别到的状态更新到 `ConditionalOperator` 中。 | """ | ```
        │   ├── auto_battle_context.py    **1. 主要功能:** |  | *   `AutoBattleContext` 类别负责管理游戏中的自动战斗逻辑，包括控制角色动作、识别战斗状态、处理闪避、切换角色、识别连携技和快速支援等。 | *   它整合了 `AutoBattleAgentContext`、`AutoBattleDodgeContext` 和 `AutoBattleCustomContext`，以实现更复杂的自动战斗行为。 |  | **2. 核心类和函数:** |  | *   **`AutoBattleContext` 类:** |     *   `__init__(self, ctx: ZContext)`: 初始化上下文，包括子上下文、锁、计时器和状态变量。 |     *   `dodge()`, `switch_next()`, `switch_prev()`, `normal_attack()`, `special_attack()`, `ultimate()`, `chain_left()`, `chain_right()`, `move_w()`, `move_s()`, `move_a()`, `move_d()`, `lock()`, `chain_cancel()`:  控制角色在战斗中的各种动作。 |     *   `quick_assist()`, `switch_by_name()`: 处理快速支援和切换角色。 |     *   `init_battle_context()`: 初始化自动战斗的配置，包括子上下文的初始化和识别区域的加载。 |     *   `check_battle_state()`: 核心函数，用于识别战斗状态，包括是否在战斗中、战斗是否结束、以及其他状态的识别。 |     *   `check_chain_attack()`, `check_quick_assist()`, `_check_battle_end()`, `check_battle_distance()`:  用于识别特定战斗状态的函数。 |     *   `is_normal_attack_btn_available()`: 快速判断是否在战斗画面。 |     *   `start_context()`, `stop_context()`: 启动和停止上下文。 | *   **`AutoBattleAgentContext` 类:** (由 `AutoBattleContext` 实例化) 处理与角色代理相关的逻辑。 | *   **`AutoBattleDodgeContext` 类:** (由 `AutoBattleContext` 实例化) 处理闪避相关的
        │   ├── auto_battle_custom_context.py    这个 Python 文件 `auto_battle_custom_context.py` 实现了一个用于自动战斗的自定义上下文。 |  | *   **主要功能:** 提供设置和清除战斗状态的功能，这些状态用于控制自动战斗的行为。 | *   **核心类:** `AutoBattleCustomContext` | *   **核心函数:** |     *   `__init__(self, ctx: ZContext)`: 初始化上下文，接收一个 `ZContext` 对象和一个模拟的 `ConditionalOperator`。 |     *   `init_battle_custom_context(self, auto_op: ConditionalOperator)`: 初始化自动操作，接收一个 `ConditionalOperator`。 |     *   `set_state(self, state_name_list: List[str], time_diff: float, time_diff_add: float, value: int, value_add: int)`: 设置多个状态，可以指定触发时间、状态值和叠加值。 |     *   `clear_state(self, state_name_list: List[str])`: 清除多个状态。 | *   **重要功能点:** |     *   使用 `ConditionalOperator` 管理状态。 |     *   支持批量设置和清除状态，提高效率。 |     *   状态设置包含时间偏移量，允许在未来触发状态变化。
        │   ├── auto_battle_dodge_context.py    ## 代码摘要 |  | **1. 主要功能:** |  | 该文件定义了 `AutoBattleDodgeContext` 类，用于在游戏自动战斗中检测闪避时机。它通过分析屏幕截图中的闪光和录制音频来识别闪避信号，并结合 `ConditionalOperator` 来触发闪避操作。 |  | **2. 核心类和函数:** |  | *   **`AudioRecorder`**:  负责录制和处理音频数据，包括启动录制、停止录制、滤波处理和获取音频数据。 |     *   `start_running_async()`: 异步启动音频录制。 |     *   `_record_loop()`: 音频录制循环，持续录制音频数据。 |     *   `stop_running()`: 停止音频录制。 |     *   `clear_audio()`: 清除当前录音。 | *   **`AutoBattleDodgeContext`**:  管理闪避检测的上下文。 |     *   `init_battle_dodge_context()`: 初始化上下文，包括加载模型和设置识别间隔。 |     *   `check_dodge_flash()`: 识别屏幕截图中的闪光，并触发闪避。 |     *   `check_dodge_audio()`: 识别音频中的闪避提示，并触发闪避。 |     *   `start_context()`: 启动音频录制。 |     *   `stop_context()`: 停止音频录制。 |     *   `get_max_corr()`: 计算两个音频信号的最大相关性。 |     *   `_get_filter_wave()`: 音频滤波。 | *   **`YoloStateEventEnum`**: 定义了用于闪避识别的事件枚举。 |  | **3. 重要功能点:** |  | *   **异步音频录制**: 使用 `ThreadPoolExecutor` 异步录制音频，避免阻塞主线程。 | *   **闪光检测**: 使用 `FlashClassifier` 模型检测屏幕截图中的闪光。 | *   **音频检测**:  通过音频模板匹配和相关性分析来检测闪避提示。 | *   **事件去重**:  通过时间间隔控制音频事件的触发频率。 | *   **滤波处理**: 对音频数据进行高通滤波处理，提高识别准确性。 | *   **条件操作**: 使用 `ConditionalOperator` 来触发
        │   ├── auto_battle_operator.py    ```python | """ | 该文件定义了 `AutoBattleOperator` 类，用于实现游戏的自动战斗功能。 |  | 主要功能： |     *   加载自动战斗配置，根据配置执行一系列操作。 |     *   处理各种游戏事件，如躲避、切换角色、释放技能等。 |     *   周期性地执行锁定敌人和视角调整操作。 |  | 核心类和函数： |     *   `AutoBattleOperator`: 继承自 `ConditionalOperator`，负责自动战斗的逻辑控制。 |         *   `__init__`: 初始化，加载配置，创建 `AutoBattleContext`。 |         *   `init_before_running`: 运行前初始化，加载自动战斗配置。 |         *   `init_before_running_async`: 异步初始化。 |         *   `get_atomic_op`: 根据操作定义获取原子操作。 |         *   `get_state_handler_template`: 获取场景处理器模板。 |         *   `get_operation_template`: 获取操作模板。 |         *   `operate_periodically`: 周期性执行锁定和视角调整。 |         *   `start_running_async`: 启动自动战斗。 |         *   `stop_running`: 停止自动战斗。 |         *   `dispose`: 销毁资源。 |     *   `AutoBattleContext`: 自动战斗上下文，管理游戏状态和操作。 |     *   `AtomicOp`: 原子操作的基类，各种具体操作的父类。 |     *   `StateRecorder`: 状态记录器。 |     *   `get_all_state_event_ids`: 获取所有状态事件ID。 |     *   `is_valid_state`: 验证状态是否合法。 |  | 重要功能点： |     *   异步初始化和启动自动战斗。 |     *   使用 `ConditionalOperator` 框架处理条件操作。 |     *   支持多种原子操作，如移动、攻击、释放技能等。 |     *   周期性地执行锁定和视角调整。 |     *   通过配置文件定义自动战斗逻辑。 | """ | ```
        │   ├── auto_battle_state.py    这个 Python 文件的摘要如下： |  | *   **主要功能：** 定义了一个枚举 `BattleStateEnum`，用于表示游戏自动战斗中的各种状态，例如按键操作、技能可用状态等。 | *   **核心类和函数：** |     *   `BattleStateEnum` (Enum):  定义了战斗状态的枚举，包含各种按键操作和状态标识。 | *   **重要功能点：** |     *   定义了游戏中常用的按键操作，如闪避、切换角色、普通攻击、特殊攻击、终结技、连携技、移动、锁定敌人等。 |     *   定义了技能可用状态，如特殊攻击准备就绪、终结技准备就绪、连携技准备就绪、快速支援准备就绪等。
        │   ├── auto_battle_utils.py    这个 Python 文件的主要功能是提供自动战斗的工具函数。 |  | 核心类和函数： |  | *   `AutoBattleOperator`: 负责自动战斗的执行。 | *   `load_auto_op(op, auto_config_sub_dir, auto_config_name)`: 加载自动战斗指令，初始化 `AutoBattleOperator`。 | *   `load_auto_op_async(op, auto_config_sub_dir, auto_config_name)`: 异步加载自动战斗指令。 | *   `stop_running(auto_op)`: 停止自动战斗。 | *   `resume_running(auto_op)`: 恢复自动战斗。 | *   `check_astra_and_switch(auto_op, timeout_seconds)`: 检查是否需要切换角色，特别是针对耀佳音的情况。 |  | 重要功能点： |  | *   提供同步和异步方式加载自动战斗配置。 | *   提供停止和恢复自动战斗的功能。 | *   针对特定角色（耀佳音）提供额外的检查和切换逻辑，以避免卡住。
        │   ├── agent_state/
        │   │   └── agent_state_checker.py    ## 摘要 |  | **文件功能:** |  | 该 Python 文件定义了一系列函数，用于检测游戏中角色状态，主要通过图像处理技术（如颜色范围检测、模板匹配、灰度分析）来判断角色状态的各种属性，如是否存在、长度、数量等。 |  | **核心类和函数:** |  | *   `ZContext`: 上下文对象，用于提供环境信息。 | *   `AgentStateDef`: 角色状态定义类，包含颜色范围、模板 ID 等状态信息。 | *   `get_template(ctx, state_def, total, pos)`:  根据角色状态定义获取对应的模板。 | *   `check_cnt_by_color_range(ctx, screen, state_def, total, pos)`:  在指定区域内，按颜色判断连通块的数量。 | *   `check_exist_by_color_range(ctx, screen, state_def, total, pos)`:  在指定区域内，按颜色判断是否存在。 | *   `check_length_by_background_gray(ctx, screen, state_def, total, pos)`:  通过背景灰度计算横条长度。 | *   `check_length_by_foreground_gray(ctx, screen, state_def, total, pos)`:  通过前景灰度计算横条长度。 | *   `check_length_by_foreground_color(ctx, screen, state_def, total, pos)`:  通过前景色计算横条长度。 | *   `check_template_not_found(ctx, screen, state_def, total, pos)`:  判断模板是否未找到。 | *   `check_template_found(ctx, screen, state_def, total, pos)`:  判断模板是否找到。 | *   `check_cnt_by_color_channel_max_range(ctx, screen, state_def, total, pos)`:  按颜色通道最大值判断连通块数量。 | *   `check_exist_by_color_channel_max_range(ctx, screen, state_def, total, pos)`:  按颜色通道最大值判断是否存在。 | *   `check_cnt_by_color_channel_equal_range(ctx, screen, state_def, total, pos)`:  按颜色
        │   └── atomic_op/
        │       ├── btn_chain_cancel.py    这个 Python 文件定义了一个 `AtomicBtnChainCancel` 类，用于在自动战斗中取消按钮链。 |  | *   **主要功能:** 执行取消按钮链的操作，包括按下、释放或单纯取消。 | *   **核心类和函数:** |     *   `AtomicBtnChainCancel`: 继承自 `AtomicOp`，用于执行取消按钮链的操作。 |     *   `__init__`: 初始化 `AtomicBtnChainCancel` 实例，根据 `press` 和 `release` 参数设置操作名称。 |     *   `execute`: 执行取消按钮链的操作，调用 `AutoBattleContext` 的 `chain_cancel` 方法。 |     *   `stop`: 在操作停止时，如果按下了按钮，则释放按钮。 | *   **重要功能点:** |     *   根据 `press`、`press_time` 和 `release` 参数，控制按钮的按下、按住时间和释放。 |     *   使用 `AutoBattleContext` 来执行实际的取消操作。 |     *   `stop` 方法确保在操作结束时释放按钮。
        │       ├── btn_chain_left.py    这个 Python 文件定义了一个用于自动战斗的原子操作，用于控制游戏中的“连锁左”按钮。 |  | *   **主要功能:** 模拟按下和释放“连锁左”按钮，用于自动战斗。 | *   **核心类:** `AtomicBtnChainLeft` 继承自 `AtomicOp`，代表一个原子操作。 | *   **重要功能点:** |     *   `__init__`: 初始化操作，根据 `press` 和 `release` 参数设置操作名称。 |     *   `execute`: 执行按钮操作，调用 `AutoBattleContext` 的 `chain_left` 方法。 |     *   `stop`: 在操作停止时，如果按钮被按下，则释放按钮。
        │       ├── btn_chain_right.py    这个 Python 文件的主要功能是定义一个原子操作，用于控制自动战斗中右侧按钮的链式操作。 |  | *   **核心类:** `AtomicBtnChainRight` 继承自 `AtomicOp`，用于执行右侧按钮的按下、释放或持续按压操作。 | *   **核心函数:** |     *   `__init__`: 初始化 `AtomicBtnChainRight` 实例，根据 `press` 和 `release` 参数设置操作名称和是否为异步操作。 |     *   `execute`: 执行右侧按钮的链式操作，调用 `AutoBattleContext` 的 `chain_right` 方法。 |     *   `stop`: 在操作停止时，如果按钮被按下，则释放按钮。 | *   **重要功能点:** |     *   根据 `press`、`press_time` 和 `release` 参数，控制右侧按钮的按下、持续按压（异步操作）和释放。 |     *   使用 `AutoBattleContext` 处理实际的按钮操作。 |     *   `stop` 方法确保在操作结束时释放按钮。
        │       ├── btn_common.py    此 Python 文件定义了用于自动战斗的通用按钮操作。 |  | **主要功能：** |  | *   实现对游戏内按钮的模拟操作，包括按下、松开和点击。 | *   支持按钮操作的重复执行、前后延时。 |  | **核心类和函数：** |  | *   `BtnWayEnum`: 定义按钮操作方式的枚举（按下、松开、点击）。 | *   `BtnRunStatus`: 定义按钮运行状态的枚举（等待、运行、停止）。 | *   `AtomicBtnCommon(AtomicOp)`: 继承自 `AtomicOp`，是核心类，负责处理具体的按钮操作。 |     *   `__init__`: 初始化按钮操作的参数，包括按钮名称、操作方式、按压时间、重复次数等，并根据按钮名称设置对应的操作方法。 |     *   `execute`: 执行按钮操作，包括前置延时、调用操作方法、后置延时，并支持重复执行。 |     *   `stop`: 停止正在进行的按钮操作。 |  | **重要功能点：** |  | *   通过 `BtnWayEnum` 定义了按钮操作的类型。 | *   `AtomicBtnCommon` 类根据 `op_def.op_name` 动态选择要执行的按钮操作方法。 | *   `execute` 方法实现了按钮操作的流程控制，包括延时和重复执行。 | *   `stop` 方法用于中断正在进行的按钮操作，并确保释放按钮。 | *   使用 `threading.Lock` 保证线程安全。
        │       ├── btn_dodge.py    这个 Python 文件定义了一个名为 `AtomicBtnDodge` 的类，它是一个用于自动战斗的原子操作，用于处理闪避按钮的按下、释放或持续按压。 |  | *   **主要功能:** 模拟在自动战斗中按下和释放闪避按钮。 | *   **核心类和函数:** |     *   `AtomicBtnDodge`: 继承自 `AtomicOp`，表示一个原子操作，用于控制闪避按钮。 |     *   `__init__`: 初始化 `AtomicBtnDodge` 实例，设置操作名称和相关参数，如是否按下、按压时间和释放。 |     *   `execute`: 执行闪避操作，调用 `AutoBattleContext` 的 `dodge` 方法。 |     *   `stop`: 在操作停止时，如果按钮被按下，则释放闪避按钮。 | *   **重要功能点:** |     *   支持按下、释放或持续按压闪避按钮。 |     *   使用 `AutoBattleContext` 进行实际的按钮操作。 |     *   `stop` 方法确保在操作结束时释放按钮。
        │       ├── btn_lock.py    这个 Python 文件定义了一个名为 `AtomicBtnLock` 的类，它是一个用于自动战斗的原子操作，用于控制游戏中的按钮锁定状态。 |  | *   **主要功能:** 模拟按钮的按下、锁定和释放操作。 | *   **核心类:** `AtomicBtnLock` 继承自 `AtomicOp`。 | *   **重要功能点:** |     *   `__init__`: 根据 `press` 和 `release` 参数初始化操作名称，并设置是否为异步操作。 |     *   `execute`: 调用 `AutoBattleContext` 的 `lock` 方法来执行按钮锁定操作。 |     *   `stop`: 如果按钮被按下，则在停止时释放按钮。
        │       ├── btn_move_a.py    这个 Python 文件定义了一个名为 `AtomicBtnMoveA` 的 `AtomicOp` 类，用于在自动战斗中控制 "A" 按钮的行为。 |  | *   **主要功能:** 模拟按下、按住和释放 "A" 按钮的操作。 | *   **核心类和函数:** |     *   `AtomicBtnMoveA`: 继承自 `AtomicOp`，负责执行 "A" 按钮的操作。 |     *   `__init__`: 初始化 `AtomicBtnMoveA` 实例，根据 `press` 和 `release` 参数设置操作名称和异步状态。 |     *   `execute`: 执行 "A" 按钮的操作，调用 `AutoBattleContext` 的 `move_a` 方法。 |     *   `stop`: 在操作停止时，如果按下了 "A" 按钮，则释放它。 | *   **重要功能点:** |     *   支持按下、按住（带有时间）和释放 "A" 按钮。 |     *   使用 `AutoBattleContext` 来执行实际的按钮操作。 |     *   `stop` 方法确保在操作结束时释放按钮。
        │       ├── btn_move_d.py    这个 Python 文件的摘要如下： |  | *   **主要功能：** 实现自动战斗中控制角色向 D 方向移动的原子操作，包括按下、保持和释放按钮。 | *   **核心类和函数：** |     *   `AtomicBtnMoveD`: 继承自 `AtomicOp`，表示一个原子操作，用于控制角色移动。 |     *   `__init__`: 初始化操作，根据 `press` 和 `release` 参数设置操作名称和是否为异步操作。 |     *   `execute`: 执行移动操作，调用 `AutoBattleContext` 的 `move_d` 方法。 |     *   `stop`: 停止移动操作，如果按下了按钮，则释放按钮。 | *   **重要功能点：** |     *   控制角色向 D 方向移动，支持按下、保持（通过 `press_time`）和释放操作。 |     *   使用 `AutoBattleContext` 处理实际的移动逻辑。 |     *   `stop` 方法确保在操作结束时释放按钮。
        │       ├── btn_move_s.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了一个名为 `AtomicBtnMoveS` 的 `AtomicOp` 类，用于在自动战斗中控制 "S" 按钮的按下、持续和释放操作。 |  | **核心类和函数:** |  | *   `AtomicBtnMoveS`: 继承自 `AtomicOp`，负责执行 "S" 按钮的相关操作。 |     *   `__init__`: 初始化 `AtomicBtnMoveS` 实例，根据 `press` 和 `release` 参数设置操作名称。 |     *   `execute`: 执行 "S" 按钮的操作，调用 `AutoBattleContext` 的 `move_s` 方法。 |     *   `stop`:  如果按钮被按下，则在停止时释放按钮。 |  | **重要功能点:** |  | *   根据 `press`、`press_time` 和 `release` 参数，支持按下、持续按下（带时间）和释放 "S" 按钮。 | *   使用 `AutoBattleContext` 执行实际的按钮操作。 | *   `stop` 方法确保在操作停止时释放按钮，防止按钮状态的持续。
        │       ├── btn_move_w.py    这个 Python 文件定义了一个名为 `AtomicBtnMoveW` 的 `AtomicOp` 类，用于控制游戏中 "W" 键的按下、持续和释放操作。 |  | *   **主要功能:** 模拟按下和释放游戏中的 "W" 键，用于自动战斗。 | *   **核心类和函数:** |     *   `AtomicBtnMoveW`: 继承自 `AtomicOp`，负责执行 "W" 键的相关操作。 |     *   `__init__`: 初始化 `AtomicBtnMoveW` 实例，根据 `press` 和 `release` 参数设置操作名称。 |     *   `execute`: 执行 "W" 键的操作，调用 `AutoBattleContext` 的 `move_w` 方法。 |     *   `stop`: 在 `press` 为 True 时，释放 "W" 键。 | *   **重要功能点:** |     *   根据 `press`、`press_time` 和 `release` 参数控制 "W" 键的行为。 |     *   使用 `AutoBattleContext` 处理实际的键盘操作。 |     *   `stop` 方法确保在需要时释放 "W" 键。
        │       ├── btn_normal_attack.py    这个 Python 文件定义了一个名为 `AtomicBtnNormalAttack` 的类，它是一个用于自动战斗的原子操作，用于控制游戏中的普通攻击按钮。 |  | *   **主要功能:** 模拟按下、按住或释放普通攻击按钮的操作。 | *   **核心类和函数:** |     *   `AtomicBtnNormalAttack`: 继承自 `AtomicOp`，表示一个原子操作，用于控制普通攻击按钮。 |     *   `__init__`: 初始化函数，根据 `press`、`press_time` 和 `release` 参数设置操作的名称和行为。 |     *   `execute`: 执行普通攻击按钮操作，调用 `AutoBattleContext` 的 `normal_attack` 方法。 |     *   `stop`: 停止操作，如果按下了按钮，则释放按钮。 | *   **重要功能点:** |     *   支持按下、按住（带持续时间）和释放普通攻击按钮。 |     *   使用 `AutoBattleContext` 来执行实际的按钮操作。 |     *   `stop` 方法确保在操作结束时释放按钮。
        │       ├── btn_quick_assist.py    这个 Python 文件定义了一个名为 `AtomicBtnQuickAssist` 的类，它是一个用于自动战斗的原子操作，用于执行“快速支援”按钮的功能。 |  | *   **主要功能:** 模拟点击“快速支援”按钮，并在执行前后添加延迟。 | *   **核心类和函数:** |     *   `AtomicBtnQuickAssist`: 继承自 `AtomicOp`，负责执行快速支援操作。 |     *   `execute()`: 执行快速支援操作，包括延迟、调用 `ctx.quick_assist()` 和更新状态。 |     *   `stop()`: 停止操作。 | *   **重要功能点:** |     *   使用 `threading.Lock` 来保护状态更新，确保线程安全。 |     *   根据 `pre_delay` 和 `post_delay` 属性添加延迟。 |     *   调用 `ctx.quick_assist()` 来触发游戏中的快速支援功能。 |     *   使用 `BtnRunStatus` 枚举来管理操作的状态。
        │       ├── btn_special_attack.py    这个 Python 文件定义了一个名为 `AtomicBtnSpecialAttack` 的类，它是一个用于自动战斗系统的原子操作，用于控制游戏中的特殊攻击按钮。 |  | *   **主要功能:** 模拟按下、释放或单纯触发特殊攻击按钮的操作。 | *   **核心类和函数:** |     *   `AtomicBtnSpecialAttack`: 继承自 `AtomicOp`，负责执行特殊攻击按钮的操作。 |     *   `__init__`: 初始化操作，根据 `press` 和 `release` 参数设置操作名称和是否为异步操作。 |     *   `execute`: 执行特殊攻击操作，调用 `AutoBattleContext` 的 `special_attack` 方法。 |     *   `stop`: 在操作停止时，如果按下了按钮，则释放按钮。 | *   **重要功能点:** |     *   支持按下、释放和单纯触发特殊攻击按钮。 |     *   使用 `AutoBattleContext` 来执行实际的按钮操作。 |     *   `stop` 方法确保在操作停止时释放按钮，避免按钮一直处于按下状态。 |     *   `async_op` 参数用于指示操作是否为异步操作。
        │       ├── btn_switch_agent.py    这个 Python 文件定义了一个名为 `AtomicBtnSwitchAgent` 的类，它是一个用于自动战斗的原子操作，用于切换游戏中的角色。 |  | *   **主要功能:** 执行切换角色的操作，包括延迟和状态管理。 | *   **核心类和函数:** |     *   `AtomicBtnSwitchAgent`: 继承自 `AtomicOp`，负责切换角色的逻辑。 |     *   `execute()`: 执行切换角色的操作，包括延迟和调用 `ctx.switch_by_name()`。 |     *   `stop()`: 停止切换操作。 | *   **重要功能点:** |     *   使用 `AutoBattleContext` 获取上下文信息。 |     *   使用 `OperationDef` 获取操作定义，包括角色名称和延迟时间。 |     *   使用 `threading.Lock` 来保护状态更新。 |     *   使用 `BtnRunStatus` 枚举来管理操作状态。 |     *   包含 `pre_delay` 和 `post_delay` 实现切换前后的延迟。
        │       ├── btn_switch_next.py    这个 Python 文件定义了一个名为 `AtomicBtnSwitchNext` 的 `AtomicOp` 类，用于在自动战斗中控制“下一场战斗”按钮。 |  | *   **主要功能:** 模拟按下、释放或单纯触发“下一场战斗”按钮。 | *   **核心类和函数:** |     *   `AtomicBtnSwitchNext`: 继承自 `AtomicOp`，负责执行按钮操作。 |     *   `__init__`: 初始化 `AtomicBtnSwitchNext` 实例，根据 `press` 和 `release` 参数设置操作名称和是否为异步操作。 |     *   `execute`: 执行按钮操作，调用 `AutoBattleContext` 的 `switch_next` 方法。 |     *   `stop`: 在 `press` 为 `True` 时，模拟释放按钮。 | *   **重要功能点:** |     *   支持按下、释放或单纯触发按钮。 |     *   使用 `AutoBattleContext` 来执行实际的按钮操作。 |     *   `press_time` 参数允许模拟按钮按下的持续时间。 |     *   `stop` 方法用于确保在需要时释放按钮。
        │       ├── btn_switch_prev.py    这个 Python 文件定义了一个名为 `AtomicBtnSwitchPrev` 的 `AtomicOp` 类，用于在自动战斗中控制“上一个”按钮的行为。 |  | *   **主要功能:** 模拟按下、释放或保持按下“上一个”按钮的操作。 | *   **核心类和函数:** |     *   `AtomicBtnSwitchPrev`: 继承自 `AtomicOp`，负责执行按钮操作。 |     *   `__init__`: 初始化操作的名称，并设置是否为异步操作。 |     *   `execute`: 执行按钮操作，调用 `AutoBattleContext` 的 `switch_prev` 方法。 |     *   `stop`: 在操作停止时，如果按钮被按下，则模拟释放按钮。 | *   **重要功能点:** |     *   支持按下、释放或保持按下按钮。 |     *   使用 `AutoBattleContext` 来执行实际的按钮操作。 |     *   `stop` 方法确保在操作结束时释放按钮。
        │       ├── btn_ultimate.py    这个 Python 文件定义了一个名为 `AtomicBtnUltimate` 的 `AtomicOp` 类，用于在自动战斗中控制终极技能按钮。 |  | *   **主要功能:** 模拟按下、释放或执行终极技能按钮的操作。 | *   **核心类和函数:** |     *   `AtomicBtnUltimate`: 继承自 `AtomicOp`，用于表示终极技能按钮的操作。 |     *   `__init__`: 初始化 `AtomicBtnUltimate` 实例，根据 `press` 和 `release` 参数设置操作名称。 |     *   `execute`: 执行终极技能按钮操作，调用 `AutoBattleContext` 的 `ultimate` 方法。 |     *   `stop`: 在按下按钮的情况下，模拟释放按钮。 | *   **重要功能点:** |     *   支持按下、释放或单纯触发终极技能按钮。 |     *   使用 `AutoBattleContext` 处理实际的按钮操作。 |     *   `async_op` 属性根据是否需要等待按钮释放而设置。
        │       ├── state_clear.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件定义了一个 `AtomicClearState` 类，用于在自动战斗中清除状态。 |  | **核心类和函数：** |  | *   `AtomicClearState`: 继承自 `AtomicOp`，负责执行清除状态的操作。 |     *   `__init__(self, ctx: AutoBattleCustomContext, op_def: OperationDef)`: 初始化 `AtomicClearState` 实例，接收上下文和操作定义。 |     *   `execute(self)`: 执行清除状态的操作，根据 `state_name_list` 或 `state_name` 清除 `AutoBattleCustomContext` 中的状态。 |  | **重要功能点：** |  | *   `AtomicClearState` 根据 `OperationDef` 中定义的 `state_name` 或 `state_name_list` 来清除状态。 | *   使用 `AutoBattleCustomContext` 的 `clear_state` 方法来清除状态。 | *   支持清除单个状态或多个状态。
        │       ├── state_set.py    这个 Python 文件定义了一个用于自动战斗的原子操作，用于设置游戏状态。 |  | *   **主要功能:** 根据定义设置游戏实体的状态。 | *   **核心类:** `AtomicSetState` 继承自 `AtomicOp`，代表设置状态的操作。 | *   **重要功能点:** |     *   `__init__`: 初始化操作，从 `OperationDef` 中获取状态名称、持续时间、值等参数。 |     *   `execute`: 执行设置状态的操作，调用 `AutoBattleCustomContext` 的 `set_state` 方法，根据配置设置状态。 |     *   支持设置单个状态或多个状态。
        │       └── wait.py    这个 Python 文件定义了一个名为 `AtomicWait` 的类，它继承自 `AtomicOp`，用于在自动战斗中执行等待操作。 |  | *   **主要功能:** 实现自动战斗中的等待功能，根据指定的秒数暂停执行。 | *   **核心类:** `AtomicWait` | *   **重要功能点:** |     *   `AtomicWait` 类初始化时，从 `OperationDef` 中获取等待秒数，并将其储存在 `self.wait_seconds` 属性中。 |     *   `execute` 方法使用 `time.sleep()` 函数暂停执行，等待 `self.wait_seconds` 秒。
        ├── config/
        │   ├── agent_outfit_config.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了代理装备的配置，包括不同角色的皮肤选项。它使用 `YamlConfig` 类来加载和管理配置，并使用 `Enum` 来定义可用的皮肤选项。 |  | **核心类和函数:** |  | *   `AgentOutfitConfig`: 继承自 `YamlConfig`，用于加载和管理代理装备的配置。它包含属性（property）用于获取和设置不同角色的皮肤，如 `nicole`, `ellen`, 和 `astra_yao`。 | *   `AgentOutfitNicole`, `AgentOutfitEllen`, `AgentOutfitAstraYao`:  使用 `Enum` 定义了每个角色的可用皮肤选项，每个选项都关联一个 `ConfigItem` 实例，包含皮肤的名称和标识符。 |  | **重要功能点:** |  | *   使用 `YamlConfig` 管理配置，这表明配置数据可能存储在 YAML 文件中。 | *   使用 `Enum` 提供了清晰的皮肤选项定义，增强了代码的可读性和可维护性。 | *   每个角色的皮肤选项都有一个默认值。 | *   提供了获取和设置皮肤配置的属性（property）。
        │   ├── game_config.py    **摘要:** |  | 该文件定义了游戏配置类 `GameConfig`，用于管理游戏中的各种键位设置和手柄类型。它继承自 `BasicGameConfig`，并使用 `Enum` 定义了手柄类型。 |  | **核心类和函数:** |  | *   `GamepadTypeEnum`: 定义了游戏手柄类型的枚举 (NONE, XBOX, DS4)。 | *   `GameConfig`: 继承自 `BasicGameConfig`，用于存储和管理游戏配置。 |     *   `__init__(self, instance_idx: int)`: 初始化函数。 |     *   一系列 `@property` 装饰器修饰的属性，用于获取和设置各种键位配置，包括普通攻击、闪避、切换、特殊攻击、爆发技、交互、移动等，以及 Xbox 和 DS4 手柄的键位设置。 |     *   `gamepad_requirement_time`: 存储依赖文件最后修改时间。 |     *   `original_hdr_value`: 存储原始 HDR 值。 |  | **重要功能点:** |  | *   定义了游戏中的各种键位设置，包括键盘和手柄。 | *   支持 Xbox 和 DS4 手柄的键位配置。 | *   提供了获取和设置键位配置的接口。 | *   存储了依赖文件的最后修改时间。 | *   存储了原始 HDR 值。
        │   ├── team_config.py    这个 Python 脚本定义了用于管理游戏中预定义队伍配置的类。 |  | *   **主要功能:** 读取、储存和管理游戏中的队伍配置，包括队伍名称、代理人 ID 列表和自动战斗配置。 | *   **核心类和函数:** |     *   `PredefinedTeamInfo`: 表示一个预定义的队伍，包含队伍的索引、名称、代理人 ID 列表和自动战斗配置。 |     *   `TeamConfig`: 继承自 `YamlConfig`，用于加载和保存队伍配置。 |         *   `team_list`: 属性，返回一个 `PredefinedTeamInfo` 列表，包含所有队伍的配置。 |         *   `update_team`: 更新一个队伍的配置。 |         *   `get_team_by_idx`: 根据索引获取队伍配置。 |         *   `update_team_members`: 更新特定队伍的代理人列表。 | *   **重要功能点:** |     *   从 YAML 配置文件加载队伍配置。 |     *   允许更新和修改队伍配置。 |     *   提供获取特定队伍信息的功能。 |     *   支持更新队伍成员。 |     *   确保每个队伍至少有三个代理人，如果不足则填充 'unknown'。
        │   └── yolo_config.py    此文件定义了 YOLO 模型相关的配置，包括模型选择、GPU 使用等。 |  | *   **核心类**: `YoloConfig` 继承自 `YamlConfig`，用于管理和存储 YOLO 模型的配置。 | *   **核心函数**: |     *   `__init__`: 初始化 `YoloConfig`，加载配置文件。 |     *   `flash_classifier`, `hollow_zero_event`, `lost_void_det`: 属性，用于获取和设置不同类型的 YOLO 模型，并确保使用最新的两个模型。 |     *   `flash_classifier_gpu`, `hollow_zero_event_gpu`, `lost_void_det_gpu`: 属性，用于获取和设置是否使用 GPU。 |     *   `using_old_model`: 判断是否在使用旧模型。 |     *   `get_flash_classifier_opts`, `get_hollow_zero_event_opts`, `get_lost_void_det_opts`:  获取不同类型模型的可用选项。 | *   **重要功能点**: |     *   管理三种 YOLO 模型（闪光、枯萎之都格子、迷失之地识别）的配置。 |     *   提供模型版本控制，只允许使用最新的两个模型。 |     *   控制是否使用 GPU。 |     *   提供获取模型选项的函数。
        ├── const/
        │   └── game_const.py    这个 Python 文件 `game_const.py` 定义了游戏中使用的常量。 |  | *   **主要功能:** 储存游戏中使用的常量，例如颜色。 | *   **核心常量:** |     *   `YOLO_DEFAULT_COLOR`:  默认的 YOLO 检测框颜色，RGB 值为 (114, 114, 114)。 | *   **重要功能点:**  定义了游戏中使用的颜色常量。
        ├── context/
        │   ├── hollow_context.py    **摘要:** |  | 该文件定义了 `HollowContext` 类，用于管理和控制游戏《崩坏：星穹铁道》中“虚数之树”活动的上下文逻辑。它负责地图寻路、角色识别、关卡信息管理以及行动决策。 |  | **核心类和函数:** |  | *   **`HollowContext`**:  主类，管理虚数之树的上下文。 |     *   `__init__(self, ctx: ZContext)`: 初始化上下文，包括数据服务、关卡信息、地图服务等。 |     *   `get_next_to_move(self, current_map: HollowZeroMap)`:  根据当前地图信息，计算并返回下一步要移动到的节点。 |     *   `update_context_after_move(self, current_map: HollowZeroMap, node: HollowZeroMapNode, update_current: bool = True)`:  在移动后更新上下文，包括已访问节点和当前节点。 |     *   `check_agent_list(self, screen: MatLike, skip_if_checked: bool = False)`:  识别屏幕上的角色列表。 |     *   `init_before_hollow_start(self, mission_type_name: str, mission_name: str, level: int = 1, phase: int = 1)`:  在进入虚数之树活动时进行初始化。 |     *   `after_app_shutdown(self)`:  在应用程序关闭后进行清理操作。 |     *   `_match_agent_in(self, img: MatLike, possible_agents: Optional[List[Agent]] = None)`: 在图像中匹配角色。 |  | **重要功能点:** |  | *   **地图寻路**:  使用 `hollow_pathfinding` 模块进行寻路，根据不同的优先级（一步可达、途经点、终点等）选择目标节点。 | *   **角色识别**:  通过模板匹配识别屏幕上的角色头像。 | *   **关卡信息管理**:  维护 `HollowLevelInfo` 对象，跟踪关卡类型、层数、阶段等信息。 | *   **行动决策**:  根据当前地图状态和关卡信息，决定下一步的行动，包括移动到哪个节点。 | *   **上下文更新**:  在移动
        │   └── zzz_context.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `ZContext` 类，它继承自 `OneDragonContext`，用于管理游戏 `Zenless Zone Zero (ZZZ)` 的上下文环境。它负责加载和管理各种配置、服务和运行记录，并提供初始化和关闭时的操作。 |  | **核心类和函数:** |  | *   **`ZContext`**:  主类，继承自 `OneDragonContext`，用于管理游戏上下文。 |     *   `__init__(self)`:  初始化函数，加载各种配置和服务。 |     *   `load_instance_config(self)`:  加载实例独有的配置。 |     *   `init_by_config(self)`:  根据配置进行初始化，包括更新语言和初始化控制器。 |     *   `init_hollow_config(self)`:  初始化空洞配置。 |     *   `init_agent_template_id(self)`:  初始化代理人头像模板ID。 |     *   `after_app_shutdown(self)`:  App 关闭后进行的操作。 |  | **重要功能点:** |  | *   **配置管理**: 加载和管理游戏配置，如 `YoloConfig`, `GameConfig`, `TeamConfig` 等。 | *   **服务管理**:  初始化游戏数据服务，如 `MapAreaService`, `CompendiumService`。 | *   **运行记录**:  管理各种运行记录，如 `EmailRunRecord`, `RandomPlayRunRecord`, `ChargePlanRunRecord` 等，并检查和更新状态。 | *   **上下文初始化**:  根据配置初始化游戏环境，包括语言设置和控制器。 | *   **空洞配置和代理人初始化**:  初始化空洞相关配置和代理人头像模板ID。 | *   **App 关闭处理**:  在 App 关闭时执行清理操作。
        ├── controller/
        │   └── zzz_pc_controller.py    **摘要:** |  | 该文件定义了 `ZPcController` 类，用于控制游戏中的 PC 操作，继承自 `PcControllerBase`。它通过模拟键盘和鼠标输入来实现游戏控制，并支持不同的输入设备（键盘、Xbox、DS4）。 |  | **核心类和函数:** |  | *   **`ZPcController`**:  核心类，负责处理游戏控制逻辑。 |     *   `__init__`: 初始化控制器，设置游戏配置和按键绑定。 |     *   `fill_uid_black`: 遮挡 UID 区域。 |     *   `enable_keyboard`, `enable_xbox`, `enable_ds4`: 根据不同的输入设备配置按键。 |     *   `dodge`, `switch_next`, `switch_prev`, `normal_attack`, `special_attack`, `ultimate`, `chain_left`, `chain_right`, `move_w`, `move_s`, `move_a`, `move_d`, `interact`, `lock`, `chain_cancel`:  封装了各种游戏操作的按键事件，包括按下、释放和点击。 |     *   `turn_by_distance`:  通过鼠标事件实现横向转向。 |     *   `start_moving_forward`, `stop_moving_forward`: 控制角色向前移动。 |  | **重要功能点:** |  | *   **按键映射**:  根据游戏配置和输入设备（键盘、Xbox、DS4）动态设置按键。 | *   **游戏操作控制**:  封装了游戏中的各种操作，如移动、攻击、闪避、切换角色等，通过模拟按键实现。 | *   **横向转向**:  通过鼠标事件实现横向转向。 | *   **移动控制**: 提供了开始和停止向前移动的函数。 | *   **UID 遮挡**: 提供遮挡 UID 的功能。
        ├── game_data/
        │   ├── agent.py    **摘要:** |  | 该 Python 文件定义了与游戏角色（Agent）相关的数据结构和枚举。 |  | **核心类和函数:** |  | *   `AgentTypeEnum`, `DmgTypeEnum`, `RareTypeEnum`: 定义了角色的类型、伤害类型和稀有度等枚举。 | *   `AgentStateCheckWay`: 定义了用于检测角色状态的不同方法。 | *   `AgentStateDef`: 定义了角色状态的结构，包括状态名称、检测方式、模板 ID、颜色范围等。 | *   `CommonAgentStateEnum`: 定义了常见的角色状态，基于 `AgentStateDef`。 | *   `Agent`: 定义了角色类，包含角色 ID、名称、稀有度、类型、伤害类型和状态列表等属性。 | *   `AgentEnum`: 定义了游戏中的角色实例，继承自 `Agent` 类。 |  | **重要功能点:** |  | *   定义了角色属性和状态，用于游戏逻辑。 | *   使用枚举来表示不同的角色属性和状态类型，增强代码可读性和可维护性。 | *   `AgentStateDef` 和 `CommonAgentStateEnum` 用于定义和管理角色的各种状态，包括能量、特殊技能、终结技等。 | *   `AgentEnum` 包含了游戏中所有角色的定义，每个角色都关联了其属性和状态。
        │   ├── compendium.py    ## 摘要 |  | 这个 Python 脚本定义了用于管理游戏内副本和咖啡数据的类和服务。 |  | **主要功能:** |  | *   加载和管理游戏副本数据，包括 Tab、Category、MissionType 和 Mission。 | *   加载和管理咖啡数据，包括咖啡名称、关联的副本信息以及每日咖啡安排。 | *   提供用于获取和查询副本数据的 API。 |  | **核心类和函数:** |  | *   **CompendiumTab, CompendiumCategory, CompendiumMissionType, CompendiumMission:**  用于表示副本数据的数据结构。 | *   **CompendiumData:**  包含所有 CompendiumTab 的数据。 | *   **Coffee:**  表示咖啡，关联到副本数据。 | *   **CompendiumService:**  管理副本和咖啡数据的服务，包括： |     *   `reload()`: 重新加载数据。 |     *   `_load_all_compendium()`: 从 YAML 文件加载副本数据。 |     *   `_load_coffee()`: 从 YAML 文件加载咖啡数据。 |     *   `get_tab_data()`, `get_category_list_data()`, `get_category_data()` 等:  用于获取副本数据的 API。 |     *   `get_coffee_config_list_by_day()`: 获取指定日期的咖啡配置列表。 |     *   `get_extra_coffee_list()`: 获取额外的咖啡列表。 |  | **重要功能点:** |  | *   从 YAML 文件加载副本和咖啡数据。 | *   提供 API 获取和查询副本数据，支持按 Tab、Category、MissionType 和 Mission 进行筛选。 | *   管理每日咖啡安排。 | *   支持额外的咖啡，不占用次数。 | *   提供获取特定副本任务名称列表的函数，例如零号空洞和迷失之地。 | *   提供获取用于收费计划的数据的函数。
        │   └── map_area.py    这个 Python 文件定义了用于管理游戏地图区域的类。 |  | **主要功能:** |  | *   加载地图区域数据。 | *   根据 OCR 结果匹配地图区域和传送点。 | *   计算从一个区域到另一个区域的方向和步数。 |  | **核心类和函数:** |  | *   `MapArea`:  表示一个地图区域，包含区域名称和传送点列表。 |     *   `__init__(self, area_name: str, tp_list: List[str])`: 初始化 MapArea 实例。 | *   `MapAreaService`:  管理地图区域数据的服务类。 |     *   `__init__(self)`: 初始化 MapAreaService 实例，并加载数据。 |     *   `reload(self) -> None`:  从 YAML 文件重新加载地图区域数据。 |     *   `get_best_match_area(self, ocr_result: str) -> Optional[MapArea]`:  根据 OCR 结果匹配最接近的地图区域。 |     *   `get_direction_to_target_area(self, current_area: MapArea, target_area: MapArea) -> int`:  计算从当前区域到目标区域的方向。 |     *   `get_best_match_tp(self, area_name: str, ocr_result: str) -> Optional[str]`:  根据 OCR 结果匹配最接近的传送点。 |  | **重要功能点:** |  | *   使用 `yaml` 库从 `map_area.yml` 文件加载地图区域数据。 | *   使用 `difflib.get_close_matches` 进行模糊匹配，以根据 OCR 结果找到最匹配的区域和传送点。 | *   计算从一个区域到另一个区域的相对位置，考虑到环形布局。
        ├── gui/
        │   ├── app.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个基于 PySide6 和 qfluentwidgets 的应用程序，该应用程序是 "一条龙" 项目的 GUI 界面。它负责创建主窗口，管理子界面，处理用户交互，并集成各种功能，如战斗助手、游戏助手、设置等。 |  | **核心类和函数:** |  | *   **`AppWindow`**:  主窗口类，继承自 `AppWindowBase`。 |     *   `__init__`: 初始化窗口，设置标题、图标，启动版本检查线程，并连接实例切换事件。 |     *   `init_window`: 初始化窗口的 UI 元素，设置样式，布局等。 |     *   `create_sub_interface`: 创建并添加各种子界面，如 HomeInterface, BattleAssistantInterface 等。 |     *   `_on_instance_active_event`: 响应实例激活事件，更新窗口标题。 |     *   `_on_instance_active_signal`: 响应实例切换信号，更新窗口标题。 |     *   `_update_version`: 更新版本显示在标题栏。 |     *   `_check_first_run`: 检查是否为首次运行，如果是则显示欢迎对话框。 | *   **`CheckVersionRunner`**:  一个 QThread，用于在后台获取当前版本信息。 |     *   `run`:  获取版本信息并发出信号。 | *   **`QApplication`**:  应用程序的主类，用于创建和运行应用程序。 |  | **重要功能点:** |  | *   **界面布局和子界面管理:**  使用 `AppWindowBase` 作为基类，管理多个子界面，并通过 `create_sub_interface` 方法添加。 | *   **主题设置:**  使用 `qfluentwidgets` 的 `setTheme` 函数设置应用程序主题。 | *   **版本检查:**  使用 `CheckVersionRunner` 线程在后台检查版本，并在标题栏显示。 | *   **实例切换:**  监听实例切换事件，并更新窗口标题。 | *   **首次运行引导:**  在首次运行时显示欢迎对话框。 | *   **错误处理:**  在应用程序启动时捕获异常，并显示错误信息。 | *   **上下文管理:**  使用 `ZContext` 管理应用程序的上下文和配置。 | *   **异步初始化:**
        │   ├── zzz_installer.py    这个 Python 脚本定义了一个安装程式的 GUI 应用程式，用于安装和配置软体。 |  | *   **主要功能:** 创建一个基于 `InstallerWindowBase` 的安装程式窗口，包含多个界面用于安装、扩展安装、程式码查看和设置。它还处理首次运行时的欢迎对话框。 | *   **核心类和函数:** |     *   `ZInstallerWindow`: 继承自 `InstallerWindowBase`，是主安装程式窗口，负责创建和管理子界面，以及处理首次运行逻辑。 |     *   `create_sub_interface`: 添加了 `InstallerInterface`, `ExtendInstallInterface`, `CodeInterface` 和 `InstallerSettingInterface` 到主窗口。 |     *   `_check_first_run`: 检查是否为首次运行，如果是，则显示 `WelcomeDialog`。 | *   **重要功能点:** |     *   使用 `PySide6` 和 `qfluentwidgets` 构建 GUI。 |     *   使用 `OneDragonEnvContext` 和 `OneDragonCustomContext` 管理环境和自定义配置。 |     *   包含安装、扩展安装、程式码查看和设置等界面。 |     *   在首次运行时显示欢迎对话框。 |     *   支持主题设置。 |     *   在应用程式启动时异步更新免费代理。
        │   └── view/
        │       ├── accounts/
        │       │   └── app_accounts_interface.py    这个 Python 文件定义了一个名为 `AccountsInterface` 的类，它是一个用于管理账户的界面，继承自 `PivotNavigatorInterface`。 |  | *   **主要功能:** 提供账户管理功能，并作为一个导航界面。 | *   **核心类和函数:** |     *   `AccountsInterface`:  继承自 `PivotNavigatorInterface`，用于账户管理的界面。 |     *   `__init__(self, ctx: ZContext, parent=None)`:  初始化 `AccountsInterface`，接收 `ZContext` 实例，并设置导航文本和图标。 |     *   `create_sub_interface(self)`:  创建子界面，目前添加了 `ZSettingInstanceInterface`。 | *   **重要功能点:** |     *   使用 `PivotNavigatorInterface` 实现导航界面。 |     *   通过 `add_sub_interface` 添加子界面。 |     *   使用 `ZContext` 进行上下文管理。
        │       ├── battle_assistant/
        │       │   ├── auto_battle_editor_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AutoBattleEditorInterface` 类，用于在 GUI 中编辑自动战斗配置。它提供了一个界面，允许用户选择、查看和管理自动战斗配置，包括作者、版本、简介和适用的配队信息。 |  | **核心类和函数:** |  | *   **`TeamSettingCard`**:  一个自定义的 `MultiPushSettingCard`，用于配置队伍信息。它包含多个 `ComboBox`，允许用户选择队伍中的角色。 |     *   `init_team(self, character_list: List[str])`: 初始化队伍信息。 |     *   `on_character_chosen(self)`: 当角色选择发生变化时触发的信号。 | *   **`AutoBattleEditorInterface`**:  继承自 `VerticalScrollInterface`，是主界面类，用于显示和编辑自动战斗配置。 |     *   `get_content_widget(self) -> QWidget`: 构建界面的主要内容。 |     *   `init_left_part(self) -> QWidget`: 初始化界面左侧部分，包含配置信息和操作按钮。 |     *   `init_right_part(self) -> QWidget`: 初始化界面右侧部分（目前为空）。 |     *   `on_interface_shown(self) -> None`: 界面显示时更新配置选项和显示。 |     *   `update_auto_battle_config_opts(self) -> None`: 更新可用的自动战斗配置选项。 |     *   `update_display_by_config(self) -> None`: 根据选定的配置更新界面显示。 |     *   `update_team_group_display(self) -> None`: 更新队伍配置组的显示。 |     *   `on_config_chosen(self, idx: int) -> None`: 当选择配置时触发，加载配置并更新界面。 |     *   `on_cancel_clicked(self) -> None`:  取消配置选择，重置界面。 |  | **重要功能点:** |  | *   **配置选择**:  使用 `ComboBox`  选择已有的自动战斗配置。 | *   **信息展示**:  使用 `HyperlinkCard`  展示作者、版本、简介等配置信息。 | *   **配队配置**:  使用 `TeamSettingCard`  配置适用的配队
        │       │   ├── auto_battle_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `AutoBattleInterface` 类，该类是用于自动战斗功能的 GUI 界面，继承自 `AppRunInterface`。它提供了用户界面元素，用于配置和控制自动战斗，包括选择战斗配置、调试、GPU 运算、截图间隔、手柄类型等。 |  | **核心类和函数:** |  | *   **`AutoBattleInterface(ctx: ZContext, parent=None)`**:  主界面类，初始化界面元素，处理用户交互，并与 `AutoBattleApp` 和 `AutoBattleDebugApp` 交互。 | *   **`get_widget_at_top() -> QWidget`**:  创建并返回界面顶部的设置区域，包括帮助链接、战斗配置选择、调试按钮、配置共享按钮、删除按钮、GPU 选项、截图间隔设置、手柄类型选择。 | *   **`get_content_widget() -> QWidget`**:  创建并返回界面的主要内容区域，包含左侧的 `AppRunInterface` 内容和右侧的 `TaskDisplay` 和 `BattleStateDisplay`。 | *   **`on_interface_shown() -> None`**:  界面显示时进行初始化，加载配置，设置信号连接。 | *   **`on_interface_hidden() -> None`**:  界面隐藏时进行清理，断开信号连接。 | *   **`_on_start_clicked() -> None`**:  启动自动战斗，创建 `AutoBattleApp` 实例。 | *   **`_on_debug_clicked() -> None`**:  启动调试模式，创建 `AutoBattleDebugApp` 实例。 | *   **`_on_auto_battle_config_changed(self, index, value)`**:  处理战斗配置改变的事件。 | *   **`_on_screenshot_interval_changed(self, value: str) -> None`**:  处理截图间隔改变的事件。 | *   **`_on_gamepad_type_changed(self, idx: int, value: str) -> None`**:  处理手柄类型改变的事件。 | *   **`_on_shared_clicked(self) -> None`**:  处理配置共享按钮点击事件。 | *   **`_on_del_clicked(self) -> None`**:
        │       │   ├── battle_assistant_interface.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了 `BattleAssistantInterface` 类，它是一个用于集成多个与战斗相关的子界面的主界面。它使用 `PivotNavigatorInterface` 作为基础，并提供了一个导航结构，用于在不同的战斗助手功能之间切换。 |  | **核心类和函数:** |  | *   **`BattleAssistantInterface`**:  继承自 `PivotNavigatorInterface`，是战斗助手的主界面。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，接收应用程序上下文 `ctx`。 |     *   `create_sub_interface(self)`:  创建并添加子界面，包括 `DodgeAssistantInterface`, `AutoBattleInterface`, `OperationDebugInterface` 和 `AutoBattleEditorInterface`。 |  | **重要功能点:** |  | *   使用 `PivotNavigatorInterface` 实现导航，提供用户友好的界面。 | *   集成多个子界面，将战斗助手的功能模块化。 | *   通过 `ZContext` 接收应用程序的上下文，以便子界面可以访问配置和状态信息。
        │       │   ├── battle_state_display.py    这个 Python 文件定义了两个用于显示自动战斗状态和任务信息的 GUI 组件，使用 PySide6 和 qfluentwidgets 库。 |  | **主要功能:** |  | *   **BattleStateDisplay:** 显示自动战斗中各个状态的触发时间和状态值。 | *   **TaskDisplay:** 显示当前正在运行的任务的触发器、条件集和持续时间。 |  | **核心类和函数:** |  | *   **BattleStateDisplay:** |     *   `__init__(self, parent=None)`: 初始化表格，设置列标题和定时器。 |     *   `set_update_display(self, to_update: bool) -> None`: 控制更新定时器的启动和停止。 |     *   `_update_display(self) -> None`:  从 `AutoBattleOperator` 获取状态信息，并在表格中更新显示。 | *   **TaskDisplay:** |     *   `__init__(self, parent=None)`: 初始化表格，设置列宽，隐藏标题和滚动条，并初始化表格数据。 |     *   `set_update_display(self, to_update: bool) -> None`: 控制更新定时器的启动和停止。 |     *   `_update_display(self) -> None`: 从 `AutoBattleOperator` 获取任务信息，并在表格中更新显示。 |     *   `adjustTableHeight(self)`: 根据行高调整表格高度。 |  | **重要功能点:** |  | *   使用 `QTimer` 定期更新表格数据。 | *   从 `AutoBattleOperator` 获取战斗状态和任务信息。 | *   使用 `FluentThemeColor.RED` 突出显示状态变化。 | *   `TaskDisplay` 根据任务信息动态更新表格内容。 | *   `TaskDisplay` 调整表格高度以适应内容。
        │       │   ├── dodge_assistant_interface.py    代码摘要： |  | 该文件定义了 `DodgeAssistantInterface` 类，用于构建闪避助手的 GUI 界面。 |  | 核心类和函数： |  | *   `DodgeAssistantInterface`: 继承自 `AppRunInterface`，是闪避助手界面的主类，负责界面布局、配置选项的显示和交互，以及与后端逻辑的交互。 |     *   `__init__`: 初始化界面，设置上下文和导航信息。 |     *   `get_widget_at_top`: 创建顶部设置区域的控件，包括使用说明、闪避方式选择、GPU 运算开关、截图间隔设置、手柄类型选择等。 |     *   `get_content_widget`: 创建内容区域的控件，包含一个水平布局，左侧是 `AppRunInterface` 的内容，右侧是 `BattleStateDisplay`，用于显示战斗状态。 |     *   `on_interface_shown`: 界面显示时进行初始化，包括更新闪避方式选项、初始化配置适配器、设置截图间隔和手柄类型，以及监听事件。 |     *   `on_interface_hidden`: 界面隐藏时取消事件监听，停止战斗状态显示。 |     *   `_update_dodge_way_opts`: 更新闪避方式选项。 |     *   `_on_screenshot_interval_changed`: 处理截图间隔变化事件。 |     *   `get_app`: 返回 `DodgeAssistantApp` 实例。 |     *   `_on_del_clicked`: 处理删除配置按钮的点击事件。 |     *   `_on_gamepad_type_changed`: 处理手柄类型选择变化事件。 |     *   `on_context_state_changed`: 根据运行状态更新显示。 |     *   `_on_auto_op_loaded_event`: 自动战斗指令加载后的处理。 |     *   `_on_auto_op_loaded_signal`: 指令加载后更新需要监听的事件。 | *   `BattleStateDisplay`: 用于显示战斗状态的组件。 |  | 重要功能点： |  | *   提供闪避方式、GPU 运算、截图间隔、手柄类型等配置选项。 | *   通过 `HyperlinkCard` 提供使用说明。 | *   显示战斗状态。 | *   支持删除配置。 | *   响应配置更改，并
        │       │   ├── operation_debug_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `OperationDebugInterface` 类，用于在 GUI 中提供一个指令调试界面，允许用户配置和调试战斗助手的操作指令。 |  | **核心类和函数:** |  | *   **`OperationDebugInterface`**: 继承自 `AppRunInterface`，是指令调试界面的主类。 |     *   `__init__`: 初始化界面，设置导航信息。 |     *   `get_widget_at_top`: 构建界面顶部的控件，包括指令配置、循环指令、手柄类型等设置。 |     *   `on_interface_shown`: 界面显示时进行初始化，加载配置。 |     *   `_update_auto_battle_config_opts`: 更新指令配置选项，从文件系统加载模板。 |     *   `_on_config_changed`: 当指令配置改变时，更新上下文中的配置。 |     *   `_on_repeat_changed`: 当循环指令设置改变时，更新上下文中的配置。 |     *   `get_app`: 返回 `OperationDebugApp` 实例。 |     *   `_on_del_clicked`: 删除选定的指令配置。 |     *   `_on_gamepad_type_changed`: 当手柄类型改变时，更新上下文中的配置。 |  | **重要功能点:** |  | *   提供指令配置的下拉选择框，允许用户选择不同的操作指令模板。 | *   提供循环指令的开关，用于控制指令的重复执行。 | *   提供手柄类型选择框，用于配置战斗助手的手柄类型。 | *   支持删除用户自定义的指令配置。 | *   界面初始化时加载并显示当前的配置。 | *   通过上下文 `ZContext` 存储和管理配置信息。
        │       │   └── template_generation_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个用于生成战斗动作模板的界面，该界面允许用户录制游戏操作，然后根据录制的数据生成 YAML 格式的动作模板。 |  | **核心类和函数:** |  | *   **`TemplateGenerationInterface`**:  继承自 `AppRunInterface`，是主界面类，负责 UI 的构建和逻辑控制。 |     *   `__init__`: 初始化界面，设置导航信息和默认设置。 |     *   `get_widget_at_top`:  创建并返回界面顶部的设置卡片，包括生成模板、载入预设模板和添加切换操作的选项。 |     *   `get_content_widget`:  创建并返回界面的主要内容，包括状态显示、开始/停止录制按钮和日志显示卡片。 |     *   `on_interface_shown`:  界面显示时初始化设置。 |     *   `_template_generation`:  根据录制的数据生成动作模板，调用 `PreProcessor` 和 `SelfAdaptiveGenerator`。 |     *   `_on_key_press`:  处理快捷键事件，启动或停止录制。 |     *   `_on_start_clicked`:  开始录制，初始化 `RecordContext`。 |     *   `_on_stop_clicked`:  停止录制，结束相关线程和进程。 |     *   `_use_existing_changed`:  处理“载入预设模板”选项的改变。 |     *   `_add_switch_changed`:  处理“添加切换操作”选项的改变。 | *   **`AppRunner`**: 继承自 `QThread`，用于在单独的线程中运行录制和模板生成逻辑。 |     *   `run`: 执行录制和输出记录。 |  | **重要功能点:** |  | *   **录制功能**:  通过 `RecordContext` 录制游戏操作。 | *   **模板生成**:  使用 `PreProcessor` 和 `SelfAdaptiveGenerator` 从录制数据生成 YAML 格式的动作模板。 | *   **用户界面**:  提供用户友好的界面，用于控制录制、设置选项和查看日志。 | *   **设置选项**:  允许用户选择是否使用预设模板和是否添加切换代理人操作。 | *   **快捷
        │       ├── devtools/
        │       │   ├── app_devtools_interface.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | `AppDevtoolsInterface` 类别定义了一个应用程式的开发工具介面，它是一个 `PivotNavigatorInterface` 的子类，用于在应用程式中提供开发者工具的导航和管理。 |  | **核心类和函数：** |  | *   `AppDevtoolsInterface`:  主介面类别，继承自 `PivotNavigatorInterface`。 |     *   `__init__(self, ctx: ZContext, parent=None)`:  建构子，初始化介面并接收 `ZContext` 实例。 |     *   `create_sub_interface(self)`:  创建并添加子介面，包括 `DevtoolsScreenshotHelperInterface`, `DevtoolsTemplateHelperInterface`, 和 `DevtoolsScreenManageInterface`。 |  | **重要功能点：** |  | *   使用 `PivotNavigatorInterface` 实现导航介面，方便使用者在不同开发工具之间切换。 | *   整合了截图、模板辅助和萤幕管理等开发工具子介面。 | *   使用 `ZContext` 进行上下文管理。
        │       │   └── devtools_screenshot_helper_interface.py    这个 Python 文件定义了一个用于截图助手的 GUI 界面，该助手是开发工具的一部分。 |  | *   **主要功能:** 提供用户界面，用于配置和控制截图助手的设置，包括截图间隔、持续时间、保存截图的快捷键以及闪避检测功能。 | *   **核心类和函数:** |     *   `DevtoolsScreenshotHelperInterface`: 继承自 `AppRunInterface`，负责创建和管理截图助手的 UI。 |     *   `get_widget_at_top()`:  创建并返回包含设置选项的 UI 元素，包括文本框、开关和按键设置卡片。 |     *   `on_interface_shown()`:  当界面显示时，从上下文加载配置并更新 UI。 |     *   `get_app()`:  返回 `ScreenshotHelperApp` 实例，用于与应用程序逻辑交互。 |     *   `_on_frequency_changed()`, `_on_length_changed()`, `_on_key_save_changed()`, `_on_dodge_detect_changed()`:  处理 UI 控件的更改事件，并将设置更新到上下文中的配置。 | *   **重要功能点:** |     *   提供用户界面，用于配置截图助手的各项参数。 |     *   使用 `TextSettingCard`, `KeySettingCard`, 和 `SwitchSettingCard` 等自定义 UI 控件来展示和编辑设置。 |     *   在界面显示时加载配置，并在设置更改时更新配置。 |     *   与 `ScreenshotHelperApp` 交互以执行截图操作。
        │       ├── game_assistant/
        │       │   ├── commission_assistant_interface.py    这个 Python 文件定义了 `CommissionAssistantRunInterface` 类，它是一个用于游戏内委托助手功能的 GUI 界面。 |  | **核心类和函数:** |  | *   `CommissionAssistantRunInterface`: 继承自 `AppRunInterface`，负责创建和管理委托助手界面的 UI 元素，并处理用户交互。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，接收上下文 `ZContext`。 |     *   `get_widget_at_top(self) -> QWidget`:  创建并返回包含各种设置选项的 UI 元素，例如对话选项、点击间隔、剧情模式、自动闪避和自动战斗的配置。 |     *   `on_interface_shown(self) -> None`:  界面显示时，初始化各个设置卡片，将配置与上下文中的数据进行绑定。 |     *   `on_interface_hidden(self) -> None`: 界面隐藏时，执行清理操作。 |     *   `get_app(self) -> Application`:  返回 `CommissionAssistantApp` 实例，作为应用程序的后端逻辑。 |  | **重要功能点:** |  | *   提供用户界面，用于配置委托助手功能的各项参数。 | *   使用 `ComboBoxSettingCard`, `TextSettingCard`, `KeySettingCard` 等自定义控件，方便用户设置。 | *   通过 `init_with_adapter` 将 UI 控件与配置数据进行绑定，实现配置的读取和保存。 | *   包含使用说明链接，方便用户了解功能。
        │       │   ├── game_assistant.py    这个 Python 文件的摘要如下： |  | *   **主要功能:** 该文件定义了一个游戏助手界面，用于整合多个游戏相关的辅助工具。 | *   **核心类和函数:** |     *   `GameAssistantInterface`: 继承自 `PivotNavigatorInterface`，是游戏助手的核心界面，负责管理和展示子界面。 |     *   `create_sub_interface()`: 创建并添加子界面，包括 `CommissionAssistantRunInterface`, `LifeOnLineRunInterface`, 和 `PredefinedTeamCheckerInterface`。 | *   **重要功能点:** |     *   使用 `PivotNavigatorInterface` 实现导航界面。 |     *   整合了多个游戏辅助工具的子界面。 |     *   使用 `ZContext` 传递上下文信息。
        │       │   ├── life_on_line_run_interface.py    这个 Python 文件定义了一个名为 `LifeOnLineRunInterface` 的界面，用于「拿命验收」功能，该功能可能与游戏助手相关。 |  | *   **主要功能:** 提供一个界面，用于配置和运行与游戏相关的「拿命验收」功能，包括查看使用说明、设置每日运行次数和选择预设队伍。 | *   **核心类和函数:** |     *   `LifeOnLineRunInterface`: 继承自 `AppRunInterface`，负责构建和管理界面。 |     *   `__init__`: 初始化界面，接收 `ZContext` 实例。 |     *   `get_widget_at_top`: 创建界面顶部的部件，包括超链接卡片（用于帮助说明）、文本设置卡片（用于每日次数）和组合框设置卡片（用于预设队伍）。 |     *   `on_interface_shown`: 在界面显示时初始化设置卡片，包括从配置中加载数据，并更新每日运行次数的显示。 |     *   `get_app`: 返回 `LifeOnLineApp` 实例。 | *   **重要功能点:** |     *   使用 `HyperlinkCard` 提供使用说明。 |     *   使用 `TextSettingCard` 显示和设置每日运行次数。 |     *   使用 `ComboBoxSettingCard` 选择预设队伍。 |     *   通过 `ZContext` 访问配置和记录数据。 |     *   使用 `LifeOnLineApp` 运行应用程序逻辑。
        │       │   └── predefined_team_checker_interface.py    这个 Python 文件定义了一个名为 `PredefinedTeamCheckerInterface` 的 GUI 界面，用于预备编队识别。 |  | *   **主要功能:** 提供一个界面，用于根据用户输入的编队名称识别代理人。 | *   **核心类和函数:** |     *   `PredefinedTeamCheckerInterface`: 继承自 `AppRunInterface`，负责界面初始化和管理。 |     *   `get_widget_at_top()`:  创建并返回界面顶部的部件，包括一个 `HyperlinkCard` 用于显示帮助信息。 |     *   `on_interface_shown()`:  界面显示时的处理函数。 |     *   `get_app()`:  返回 `PredefinedTeamChecker` 实例，作为应用程序的核心逻辑。 | *   **重要功能点:** |     *   使用 `HyperlinkCard` 提供用户帮助。 |     *   通过 `get_app()` 函数，将 `PredefinedTeamChecker` 实例作为应用程序的核心逻辑。 |     *   继承自 `AppRunInterface`，表明它是一个应用程序运行界面。
        │       ├── hollow_zero/
        │       │   ├── hollow_zero_challenge_config_interface.py    ```python | # 摘要 | # 1. 文件主要功能： | #    - 提供一个GUI界面，用于配置和管理枯萎之零挑战的配置。用户可以创建、复制、删除和编辑挑战配置，包括目标配队、自动战斗设置、寻路方式、奖励优先级等。 | # 2. 核心类和函数： | #    - HollowZeroChallengeConfigInterface: 继承自VerticalScrollInterface，是主界面类，负责UI的构建和事件处理。 | #    - _init_left_part(): 初始化左侧的配置选项，包括按钮、文本框、下拉框等。 | #    - _init_right_part(): 初始化右侧的奖励优先级输入框。 | #    - on_interface_shown():  界面显示时初始化，更新界面状态。 | #    - _update_whole_display():  根据当前配置状态更新整个界面的显示。 | #    - _on_..._clicked():  处理各种按钮点击事件，如创建、复制、删除、取消等。 | #    - _on_..._changed():  处理各种配置选项改变的事件，如名称、自动战斗、寻路方式等。 | # 3. 重要功能点： | #    - 配置的创建、复制、删除和保存。 | #    - 目标配队的配置，通过EditableComboBox选择角色。 | #    - 自动战斗配置的选择。 | #    - 寻路方式的配置，包括自定义寻路设置。 | #    - 奖励优先级的配置。 | ```
        │       │   ├── hollow_zero_interface.py    这个 Python 文件的摘要如下： |  | *   **主要功能:**  `HollowZeroInterface` 是一个用于管理 "零号空洞" 相关子界面的导航界面。它使用 `PivotNavigatorInterface` 作为基类，并负责创建和组织与 "零号空洞" 相关的配置和运行界面。 | *   **核心类和函数:** |     *   `HollowZeroInterface`:  继承自 `PivotNavigatorInterface`，是主界面类。 |     *   `__init__(self, ctx: ZContext, parent=None)`:  构造函数，初始化上下文 (`ZContext`) 和父窗口。 |     *   `create_sub_interface(self)`:  创建并添加子界面，包括 `HollowZeroRunInterface`, `HollowZeroChallengeConfigInterface`, `LostVoidRunInterface`, 和 `LostVoidChallengeConfigInterface`。 | *   **重要功能点:** |     *   使用 `PivotNavigatorInterface` 实现导航功能。 |     *   管理与 "零号空洞" 相关的子界面，包括运行和配置界面。 |     *   使用 `ZContext` 传递上下文信息。 |     *   使用 `FluentIcon.IOT` 设置导航图标。
        │       │   ├── hollow_zero_run_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `HollowZeroRunInterface` 类，用于在 GUI 中展示和控制“枯萎之都”的运行界面。它继承自 `AppRunInterface`，提供了用户界面元素，允许用户配置和启动枯萎之都相关的任务。 |  | **核心类和函数:** |  | *   **`HollowZeroRunInterface(ctx: ZContext, parent=None)`**:  构造函数，初始化界面，接收 `ZContext` 上下文。 | *   **`get_widget_at_top() -> QWidget`**:  创建并返回包含左右布局的顶层 widget，用于放置设置选项。 | *   **`_get_left_opts() -> QWidget`**:  创建并返回左侧的设置选项，包括帮助链接、副本选择、每周基础次数、额外刷取选项。 | *   **`_get_right_opts() -> QWidget`**:  创建并返回右侧的设置选项，包括运行记录、挑战配置、每日进入次数、额外刷取方式选项。 | *   **`on_interface_shown() -> None`**:  界面显示时进行初始化，包括更新副本选项、挑战配置选项，以及设置初始值。 | *   **`_update_run_record_display() -> None`**:  更新运行记录的显示内容。 | *   **`_update_mission_options() -> None`**:  更新副本选择的选项。 | *   **`_update_challenge_config_options() -> None`**:  更新挑战配置的选项。 | *   **`_on_mission_changed(self, idx, value) -> None`**:  处理副本选择改变的事件。 | *   **`_on_reset_record_clicked() -> None`**:  处理重置运行记录的点击事件。 | *   **`get_app() -> ZApplication`**:  获取当前运行的应用程序实例。 | *   **`_on_start_clicked() -> None`**:  处理正常运行按钮的点击事件，启动 `HollowZeroApp`。 | *   **`_on_debug_clicked() -> None`**:  处理调试按钮的点击事件，启动 `HollowZeroDebugApp`。 | *   **`_on_weekly_plan_times
        │       │   ├── lost_void_challenge_config_interface.py    **文件摘要** |  | *   **主要功能:**  该文件定义了一个用于配置《迷失虚空挑战》的界面，允许用户创建、编辑、复制和删除挑战配置。界面包含多个设置选项，如自动战斗配置、周期增益、商店购买策略以及藏品和区域类型的优先级设置。 | *   **核心类和函数:** |     *   `LostVoidChallengeConfigInterface`:  继承自 `VerticalScrollInterface`，是配置界面的主类。 |     *   `_init_left_part()`:  初始化界面左侧的控件，包括按钮和各种设置卡片。 |     *   `_init_right_part()`:  初始化界面右侧的控件，主要用于输入藏品和区域类型的优先级。 |     *   `on_interface_shown()`:  界面显示时进行初始化，加载数据并更新显示。 |     *   `_update_whole_display()`:  根据当前配置状态更新整个界面的显示。 |     *   `_on_choose_existed_yml()`:  处理选择现有配置的事件。 |     *   `_on_create_clicked()`:  处理创建新配置的事件。 |     *   `_on_copy_clicked()`:  处理复制配置的事件。 |     *   `_on_delete_clicked()`:  处理删除配置的事件。 |     *   `_on_cancel_clicked()`:  处理取消编辑的事件。 |     *   `_on_name_changed()`:  处理配置名称改变的事件。 |     *   `_on_artifact_priority_changed()`:  处理藏品优先级改变的事件。 |     *   `_on_region_type_priority_changed()`:  处理区域类型优先级改变的事件。 | *   **重要功能点:** |     *   提供创建、复制、删除配置的功能。 |     *   允许用户选择现有的配置。 |     *   提供多种设置选项，包括自动战斗、周期增益、商店购买策略等。 |     *   允许用户自定义藏品和区域类型的优先级。 |     *   提供错误消息提示。 |     *   界面根据配置状态动态更新控件的可用状态。
        │       │   └── lost_void_run_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `LostVoidRunInterface` 类，用于构建“迷失之地”功能的 GUI 界面，允许用户配置和运行与“迷失之地”相关的任务。 |  | **核心类和函数:** |  | *   **`LostVoidRunInterface(ctx: ZContext, parent=None)`:**  主界面类，继承自 `AppRunInterface`，负责界面的初始化和布局。 | *   **`get_widget_at_top() -> QWidget`:**  创建并返回包含左右两侧设置选项的容器 widget。 | *   **`_get_left_opts() -> QWidget`:**  创建并返回左侧的设置选项，包括帮助说明、副本选择、每周基础次数和额外刷取选项。 | *   **`_get_right_opts() -> QWidget`:**  创建并返回右侧的设置选项，包括运行记录、挑战配置和每天进入次数选项。 | *   **`on_interface_shown() -> None`:**  界面显示时进行初始化，更新各种选项。 | *   **`_update_mission_options() -> None`:**  更新副本选择的选项。 | *   **`_update_challenge_config_options() -> None`:**  更新挑战配置的选项。 | *   **`_on_reset_record_clicked() -> None`:**  重置运行记录。 | *   **`_on_start_clicked() -> None`:**  启动 LostVoidApp。 | *   **`_on_context_state_changed() -> None`:**  根据运行状态更新显示。 |  | **重要功能点:** |  | *   提供用户界面，用于配置迷失之地任务的各种参数，如副本、挑战配置、刷取次数等。 | *   使用 `ComboBoxSettingCard` 和 `TextSettingCard` 等自定义控件来展示和编辑配置选项。 | *   通过 `HyperlinkCard` 提供使用说明。 | *   提供重置运行记录的功能。 | *   根据上下文状态更新界面显示。 | *   启动 `LostVoidApp` 来运行迷失之地任务。
        │       ├── home/
        │       │   └── home_interface.py    ```python | # 摘要 |  | # 主要功能: | # 这是一个用于 Zenless Zone Zero (ZZZ) 的主页界面，提供了启动游戏、访问官网、GitHub 仓库、文档和社群的功能，并包含检查更新的机制。 |  | # 核心类和函数: | # - HomeInterface: 主页界面的核心类，继承自 VerticalScrollInterface，负责布局和管理主页的 UI 元素，包括按钮组、公告卡片和启动游戏按钮。 | # - ButtonGroup: 包含一系列 IconButton，用于导航到官网、GitHub、文档、社群等。 | # - CheckRunnerBase, CheckCodeRunner, CheckVenvRunner, CheckModelRunner: 用于检查代码、依赖、模型更新的线程类。 | # - GameStartThread: 启动游戏的线程，负责调用 OpenGame 操作。 | # - LauncherGame: 继承自 Operation，封装了启动游戏的操作。 | # - start_game: HomeInterface 的函数，用于启动游戏，显示启动中对话框，并启动 GameStartThread。 |  | # 重要功能点: | # - 界面布局: 使用 PySide6 的组件构建主页界面，包括 Banner、按钮组、公告卡片和启动按钮。 | # - 导航功能: ButtonGroup 中的按钮链接到官网、GitHub、文档和社群。 | # - 启动游戏: 点击启动游戏按钮后，通过 GameStartThread 启动游戏，并显示启动中对话框。 | # - 更新检查: 启动时自动检查代码、依赖和模型更新，并在有更新时显示提示。 | # - 错误处理: 启动游戏失败时，显示错误信息。 | ```
        │       ├── installer/
        │       │   ├── extend_install_interface.py    这个 Python 文件定义了一个名为 `ExtendInstallInterface` 的界面，用于扩展安装功能。 |  | **主要功能:** |  | *   提供一个用于扩展安装的界面，包括进度条、Gamepad 安装选项和日志显示。 |  | **核心类和函数:** |  | *   `ExtendInstallInterface`: 继承自 `VerticalScrollInterface`，是主界面类。 |     *   `__init__(self, ctx: OneDragonEnvContext, parent=None)`: 初始化界面，设置上下文和导航信息。 |     *   `get_content_widget(self) -> QWidget`: 创建界面内容，包括进度条、Gamepad 安装卡片和日志显示卡片。 |     *   `on_interface_shown(self) -> None`: 界面显示时的回调，用于检查和更新组件状态。 |     *   `on_interface_hidden(self) -> None`: 界面隐藏时的回调，用于停止日志。 |     *   `update_progress(self, progress: float, message: str) -> None`: 更新进度条的显示。 |  | **重要功能点:** |  | *   使用 `ProgressBar` 和 `IndeterminateProgressBar` 显示安装进度。 | *   包含 `GamepadInstallCard` 用于 Gamepad 相关的安装选项。 | *   使用 `LogDisplayCard` 显示安装日志。 | *   提供 `on_interface_shown` 和 `on_interface_hidden` 回调函数，用于界面生命周期的管理。 | *   `update_progress` 函数用于更新进度条，支持确定和不确定进度模式。
        │       │   └── gamepad_install_card.py    这个 Python 文件定义了一个名为 `GamepadInstallCard` 的类，它继承自 `BaseInstallCard`，用于在 GUI 中安装和管理虚拟手柄的依赖。 |  | **核心类和函数:** |  | *   **`GamepadInstallCard`**: 继承自 `BaseInstallCard`，负责处理虚拟手柄的安装和状态显示。 |     *   `__init__`: 初始化，设置标题和安装方法。 |     *   `after_progress_done`: 安装完成后的回调，更新配置和显示。 |     *   `get_display_content`: 获取显示的状态信息（图标和文本）。 |     *   `get_requirement_time`: 获取 requirements.txt 文件的最后更新时间。 |     *   `install_requirements`: 安装虚拟手柄的依赖。 |     *   `get_requirement_path`: 获取 requirements.txt 文件的路径。 |  | **重要功能点:** |  | *   **依赖安装:** 使用 `pip` 安装 requirements.txt 中指定的依赖。 | *   **状态显示:** 根据依赖的安装状态显示不同的图标和文本。 | *   **更新检测:** 检查 requirements.txt 的更新时间，提示用户更新。 | *   **配置管理:** 使用 `OneDragonEnvContext` 获取环境配置，并在安装成功后更新配置。 | *   **进度回调:** 在安装过程中提供进度回调。
        │       ├── one_dragon/
        │       │   ├── charge_plan_interface.py    **摘要:** |  | 该文件定义了用于管理和显示游戏内体力计划的 GUI 界面。 |  | **核心类和函数:** |  | *   **`ChargePlanCard`**:  一个 `MultiLineSettingCard` 的子类，用于显示和编辑单个体力计划的详细信息。 |     *   包含多个 `ComboBox` 和 `LineEdit`，用于设置计划的类别、任务类型、任务、卡牌数量、狩猎buff、预设队伍、自动战斗配置、运行次数和计划次数。 |     *   使用信号连接到上下文对象，以便在计划更改时更新配置。 |     *   `init_with_plan()`:  使用给定的 `ChargePlanItem` 初始化卡片。 |     *   `_on_..._changed()`:  处理各种控件的更改事件，更新 `ChargePlanItem` 并发出 `changed` 信号。 |     *   `_on_..._clicked()`:  处理按钮点击事件，例如删除、上移、置顶。 |     *   `update_by_history()`:  根据历史记录更新计划。 | *   **`ChargePlanInterface`**:  一个 `VerticalScrollInterface` 的子类，用于显示和管理体力计划列表。 |     *   `get_content_widget()`:  创建界面内容，包括循环执行开关和体力计划卡片列表。 |     *   `update_plan_list_display()`:  根据配置更新计划卡片的显示。 |     *   `_on_add_clicked()`:  添加新的体力计划。 |     *   `_on_plan_item_...()`:  处理单个计划卡片发出的信号，例如更改、删除、上移、置顶。 |     *   `_on_loop_changed()`:  处理循环执行开关的更改。 |  | **重要功能点:** |  | *   **体力计划编辑**:  允许用户配置和编辑体力计划的各个方面，包括类别、任务、卡牌数量等。 | *   **计划列表管理**:  支持添加、删除、移动计划，并根据配置动态更新界面。 | *   **循环执行**:  提供一个开关，用于启用或禁用循环执行体力计划。 | *   **历史记录集成**:  根据历史记录更新计划。 | *   **用户界面**:  使用 `qfluentwidgets`
        │       │   ├── coffee_plan_interface.py    **摘要:** |  | 该文件定义了 `CoffeePlanInterface` 类，用于在 GUI 中展示和配置咖啡计划相关的设置。它基于 `VerticalScrollInterface`，并使用各种设置卡片（`ComboBoxSettingCard` 和 `SwitchSettingCard`）来提供用户界面。 |  | **核心类和函数:** |  | *   **`CoffeePlanInterface(VerticalScrollInterface)`**:  主界面类，继承自 `VerticalScrollInterface`。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，设置上下文和导航文本。 |     *   `get_content_widget(self) -> QWidget`:  构建界面内容，包括各种设置卡片，如咖啡选择方式、挑战方式、体力计划外的数量、预备编队、自动战斗和结束后运行体力计划。 |     *   `on_interface_shown(self) -> None`:  界面显示时初始化设置卡片的值，从上下文获取配置适配器，并设置选项。 |     *   `on_predefined_team_changed(self, idx: int, value: str) -> None`:  当预备编队选项改变时，根据选择的编队，控制自动战斗选项的可见性。 |  | **重要功能点:** |  | *   **配置界面**:  提供用户友好的界面，用于配置咖啡计划的各种参数。 | *   **设置卡片**:  使用 `ComboBoxSettingCard` 和 `SwitchSettingCard` 等自定义设置卡片，方便用户进行配置。 | *   **数据绑定**:  通过配置适配器，将设置卡片与应用程序的配置数据绑定。 | *   **动态更新**:  根据用户选择的预备编队，动态控制自动战斗选项的可见性。 | *   **上下文依赖**:  依赖于 `ZContext` 来访问应用程序的配置和数据。
        │       │   ├── miscellany_run_interface.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | *   `MiscellanyRunInterface` 类别定义了一个用于执行杂项任务的用户界面，它继承自 `OneDragonRunInterface`。 |  | **核心类和函数：** |  | *   `MiscellanyRunInterface`: 继承自 `OneDragonRunInterface`，用于创建杂项任务的运行界面。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，设置上下文、导航文本、对象名称等。 |     *   `get_one_dragon_app(self) -> OneDragonApp`:  返回 `MiscellanyApp` 的实例。 |     *   `get_one_dragon_app_config(self) -> OneDragonAppConfig`: 返回杂项配置。 |  | **重要功能点：** |  | *   界面初始化时，会设置导航文本为“杂项任务”，并指定帮助文档的 URL。 | *   `get_one_dragon_app` 方法用于获取 `MiscellanyApp` 实例，用于处理杂项任务的应用逻辑。 | *   `get_one_dragon_app_config` 方法用于获取杂项配置，用于配置杂项任务的行为。
        │       │   ├── notorious_hunt_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了用于在 GUI 中显示和编辑“恶名狩猎”计划的界面。它允许用户配置和管理狩猎任务的各种参数，例如任务类型、等级、预设队伍、自动战斗配置、buff 和运行次数。 |  | **核心类和函数:** |  | *   **`ChargePlanCard`**: |     *   `__init__`: 初始化一个用于显示和编辑单个“恶名狩猎”计划的卡片。包含多个 `ComboBox` 和 `LineEdit` 用于配置计划的各个属性。 |     *   `init_with_plan`: 使用给定的 `ChargePlanItem` 初始化卡片中的控件。 |     *   `init_mission_type_combo_box`, `init_level_combo_box`, `init_buff_combo_box`, `init_auto_battle_box`, `init_predefined_team_opt`, `init_run_times_input`, `init_plan_times_input`: 用于初始化各个控件，从配置中加载数据。 |     *   `_on_mission_type_changed`, `_on_level_changed`, `on_buff_changed`, `on_predefined_team_changed`, `_on_auto_battle_changed`, `_on_run_times_changed`, `_on_plan_times_changed`: 响应控件值改变的槽函数，更新 `ChargePlanItem` 的属性并发出 `changed` 信号。 |     *   `_emit_value`: 发出 `changed` 信号，通知计划已更改。 | *   **`NotoriousHuntPlanInterface`**: |     *   `__init__`: 初始化“恶名狩猎”计划的界面，继承自 `VerticalScrollInterface`。 |     *   `get_content_widget`: 创建并返回包含 `ChargePlanCard` 实例的 `Column` 布局。 |     *   `update_plan_list_display`: 根据配置中的计划列表动态更新卡片列表。 |     *   `on_interface_shown`: 当界面显示时，调用 `update_plan_list_display`。 |     *   `on_interface_hidden`: 当界面隐藏时，执行清理操作。 |     *   `_on_plan_item_changed`:
        │       │   ├── setting_team_interface.py    这个 Python 文件的主要功能是提供一个用于配置游戏中预设队伍的 GUI 介面。它允许使用者设定队伍名称、自动战斗选项和队伍成员的代理人。 |  | 核心类和函数： |  | *   **TeamSettingCard**: 继承自 `MultiPushSettingCard`，用于显示和编辑单个预设队伍的设定。 |     *   `__init__`: 初始化 UI 元素，例如下拉选单和输入框，并连接信号槽。 |     *   `init_setting_card`: 使用给定的队伍资讯初始化卡片。 |     *   `on_name_changed`, `on_auto_battle_changed`, `on_agent_1_changed`, `on_agent_2_changed`, `on_agent_3_changed`: 处理使用者输入更改，更新队伍资讯，并发射 `changed` 信号。 | *   **SettingTeamInterface**: 继承自 `VerticalScrollInterface`，是整个设定介面的主介面。 |     *   `__init__`: 初始化介面，包括上下文和导航文本。 |     *   `get_content_widget`: 建立介面的内容，包括帮助讯息和多个 `TeamSettingCard` 实例。 |     *   `on_interface_shown`: 在介面显示时初始化每个 `TeamSettingCard` 的设定。 |     *   `on_team_info_changed`: 处理 `TeamSettingCard` 发射的 `changed` 信号，更新上下文中的队伍配置。 |  | 重要功能点： |  | *   允许使用者设定预设队伍的名称。 | *   允许使用者选择每个队伍的自动战斗选项。 | *   允许使用者为每个队伍选择三个代理人。 | *   使用 `VerticalScrollInterface` 显示可滚动的介面。 | *   使用 `MultiPushSettingCard` 显示每个队伍的设定。 | *   使用 `ComboBox` 和 `EditableComboBox` 实现下拉选单。 | *   使用 `LineEdit` 实现文字输入。 | *   使用信号和槽来处理使用者输入更改，并更新队伍配置。 | *   提供帮助讯息。
        │       │   ├── shiyu_defense_interface.py    **摘要：** |  | 该文件定义了 `ShiyuDefenseInterface` 类，用于在用户界面中展示和管理式舆防卫战相关信息。它基于 `VerticalScrollInterface`，并使用 `QTableWidget` 和 `CheckBox` 等控件来显示队伍信息和设置。 |  | **核心类和函数：** |  | *   `ShiyuDefenseInterface`:  继承自 `VerticalScrollInterface`，是式舆防卫战界面的主类。 |     *   `__init__`: 初始化界面，设置上下文和导航文本。 |     *   `get_content_widget`: 构建界面内容，包括重置按钮和队伍表格。 |     *   `on_interface_shown`:  界面显示时更新表格数据，包括队伍名称、剧变节点状态和属性弱点。 |     *   `on_weakness_check_changed`: 处理属性弱点复选框状态改变的事件。 |     *   `on_critical_changed`: 处理剧变节点复选框状态改变的事件。 |     *   `on_critical_reset_clicked`: 处理重置运行记录按钮点击事件。 |  | **重要功能点：** |  | *   **队伍信息展示:**  使用表格显示队伍名称、是否参与剧变节点以及属性弱点。 | *   **剧变节点设置:**  通过复选框控制队伍是否参与剧变节点。 | *   **属性弱点设置:**  通过复选框设置队伍的属性弱点。 | *   **重置功能:**  提供重置剧变节点运行记录的功能。 | *   **数据绑定:**  将界面控件与上下文中的数据（如队伍配置、弱点信息）进行绑定，并响应用户交互更新数据。
        │       │   ├── zzz_one_dragon_interface.py    这个 Python 文件定义了一个名为 `ZOneDragonInterface` 的类，它是一个用于管理“一条龙”功能的界面，继承自 `PivotNavigatorInterface`。 |  | *   **主要功能**: 作为一个导航界面，整合了多个子界面，提供对“一条龙”相关功能的访问。 | *   **核心类**: `ZOneDragonInterface` 继承自 `PivotNavigatorInterface`。 | *   **重要功能点**: |     *   `__init__`: 初始化界面，设置导航图标、名称和父对象。 |     *   `create_sub_interface`: 创建并添加多个子界面，包括 `ZOneDragonRunInterface`, `SettingTeamInterface`, `ChargePlanInterface`, `NotoriousHuntPlanInterface`, `CoffeePlanInterface`, `ShiyuDefenseInterface` 和 `ZOneDragonSettingInterface`。
        │       │   ├── zzz_one_dragon_run_interface.py    这个 Python 文件定义了 `ZOneDragonRunInterface` 类，它继承自 `OneDragonRunInterface`。 |  | *   **主要功能:**  为 ZZZ 版本的 OneDragon 应用提供运行界面。 | *   **核心类:** |     *   `ZOneDragonRunInterface`:  继承自 `OneDragonRunInterface`，用于初始化和获取 ZZZ 版本的 OneDragon 应用。 | *   **重要功能点:** |     *   `__init__`:  初始化 `ZOneDragonRunInterface`，接收 `ZContext` 实例，并设置帮助文档的 URL。 |     *   `get_one_dragon_app`:  返回 `ZOneDragonApp` 实例，用于获取 ZZZ 版本的 OneDragon 应用。
        │       │   └── zzz_one_dragon_setting_interface.py    这个 Python 文件定义了一个用于配置游戏设置的界面，使用 PySide6 和 qfluentwidgets 库。 |  | **主要功能:** |  | *   提供一个垂直滚动的界面，用于配置游戏的各种设置，包括代理人皮肤、影像店代理人和驱动盘拆解选项。 |  | **核心类和函数:** |  | *   `ZOneDragonSettingInterface`: 继承自 `VerticalScrollInterface`，是主要的设置界面类。 |     *   `__init__`: 初始化界面，接收一个 `ZContext` 实例。 |     *   `get_content_widget`: 创建并返回包含所有设置组件的 `QWidget`。 |     *   `get_agent_outfit_group`: 创建代理人皮肤设置组。 |     *   `get_coffee_shop_group`: 创建影像店设置组。 |     *   `get_drive_disc_dismantle_group`: 创建驱动盘拆解设置组。 |     *   `on_interface_shown`: 在界面显示时初始化设置卡片的值，使用配置适配器。 |     *   `on_agent_outfit_changed`: 当代理人皮肤选项更改时调用，重新初始化代理人模板 ID。 |  | **重要功能点:** |  | *   使用 `SettingCardGroup` 组织设置选项。 | *   使用 `ComboBoxSettingCard` 和 `EditableComboBoxSettingCard` 实现下拉框设置。 | *   使用 `SwitchSettingCard` 实现开关设置。 | *   使用 `ConfigItem` 封装配置选项。 | *   使用 `ZContext` 访问游戏配置和数据。 | *   使用配置适配器来绑定设置卡片的值到配置。 | *   支持多语言，使用 `gt` 函数进行文本翻译。
        │       └── setting/
        │           ├── app_setting_interface.py    这个 Python 文件的摘要如下： |  | *   **主要功能:**  定义了应用程式的设置界面，它是一个导航界面，用于管理不同类型的设置子界面。 | *   **核心类和函数:** |     *   `AppSettingInterface`:  继承自 `PivotNavigatorInterface`，是主要的设置界面，负责管理和显示子设置界面。 |     *   `create_sub_interface()`:  创建并添加了多个子设置界面，包括游戏设置、YOLO设置、环境设置和自定义设置。 | *   **重要功能点:** |     *   使用 `PivotNavigatorInterface` 实现导航功能，提供了一个设置页面的入口。 |     *   通过 `add_sub_interface()` 添加了多个子设置界面，实现了模块化的设置管理。 |     *   依赖于 `ZContext` 类来获取应用程式的上下文信息。
        │           ├── setting_game_interface.py    ```python | # 摘要 | # 该文件定义了游戏设置界面，允许用户配置游戏内的多个选项。 |  | # 核心类和函数 | # - SettingGameInterface: 继承自 VerticalScrollInterface，用于创建游戏设置界面的主窗口。 | #   - get_content_widget: 构建界面内容，包含多个设置组。 | #   - _get_agent_outfit_group: 创建代理人皮肤设置组。 | #   - _get_basic_group: 创建游戏基础设置组。 | #   - _get_launch_argument_group: 创建启动参数设置组。 | #   - _get_key_group: 创建游戏按键设置组。 | #   - _get_gamepad_group: 创建手柄按键设置组。 | #   - on_interface_shown: 初始化界面，将设置选项与配置数据绑定。 | #   - _update_gamepad_part: 根据手柄类型更新手柄按键设置的可见性。 | #   - _on_gamepad_type_changed: 处理手柄类型更改事件。 | #   - _on_agent_outfit_changed: 处理代理人皮肤更改事件。 | #   - _on_hdr_switch_changed: 处理HDR开关更改事件。 | #   - _on_launch_argument_switch_changed: 处理启动参数开关更改事件。 |  | # 重要功能点 | # - 代理人皮肤选择 | # - 游戏基础设置 (输入方式) | # - 启动参数设置 (窗口尺寸, 全屏, 无边框窗口, 显示器) | # - 按键绑定 | # - 手柄按键绑定 (Xbox, DS4) | # - HDR 开关 | # - 启动参数开关 | ```
        │           ├── setting_yolo_interface.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `SettingYoloInterface` 类，用于在 GUI 中显示和管理 YOLO 模型相关的设置。它允许用户选择和下载不同的 YOLO 模型，并配置 GPU 运算选项。同时，它还包含一个日志显示区域，用于显示模型下载和配置过程中的日志信息。 |  | **核心类和函数:** |  | *   `SettingYoloInterface`: 继承自 `VerticalScrollInterface`，是主界面，用于展示 YOLO 模型的设置选项。 |     *   `__init__(self, ctx: ZContext, parent=None)`: 初始化界面，接收一个 `ZContext` 对象。 |     *   `get_content_widget(self) -> QWidget`: 构建界面内容，包括模型设置组和日志组。 |     *   `_init_model_group(self) -> SettingCardGroup`: 初始化模型设置组，包含模型下载和 GPU 运算选项。 |     *   `_init_log_group(self) -> SettingCardGroup`: 初始化日志组，包含日志显示卡片。 |     *   `on_interface_shown(self) -> None`: 界面显示时初始化配置和启动日志。 |     *   `on_interface_hidden(self) -> None`: 界面隐藏时停止日志。 |     *   `_init_flash_classifier_opts(self) -> None`: 初始化闪光识别模型选项。 |     *   `_init_hollow_zero_event_opts(self) -> None`: 初始化空洞格子识别模型选项。 |     *   `_init_lost_void_det_opts(self) -> None`: 初始化迷失之地识别模型选项。 |     *   `_on_flash_classifier_changed(self, index: int, value: str) -> None`: 闪光识别模型选项改变时的处理函数。 |     *   `_on_hollow_zero_event_changed(self, index: int, value: str) -> None`: 空洞格子识别模型选项改变时的处理函数。 |     *   `_on_lost_void_det_changed(self, index: int, value: str) -> None`: 迷失之地识别模型选项改变时的处理函数。 | *   `ZContext`: 上下文对象，用于访问配置信息
        │           └── zzz_setting_instance_interface.py    这个 Python 文件的摘要如下： |  | *   **主要功能：** 该文件定义了 `ZSettingInstanceInterface` 类，它继承自 `SettingInstanceInterface`，用于在 GUI 中处理设置相关的界面。 | *   **核心类和函数：** |     *   `ZSettingInstanceInterface`: 继承自 `SettingInstanceInterface`，用于处理设置界面的实例。 |     *   `__init__(self, ctx: OneDragonContext, parent=None)`: 构造函数，初始化 `ZSettingInstanceInterface` 实例，接收 `OneDragonContext` 实例和可选的父级部件。 | *   **重要功能点：** |     *   初始化时接收 `OneDragonContext` 实例，并将其保存为 `ctx` 属性。 |     *   调用父类 `SettingInstanceInterface` 的构造函数进行初始化。
        ├── hollow_zero/
        │   ├── hollow_battle.py    ```python | 文件摘要： |  | 该文件定义了 `HollowBattle` 类，用于处理《崩坏：星穹铁道》游戏中的零号空洞战斗流程自动化。它继承自 `ZOperation`，并使用状态机模式来控制战斗的各个阶段，包括加载自动战斗指令、等待战斗画面加载、识别特殊移动、移动到战斗位置、自动战斗、处理战斗结果（结算、更新楼层信息、撤退等）以及退出战斗。 |  | 核心类和函数： |  | *   `HollowBattle` 类：核心类，负责控制零号空洞战斗的整个流程。 |     *   `__init__(self, ctx: ZContext, is_critical_stage: bool = False)`: 初始化函数，设置战斗状态和相关参数。 |     *   `load_auto_op()`: 加载自动战斗指令。 |     *   `wait_battle_screen()`: 等待战斗画面加载。 |     *   `check_special_move()`: 识别是否需要特殊移动。 |     *   `special_move()`: 执行特殊移动。 |     *   `move_to_battle()`: 移动到战斗位置。 |     *   `auto_battle()`: 执行自动战斗。 |     *   `period_reward_full()`: 处理结算周期上限。 |     *   `after_battle()`: 处理战斗结果，点击确定按钮。 |     *   `mission_complete()`: 处理普通战斗完成。 |     *   `update_level_info()`: 更新楼层信息。 |     *   `battle_fail()`: 处理战斗失败，点击撤退。 |     *   `move_fail()`: 处理移动失败，尝试退出战斗。 |     *   `click_exit()`: 点击退出战斗。 |     *   `click_exit_confirm()`: 确认退出战斗。 |     *   `wait_exit()`: 等待退出战斗完成。 |     *   `check_distance_to_move(self, screen: MatLike)`: 检查移动距离。 |     *   `_on_pause(self, e=None)`: 暂停时停止自动战斗。 |     *   `_on_resume(self, e=None)`: 恢复时恢复自动战斗。 |     *   `after_operation
        │   ├── hollow_exit_by_menu.py    这个 Python 脚本 `hollow_exit_by_menu.py` 实现了在游戏中通过菜单离开空洞的功能。 |  | *   **主要功能:** 让角色通过点击菜单上的按钮，离开零号空洞。 | *   **核心类:** `HollowExitByMenu` 继承自 `ZOperation`，负责执行离开空洞的操作。 | *   **重要功能点:** |     *   `click_menu`: 点击菜单按钮，如果成功，则等待；否则重试。 |     *   `click_leave`: 点击「离开」按钮。 |     *   `confirm_leave`: 确认离开。 |     *   `click_finish`: 点击「完成」按钮，直到返回街区。 |     *   使用 `operation_node` 和 `node_from` 装饰器定义操作流程和节点之间的依赖关系。 |     *   使用 `round_by_find_area` 和 `round_by_click_area` 等方法来进行屏幕截图、区域查找和点击操作。
        │   ├── hollow_level_info.py    这个 Python 文件定义了一个名为 `HollowLevelInfo` 的类，用于储存和管理与游戏或应用程序中的空心关卡相关的信息。 |  | *   **核心类:** `HollowLevelInfo` | *   **核心函数:** |     *   `__init__`: 初始化 `HollowLevelInfo` 实例，设置任务类型名称、任务名称、关卡和阶段。 |     *   `is_mission_type`: 检查给定的任务类型名称和关卡是否与当前实例匹配。 |     *   `to_next_level`: 将关卡提升到下一级，并将阶段重置为 1。 |     *   `to_next_phase`: 将阶段提升到下一阶段。 | *   **重要功能点:** |     *   储存关卡相关信息 (任务类型、任务名称、关卡、阶段)。 |     *   提供方法来判断是否为特定任务类型和关卡。 |     *   提供方法来推进关卡和阶段。
        │   ├── hollow_runner.py    ## 代码摘要 |  | **主要功能:** |  | 该 Python 脚本 `hollow_runner.py` 实现了在游戏《崩坏：星穹铁道》中自动执行“零号空洞”活动的逻辑。它通过图像识别、事件处理和寻路算法，实现自动探索、战斗、处理事件和退出空洞的功能。 |  | **核心类和函数:** |  | *   **`HollowRunner(ZOperation)`**:  核心类，继承自 `ZOperation`，负责整个空洞活动的流程控制。 |     *   `check_screen()`:  核心函数，用于识别游戏画面，根据识别结果触发相应的事件处理或寻路操作。 |     *   `_handle_event(screen: MatLike, event_name: str)`:  处理识别到的事件，根据事件类型调用相应的处理程序。 |     *   `try_move_by_map(screen: MatLike, screen_time: float, current_map: HollowZeroMap)`:  根据地图信息进行自动寻路和移动。 |     *   `get_map_node_pos_to_click(screen: MatLike, node: HollowZeroMapNode)`:  获取地图上格子的点击位置，并避开可能出现的选项。 |     *   `exit_hollow()`: 离开空洞 |     *   `mission_complete()`: 完成任务 |  | **重要功能点:** |  | *   **图像识别:**  使用 `hollow_event_utils.check_screen()`  识别游戏画面中的事件和状态。 | *   **事件处理:**  根据识别到的事件，调用不同的事件处理程序 (例如 `CallForSupport`, `BambooMerchant`, `HollowBattle` 等)。 | *   **自动寻路:**  通过 `HollowZeroMap` 和相关服务实现自动寻路，并根据地图信息移动到目标位置。 | *   **地图交互:**  通过点击地图上的格子进行移动，并处理格子上的事件。 | *   **退出机制:**  在满足特定条件或完成任务后，通过菜单退出空洞。 | *   **额外任务处理:**  处理额外的任务，例如业绩考察点和周期性奖励。 | *   **调试功能:**  提供保存截图用于调试和优化模型的功能。
        │   ├── hollow_zero_challenge_config.py    ## 代码摘要 |  | 该Python文件定义了用于管理"Hollow Zero Challenge"配置的类和函数，这些配置基于YAML文件。 |  | **主要功能:** |  | *   加载、保存和管理Hollow Zero Challenge的配置。 | *   提供配置文件的创建、复制和更新功能。 | *   定义了配置项的属性，如自动战斗设置、优先购买物品、寻路方式等。 | *   提供获取所有配置实例和生成新配置文件名称的函数。 |  | **核心类和函数:** |  | *   **`HollowZeroChallengePathFinding(Enum)`:** 定义了寻路方式的枚举。 | *   **`HollowZeroChallengeConfig(YamlConfig)`:** 继承自`YamlConfig`，用于处理Hollow Zero Challenge的配置。 |     *   `__init__`: 初始化配置，设置子目录、是否为mock等。 |     *   `copy_new`: 复制配置并生成新的配置文件名。 |     *   `remove_sample`: 将配置文件标记为非sample。 |     *   `update_module_name`: 更新模块名称并保存配置。 |     *   `save`: 保存配置，处理旧文件删除和文件路径更新。 |     *   `auto_battle`, `resonium_priority`, `event_priority`, `target_agents`, `path_finding`, `go_in_1_step`, `waypoint`, `avoid`, `buy_only_priority`:  定义了配置项的getter和setter方法，用于访问和修改配置。 | *   **`get_all_hollow_zero_challenge_config(with_sample: bool = True)`:**  从配置文件目录加载所有HollowZeroChallengeConfig实例。 | *   **`get_hollow_zero_challenge_new_name()`:**  生成新的配置文件名。 |  | **重要功能点:** |  | *   支持多种寻路方式。 | *   可以设置自动战斗模式。 | *   可以设置共鸣优先购买列表。 | *   可以设置事件优先级。 | *   可以设置目标代理。 | *   可以设置途经点和避免点。 | *   支持只购买优先级中的物品。 | *   提供复制、重命名和删除旧配置文件的功能。
        │   ├── hollow_zero_data_service.py    **摘要:** |  | 该 Python 文件定义了一个 `HallowZeroDataService` 类，用于管理和处理空零游戏的数据，包括事件、入口和鸣徽信息。它从 YAML 文件中加载数据，并提供各种方法来检索、匹配和验证这些数据。 |  | **核心类和函数:** |  | *   **`HallowZeroDataService`**:  主要的数据服务类，负责加载和管理游戏数据。 |     *   `reload()`: 重新加载所有数据。 |     *   `_load_normal_events()`: 加载普通事件。 |     *   `get_normal_event_by_name(event_name: str)`: 通过名称获取事件。 |     *   `_load_entry_list()`: 加载入口列表。 |     *   `get_entry_by_name(entry_name: str)`: 通过名称获取入口。 |     *   `_load_resonium()`: 加载鸣徽数据。 |     *   `match_resonium_by_ocr(cate_ocr: str, name_ocr: str)`:  通过 OCR 识别的类别和名称匹配鸣徽。 |     *   `match_resonium_by_ocr_full(name_full_str: str)`: 通过完整的 OCR 文本匹配鸣徽。 |     *   `check_resonium_priority(input_str: str)`: 校验鸣徽优先级输入。 |     *   `check_entry_list_input(input_str: str)`: 校验入口列表输入。 |     *   `get_default_go_in_1_step_entry_list()`: 获取默认的一步可达入口列表。 |     *   `get_only_boss_go_in_1_step_entry_list()`: 获取速通模式的一步可达入口列表。 |     *   `get_default_waypoint_entry_list()`: 获取默认的途径点入口列表。 |     *   `get_only_boss_waypoint_entry_list()`: 获取速通模式的途径点入口列表。 |     *   `get_default_avoid_entry_list()`: 获取默认的避免途经点入口列表。 |     *   `get_no_battle_list()`: 获取不包含战斗的
        │   ├── event/
        │   │   ├── bamboo_merchant.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个名为 `BambooMerchant` 的类，用于在游戏“零号空洞”中与邦布商人交互，主要功能是识别商店界面，并尝试购买鸣徽或进行催化。 |  | **核心类和函数:** |  | *   **`BambooMerchant(ZOperation)`:**  继承自 `ZOperation` 类，是处理邦布商人逻辑的核心类。 |     *   `check_screen()`:  识别当前屏幕状态，判断是否进入商店、是否为鸣徽交易或催化界面，并根据识别结果返回不同的状态。 |     *   `choose_buy()`:  在第一层界面选择“鸣徽交易”或“特价折扣”。 |     *   `choose_item()`:  选择要购买的鸣徽，通过 OCR 识别商品描述和价格，并根据配置的优先级选择。 |     *   `buy()`:  点击购买按钮。 |     *   `confirm()`:  确认购买。 |     *   `upgrade_resonium()`:  处理鸣徽催化逻辑。 |     *   `back()`:  返回上一级界面。 |     *   `_ocr_price_area(screen: MatLike)`:  使用 OCR 识别商品价格区域。 |     *   `_ocr_desc_area(screen: MatLike)`:  使用 OCR 识别商品描述区域。 |  | **重要功能点:** |  | *   **屏幕识别:** 使用 OCR 技术识别屏幕上的文本，判断当前界面状态。 | *   **商品选择:**  根据 OCR 结果，结合配置的鸣徽优先级，选择要购买的商品。 | *   **流程控制:**  通过状态转换和节点连接，控制操作流程。 | *   **错误处理:**  通过 `round_retry` 和 `round_wait` 处理可能的错误和等待。 | *   **OCR 辅助:** 提供了 `_ocr_price_area` 和 `_ocr_desc_area` 函数，用于从屏幕截图中提取商品信息。 | *   **调试:** 包含一个 `__debug_check_screen` 函数，用于调试和测试屏幕识别。
        │   │   ├── call_for_support.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了 `CallForSupport` 类，用于处理游戏《零号空洞》中的“呼叫支援”事件。它通过 OCR 识别屏幕上的文本，判断是否需要支援，并根据当前队伍和目标队伍配置，选择合适的支援角色和位置。 |  | **核心类和函数:** |  | *   **`CallForSupport(ZOperation)`**:  继承自 `ZOperation`，是处理“呼叫支援”事件的核心类。 |     *   `check_screen()`:  识别屏幕，触发事件处理流程。 |     *   `check_team()`:  判断当前队伍，决定是否需要支援。 |     *   `_get_support_agent(screen)`:  从屏幕上识别支援角色。 |     *   `_best_match_agent(ocr_result)`:  根据 OCR 结果匹配支援角色。 |     *   `_should_call_backup(agent_list, new_agent)`:  判断是否应该呼叫支援，并确定位置。 |     *   `accept_backup()`:  接受支援。 |     *   `choose_pos()`:  选择支援角色位置。 |     *   `confirm()`:  确认支援。 |     *   `reject_agent()`:  拒绝支援。 |  | *   **`RejectOption`**:  定义拒绝支援的选项，包含关键词和相似度阈值。 |  | **重要功能点:** |  | *   **事件识别**:  通过 OCR 识别屏幕上的文本，判断是否触发“呼叫支援”事件。 | *   **角色识别**:  从屏幕上识别支援角色的名称。 | *   **队伍配置判断**:  根据当前队伍和目标队伍配置，决定是否需要支援，以及支援角色的位置。 | *   **自动化操作**:  自动接受支援、选择位置、确认支援或拒绝支援。 | *   **调试功能**:  包含多个调试函数 (`__debug`, `__debug_support_agent`, `__debug_current_agent`, `__debug_check_screen`) 用于测试和开发。
        │   │   ├── choose_resonium.py    这段代码实现了在游戏中选择鸣徽的功能。 |  | 主要功能： |  | *   选择鸣徽：根据优先级选择鸣徽，并点击选择。 | *   兜底选择：如果选择失败，则随机选择一个鸣徽。 |  | 核心类和函数： |  | *   `ChooseResonium`：继承自 `ZOperation`，负责选择鸣徽的操作。 |     *   `choose_one()`：选择鸣徽的主要逻辑，包括截图、获取可选列表、根据优先级选择、点击选择。 |     *   `choose_default()`：兜底选择逻辑，如果 `choose_one` 失败，则随机选择一个。 | *   `ZContext`：游戏上下文，包含游戏状态和控制相关的信息。 | *   `resonium_utils.get_to_choose_list()`：获取可选鸣徽列表。 | *   `resonium_utils.choose_resonium_by_priority()`：根据优先级选择鸣徽。 |  | 重要功能点： |  | *   优先级选择：根据配置的优先级选择鸣徽。 | *   错误处理：如果没有可选的鸣徽或优先级匹配失败，则重试或兜底选择。 | *   屏幕截图和 OCR：用于获取游戏画面信息和识别文字。 | *   点击操作：用于点击选择的鸣徽。
        │   │   ├── confirm_resonium.py    这个 Python 文件的主要功能是处理游戏中「确认鸣徽」事件的操作。 |  | 核心类和函数： |  | *   **ConfirmResonium**: 继承自 `ZOperation`，负责处理确认鸣徽事件的逻辑。 |     *   `__init__(self, ctx: ZContext)`: 构造函数，初始化操作名称。 |     *   `choose_one(self) -> OperationRoundResult`: 核心函数，使用 OCR 和点击操作来选择鸣徽。 |  | 重要功能点： |  | *   使用 OCR 识别屏幕上的文本（"确认" 或 "确定"）。 | *   根据 OCR 结果，在指定的区域内进行点击操作。 | *   根据操作结果返回成功、重试或失败状态。
        │   │   ├── critical_stage.py    这个 Python 文件的主要功能是处理《空洞零》游戏中的关键进展事件。它通过识别屏幕上的文本来触发事件，然后执行自动战斗，并在战斗完成后增加通关次数。 |  | 核心类和函数： |  | *   **CriticalStage**: 继承自 `ZOperation`，负责处理关键进展事件的逻辑。 |     *   `__init__`: 初始化，设置事件处理器。 |     *   `check_screen`: 识别屏幕上的文本，判断是否触发事件。 |     *   `load_auto_op`: 执行自动战斗。 |     *   `add_times`: 增加通关次数。 |  | 重要功能点： |  | *   使用 `EventOcrResultHandler` 处理事件文本识别。 | *   触发自动战斗 (`HollowBattle`)。 | *   更新游戏记录 (增加通关次数)。 | *   使用装饰器 `@operation_node` 和 `@node_from` 定义操作流程和节点之间的依赖关系。
        │   │   ├── door_battle.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件定义了处理《空洞零》游戏中「门扉禁闭-善战」事件的逻辑。它负责识别游戏画面中的事件文本，并根据识别结果执行相应的操作。 |  | **核心类和函数：** |  | *   **`DoorBattle(ZOperation)`:** 继承自 `ZOperation`，是处理「门扉禁闭-善战」事件的主要类。 |     *   `__init__(self, ctx: ZContext)`: 初始化函数，设置事件名称和 OCR 处理器。 |     *   `check_screen(self) -> OperationRoundResult`: 使用截图和 OCR 处理器来识别屏幕上的事件文本，并执行相应的操作。 |  | *   **`EventOcrResultHandler`:** 处理 OCR 识别结果的类，用于匹配事件文本并执行操作。 |  | **重要功能点：** |  | *   **事件处理流程：** 该文件定义了事件处理的流程，包括截图、OCR 文本识别和根据识别结果执行操作。 | *   **OCR 处理器：** 使用 `EventOcrResultHandler` 来处理 OCR 识别结果，匹配事件文本并执行操作。 | *   **兼容性：** 包含对「门扉禁闭-侵蚀」事件的兼容处理，以应对识别错误的情况。
        │   │   ├── drop_resonium.py    这个 Python 文件定义了在游戏中丢弃鸣徽的操作。 |  | *   **主要功能:** 模拟玩家在零号空洞事件中丢弃鸣徽的行为，包括选择和确认丢弃。 | *   **核心类和函数:** |     *   `DropResoniumBase`: 基础类，包含丢弃鸣徽的逻辑。 |         *   `choose_one()`: 选择要丢弃的鸣徽。 |         *   `choose_default()`: 兜底选择，如果选择失败则随机选择一个。 |     *   `DropResonium`: 继承自 `DropResoniumBase`，用于丢弃鸣徽。 |     *   `DropResonium2`: 继承自 `DropResoniumBase`，用于抵押欠款。 | *   **重要功能点:** |     *   使用 OCR 识别屏幕上的选项。 |     *   根据优先级选择要丢弃的鸣徽。 |     *   处理选择失败的情况，提供兜底方案。 |     *   与游戏控制器交互，执行点击操作。
        │   │   ├── event_ocr_result_handler.py    这个 Python 文件定义了一个名为 `EventOcrResultHandler` 的类，用于处理 OCR 结果。 |  | *   **主要功能:** 封装 OCR 结果处理逻辑，包括目标文本、匹配阈值、处理方法、点击行为等。 | *   **核心类:** `EventOcrResultHandler` | *   **重要功能点:** |     *   `__init__`: 类的构造函数，初始化 OCR 结果处理器的各个属性，包括目标文本 (`target_cn`)、匹配阈值 (`lcs_percent`)、处理方法 (`method`)、点击行为 (`click_result`, `click_wait`) 和事件标记 (`is_event_mark`)。 |     *   `target_cn`: 待匹配的中文文本。 |     *   `lcs_percent`: 文本匹配的相似度阈值。 |     *   `method`: 处理 OCR 结果的回调函数。 |     *   `click_result`: 是否点击 OCR 结果。 |     *   `click_wait`: 点击后的等待时间。 |     *   `is_event_mark`: 是否为事件标记。 |     *   `status`: 状态标识。
        │   │   ├── full_in_bag.py    这个 Python 文件的主要功能是处理在游戏中背包已满的事件。 |  | 核心类和函数： |  | *   **FullInBag**: 继承自 `ZOperation`，负责处理背包已满的事件。 |     *   `__init__`: 初始化操作，设置操作名称。 |     *   `drop`: 核心功能，尝试通过 OCR 识别屏幕上的 "丢弃" 按钮并点击，以处理背包已满的情况。 | *   `__debug`: 是一个用于调试的函数，模拟游戏环境，初始化上下文，并调用 `drop` 方法。 |  | 重要功能点： |  | *   使用 OCR 技术识别屏幕上的 "丢弃" 按钮。 | *   点击 "丢弃" 按钮以处理背包已满的事件。 | *   包含调试功能，方便开发和测试。
        │   │   ├── hollow_event_utils.py    ## 摘要 |  | 这个 Python 文件定义了用于处理零号空洞事件的工具函数，主要用于识别和响应游戏中的事件。 |  | **核心类和函数:** |  | *   `check_event_at_right(ctx, screen, ignore_events)`: 识别右侧区域的事件名称。 | *   `check_entry_opt_at_right(ctx, screen, ignore_events)`: 识别右侧区域的事件入口选项。 | *   `check_event_text_and_run(op, screen, handlers)`: 识别事件文本并根据处理程序执行相应的操作。 | *   `click_empty(op, bottom_opt_pos)`: 点击空白区域，用于兜底操作。 | *   `check_screen(ctx, screen, ignore_events)`: 识别当前屏幕的状态，包括事件、选项、对话框等。 | *   `get_special_event_by_name(event_name)`: 根据事件名称获取特殊事件。 | *   `check_battle_screen(ctx, screen)`: 判断是否在战斗画面 | *   `check_mission_complete(ctx, screen)`: 判断是否通关 | *   `check_in_hollow(ctx, screen)`: 判断是否在空洞内 | *   `check_old_capital(ctx, screen)`: 判断是否在旧都失物 | *   `check_interact(ctx, screen)`: 判断是否可以交互 |  | **重要功能点:** |  | *   **事件识别:** 使用 OCR 识别事件文本和选项。 | *   **事件处理:** 根据识别结果，执行相应的操作，例如点击按钮。 | *   **屏幕状态检测:** 检测游戏屏幕的各种状态，例如战斗、任务完成、背包已满等。 | *   **特殊事件处理:** 处理特定的游戏事件，例如鸣徽选择、催化等。 | *   **兜底机制:** 在无法匹配到特定事件时，提供兜底的点击操作。 | *   **使用 `EventOcrResultHandler` 处理事件。**
        │   │   ├── hollow_interact.py    这个 Python 文件的摘要如下： |  | *   **主要功能:** 处理空洞零事件中的交互操作。 | *   **核心类和函数:** |     *   `HollowInteract`: 继承自 `ZOperation`，负责处理交互逻辑。 |     *   `interact(self) -> OperationRoundResult`:  `HollowInteract` 类中的主要方法，模拟游戏中的交互操作，例如按压按钮。 | *   **重要功能点:** |     *   使用 `operation_node` 装饰器标记 `interact` 方法，表明其为操作节点，且是起始节点。 |     *   `interact` 方法通过调用 `self.ctx.controller.interact()` 来模拟交互，并设定按压和释放的时间。 |     *   `round_success(wait=1)` 表示交互成功，并等待 1 秒。
        │   │   ├── leave_random_zone.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了一个名为 `LeaveRandomZone` 的操作，用于处理在游戏中离开随机区域的事件。它通过屏幕识别、交互和重试机制来实现。 |  | **核心类和函数:** |  | *   `LeaveRandomZone`: 继承自 `ZOperation`，负责处理离开随机区域的逻辑。 |     *   `check_screen()`: 核心函数，用于检查屏幕，识别事件，并执行相应的操作，例如交互。 |  | **重要功能点:** |  | *   使用 `operation_node` 装饰器定义操作流程的节点。 | *   使用屏幕截图和图像识别来检测游戏画面。 | *   根据识别结果，执行交互操作（例如点击）。 | *   处理成功、等待和重试状态。 | *   使用 `hollow_event_utils.check_screen` 检查特殊区域事件。
        │   │   ├── normal_event_handler.py    这个 Python 文件定义了 `NormalEventHandler` 类，用于处理空洞零事件。 |  | **主要功能:** |  | *   处理空洞零游戏中的常规事件，通过屏幕识别和 OCR 来触发相应的操作。 |  | **核心类和函数:** |  | *   `NormalEventHandler`: 继承自 `ZOperation`，负责处理事件逻辑。 |     *   `__init__(self, ctx: ZContext, event: HallowZeroEvent)`: 初始化事件处理器，根据事件配置创建 `EventOcrResultHandler` 列表。 |     *   `check_screen(self) -> OperationRoundResult`: 截取屏幕截图，并使用 `hollow_event_utils.check_event_text_and_run` 进行 OCR 识别和操作。 | *   `EventOcrResultHandler`: 处理 OCR 结果的类，用于匹配屏幕上的文本。 | *   `__debug_opts()`: 是一个用于调试的函数，模拟事件处理流程。 |  | **重要功能点:** |  | *   使用 OCR 识别屏幕上的文本，以触发事件。 | *   根据事件配置，创建多个 `EventOcrResultHandler` 进行匹配。 | *   `check_screen` 方法是事件处理的核心，它截取屏幕截图并触发 OCR 识别。 | *   `__debug_opts` 函数提供了一个调试环境，方便测试和验证事件处理逻辑。
        │   │   ├── old_capital.py    这个 Python 脚本定义了一个名为 `OldCapital` 的类，它继承自 `ZOperation`。 |  | *   **主要功能:** 处理游戏中与旧都失物相关的事件，允许玩家选择返回。 | *   **核心类和函数:** |     *   `OldCapital`: 继承自 `ZOperation`，负责处理旧都失物事件。 |     *   `__init__(self, ctx: ZContext)`: 构造函数，初始化事件名称。 |     *   `choose_one(self) -> OperationRoundResult`: 是一个操作节点，用于截图、查找并点击 "旧都失物-返回" 按钮，以返回到事件画面。 | *   **重要功能点:** |     *   使用 `operation_node` 装饰器标记 `choose_one` 作为操作节点，并将其标记为起始节点。 |     *   使用 `round_by_find_and_click_area` 函数来执行查找和点击操作。
        │   │   ├── remove_corruption.py    这个 Python 文件定义了一个名为 `RemoveCorruption` 的类，它继承自 `ZOperation`，用于处理游戏中清除侵蚀症状的事件。 |  | *   **主要功能:** 执行游戏中清除侵蚀症状的操作。 | *   **核心类和函数:** |     *   `RemoveCorruption`: 继承自 `ZOperation`，负责清除侵蚀症状。 |     *   `choose_one()`: 使用 OCR 和点击操作，在屏幕上选择并清除侵蚀症状。 | *   **重要功能点:** |     *   使用 `operation_node` 装饰器标记 `choose_one` 方法为操作节点，并将其设置为起始节点。 |     *   使用 OCR 识别屏幕上的文本，并根据识别结果进行点击操作。 |     *   使用 `round_by_ocr_and_click` 方法执行 OCR 识别和点击操作，并处理结果。
        │   │   ├── resonium_utils.py    此 Python 文件 `resonium_utils.py` 提供了用于处理《零号空洞》游戏中鸣徽相关逻辑的工具函数。 |  | *   **主要功能:** 识别屏幕上的鸣徽，并根据优先级选择鸣徽。 | *   **核心函数:** |     *   `get_to_choose_list(ctx: ZContext, screen: MatLike, target_cn: str, target_lcs_percent: float = 1) -> List[MatchResult]`:  识别屏幕上的鸣徽，返回匹配的鸣徽及其位置信息。 |     *   `choose_resonium_by_priority(item_list: List[Resonium], priority_list: List[str], only_priority: bool = False)`: 根据优先级列表从鸣徽列表中选择鸣徽，并返回其索引列表。 | *   **重要功能点:** |     *   使用 OCR 技术识别鸣徽名称。 |     *   基于最长公共子序列 (LCS) 算法进行字符串匹配。 |     *   支持根据优先级列表选择鸣徽，并可选择仅保留优先级匹配的结果。 |     *   `MatchResult` 用于存储匹配结果，包含鸣徽位置和数据。 |     *   依赖于 `ZContext` 上下文，`Resonium` 数据结构，以及其他工具函数如 `cv2_utils` 和 `str_utils`。
        │   │   ├── swift_supply.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件定义了一个名为 `SwiftSupply` 的操作，用于处理游戏中“及时补给”事件。它主要负责在选择奖励的画面中选择一个选项。 |  | **核心类和函数：** |  | *   `SwiftSupply`：继承自 `ZOperation`，代表“及时补给”事件的操作。 |     *   `__init__(self, ctx: ZContext)`：初始化函数，设置操作名称。 |     *   `choose_one(self) -> OperationRoundResult`：使用 OCR 识别并点击“降低压力值”选项。 |  | **重要功能点：** |  | *   使用 OCR 技术从屏幕截图中识别文本。 | *   根据识别结果，在指定区域内进行点击操作。 | *   包含重试机制，以确保操作成功。
        │   │   ├── switch_resonium.py    这个 Python 脚本 `switch_resonium.py` 实现了在游戏中交换鸣徽的功能。 |  | **主要功能:** |  | *   选择并交换鸣徽。 |  | **核心类和函数:** |  | *   `SwitchResonium(ZOperation)`:  继承自 `ZOperation`，负责执行交换鸣徽的操作。 |     *   `choose_one()`:  选择鸣徽，基于优先级和屏幕截图识别。 |     *   `choose_default()`:  兜底选择，如果 `choose_one()` 失败，则随机选择一个。 | *   `__debug()`:  用于测试和调试，初始化上下文并执行操作。 |  | **重要功能点:** |  | *   使用屏幕截图和 OCR 识别可选的鸣徽。 | *   根据配置的优先级选择鸣徽。 | *   提供兜底机制，以防识别失败。 | *   使用 `operation_node` 和 `node_from` 装饰器定义操作流程和节点之间的关系。 | *   使用 `round_retry` 和 `round_by_click_area` 处理操作结果和重试逻辑。
        │   │   └── upgrade_resonium.py    这个 Python 脚本 `upgrade_resonium.py` 实现了在游戏中升级共鸣徽章（Resonium）的自动化操作。 |  | *   **主要功能:** 选择并升级共鸣徽章。 | *   **核心类和函数:** |     *   `UpgradeResonium`: 继承自 `ZOperation`，负责整个升级流程。 |     *   `choose_one()`: 选择一个共鸣徽章。 |     *   `choose_default()`: 兜底选择，如果 `choose_one()` 失败则执行。 | *   **重要功能点:** |     *   使用 `resonium_utils` 模块来获取可选择的共鸣徽章列表并根据优先级进行选择。 |     *   使用屏幕截图和 OCR 识别来定位和点击 UI 元素。 |     *   包含重试机制，以处理识别失败的情况。 |     *   使用 `operation_node` 和 `node_from` 装饰器来定义操作流程和节点之间的关系。
        │   ├── game_data/
        │   │   ├── hollow_zero_event.py    这个 Python 文件定义了用于空洞零游戏的事件相关的数据结构。 |  | *   **主要功能:** 定义了游戏中事件的结构，包括事件的类型、选项和属性。 | *   **核心类和函数:** |     *   `HollowZeroEntry`: 表示地图上的入口点，包含入口的名称、类型、是否可通行等属性。 |     *   `HallowZeroNormalEventOption`: 表示事件的选项，包含选项的名称、描述、等待时间和 OCR 关键字等。 |     *   `HallowZeroEvent`: 表示游戏中的事件，包含事件名称、选项列表、是否在右侧显示等属性。 |     *   `HollowZeroSpecialEvent (Enum)`:  定义了特定类型的事件，使用 `Enum` 方便管理和引用。 | *   **重要功能点:** |     *   定义了不同类型的事件，例如商店、战斗、副本通关等。 |     *   每个事件可以有多个选项，每个选项都有自己的属性。 |     *   `HollowZeroEntry` 类用于表示地图上的入口，并包含一些重要的属性，例如是否为传送点，是否可通行等。 |     *   `HollowZeroEvent` 类中的 `is_entry_opt` 标记用于标识进入格子的选项。
        │   │   └── hollow_zero_resonium.py    这个 Python 文件定义了一个名为 `Resonium` 的类，用于表示游戏中的 Resonium 资源。 |  | *   **核心类:** `Resonium` | *   **核心函数:** `__init__` (构造函数，初始化 Resonium 实例的属性) | *   **重要功能点:** |     *   `Resonium` 类用于储存 Resonium 资源的资讯，包括 `category` (类别), `name` (名称), 和 `level` (等级)。
        │   └── hollow_map/
        │       ├── hollow_map_utils.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了用于构建和处理空洞零地图的工具函数。它主要负责从 YOLO 识别结果构建地图，合并地图，判断地图和节点是否相同，以及获取节点在地图中的索引。 |  | **核心类和函数:** |  | *   `construct_map_from_yolo_result(ctx, detect_result, name_2_entry)`:  从 YOLO 识别结果构建地图。 | *   `construct_map_from_nodes(ctx, nodes, check_time)`:  从节点列表构建地图。 | *   `is_same_map(map_1, map_2)`:  判断两个地图是否相同。 | *   `merge_map(ctx, map_list)`:  合并多个地图。 | *   `is_same_node_pos(x, y)`:  判断两个节点的坐标是否一致。 | *   `is_same_node(x, y)`:  判断两个节点是否是同一个节点。 | *   `get_node_index(current_map, node)`: 获取节点在地图上的下标。 | *   `_at_left`, `_at_right`, `_above`, `_under`:  判断节点之间的相对位置关系。 | *   `_is_same_row`, `_is_same_col`:  判断节点是否在同一行或同一列。 | *   `_add_edge`, `_add_directed_edge`:  添加边到地图的邻接表中。 |  | **重要功能点:** |  | *   从 YOLO 检测结果中提取节点信息，并根据节点类型和位置构建地图。 | *   处理节点合并逻辑，包括底座和格子的合并，以及根据置信度和时间戳更新节点信息。 | *   判断地图和节点是否相同，用于地图的比较和去重。 | *   合并多个地图，用于整合不同时间或不同视角下的地图信息。 | *   构建地图的邻接表，用于表示节点之间的连接关系。 | *   处理“当前”节点，确保地图中只有一个“当前”节点，并处理移动失败的情况。
        │       ├── hollow_pathfinding.py    代码摘要： |  | 该 Python 文件实现了空洞零地图的寻路功能，主要用于计算地图上节点之间的最短路径，并提供了一些辅助函数来获取特定类型的路径。 |  | 核心类和函数： |  | *   `search_map(current_map, avoid_entry_list, visited_nodes)`:  对地图进行广度优先搜索，计算从当前节点到其他节点的最短路径，并避开指定节点。 | *   `_bfs_search_map(current_map, start_idx_list, avoid_entry_list, visited_nodes)`:  使用广度优先搜索算法计算最短路径。 | *   `get_route_in_1_step(current_map, visited_nodes, target_entry_list)`:  获取一步可到达的节点路径。 | *   `get_route_by_entry(current_map, entry_name, visited_nodes)`:  获取到达特定类型格子的最短路径。 | *   `get_route_by_direction(current_map, direction)`:  获取符合特定方向的最远路径。 | *   `had_been_visited(current, visited_nodes)`:  判断节点是否已经访问过。 | *   `draw_map(screen, current_map, next_node, to_click)`:  在图像上绘制地图，包括节点、边和路径信息。 |  | 重要功能点： |  | *   使用广度优先搜索算法计算地图上节点之间的最短路径。 | *   支持避开特定节点进行寻路。 | *   提供获取一步可达路径、到达特定类型格子路径、以及特定方向最远路径的函数。 | *   通过 `visited_nodes` 避免重复访问节点。 | *   提供地图可视化功能，用于调试和展示寻路结果。
        │       ├── hollow_zero_map.py    此文件定义了用于处理空零地图的类和相关数据结构。 |  | **主要功能:** |  | *   表示空零地图的节点和地图本身，包含寻路信息。 | *   提供地图有效性检查、节点搜索等功能。 |  | **核心类和函数:** |  | *   **HollowZeroMapNode:** |     *   `__init__`: 初始化节点，包含位置、入口信息、访问次数、寻路相关信息（路径上的第一个节点、需要步数的节点、步数等）。 |     *   `gt_max_visited_times`: 检查访问次数是否超过限制。 |     *   `next_node_to_move`: 获取下一个要移动的节点。 | *   **HollowZeroMap:** |     *   `__init__`: 初始化地图，包含节点列表、当前索引、边信息、识别时间。 |     *   `is_valid_map`: 检查地图是否有效。 |     *   `contains_entry`: 检查地图是否包含特定类型的入口。 |     *   `search_entry`: 搜索地图中是否存在特定入口。 |     *   `init_path_related`: 初始化所有节点的寻路相关信息。 |  | **重要功能点:** |  | *   寻路信息的存储和管理，包括路径上的第一个节点、步数等。 | *   地图有效性检查，用于判断地图是否可用。 | *   节点搜索，用于查找特定类型的入口。
        │       └── hollow_zero_map_service.py    这个 Python 脚本定义了一个 `HollowZeroMapService` 类，用于根据游戏画面计算空洞地图。 |  | **主要功能:** |  | *   从游戏画面中识别空洞地图，并可与过去的地图结果合并。 | *   使用 YOLO 模型检测游戏画面中的事件。 | *   提供清除地图识别结果的功能。 |  | **核心类和函数:** |  | *   `HollowZeroMapService`: 负责处理空洞地图的识别和管理。 |     *   `__init__(self, ctx: ZContext)`: 初始化服务，包括上下文、数据服务和事件模型。 |     *   `init_event_yolo(self) -> None`: 初始化 YOLO 事件检测器。 |     *   `cal_current_map_by_screen(self, screen: MatLike, screenshot_time: float) -> Optional[HollowZeroMap]`: 根据当前画面计算空洞地图。 |     *   `cal_map_by_screen(self, screen: MatLike, screenshot_time: float) -> Optional[HollowZeroMap]`: 计算空洞地图，并与过去的结果合并。 |     *   `clear_map_result(self) -> None`: 清除所有识别结果。 |  | **重要功能点:** |  | *   使用 YOLO 模型进行事件检测，用于识别地图元素。 | *   合并过去的地图识别结果，以提高准确性。 | *   `cal_map_by_screen` 函数实现了地图的识别和合并逻辑。 | *   `clear_map_result` 函数用于重置地图识别状态。 | *   包含一个 `__debug_cal_current_map_by_screen` 函数，用于调试和测试地图识别功能。
        ├── operation/
        │   ├── back_to_normal_world.py    ## 代码摘要 |  | **文件功能:** |  | 该 Python 文件定义了一个名为 `BackToNormalWorld` 的类，其主要功能是尝试将游戏画面导航回大世界。它通过识别游戏画面中的不同元素，如菜单、街区、对话框等，并执行相应的点击操作，以确保在任何情况下都能返回到游戏的大世界。 |  | **核心类和函数:** |  | *   **`BackToNormalWorld(ZContext)`**:  继承自 `ZOperation` 类，是该文件的核心类，负责执行返回大世界的操作。 |     *   `__init__(self, ctx: ZContext)`:  构造函数，初始化操作名称和上下文。 |     *   `check_screen_and_run(self, screen: Optional[MatLike] = None) -> OperationRoundResult`:  核心函数，用于识别游戏画面并执行相应的操作，尝试返回大世界。它包含了多个子函数调用，用于处理不同的游戏状态。 |     *   `_check_agent_dialog(self, screen: MatLike) -> bool`: 检查是否存在代理人好感度对话。 |     *   `_handle_agent_dialog(self, screen: MatLike) -> OperationRoundResult`: 处理代理人好感度对话。 |     *   `check_compendium(self, screen: MatLike) -> OperationRoundResult`: 检查是否在快捷手册中。 |  | **重要功能点:** |  | *   **画面识别和导航:**  使用 `round_by_goto_screen`, `round_by_find_area`, `round_by_find_and_click_area` 等函数，根据屏幕截图识别游戏画面中的元素，并执行点击操作。 | *   **处理各种游戏状态:**  能够处理多种游戏状态，包括： |     *   直接进入大世界 |     *   通过街区返回 |     *   通过菜单返回 |     *   处理对话框（例如空洞继续对话框） |     *   处理好感度对话 |     *   处理战斗画面 |     *   处理空洞内的撤退和完成 |     *   处理快捷手册 | *   **循环重试机制:**  使用 `round_retry` 和 `node_max_retry_times` 实现循环重试机制，以应对操作失败的情况。 | *   **调试功能:**
        │   ├── choose_predefined_team.py    这个 Python 脚本定义了一个名为 `ChoosePredefinedTeam` 的类，它继承自 `ZOperation`，用于在游戏中选择预先定义的团队。 |  | **主要功能:** |  | *   在游戏的“出战”画面中，根据提供的索引列表选择预先定义的团队。 | *   通过图像识别和点击操作来导航游戏界面。 | *   处理选择失败的情况，包括重试和滚动屏幕。 |  | **核心类和函数:** |  | *   `ChoosePredefinedTeam(ctx: ZContext, target_team_idx_list: List[int])`: 构造函数，初始化操作，接收 `ZContext` 和目标团队索引列表。 | *   `check_screen()`: 检查屏幕上是否出现“实战模拟室”和“预备编队”的标志，作为操作的起点。 | *   `click_team()`: 点击“预备编队”按钮。 | *   `choose_team()`: 选择目标团队。它使用 OCR 识别团队名称，并点击相应的团队。如果 OCR 失败，则重试。 | *   `choose_team_fail()`: 处理选择团队失败的情况，包括重试和滚动屏幕。 | *   `click_confirm()`: 点击“预备出战”按钮确认选择。 | *   `__debug()`: 是一个用于调试的函数，用于测试 OCR 功能。 |  | **重要功能点:** |  | *   使用 OCR 识别游戏界面上的文本。 | *   使用 `difflib.get_close_matches` 找到与目标团队名称最匹配的 OCR 结果。 | *   处理选择团队失败的情况，包括重试和滚动屏幕。 | *   使用 `operation_node` 和 `node_from` 装饰器定义操作流程和节点之间的依赖关系。
        │   ├── deploy.py    这个 Python 脚本定义了一个名为 `Deploy` 的类，它继承自 `ZOperation`，用于处理游戏中的出战操作。 |  | **主要功能：** |  | *   执行游戏中的出战流程，包括点击出战按钮，处理可能出现的确认弹窗，并最终标记出战成功。 |  | **核心类和函数：** |  | *   `Deploy` 类：继承自 `ZOperation`，负责出战流程的控制。 |     *   `__init__(self, ctx: ZContext)`：初始化函数，设置操作名称。 |     *   `deploy(self) -> OperationRoundResult`：点击出战按钮，尝试出战。 |     *   `check_level(self) -> OperationRoundResult`：处理出战确认弹窗，例如队员数量不足或等级过低的情况。 |     *   `finish(self) -> OperationRoundResult`：标记出战成功。 | *   `ZContext`：上下文类，提供游戏环境的相关信息。 | *   `ZOperation`：基类，提供操作相关的基础功能。 | *   `operation_node`：装饰器，用于定义操作节点。 | *   `node_from`：装饰器，用于定义节点之间的依赖关系。 |  | **重要功能点：** |  | *   使用 `operation_node` 和 `node_from` 装饰器定义了操作流程的节点和依赖关系，构建了流程的状态机。 | *   使用 `round_by_find_and_click_area` 函数来查找并点击屏幕上的特定区域。 | *   处理了出战过程中可能出现的确认弹窗，例如队员数量不足或等级过低的情况。 | *   `__debug()` 函数用于测试 `Deploy` 类的执行。
        │   ├── eat_noodle.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了一个名为 `EatNoodle` 的操作，用于在游戏中执行吃拉面的流程。它通过一系列步骤，包括传送、等待、移动交互、选择拉面、点单、确认、跳过和返回，来模拟吃拉面的过程。 |  | **核心类和函数:** |  | *   **`EatNoodle(ZOperation)`:**  继承自 `ZOperation`，是执行吃拉面流程的核心类。 |     *   `__init__(self, ctx: ZContext, noodle_name: str)`:  初始化函数，接收上下文 `ctx` 和拉面名称 `noodle_name`。 |     *   一系列以 `@operation_node` 装饰的函数，定义了吃拉面的各个步骤，如 `transport`, `wait_world`, `move_and_interact` 等。 |  | **重要功能点:** |  | *   **流程控制:** 使用 `@operation_node` 和 `@node_from` 装饰器定义了操作的流程，每个函数代表一个步骤，并指定了前后依赖关系。 | *   **交互操作:**  使用 `self.ctx.controller` 执行游戏中的移动、交互等操作。 | *   **图像识别:**  使用 `self.screenshot()` 和 `self.ctx.screen_loader` 进行屏幕截图和区域识别，用于判断界面状态和点击特定元素。 | *   **OCR:** 使用 `round_by_ocr_and_click` 函数进行 OCR 识别并点击。 | *   **错误处理和重试:** 使用 `round_by_op_result`, `round_success`, `round_retry` 等方法处理操作结果，并进行重试。 | *   **界面元素定位:** 使用 `round_by_find_area` 和 `round_by_find_and_click_area` 函数来定位和点击界面元素。
        │   ├── key_sim_runner.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件定义了一个 `KeySimRunner` 类，用于模拟按键操作。它从配置文件中加载按键操作，然后执行它们。 |  | **核心类和函数：** |  | *   `KeySimRunner`: 继承自 `ZOperation`，负责按键模拟的流程控制。 |     *   `__init__(self, ctx: ZContext, config_name: str)`: 初始化 `KeySimRunner`，接收上下文和配置名称。 |     *   `load_config(self) -> OperationRoundResult`: 从 YAML 配置文件中加载按键操作，并将其转换为 `AtomicOp` 列表。 |     *   `run_key_sim(self) -> OperationRoundResult`: 执行加载的按键操作。 |  | **重要功能点：** |  | *   使用 `YamlConfig` 加载按键模拟的配置。 | *   使用 `utils.get_ops_from_data` 将配置数据转换为 `AtomicOp` 列表。 | *   使用 `AutoBattleOperator` 获取 `AtomicOp` 实例。 | *   使用 `@operation_node` 和 `@node_from` 装饰器定义操作流程。 | *   `run_key_sim` 函数迭代执行 `AtomicOp` 列表中的操作。
        │   ├── open_menu.py    这个 Python 文件定义了一个名为 `OpenMenu` 的操作，用于在游戏中打开菜单。 |  | **主要功能:** |  | *   识别游戏画面，判断是否已在菜单页面。 | *   如果不在菜单页面，则尝试返回大世界。 | *   在大世界画面中，点击菜单按钮以打开菜单。 |  | **核心类和函数:** |  | *   `OpenMenu`: 继承自 `ZOperation`，负责打开菜单的操作。 |     *   `__init__(self, ctx: ZContext)`: 初始化操作，设置操作名称。 |     *   `check_menu(self) -> OperationRoundResult`: 识别画面，判断是否在菜单页面或大世界。 |     *   `back_to_world(self) -> OperationRoundResult`: 如果不在菜单页面，返回大世界。 |     *   `click_menu(self) -> OperationRoundResult`: 在大世界画面中点击菜单按钮。 |  | **重要功能点:** |  | *   使用 OCR 和图像匹配来识别画面。 | *   使用 `node_from` 和 `operation_node` 装饰器来定义操作流程和节点。 | *   依赖 `ZContext` 获取上下文信息。 | *   使用 `BackToNormalWorld` 操作返回大世界。
        │   ├── transport.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `Transport` 类，用于在游戏中执行传送操作。它通过一系列步骤，包括返回大世界、打开地图、选择区域、选择传送点和确认传送，最终实现传送功能。 |  | **核心类和函数:** |  | *   **`Transport(ZOperation)`**:  继承自 `ZOperation` 的类，负责执行传送操作。 |     *   `__init__(self, ctx: ZContext, area_name: str, tp_name: str, wait_at_last: bool = True)`:  初始化函数，设置传送的目标区域和传送点。 |     *   `check_screen()`:  检查当前是否在地图页面。 |     *   `back_to_world()`:  如果不在地图页面，则返回大世界。 |     *   `open_map()`:  在大世界画面中打开地图。 |     *   `choose_area()`:  在地图页面选择目标区域。 |     *   `choose_tp()`:  在地图页面选择目标传送点。 |     *   `click_tp()`:  在地图页面点击确认传送。 |     *   `wait_in_world()`:  等待大世界加载完成。 |  | **重要功能点:** |  | *   **流程控制:**  使用 `@operation_node` 和 `@node_from` 装饰器定义操作流程，实现状态机模式。 | *   **画面识别:**  使用 `screenshot()` 和 `round_by_find_area()` 等方法进行画面识别，判断当前状态。 | *   **OCR:** 使用 OCR 技术识别地图上的区域和传送点名称。 | *   **地图服务:**  使用 `ctx.map_service` 获取地图信息，例如区域之间的方向，传送点列表等。 | *   **滑动操作:**  当目标传送点不在当前显示范围内时，通过滑动操作来查找。 | *   **错误处理:**  使用 `round_retry()` 处理操作失败的情况，并进行重试。 | *   **等待机制:**  `wait_in_world()` 函数用于等待大世界加载完成，确保传送成功。
        │   ├── wait_normal_world.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了一个名为 `WaitNormalWorld` 的操作，其主要功能是等待游戏中的大世界画面加载完成。它使用画面识别来判断大世界是否已加载，并设定了超时机制。 |  | **核心类和函数:** |  | *   `WaitNormalWorld`: 继承自 `ZOperation`，代表等待大世界加载的操作。 |     *   `__init__(self, ctx: ZContext)`: 构造函数，初始化操作，设置操作名称。 |     *   `check_screen(self) -> OperationRoundResult`: 使用画面识别来判断大世界是否已加载。 该函数使用 `@operation_node` 装饰器，并设定了重试次数。 |  | **重要功能点:** |  | *   使用 `ZOperation` 作为基类，表明该操作属于游戏操作流程的一部分。 | *   `check_screen` 函数使用画面截图和图像识别来判断大世界是否加载成功。 | *   `@operation_node` 装饰器用于定义操作节点，并配置了重试次数，增加了操作的稳定性。 | *   `round_by_find_area` 函数用于基于画面截图和关键字来判断画面是否符合预期。
        │   ├── zzz_operation.py    这个 Python 文件定义了一个名为 `ZOperation` 的类，它继承自 `one_dragon` 框架中的 `Operation` 类。 |  | *   **主要功能:**  `ZOperation` 类是针对 `zzz_od` 游戏的特定操作的基类，它封装了游戏操作的逻辑，包括重试机制、超时设置和回调函数。 | *   **核心类和函数:** |     *   `ZOperation`:  继承自 `Operation`，是游戏操作的基类。 |     *   `__init__`:  `ZOperation` 类的构造函数，初始化上下文 `ZContext`，并创建一个 `OpenAndEnterGame` 的实例，然后调用父类 `Operation` 的构造函数进行初始化。 | *   **重要功能点:** |     *   初始化 `ZContext` 上下文。 |     *   创建 `OpenAndEnterGame` 操作实例。 |     *   继承了 `Operation` 类提供的重试、超时、回调和游戏胜利检查等功能。
        │   ├── arcade/
        │   │   ├── arcade_snake_suicide.py    这个 Python 文件的主要功能是自动化在游戏中进行蛇对蛇自杀操作，以完成每周行程。 |  | 核心类和函数： |  | *   **ArcadeSnakeSuicide**: 继承自 ZOperation，负责整个自杀流程的控制。 |     *   `__init__`: 初始化，设置所需完成的次数和已完成的次数。 |     *   `handle_init`: 初始化已完成的次数。 |     *   `start_game`: 启动蛇对蛇游戏。 |     *   `wait_game_load`: 等待游戏加载完成。 |     *   `click_empty`: 模拟点击空白处继续，并在达到指定次数后返回大世界。 |     *   `back_to_normal_world`: 返回大世界。 |  | 重要功能点： |  | *   自动化蛇对蛇游戏的启动和结束流程。 | *   根据配置的总次数，循环进行自杀操作。 | *   使用截图和图像识别来判断游戏状态。 | *   在完成指定次数后，自动返回到大世界。
        │   │   └── arcade_start_game.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了 `ArcadeStartGame` 类，用于在游戏中启动街机游戏。它通过一系列操作，模拟玩家在游戏中的行为，包括传送、等待加载、选择游戏模式和游戏，最终启动游戏。 |  | **核心类和函数:** |  | *   **`ArcadeStartGame(ZOperation)`**:  继承自 `ZOperation`，是启动街机游戏的核心类。 |     *   `__init__(self, ctx: ZContext, game_name: str)`: 初始化函数，接收游戏名称作为参数。 |     *   `transport(self) -> OperationRoundResult`: 传送至电玩店。 |     *   `wait_world(self) -> OperationRoundResult`: 等待大世界加载。 |     *   `move_and_interact(self) -> OperationRoundResult`: 移动并交互。 |     *   `wait_noodle_shop(self) -> OperationRoundResult`: 等待加载。 |     *   `choose_mode(self) -> OperationRoundResult`: 选择游戏模式。 |     *   `choose_game(self) -> OperationRoundResult`: 选择游戏。 |     *   `click_choose(self) -> OperationRoundResult`: 点击选择游戏。 |     *   `click_start(self) -> OperationRoundResult`: 点击开始游戏。 |  | **重要功能点:** |  | *   **游戏流程自动化:**  通过一系列 `operation_node` 装饰的函数，定义了启动街机游戏的完整流程。 | *   **屏幕交互:**  使用 `self.ctx.controller` 进行移动和交互操作，模拟用户行为。 | *   **图像识别:**  使用 `self.screenshot()` 和 `self.round_by_ocr_and_click()` 等函数，通过屏幕截图和 OCR 技术来识别和点击游戏界面上的元素。 | *   **重试机制:**  使用 `node_max_retry_times` 参数，在某些步骤中设置重试机制，提高操作的稳定性。 | *   **国际化支持:** 使用 `gt()` 函数进行国际化文本处理。
        │   ├── challenge_mission/
        │   │   ├── check_next_after_battle.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 这个文件定义了一个操作，用于在战斗结束后，根据用户的选择（"再来一次" 或 "结束"）来执行相应的动作。 |  | **核心类和函数:** |  | *   `ChooseNextOrFinishAfterBattle(ZOperation)`:  继承自 `ZOperation`，负责处理战斗结束后的选择逻辑。 |     *   `__init__(self, ctx: ZContext, try_next: bool)`:  构造函数，初始化上下文和是否尝试 "再来一次" 的标志。 |     *   `check_next(self) -> OperationRoundResult`:  判断是否点击 "再来一次" 按钮。如果 `try_next` 为 True，则尝试点击 "再来一次"；否则，尝试点击 "完成"。 |     *   `finish(self) -> OperationRoundResult`:  如果 `check_next` 失败，则尝试点击 "完成" 按钮。 |  | **重要功能点:** |  | *   根据 `try_next` 标志，决定是尝试 "再来一次" 还是 "完成"。 | *   使用 `round_by_find_and_click_area` 函数来查找屏幕上的按钮并点击。 | *   包含重试机制，以应对按钮未立即出现的情况。 | *   使用 `operation_node` 装饰器定义操作节点，用于流程控制。
        │   │   └── exit_in_battle.py    这个 Python 文件定义了一个名为 `ExitInBattle` 的类，该类继承自 `ZOperation`，其主要功能是在战斗画面中尝试退出战斗。 |  | 核心类和函数： |  | *   **`ExitInBattle(ZContext, wait_screen_name: str = None, wait_area_name: str = None)`**: 构造函数，初始化操作，接收上下文和退出后等待的画面信息。 | *   **`check_screen()`**: 识别战斗画面，尝试点击菜单按钮，并寻找退出战斗按钮。 | *   **`click_exit_battle()`**: 点击退出战斗按钮。 | *   **`click_confirm()`**: 点击确认退出按钮。 | *   **`wait_at_last()`**: 退出后等待，直到指定的画面出现。 |  | 重要功能点： |  | *   使用 `operation_node` 装饰器定义操作步骤，并使用 `node_from` 装饰器指定步骤之间的依赖关系。 | *   使用 `round_by_find_area` 和 `round_by_find_and_click_area` 等方法进行画面识别和点击操作。 | *   支持重试机制，以应对画面识别失败的情况。 | *   支持在退出战斗后等待指定的画面出现。
        │   ├── compendium/
        │   │   ├── combat_simulation.py    ```python | 文件摘要： | 该文件定义了 `CombatSimulation` 类，用于在游戏中执行实战模拟室的自动化操作，包括选择任务、检查电量、部署队伍和自动战斗。 |  | 核心类和函数： | *   `CombatSimulation(ZOperation)`:  核心类，继承自 `ZOperation`，负责实战模拟的流程控制。 |     *   `async_init_auto_op()`: 异步初始化自动战斗。 |     *   `wait_entry_load()`: 等待进入实战模拟室界面。 |     *   `choose_mission_type()`: 选择任务类型。 |     *   `choose_mission()`: 选择任务。 |     *   `click_card()`: 点击卡片选择按钮。 |     *   `choose_card_num()`: 选择卡片数量。 |     *   `check_charge()`: 检查电量是否足够。 |     *   `click_next()`: 点击下一步按钮。 |     *   `choose_predefined_team()`: 选择预设队伍。 |     *   `deploy()`: 部署队伍。 |     *   `init_auto_battle()`: 初始化自动战斗。 |     *   `wait_battle_screen()`: 等待战斗画面加载。 |     *   `move_to_battle()`: 进入战斗。 |     *   `auto_battle()`: 执行自动战斗。 |     *   `after_battle()`: 战斗结束后的处理。 |     *   `check_next()`: 判断是否进行下一次模拟。 |     *   `handle_pause()`: 暂停时的处理。 |     *   `handle_resume()`: 恢复时的处理。 |     *   `after_operation_done()`: 操作完成后的清理。 | *   `__debug_coffee()`: 调试函数，用于测试咖啡任务。 | *   `__debug_charge()`: 调试函数，用于测试电量识别。 | *   `__debug()`: 调试函数，用于测试实战模拟。 |  | 重要功能点： | *   任务选择：根据配置选择任务类型和具体任务。 | *   电
        │   │   ├── compendium_choose_category.py    这个 Python 脚本定义了一个名为 `CompendiumChooseCategory` 的操作，用于在游戏的快捷手册中选择一个特定的分类。 |  | **主要功能:** |  | *   选择快捷手册中的指定分类。 |  | **核心类和函数:** |  | *   `CompendiumChooseCategory`: 继承自 `ZOperation`，负责执行选择分类的操作。 |     *   `__init__(self, ctx: ZContext, category_name: str)`: 初始化操作，接收上下文和分类名称。 |     *   `choose_tab(self) -> OperationRoundResult`: 核心函数，截取屏幕，使用 OCR 识别分类列表，找到目标分类并点击。 | *   `__debug()`: 用于测试，初始化上下文，创建 `CompendiumChooseCategory` 实例并执行。 |  | **重要功能点:** |  | *   使用 OCR 识别屏幕上的分类列表。 | *   基于最长公共子序列 (LCS) 匹配来查找目标分类。 | *   点击找到的分类。 | *   包含重试机制，如果找不到分类则重试。
        │   │   ├── compendium_choose_mission_type.py    **摘要:** |  | 该文件定义了一个名为 `CompendiumChooseMissionType` 的类，用于在游戏《明日方舟》的快捷手册中选择特定类型的副本。它通过 OCR 识别副本类型，并模拟点击操作来选择和确认副本。 |  | **核心类和函数:** |  | *   **`CompendiumChooseMissionType(ZOperation)`**:  继承自 `ZOperation`，负责选择副本类型的操作。 |     *   `__init__(self, ctx: ZContext, mission_type: CompendiumMissionType)`: 初始化函数，设置上下文和目标副本类型。 |     *   `choose_tab(self) -> OperationRoundResult`:  核心函数，用于选择副本类型。它使用 OCR 识别副本名称，并根据识别结果进行点击或滑动操作。 |     *   `confirm(self) -> OperationRoundResult`: 确认选择的副本。 |  | **重要功能点:** |  | *   **OCR 识别**: 使用 OCR 技术识别屏幕上的文本，以确定副本类型和“前往”按钮的位置。 | *   **滑动操作**:  如果目标副本不在当前可见范围内，则执行滑动操作。 | *   **点击操作**:  模拟点击操作来选择副本和确认传送。 | *   **错误处理**: 包含重试机制和错误处理，以应对识别失败或操作失败的情况。 | *   **调试函数**: 包含一个 `__debug()` 函数，用于测试和调试。
        │   │   ├── compendium_choose_tab.py    这个 Python 文件的摘要如下： |  | **主要功能:** |  | 该文件定义了一个操作，用于在游戏的快捷手册中选择指定的 Tab。 |  | **核心类和函数:** |  | *   `CompendiumChooseTab`: 继承自 `ZOperation`，负责选择快捷手册中的 Tab。 |     *   `__init__(self, ctx: ZContext, tab_name: str)`: 初始化操作，接收上下文和 Tab 名称。 |     *   `choose_tab(self) -> OperationRoundResult`: 核心函数，执行选择 Tab 的逻辑。 | *   `__debug()`: 是一个用于测试的函数，用于初始化上下文、启动 OCR 模型，并执行 `CompendiumChooseTab` 操作。 |  | **重要功能点:** |  | *   使用 OCR 识别 Tab 列表中的文本。 | *   根据 Tab 名称查找目标点。 | *   使用控制器点击目标点以选择 Tab。 | *   包含重试机制，如果找不到 Tab 则重试。 | *   包含一个用于测试的 `__debug` 函数。
        │   │   ├── expert_challenge.py    **摘要:** |  | 该 Python 文件定义了 `ExpertChallenge` 类，用于自动化处理游戏中的专业挑战室任务。它通过模拟用户操作，包括识别电量、选择队伍、部署、自动战斗和处理战斗结果等步骤，以实现自动完成挑战的目的。 |  | **核心类和函数:** |  | *   **`ExpertChallenge`**:  核心类，继承自 `ZOperation`，负责执行专业挑战室的自动化流程。 |     *   `__init__`: 初始化函数，设置挑战计划、是否需要检查电量等参数。 |     *   `wait_entry_load`: 等待进入挑战室界面加载完成。 |     *   `check_charge`: 识别并检查剩余电量是否足够进行挑战。 |     *   `click_next`: 点击“下一步”按钮，直到出现“出战”按钮。 |     *   `choose_predefined_team`: 选择预定义的队伍。 |     *   `deploy`: 执行部署操作。 |     *   `init_auto_battle`: 加载自动战斗指令。 |     *   `wait_battle_screen`: 等待战斗画面加载。 |     *   `move_to_battle`: 移动角色进入战斗。 |     *   `auto_battle`: 执行自动战斗，并监控战斗状态。 |     *   `after_battle`: 处理战斗结束后的逻辑，如减少可运行次数。 |     *   `check_next`: 判断是否需要进行下一次挑战。 |     *   `check_charge_fail`: 处理电量识别失败的情况。 |     *   `battle_timeout`: 处理战斗超时的逻辑。 |     *   `click_result_exit`: 点击挑战结果界面上的退出按钮。 |     *   `handle_pause`: 暂停自动战斗。 |     *   `handle_resume`: 恢复自动战斗。 |     *   `after_operation_done`: 清理资源。 |  | **重要功能点:** |  | *   **电量检查**:  根据配置，检查剩余电量是否足够进行挑战，并计算可运行次数。 | *   **自动战斗**:  集成自动战斗功能，通过加载自动战斗指令，实现战斗过程的自动化。 | *   **流程控制**:  通过一系列 `operation_node` 装饰器定义的节点，构建了完整的挑战流程，包括界面识别、
        │   │   ├── notorious_hunt.py    **摘要:** |  | 该 Python 文件定义了 `NotoriousHunt` 类，用于自动化《代号：无限大》游戏中的恶名狩猎活动。它通过 OCR 识别、图像匹配和模拟用户操作来实现自动选择副本、难度、深度追猎模式、编队、战斗、处理战斗结果等功能。 |  | **核心类和函数:** |  | *   **`NotoriousHunt` 类:** 继承自 `ZOperation`，负责恶名狩猎的整体流程控制。 |     *   `__init__`: 初始化操作，包括计划信息、是否使用电量、运行次数等。 |     *   `wait_entry_load`: 等待恶名狩猎入口加载。 |     *   `check_mission`: 检查副本名称是否匹配。 |     *   `choose_mission`: 选择目标副本。 |     *   `choose_by_use_power`: 选择是否开启深度追猎。 |     *   `check_can_run_times`: 检查剩余可运行次数和电量。 |     *   `choose_level`: 选择挑战难度。 |     *   `click_next`: 点击“下一步”按钮。 |     *   `choose_predefined_team`: 选择预设编队。 |     *   `click_start`: 点击“出战”按钮。 |     *   `init_auto_battle`: 加载自动战斗指令。 |     *   `wait_battle_screen`: 等待战斗画面加载。 |     *   `first_move`: 战斗开始前的移动。 |     *   `move_and_interact`: 移动并交互。 |     *   `choose_buff`: 选择增益效果。 |     *   `move_to_battle`: 移动到战斗位置。 |     *   `auto_battle`: 执行自动战斗。 |     *   `battle_fail`: 处理战斗失败情况。 |     *   `battle_fail_exit`: 战斗失败后退出。 |     *   `after_battle`: 战斗结束后处理。 |     *   `check_next`: 检查是否继续挑战。 |     *   `no_left_times`: 处理没有剩余次数的情况。 |     *   `restart_confirm`: 重新开始挑战的确认。 |     *   `wait_back_to_entry`: 等
        │   │   ├── open_compendium.py    这个 Python 文件定义了一个名为 `OpenCompendium` 的类，它继承自 `ZOperation`，旨在实现打开游戏中的快捷手册功能。 |  | *   **主要功能:** 打开游戏中的快捷手册。 | *   **核心类和函数:** |     *   `OpenCompendium`: 继承自 `ZOperation`，负责整个打开快捷手册的流程。 |     *   `open_menu()`:  打开游戏菜单，作为流程的起始节点。 |     *   `click_more()`:  在菜单中点击“快捷手册”按钮。 | *   **重要功能点:** |     *   使用 `OpenMenu` 类打开菜单。 |     *   使用 OCR 和点击功能来定位和点击“快捷手册”按钮。 |     *   使用 `operation_node` 和 `node_from` 装饰器来定义操作流程。
        │   │   ├── routine_cleanup.py    ## 代码摘要 |  | **1. 主要功能:** |  | 该 Python 文件定义了 `RoutineCleanup` 类，用于执行《明日方舟》游戏中的定期清剿任务。它自动化了选择关卡、检查电量、部署队伍、自动战斗和处理战斗结果的流程。 |  | **2. 核心类和函数:** |  | *   **`RoutineCleanup` 类:** 继承自 `ZOperation`，负责执行定期清剿任务。 |     *   `__init__`: 初始化，接收 `ZContext`、`ChargePlanItem`、运行次数和是否需要检查电量等参数。 |     *   `wait_entry_load`: 等待进入清剿入口。 |     *   `check_charge`: 检查剩余电量是否足够。 |     *   `click_next`: 点击下一步按钮，进入战斗准备。 |     *   `choose_predefined_team`: 选择预设编队。 |     *   `deploy`: 部署队伍。 |     *   `init_auto_battle`: 加载自动战斗指令。 |     *   `wait_battle_screen`: 等待战斗画面加载。 |     *   `move_to_battle`: 角色向前移动准备战斗。 |     *   `auto_battle`: 执行自动战斗。 |     *   `after_battle`: 战斗结束后的处理。 |     *   `check_next`: 判断是否继续下一次清剿。 |     *   `check_charge_fail`: 电量识别失败处理。 |     *   `battle_timeout`: 战斗超时处理。 |     *   `click_result_exit`: 点击挑战结果退出。 |     *   `handle_pause`: 暂停时的处理。 |     *   `handle_resume`: 恢复时的处理。 |     *   `after_operation_done`: 操作完成后的清理。 | *   **`__debug_charge` 函数:** 用于测试电量识别功能。 | *   **`__debug` 函数:** 用于测试整个清剿流程。 |  | **3. 重要功能点:** |  | *   **电量检查:** 根据配置判断是否需要检查电量，并根据剩余
        │   │   └── tp_by_compendium.py    这个 Python 脚本定义了一个名为 `TransportByCompendium` 的类，它继承自 `ZOperation`，用于通过游戏内的快捷手册进行传送。 |  | **主要功能:** |  | *   通过游戏内的快捷手册，选择 Tab、分类和任务类型，实现快速传送。 |  | **核心类和函数:** |  | *   `TransportByCompendium(ZOperation)`:  主类，负责整个传送流程。 |     *   `__init__`: 初始化操作，设置传送的目标 Tab、分类和任务类型。 |     *   `check_first_screen`: 检查初始画面，判断是否已在快捷手册界面。 |     *   `open_compendium`: 打开快捷手册。 |     *   `choose_tab`: 选择指定的 Tab。 |     *   `choose_category`: 选择指定的分类。 |     *   `choose_mission_type`: 选择指定的任务类型。 | *   `ZContext`: 游戏上下文，提供游戏数据和服务。 | *   `OpenCompendium`:  打开快捷手册的操作。 | *   `CompendiumChooseCategory`: 选择分类的操作。 | *   `CompendiumChooseMissionType`: 选择任务类型的操作。 |  | **重要功能点:** |  | *   使用 `operation_node` 和 `node_from` 装饰器定义操作流程，实现状态机。 | *   根据提供的 Tab、分类和任务类型，逐步导航到目标界面。 | *   `__debug` 函数用于测试。 | *   `if __name__ == '__main__':` 块用于运行测试。
        │   ├── enter_game/
        │   │   ├── auto_hdr.py    ## 代码摘要 |  | **文件功能:** |  | 该文件定义了两个操作类，用于在游戏中禁用和启用自动 HDR (High Dynamic Range) 功能，通过修改 Windows 注册表实现。 |  | **核心类和函数:** |  | *   **`DisableAutoHDR(Operation)`:**  用于禁用自动 HDR。 |     *   `disable_auto_hdr()`:  禁用 HDR 的主函数，首先保存原始 HDR 设置，然后将注册表键值设置为禁用 HDR。 | *   **`EnableAutoHDR(Operation)`:** 用于启用自动 HDR。 |     *   `enable_auto_hdr()`: 启用 HDR 的主函数，恢复原始 HDR 设置，或者删除键值（如果之前没有保存原始设置）。 |  | **重要功能点:** |  | *   使用 `winreg` 模块操作 Windows 注册表。 | *   保存和恢复 HDR 设置，以确保可以还原到原始状态。 | *   处理游戏路径未配置的情况。 | *   使用 `operation_node` 装饰器定义操作节点，并使用 `OperationRoundResult` 返回操作结果。 | *   包含错误处理机制，捕获 `WindowsError` 异常并记录日志。
        │   │   ├── enter_game.py    ## 代码摘要 |  | **1. 主要功能:** |  | 该 Python 文件定义了 `EnterGame` 类，其主要功能是自动化进入游戏。它通过图像识别和模拟用户操作（如点击、输入账号密码）来完成登录过程，并支持国服、B服和国际服的登录流程。 |  | **2. 核心类和函数:** |  | *   **`EnterGame(ZOperation)`**:  核心类，继承自 `ZOperation`，负责游戏登录的整个流程。 |     *   `__init__(self, ctx: ZContext, switch: bool = False)`: 初始化函数，设置登录相关的配置。 |     *   `check_screen(self) -> OperationRoundResult`:  画面识别，根据当前屏幕状态判断下一步操作，是整个登录流程的起始节点。 |     *   `check_screen_intl(self) -> OperationRoundResult`: 国际服的画面识别。 |     *   `input_account_password(self) -> OperationRoundResult`:  国服账号密码输入。 |     *   `input_account_password_new(self) -> OperationRoundResult`:  国服账号密码输入 (新版UI)。 |     *   `input_bilibili_account_password(self) -> OperationRoundResult`:  B服账号密码输入。 |     *   `input_account_password_intl(self) -> OperationRoundResult`:  国际服账号密码输入。 |     *   `check_server(self) -> OperationRoundResult`: 国际服换服操作。 |     *   `wait_game(self) -> OperationRoundResult`: 等待游戏加载完成。 |  | **3. 重要功能点:** |  | *   **多平台支持:**  支持国服、B服和国际服的登录流程，通过不同的 `input_...` 函数实现。 | *   **图像识别:** 使用 `round_by_find_area` 和 `round_by_find_and_click_area` 等函数进行图像识别，判断当前屏幕状态并执行相应操作。 | *   **账号密码输入:**  支持使用剪切板或模拟键盘输入账号密码。 | *   **换服功能:**  针对国际服，支持切换服务器。 | *   **重试机制:**  使用 `operation_node` 装饰器，并设置 `node
        │   │   ├── open_and_enter_game.py    这个 Python 文件定义了一个名为 `OpenAndEnterGame` 的操作，用于打开并进入游戏。 |  | **主要功能:** |  | *   打开游戏并进入游戏。 | *   处理游戏窗口的初始化和激活。 | *   控制 HDR 设置。 |  | **核心类和函数:** |  | *   `OpenAndEnterGame`: 继承自 `Operation`，负责整个打开并进入游戏的流程。 |     *   `__init__`: 初始化操作，包括上下文和操作名称。 |     *   `handle_init`: 初始化操作，目前为空。 |     *   `add_edges_and_nodes`: 添加操作流程中的节点和边。 |     *   `open_game`: 打开游戏，并禁用 HDR。 |     *   `wait_game`: 等待游戏打开，激活游戏窗口，并启用 HDR。 |     *   `enter_game`: 进入游戏。 | *   `OperationNode`:  用于定义操作流程中的节点。 | *   `OperationRoundResult`: 用于表示操作的结果。 | *   `OpenGame`:  用于打开游戏的操作。 | *   `EnterGame`:  用于进入游戏的操作。 | *   `EnableAutoHDR`, `DisableAutoHDR`:  用于控制 HDR 设置的操作。 |  | **重要功能点:** |  | *   使用 `Operation` 框架构建操作流程。 | *   使用节点和边定义操作的执行顺序。 | *   在打开游戏和等待游戏打开阶段控制 HDR。 | *   包含重试机制，用于等待游戏窗口准备就绪。
        │   │   ├── open_game.py    这个 Python 文件的主要功能是打开游戏。 |  | 核心类： |  | *   `OpenGame`: 继承自 `Operation`，负责启动游戏。 |  | 核心函数： |  | *   `open_game`: 启动游戏的函数，使用 `subprocess.Popen` 执行游戏可执行文件。 |  | 重要功能点： |  | *   从 `ZContext` 获取游戏路径和启动参数。 | *   构建命令行指令，用于启动游戏，包括处理屏幕尺寸、全屏模式、弹出窗口和监视器等参数。 | *   使用 `subprocess.Popen` 在后台启动游戏。 | *   提供错误处理，如果未配置游戏路径，则返回失败。
        │   │   └── switch_account.py    这个 Python 脚本实现了在游戏中切换帐号的功能。 |  | *   **主要功能:** 执行一系列操作，包括打开菜单、点击更多、选择登出、确认登出，并最终重新进入游戏。 | *   **核心类和函数:** |     *   `SwitchAccount`: 继承自 `ZOperation`，负责切换帐号的流程控制。 |     *   `open_menu`: 打开游戏菜单。 |     *   `click_more`: 点击菜单中的“更多”选项。 |     *   `more_click_logout`: 在“更多”选项中选择“登出”。 |     *   `more_logout_confirm`: 确认登出操作。 |     *   `wait_switch_can_click`: 等待切换帐号完成，直到可以点击“进入游戏”。 |     *   `enter_game`: 重新进入游戏。 |     *   `__debug`: 测试函数，用于初始化上下文并执行切换帐号操作。 | *   **重要功能点:** |     *   使用 OCR 和图像识别来定位和点击屏幕上的元素。 |     *   使用 `operation_node` 和 `node_from` 装饰器来定义操作流程和节点之间的依赖关系。 |     *   包含重试机制，以应对操作失败的情况。 |     *   使用 `ZContext` 存储上下文信息。
        │   ├── goto/
        │   │   └── goto_menu.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | 该文件定义了一个名为 `GotoMenu` 的操作，其主要功能是导航到游戏的菜单界面。它旨在确保在任何情况下都能成功前往菜单。 |  | **核心类和函数：** |  | *   `GotoMenu`：继承自 `ZOperation`，是核心类，负责执行前往菜单的操作。 |     *   `__init__(self, ctx: ZContext)`：构造函数，初始化操作，设置操作名称为“前往菜单”。 |     *   `check_screen_and_run(self, screen: Optional[MatLike] = None) -> OperationRoundResult`：核心函数，负责检查当前画面并尝试导航到菜单。它使用 `round_by_goto_screen` 尝试直接导航，如果失败，则尝试返回大世界，然后再次尝试导航。 |  | **重要功能点：** |  | *   使用 `operation_node` 装饰器标记 `check_screen_and_run` 函数，并设置了重试次数。 | *   使用 `round_by_goto_screen` 尝试直接导航到菜单。 | *   如果直接导航失败，则使用 `BackToNormalWorld` 操作返回大世界。 | *   处理了无法到达菜单的情况，返回失败状态。 | *   包含屏幕截图功能。
        │   └── hdd/
        │       └── enter_hdd_mission.py    此文件定义了 `EnterHddMission` 类，用于处理进入 HDD（Hard Disk Drive）副本的操作流程。 |  | *   **核心类:** `EnterHddMission` 继承自 `ZOperation`，负责执行进入 HDD 副本的步骤。 | *   **核心函数:** |     *   `__init__`: 初始化操作，设置章节、任务类型、任务名称和预设队伍索引。 |     *   `choose_chapter`: 选择章节。 |     *   `choose_mission_type`: 选择任务类型。 |     *   `choose_mission`: 选择副本。 |     *   `click_next`: 点击“下一步”。 |     *   `choose_predefined_team`: 选择预设队伍。 |     *   `click_deploy`: 点击“出战”。 |     *   `check_level`: 检查并处理低等级提示。 |     *   `finish`: 标记流程完成。 | *   **重要功能点:** |     *   通过 OCR 和图像识别来定位和点击屏幕元素。 |     *   支持选择章节、任务类型和副本。 |     *   可以选择预设队伍。 |     *   处理低等级提示。 |     *   使用 `operation_node` 和 `node_from` 装饰器定义操作流程和依赖关系。 |     *   包含重试机制和等待时间，以处理可能出现的错误。
        ├── screen_area/
        │   └── screen_normal_world.py    这个 Python 文件定义了一个名为 `ScreenNormalWorldEnum` 的枚举，用于表示游戏屏幕中特定区域的定义。 |  | *   **主要功能:** 定义游戏屏幕中不同区域的常量，特别是针对 UID 区域。 | *   **核心类和函数:** |     *   `ScreenNormalWorldEnum`:  一个枚举类，用于定义屏幕区域的常量。 |     *   `ScreenArea`:  从 `one_dragon.base.screen.screen_area` 导入的类，用于表示屏幕区域。 |     *   `Rect`:  从 `one_dragon.base.geometry.rectangle` 导入的类，用于定义矩形区域。 | *   **重要功能点:** |     *   `UID`:  定义了屏幕中 UID 区域的 `ScreenArea` 实例，使用 `Rect` 定义了其在 PC 屏幕上的坐标。
        ├── win_exe/
        │   ├── full_launcher.py    这个 Python 脚本 `full_launcher.py` 的主要功能是启动一个特定的 Python 应用程式。 |  | *   **核心函数:** `python_launcher.run_python()` | *   **重要功能点:** |     *   使用 `python_launcher` 模块来执行另一个 Python 脚本。 |     *   启动的脚本是 `zzz_od.gui.app.py`。 |     *   `no_windows=True` 参数表示在没有 Windows 终端视窗的情况下运行。
        │   └── scheduler_launcher.py    这个 Python 脚本 `scheduler_launcher.py` 的主要功能是启动一个名为 `zzz_one_dragon_app.py` 的应用程式。 |  | *   **核心函数:** `python_launcher.run_python()` | *   **重要功能点:** |     *   使用 `one_dragon.devtools.python_launcher` 模组来执行 Python 程式。 |     *   启动 `zzz_od.application.zzz_one_dragon_app.py` 应用程式。 |     *   `no_windows=False` 表示启动时会显示 Windows 视窗。
        └── yolo/
            ├── flash_classifier.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | `FlashClassifier` 类别实现了一个基于 YOLOv8 的分类器，用于快速分类图像。它继承自 `Yolov8Classifier`，并通过下载和加载预训练模型来执行分类任务。 |  | **核心类和函数：** |  | *   `FlashClassifier`: 继承自 `Yolov8Classifier`，初始化时会下载并加载 YOLOv8 模型。 | *   `__init__`:  `FlashClassifier` 的构造函数，初始化分类器的各种参数，例如模型名称、GPU 使用情况和结果保留时间。 |  | **重要功能点：** |  | *   **模型加载和管理：**  从指定的 URL 下载 YOLOv8 模型，并在本地管理模型文件。 | *   **GPU 加速：** 支援使用 GPU 进行加速，以提高分类速度。 | *   **结果保留：**  可以配置结果保留时间，控制分类结果的生命周期。 | *   **代理设置：** 支援通过 GitHub 代理或个人代理下载模型。
            └── hollow_event_detector.py    这个 Python 文件的摘要如下： |  | **主要功能：** |  | *   `HollowEventDetector` 类别实现了一个基于 YOLOv8 的空洞事件检测器，专为崩铁游戏设计。它继承自 `Yolov8Detector`，并利用 YOLOv8 模型进行物件侦测。 |  | **核心类和函数：** |  | *   `HollowEventDetector`: 继承自 `Yolov8Detector`，初始化 YOLOv8 模型，并设定模型名称、GPU 使用情况和结果保留时间等参数。 | *   `__init__`: 类别的建构子，用于初始化检测器，并设定模型下载路径、代理设定等。 |  | **重要功能点：** |  | *   初始化 YOLOv8 模型，并从指定 URL 下载模型。 | *   支援 GPU 加速。 | *   设定结果保留时间，用于管理检测结果的生命周期。 | *   使用 `yolo_config_utils.get_model_category_dir` 获取模型存放路径。 | *   使用 `ZZZ_MODEL_DOWNLOAD_URL` 下载模型。
```
